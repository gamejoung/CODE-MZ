/*:
 * @plugindesc (v.0.10.0 BETA)[PRO] Active Battle System
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-abs-z/
 *
 * @help
 *
 * Alpha ABS Z plugin is still in development
 *
 * Documentation: https://github.com/KageDesu/Alpha-ABS-Z/wiki
 *
 * Quick Start guide:
 * https://github.com/KageDesu/Alpha-ABS-Z/wiki/For-beginners-(if-you-just-installed-plugin)
 * ----------------------------------------------------------- 
 * Alpha ABS Z plugin content:
 *
 * Plugin: js/plugins/Alpha_ABSZ.js
 * Fonts: fonts/
 *      -AABS_0.ttf
 *      -AABS_1.ttf
 *      -AABS_2.ttf
 *      -AABS_3.ttf
 * Images: img/Alpha/ *all files*
 * Data: data/AABSZ/ *all files*
 *
 *
 * @requiredAssets img/Alpha/Button_SkSItemsGroup_00
* @requiredAssets img/Alpha/Button_SkSItemsGroup_01
* @requiredAssets img/Alpha/Button_SkSItemsGroup_03
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_00
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_01
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_03
* @requiredAssets img/Alpha/Enemy_Background
* @requiredAssets img/Alpha/Enemy_BattleState_Free
* @requiredAssets img/Alpha/Event_HPGauge2
* @requiredAssets img/Alpha/Player_HPGauge
* @requiredAssets img/Alpha/Player_HPGaugeLabel
* @requiredAssets img/Alpha/Player_MPGauge
* @requiredAssets img/Alpha/Player_MPGaugeLabel
* @requiredAssets img/Alpha/Player_TPGauge
* @requiredAssets img/Alpha/Player_TPGaugeLabel
* @requiredAssets img/Alpha/SkillSlot_00
* @requiredAssets img/Alpha/SkillSlot_01
* @requiredAssets img/Alpha/SkillSlot_Disabled
* @requiredAssets img/Alpha/SkillSlot_Outline
* @requiredAssets img/Alpha/PlayerStateIcons
* @requiredAssets img/Alpha/Player_EXPGauge
* @requiredAssets img/Alpha/Player_EXPGaugeForeground
* @requiredAssets img/Alpha/Player_EXPGaugeMask
* @requiredAssets img/Alpha/Windows/headerLine
* @requiredAssets img/Alpha/Windows/windowCloseButton_00
* @requiredAssets img/Alpha/Windows/windowCloseButton_01
* @requiredAssets img/Alpha/Windows/windowFrame
 * @param AABSZ @text @desc
 * 
 * @param inputSettings:struct
 * @text Controls Settings
 * @type struct<LInputSettings>
 * @default {"LMBMapTouchMode":"Default (move)","RMBMapTouchMode":"Turn","LMBTargetTouchMode":"Smart attack (Primary)","RMBTargetTouchMode":"Smart attack (Secondary)","moveType":"WASD and Arrows","isDiagonalMovement:b":"true","isStaticAtkRot:b":"true","keybingind":"","kbReload":"R","kbCommandMenu":"C","kbRotate":"Control"}
 * @desc Controls and keybingind settings
 * 
 * @param diagonalMoveSpeedMod:int
 * @parent inputSettings:struct
 * @text Diagonal Move Speed
 * @type number
 * @decimals 2
 * @default 0.95
 * @min 0.01
 * @max 1.00
 * @desc Diagonal move speed modifier. Default is 0.95 (95% of normal speed).
 * 
 * @param isAllowDodge:b
 * @parent inputSettings:struct
 * @text Is Allow Dodge?
 * @type boolean
 * @default true
 * @desc Allow player make dodge action?
 * 
 * @param dodgeSettings:struct
 * @parent isAllowDodge:b
 * @text Configuration
 * @type struct<LDodgeActionSettings>
 * @default {"dodgeKey":"f","dodgeSwitch:i":"0","isInvincible:b":"true","stepsCount:i":"2","delayBetweenStepMS:i":"100","dodgeMoveSpeed:i":"5","dodgeRestTimerFrames:i":"30","dodgeRestVariable:i":"0"}
 * @desc Dodge action configuration
 * 
 * @param spacer|abs @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absSettingsGroup
 * @text ABS System
 * 
 * @param spacer|movement @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absMovementSettingsGroup
 * @text Extended Movement
 * 
 * @param useExtendedMovementSystem:bool
 * @parent absMovementSettingsGroup
 * @text Use Extended Movement System?
 * @type boolean
 * @on Yes (extended)
 * @off No (default)
 * @default true
 * @desc Use extended (pixel-based) movement system? If false, use default RPG Maker MV movement system.
 * 
 * @param movementGridSize:int
 * @parent absMovementSettingsGroup
 * @text Movement Grid Size
 * @type select
 * @option 12
 * @value 12
 * @option 16
 * @value 16
 * @option 24
 * @value 24
 * @option 48
 * @value 48
 * @default 24
 * @desc Size of movement grid. Default is 24px. Can be 12, 16, 24, 48.
 * 
 * @param showPathfindingGridKey
 * @parent absMovementSettingsGroup
 * @text Show Pathfinding Grid Key
 * @type text
 * @default p
 * @desc Key for show pathfinding grid for debug purposes. Default is "p". You can change it to any key you want.
 * 
 * @param noMovementPassRegionIds:intA
 * @parent absMovementSettingsGroup
 * @text No Movement Pass Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The region IDs (1-255) through which the player can not pass. Global, for all maps.
 * 
 * @param noMovementPassTerrainTags:intA
 * @parent absMovementSettingsGroup
 * @text No Movement Pass Terrain Tags
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the player can not pass. Global, for all maps.
 * 
 * @param absCollisionsGroup
 * @parent absMovementSettingsGroup
 * @text Collisions
 * 
 * @param showCollisionLayerKey
 * @parent absCollisionsGroup
 * @text Show Collision Layer Key
 * @type text
 * @default c
 * @desc Key for show collision layer for debug purposes. Default is "c". You can change it to any key you want.
 * 
 * @param eventDefaultColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Event Default Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"4","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"14"}
 * @desc Default collider settings for events. If you want to set custom collider settings for event, use <aCollider: {...}> comment.
 * 
 * @param enemiesShouldHaveDefaultCollider:bool
 * @parent eventDefaultColliderConfig:struct
 * @text Enemies have default collider?
 * @type boolean
 * @on Yes (default)
 * @off No (custom or nothing)
 * @default false
 * @desc If true, all enemies will have default collider settings. If false, enemies will have custom collider settings (if set) or nothing (if not set).
 * 
 * @param actorDefaultColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Actor Default Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"12","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"10"}
 * @desc Default collider settings for actors. If you want to set custom collider settings for actor, use <aCollider: {...}> in Actor's notetag.
 * 
 * @param eventDefaultInteractionColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Event Default Interaction Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"8","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"30"}
 * @desc Default interaction collider settings for events. If you want to set custom collider settings for event, use <aInteractionArea: {...}> comment.
 * 
 * @param highlightInteractableEvents:bool
 * @parent eventDefaultInteractionColliderConfig:struct
 * @text Highlight Interactable Events
 * @type boolean
 * @on Yes (highlight)
 * @off No (no highlight)
 * @default true
 * @desc Highlight interactable events (with <aInteractionArea: {...}> comment) when player is near. If false, no highlight.
 * 
 * @param highlightInteractableEventsUnderCursor:bool
 * @parent eventDefaultInteractionColliderConfig:struct
 * @text Highlight Interactable Events Under Cursor
 * @type boolean
 * @on Yes (highlight)
 * @off No (no highlight)
 * @default true
 * @desc Highlight interactable events (with <aInteractionArea: {...}> comment) when event is under cursor. If false, no highlight.
 * 
 * @param spacer|hitboxes @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absHitboxesSettingsGroup
 * @text Hitboxes
 * 
 * @param enemyDefaultHitBoxConfig:struct
 * @parent absHitboxesSettingsGroup
 * @text Enemy Default Hit Box
 * @type struct<AAColliderConfig>
 * @default {"type":"b","dx:int":"0","dy:int":"-4","onlyForBox":"","width:int":"36","height:int":"42","onlyForCircle":"","radius:int":"16"}
 * @desc Default hit box settings for enemies. If you want to set custom hit box settings for enemy, use <aHitbox: {...}> comment.
 * 
 * @param actorDefaultHitBoxConfig:struct
 * @parent absHitboxesSettingsGroup
 * @text Actor Default Hit Box
 * @type struct<AAColliderConfig>
 * @default {"type":"b","dx:int":"0","dy:int":"-4","onlyForBox":"","width:int":"36","height:int":"42","onlyForCircle":"","radius:int":"16"}
 * @desc Default hit box settings for actors. If you want to set custom hit box settings for actor, use <aHitbox: {...}> in Actor's notetag.
 * 
 * @param spacer|projectiles @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absProjectilesSettingsGroup
 * @text Projectiles
 * 
 * @param noProjectilesPassRegionIds:intA
 * @parent absProjectilesSettingsGroup
 * @text No Projectiles Pass Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The numbers of the regions through which the projectiles can not pass. Global, for all projectiles and maps.
 * 
 * @param noProjectilesPassTerrainTags:intA
 * @parent absProjectilesSettingsGroup
 * @text No Projectiles Pass Terrain Tags
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the projectiles can not pass. Global, for all projectiles and maps.
 * 
 * @param showProjectilesCollisionLayerKey
 * @parent absProjectilesSettingsGroup
 * @text Show Collision for Projectiles Layer Key
 * @type text
 * @default j
 * @desc Key for show collision layer for debug purposes. Default is "j". You can change it to any key you want.
 * 
 * 
 * @param spacer|common @text‏‏‎ ‎@desc ===============================================
 * 
 * @param commonSettingsGroup
 * @text Common Parameters
 * 
 * @param fonts:strA
 * @parent commonSettingsGroup
 * @text Fonts
 * @type text[]
 * @default []
 * @desc Font files names for preload (from fonts\ folder), without extension
 * 
 * @param isSaveUIEditsGlobal:bool
 * @parent commonSettingsGroup
 * @type boolean
 * @text Is global UI?
 * @on Yes (global)
 * @off No (only savegame)
 * @default false
 * @desc If True - changes made to UI (via UI Editor or script calls) will saves globaly and applies again when game starts
 * 
 * @param customGaugesSet:structA
 * @parent commonSettingsGroup
 * @text Custom Gauges
 * @default []
 * @type struct<CGaugeCustom>[]
 * @desc Custom gauges, used in uAPI script calls, read Wiki for more information
 * 
 * @param spacer|popUpSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param popUpDamageSettingsGroup
 * @text Pop Up Settings
 * 
 * @param isShowPopUp:bool
 * @parent popUpDamageSettingsGroup
 * @type boolean
 * @text Is Enable?
 * @on Yes (enabled)
 * @off No (disabled)
 * @default true
 * @desc Is Pop Up system enabled? false - not any Pop Up's at all
 * 
 * @param popUpTextForMiss
 * @parent popUpDamageSettingsGroup
 * @text Text for Miss
 * @default Miss
 * @desc Text for Miss PopUp
 * 
 * @param popUpExpSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Experience Pop Up
 * @type struct<LDPUExp>
 * @default {"active:b":"true","styleId":"Experience","textFormat":"+%1 exp","aboveChar:b":"false","bindToChar:b":"false"}
 * @desc Settings for Experience Pop Up
 * 
 * @param popUpGoldSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Gold Pop Up
 * @type struct<LDPUGold>
 * @default {"popUpStyle:s":"{\"id\":\"gold\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"right\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e6c42e\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"goldPopUpIcon\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","textFormat":" *1","bindToChar:b":"true"}
 * @desc Settings for Gold Pop Up
 * 
 * @param popUpDamageTable:structA
 * @parent popUpDamageSettingsGroup
 * @text Pop Up Table
 * @type struct<LDamagePopUpVisualSettings>[]
 * @default ["{\"id\":\"Miss_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"13\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"16\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#E6E6E6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Heal_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#80FF00\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FFFFFF\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"17\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e3483d\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy_Critical\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-5\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#F3E107\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player_Critical\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FF0000\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_Other_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#008080\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Experience\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-10\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#a365e6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}"]
 * @desc Damage (skills) PopUp's visual settings
 * 
 * @param spacer|buffsStatesSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param buffsStatesSettingsGroup
 * @text Buffs And States Settings
 * 
 * @param isShowBuffsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text Is show Buffs on UI?
 * @on Yes (show)
 * @off No
 * @default true
 * @desc Show player actor's buffs on UI (left top corner by default)?
 * 
 * @param buffsIconsPositions:structA
 * @parent isShowBuffsOnUI:bool
 * @type struct<XY>[]
 * @text Buffs positions
 * @default ["{\"x:int\":\"4\",\"y:int\":\"4\"}","{\"x:int\":\"42\",\"y:int\":\"4\"}","{\"x:int\":\"80\",\"y:int\":\"4\"}","{\"x:int\":\"118\",\"y:int\":\"4\"}"]
 * @desc Buffs icons positions. You can add or remove icons positions. Positions count = visible buffs count.
 * 
 * @param buffIconSettings:struct
 * @parent isShowBuffsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text Visual Settings
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"-2\\\",\\\"y:int\\\":\\\"-4\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc Buff icon visual settings
 * 
 * @param isShowStatsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text Is show States on UI?
 * @on Yes (show)
 * @off No
 * @default true
 * @desc Show player actor's states on UI (left top corner by default)?
 * 
 * @param statesIconsPositions:structA
 * @parent isShowStatsOnUI:bool
 * @type struct<XY>[]
 * @text States positions
 * @default ["{\"x:int\":\"4\",\"y:int\":\"40\"}","{\"x:int\":\"42\",\"y:int\":\"40\"}","{\"x:int\":\"80\",\"y:int\":\"40\"}","{\"x:int\":\"118\",\"y:int\":\"40\"}"]
 * @desc States icons positions. You can add or remove icons positions. Positions count = visible states count.
 * 
 * @param statsIconSettings:struct
 * @parent isShowStatsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text Visual Settings
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc Status icon visual settings
 * 
 * @param stateIconsAboveChars
 * @parent buffsStatesSettingsGroup
 * @text State Icons on Characters
 * 
 * @param isShowStateIconAbvPl:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Player?
 * @on Yes (show)
 * @off No
 * @default false
 * @desc Is state icons will be visible above player character?
 * 
 * @param isShowStateIconAbvEnms:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Enemies?
 * @on Yes (show)
 * @off No
 * @default true
 * @desc Is state icons will be visible above enemies?
 * 
 * @param isShowStateIconAbvAls:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Allies?
 * @on Yes (show)
 * @off No
 * @default true
 * @desc Is state icons will be visible above party members?
 * 
 * @param stateIconsMargins:struct
 * @text Margins
 * @parent stateIconsAboveChars
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"-64"}
 * @desc Position of state icon, relative character
 * 
 * @param stateIconsScale:int
 * @text Icon scale
 * @parent stateIconsAboveChars
 * @type number
 * @decimals 2
 * @default 0.7
 * @desc Default icons size is 32px. This is scale that will be applied to default size.
 * 
 * @param stateIconsOnEnemyInfoUI
 * @parent buffsStatesSettingsGroup
 * @text State Icons on Enemy UI
 * 
 * @param statesIconsPositionsForEnemy:structA
 * @parent stateIconsOnEnemyInfoUI
 * @type struct<XY>[]
 * @text States positions
 * @default ["{\"x:int\":\"8\",\"y:int\":\"64\"}","{\"x:int\":\"28\",\"y:int\":\"64\"}","{\"x:int\":\"48\",\"y:int\":\"64\"}","{\"x:int\":\"68\",\"y:int\":\"64\"}"]
 * @desc States icons positions. You can add or remove icons positions. Positions count = visible states count.
 * 
 * @param stateIconsScaleOnEnUI:int
 * @text Icon scale
 * @parent stateIconsOnEnemyInfoUI
 * @type number
 * @decimals 2
 * @default 0.6
 * @desc Default icons size is 32px. This is scale that will be applied to default size.
 * 
 * @param spacer|skillPanel @text‏‏‎ ‎@desc ===============================================
 * 
 * @param skillPanelSettingsGroup
 * @text Skill Panel settings
 * 
 * @param isAddNewSkillsOnPanelOnLearning:bool
 * @parent skillPanelSettingsGroup
 * @text Add Skill On Learning?
 * @type boolean
 * @on Add
 * @off No
 * @default true
 * @desc When player learn new skill, add skill on skills panel automatically?
 * 
 * @param isAddNewItemOnPanelOnPickup:bool
 * @parent skillPanelSettingsGroup
 * @text Add Item On Pick up?
 * @type boolean
 * @on Add
 * @off No
 * @default true
 * @desc When player pick up new item, add item on skills panel automatically?
 * 
 * @param isRemoveItemFromPanelIfZeroCount:bool
 * @parent skillPanelSettingsGroup
 * @text Remove Zero Items?
 * @type boolean
 * @default false
 * @desc Remove an item from the skill panel if the count of item is 0 
 * 
 * @param isUseOutlineEffect:bool
 * @parent skillPanelSettingsGroup
 * @text Outline effect?
 * @type boolean
 * @on Yes (quality)
 * @off No (performance)
 * @default true
 * @desc Outline glow effects for skill slots (when activated, ready, disabled) Turn OFF for better performance.
 * 
 * @param primaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text Primary Attack Slot
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"218\",\"y:e\":\"583\"}","symbol":"E"}
 * @desc Required. Skill slot for primary attack (main weapon)
 * 
 * @param secondaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text Secondary Attack Slot
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"255\",\"y:e\":\"583\"}","symbol":"Q"}
 * @desc Required. Skill slot for secondary attack
 * 
 * @param allSkillSlots:structA
 * @parent skillPanelSettingsGroup
 * @text Skill Slots
 * @type struct<LSkillSlotItem>[]
 * @default ["{\"position:struct\":\"{\\\"x:e\\\":\\\"302\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"1\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"339\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"2\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"376\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"3\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"413\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"4\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"450\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"5\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"487\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"6\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"524\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"7\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"561\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"8\"}"]
 * @desc Optional. Skill slots.
 * 
 * @param skillSlotVisualSettings:s
 * @parent skillPanelSettingsGroup
 * @text Skill Slot Visual
 * @type struct<LSkillSlotItemVisual> 
 * @desc Skill Slot visual settings
 * @default {"visible:bool":"true","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","outlineGroup":"","outlineMargins:s":"{\"x:int\":\"-2\",\"y:int\":\"-2\"}","outlinePulseSpeed:i":"40","selectedOutlineColor:str":"#fcba03","clickedOutlineColor:str":"#0b03fc","readyOutlineColor:str":"#21b53c","badOutlineColor:str":"#d61a1a","icon:s":"{\"visible:b\":\"true\",\"size:i\":\"32\",\"index:i\":\"0\"}","iconMargins:s":"{\"x:int\":\"2\",\"y:int\":\"2\"}","symbolText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"20\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"18\\\",\\\"y:int\\\":\\\"22\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"14\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#e0cfbf\"}","timeText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"2\\\",\\\"y:int\\\":\\\"2\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fcba03\"}","countText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"-6\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#eb852d\"}"}
 * 
 * 
 * @param spacer|playerAndParty @text‏‏‎ ‎@desc ===============================================
 * 
 * @param playerAndPartySettingsGroup
 * @text Player and Party settings
 * 
 * @param isShakeScreenWhenPlayerGetDamage:bool
 * @parent playerAndPartySettingsGroup
 * @text Is Shake on Damage?
 * @type boolean
 * @on Shake
 * @off No
 * @default true
 * @desc Is shake screen when player receive damage?
 * 
 * @param isShowBloodSplatterEffect:bool
 * @parent playerAndPartySettingsGroup
 * @text Low HP screen effect?
 * @type boolean
 * @on Show
 * @off No
 * @default true
 * @desc Flash screen when player HP is low. Blood splatter effect.
 * 
 * @param boolSplatterEffectSettings:struct
 * @parent isShowBloodSplatterEffect:bool
 * @text Effect Settings
 * @type struct<LBloodSplatterEffectSettings> 
 * @default {"BS_Picture":"","BS_Color":"#cf3d23","BS_Opacity:int":"124","BS_HpRate:int":"15"}
 * @desc Blood splatter effect settings
 * 
 * @param commonEventOnPlayerDeath:int
 * @parent playerAndPartySettingsGroup
 * @text On Death Event
 * @type common_event
 * @default 0
 * @desc Common Event when player is dead. If 0 - Game Over screen.
 * 
 * @param characterDeadMotionType:int
 * @parent commonEventOnPlayerDeath:int
 * @text Show Death Motion
 * @type select
 * @option Never
 * @value 0
 * @option Always
 * @value 1
 * @option If not have AnimaX
 * @value 2
 * @default 1
 * @desc Show character (player or ally) dead motion [from SV Battler] sprite? 
 * 
 * @param partyExpGainMode
 * @parent playerAndPartySettingsGroup
 * @text How gain Exp?
 * @type select
 * @option To player only
 * @value player
 * @option For all
 * @value party
 * @option For all divided
 * @value partyDivided
 * @option One who kill
 * @value killer
 * @default partyDivided
 * @desc How gain exp (for killed enemies) to party?
 * 
 * @param isUseCustomLevelUp:bool
 * @parent playerAndPartySettingsGroup
 * @text Is Use Custom LevelUp?
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc Are show custom level up efffect instead of default one?
 * 
 * @param customLevelUpSettings:struct
 * @parent isUseCustomLevelUp:bool
 * @text Level Up Settings
 * @type struct<LCustomLevelUpSettings>
 * @default {"databaseAnimationId:i":"0","imageSeqAnimationName:str":"","imageSeqAnimationMargins:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","extraSE:str":"","isShowPopUp:b":"true","popUpText:str":"Level %1!","popUpStyle:s":"{\"id\":\"levelUp\",\"randDX:int\":\"0\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"60\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"20\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#deb521\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","commonEvent:i":"0","scriptAction:str":""}
 * 
 * @param playerVisualSettingsGroup
 * @parent playerAndPartySettingsGroup
 * @text UI Elements Settings
 * 
 * @param pvsGaugesSubGroup
 * @parent playerVisualSettingsGroup
 * @text Gauges
 * 
 * @param playerHpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text HP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"304\",\"y:e\":\"560\"}","label":"Player_HPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-33\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Player HP gauge visual settings
 * 
 * @param playerMpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text MP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_MPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_MPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Player MP gauge visual settings
 * 
 * @param playerTpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text TP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"false","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_TPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_TPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Player TP gauge visual settings
 * 
 * @param playerExpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text EXP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"273\",\"y:e\":\"528\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_EXPGauge\",\"foreground\":\"Player_EXPGaugeForeground\",\"mask\":\"Player_EXPGaugeMask\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Player Exp gauge visual settings
 * 
 * @param spacer|enemies @text‏‏‎ ‎@desc ===============================================
 * 
 * @param enemySettingsGroup
 * @text Enemies settings
 * 
 * @param enemyVisualSettingsGroup
 * @parent enemySettingsGroup
 * @text UI Elements Settings
 * 
 * @param enemyVSGaugesSubGroup
 * @parent enemyVisualSettingsGroup
 * @text Gauges
 * 
 * @param enemyMiniHpGaugeSettings:struct
 * @parent enemyVSGaugesSubGroup
 * @text Mini HP Gauge Settings
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc HP gauge above enemies on map (default one)
 * 
 * @param enemyMiniHpGaugesCustoms:structA
 * @parent enemyVSGaugesSubGroup
 * @text Customs
 * @type struct<LEnemyCustomMiniGauge>[]
 * @default []
 * @desc [PRO] You can assign custom gauge to certain enemy by <miniHpGaugeStyle> ABS parameter
 * 
 * @param enemyInfoVisualSettings:struct
 * @text Enemy Info
 * @type struct<LEnemyInfoVisual>
 * @parent enemyVisualSettingsGroup
 * @desc Enemy Info visual settings [information when you select\hover enemy]
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"640\",\"y:e\":\"66\"}","image":"Enemy_Background","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","nameFormat":" *2","hpText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"12\\\",\\\"y:int\\\":\\\"28\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:s":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}","gaugeMargins:s":"{\"x:int\":\"6\",\"y:int\":\"28\"}","face:s":"{\"visible:bool\":\"true\",\"faceName\":\"\",\"faceIndex:i\":\"0\",\"mirror:b\":\"false\",\"size:i\":\"74\",\"margins:s\":\"{\\\"x:int\\\":\\\"92\\\",\\\"y:int\\\":\\\"10\\\"}\"}","battleState:s":"{\"visible:bool\":\"true\",\"image\":\"Enemy_BattleState_Free\",\"margins:s\":\"{\\\"x:int\\\":\\\"142\\\",\\\"y:int\\\":\\\"60\\\"}\"}","foregroundImage:s":"{\"visible:bool\":\"true\",\"image\":\"\",\"margins:s\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\"}"}
 * 
 * @param enemyAIUpdateThreadMS:int
 * @parent enemySettingsGroup
 * @text AI Think Interval
 * @type number
 * @min 1
 * @max 200
 * @default 100
 * @desc Enemy AI logic update interval, in milliseconds!. Less value, AI more quicker takes decisions.
 * 
 * @param enemyAIUpdateVisionIntervalFR:int
 * @parent enemySettingsGroup
 * @text AI Vision Interval
 * @type number
 * @min 1
 * @max 32
 * @default 4
 * @desc Enemy vision check interval, in FRAMES!. Less value, AI more quicker check around for enemies
 * 
 * 
 * @param enemies_noPassVision:intA
 * @parent enemySettingsGroup
 * @text No Pass Vision Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The numbers of the regions through which the enemies can not see. Global, for all enemies.
 * 
 * @param enemies_noPassVision2:intA
 * @parent enemySettingsGroup
 * @text No Pass Vision Terrains
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the enemies can not see. Global, for all enemies.
 * 
 * @param enemies_afterDeathBonuses:structA
 * @parent enemySettingsGroup
 * @text Flying bonuses
 * @type struct<FlyBonus>[]
 * @default ["{\"image:str\":\"BonusGreen\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"25\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusBlue\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"25\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusYellow\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"50\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"20\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"ba_1\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}"]
 * @desc Bonuses defenitions for bonusOnDeadIds ABS parameter
 * 
 * @param enemiesSpawnSettingsGroup
 * @parent enemySettingsGroup
 * @text Spawning Settings
 * 
 * @param enemies_spawn_mapId:int
 * @parent enemiesSpawnSettingsGroup
 * @text Spawn Map ID
 * @type number
 * @min 0
 * @default 0
 * @desc [Required] Map ID with events templates for spawning. 0 - spawn system not will works
 * 
 * @param enemies_spawn_aboveEvents:b
 * @parent enemiesSpawnSettingsGroup
 * @text Is spawn above events?
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc Is spawning enemies above another events (or enemies) allowed?
 * 
 * @param enemies_spawn_cacheAllowed:b
 * @parent enemiesSpawnSettingsGroup
 * @text Is use region cache?
 * @type boolean
 * @on Yes (more performance)
 * @off No
 * @default true
 * @desc If you dinamycally change region Id's on map during game, set this parameter to NO (false)
 * 
 * @param spawn_points:structA
 * @parent enemiesSpawnSettingsGroup
 * @text Spawn Points
 * @type struct<LSpawnPoint>[]
 * @default []
 * @desc Spawning points definitions for <absSpawnPoint:ID> event comment. Read Wiki for more information.
 * 
 * 
 * @param spacer|map @text‏‏‎ ‎@desc ===============================================
 * 
 * @param mapSettingsGroup
 * @text Map settings
 * 
 * @param mapScrolling:s
 * @text Map Scrolling
 * @parent mapSettingsGroup
 * @type struct<LMapScrollSettings>
 * @default {"isEnabled:b":"false","scrollZone:int":"10","speed:int":"5","delay:int":"60","resetOnMove:b":"true","resetOnAction:b":"true"}
 * @desc Mouse map scrolling settings
 * 
 * @param miniHpGaugeSetings:s
 * @text Mini HP Gauges
 * @parent mapSettingsGroup
 * @type struct<LMiniHpGaugeSettings>
 * @default {"active:b":"true","showOnlyOnHover:b":"true","showOnDamage:b":"true","showWhenNotFull:b":"false"}
 * @desc Mini HP gauges above ABS events settings
 * 
 * @param mvAnimationAutoScalling:int
 * @parent mapSettingsGroup
 * @text [MV] Animation Scalling
 * @type number
 * @decimals 1
 * @default 0.3
 * @desc [MV Only] Animation auto scalling factor when animation playing on Map or on ABS character (event, player). Set 1 to 100% (as in Animation Editor)
 * 
 * @param defaultBattleAutoBgm:struct
 * @parent mapSettingsGroup
 * @text Battle Auto BGM
 * @type struct<BattleAutoBGM>
 * @desc BGM for autoplay when player engage in battle. You can specify per map with <battleAutoBgm:NAME> notetag in Map
 * @default {"name":"","delay:i":"0.50"}
 * 
 * 
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * 
 * 
 * 
 * @command ABSEventSettings
 * @text ABS Enemy Configurate
 * @desc Configurate enemy ABS parameters for this certaint event
 * 
 * @arg MainGroup
 * @text Main Group
 * 
 * @arg viewRadius
 * @parent MainGroup
 * @text View Radius
 * @type number
 * @min 1
 * @max 100
 * @default 5
 * @desc On how many map cells sees enemy
 * 
 * @arg returnRadius
 * @parent MainGroup
 * @text Return Radius
 * @type number
 * @min 1
 * @max 100
 * @default 12
 * @desc How far can the enemy move away from the place where the battle begins
 * 
 * @arg noMoveInBattle
 * @parent MainGroup
 * @text No Move in Battle
 * @type boolean
 * @default false
 * @desc If TRUE -> enemy can't moving during battle
 * 
 * @arg noApproach
 * @parent MainGroup
 * @text No Approach Target
 * @type boolean
 * @default false
 * @desc If TRUE -> enemy can't approach target during battle
 * 
 * @arg onDeath
 * @parent MainGroup
 * @text On Death
 * @type text
 * @default
 * @desc ABS Script action (SAction), called when enemy is die
 * 
 * @arg onSeeTarget
 * @parent MainGroup
 * @text On See Target
 * @type text
 * @default
 * @desc ABS Script action (SAction), called when enemy is see target 
 * 
 * @arg onHit
 * @parent MainGroup
 * @text On Hit
 * @type text
 * @default
 * @desc ABS Script action (SAction), called when enemy get hitted (get health damage > 0)
 * 
 * @arg expVar
 * @parent MainGroup
 * @text Exp Variable
 * @type variable
 * @default 0
 * @desc If any -> experience will be given from this variable. 0 - from Database settings 
 * 
 * @arg autoExp
 * @parent MainGroup
 * @text Auto Exp
 * @type boolean
 * @default false
 * @desc If TRUE -> player will receive exp automatically after kill this enemy.
 * 
 * @arg notAgressive
 * @parent MainGroup
 * @text Not Agressive
 * @type boolean
 * @default false
 * @desc If TRUE -> the enemy will not attack first
 * 
 * @arg teamId
 * @parent MainGroup
 * @text  Team ID
 * @type number
 * @min 1
 * @max 10
 * @default 1
 * @desc Enemies with different team ID's will fight each other
 * 
 * @arg onDeathVar
 * @parent MainGroup
 * @text Death Variable
 * @type variable
 * @default 0
 * @desc If any -> +1 to this variable if this enemy is die 
 * 
 * @arg saveHp
 * @parent MainGroup
 * @text Save HP
 * @type boolean
 * @default false
 * @desc If TRUE -> stores enemy HP value when leave the map and restores when returns to this map
 * 
 * @arg MapGroup
 * @text Map Group
 * 
 * @arg shatterEffect
 * @parent MapGroup
 * @text Shatter Effect?
 * @type boolean
 * @default true
 * @desc Is play sprite shatter effect when enemy is die?
 * 
 * @arg deadSwitch
 * @parent MapGroup
 * @text Dead Switch
 * @type select
 * @option A
 * @option B
 * @option C
 * @option D
 * @option 0
 * @default 0
 * @desc Will turn ON this self.switch when enemy is die ( 0 - nothing )
 * 
 * @arg eraseOnDead
 * @parent deadSwitch
 * @text Erase on Dead?
 * @type boolean
 * @default true
 * @desc Erase Event when enemy is die? Only if NOT HAVE Dead Switch
 * 
 * @arg heavy
 * @parent MapGroup
 * @text Is heavy
 * @type boolean
 * @default false
 * @desc If TRUE -> this enemy can't be moved by Impulse skills
 * 
 * @arg weaponMotionType
 * @parent MapGroup
 * @text Weapon Motion Type
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc Weapon Motion Type for skills with Weapon Motions.
 * 
 * @arg lootDropOnDeath
 * @parent MapGroup
 * @text Drop Loot
 * @type boolean
 * @default false
 * @desc If TRUE -> auto loot (from Database Drop Items and Gold) drop on Death
 * 
 * @arg VisualGroup
 * @text Visual Group
 * 
 * @arg UIInfo
 * @parent VisualGroup
 * @text Show UI Info?
 * @type boolean
 * @default true
 * @desc Is show portrait UI when enemy is under cursor?
 * 
 * @arg faceName
 * @parent VisualGroup
 * @text Face Name
 * @type file
 * @required 1
 * @dir img\faces
 * @default
 * @desc Image name for portrait UI
 * 
 * @arg faceIndex
 * @parent faceName
 * @text Face Index
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc Face index on face image for portrait UI
 * 
 * @arg miniHpGaugeStyle
 * @parent VisualGroup
 * @text Mini HP Gauge Style
 * @type number
 * @default
 * @desc Enemy HP gauge style from Gauges -> Customs plugin parameter
 * 
 * @arg AnimationGroup
 * @text Animation Group
 * 
 * @arg hitAnimationId
 * @parent AnimationGroup
 * @text Hit Animation
 * @type animation
 * @default 1
 * @desc Hit animation on character when enemy attacks
 * 
 * @command EMPTY_HOLDER
 * @text ‏
 * @desc
 * @default
 */
/*:ru
 * @plugindesc (v.0.10.0 BETA)[PRO] Активная боевая система
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-abs-z/
 *
 * @help
 *
 * Плагин Alpha ABS Z находится в разработке
 *
 * Документация: https://github.com/KageDesu/Alpha-ABS-Z/wiki
 *
 * С чего начать:
 * https://github.com/KageDesu/Alpha-ABS-Z/wiki/For-beginners-(if-you-just-installed-plugin)
 * ----------------------------------------------------------- 
 * Содержимое плагина (необходимые файлы):
 *
 * Файл плагина: js/plugins/Alpha_ABSZ.js
 * Шрифты в папке: fonts/
 *      -AABS_0.ttf
 *      -AABS_1.ttf
 *      -AABS_2.ttf
 *      -AABS_3.ttf
 * Изображения: img/Alpha/ *все файлы*
 * Данные (настройки): data/AABSZ/ *все файлы*
 *
 * Скопируйте эти файлы и папки в себе проект чтобы Alpha ABS Z работал корректно
 *
  * @requiredAssets img/Alpha/Button_SkSItemsGroup_00
* @requiredAssets img/Alpha/Button_SkSItemsGroup_01
* @requiredAssets img/Alpha/Button_SkSItemsGroup_03
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_00
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_01
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_03
* @requiredAssets img/Alpha/Enemy_Background
* @requiredAssets img/Alpha/Enemy_BattleState_Free
* @requiredAssets img/Alpha/Event_HPGauge2
* @requiredAssets img/Alpha/Player_HPGauge
* @requiredAssets img/Alpha/Player_HPGaugeLabel
* @requiredAssets img/Alpha/Player_MPGauge
* @requiredAssets img/Alpha/Player_MPGaugeLabel
* @requiredAssets img/Alpha/Player_TPGauge
* @requiredAssets img/Alpha/Player_TPGaugeLabel
* @requiredAssets img/Alpha/SkillSlot_00
* @requiredAssets img/Alpha/SkillSlot_01
* @requiredAssets img/Alpha/SkillSlot_Disabled
* @requiredAssets img/Alpha/SkillSlot_Outline
* @requiredAssets img/Alpha/PlayerStateIcons
* @requiredAssets img/Alpha/Player_EXPGauge
* @requiredAssets img/Alpha/Player_EXPGaugeForeground
* @requiredAssets img/Alpha/Player_EXPGaugeMask
* @requiredAssets img/Alpha/Windows/headerLine
* @requiredAssets img/Alpha/Windows/windowCloseButton_00
* @requiredAssets img/Alpha/Windows/windowCloseButton_01
* @requiredAssets img/Alpha/Windows/windowFrame
 * @param AABSZ @text @desc
 * 
 * @param inputSettings:struct
 * @text Управление
 * @type struct<LInputSettings>
 * @default {"LMBMapTouchMode":"Default (move)","RMBMapTouchMode":"Turn","LMBTargetTouchMode":"Smart attack (Primary)","RMBTargetTouchMode":"Smart attack (Secondary)","moveType":"WASD and Arrows","isDiagonalMovement:b":"true","isStaticAtkRot:b":"true","keybingind":"","kbReload":"R","kbCommandMenu":"C","kbRotate":"Control"}
 * @desc Настройки управления и привязки кнопок
 * 
 * @param isAllowDodge:b
 * @parent inputSettings:struct
 * @text Is Allow Dodge?
 * @type boolean
 * @default true
 * @desc Может ли игрок совершать перекат?
 * 
 * @param dodgeSettings:struct
 * @parent isAllowDodge:b
 * @text Configuration
 * @type struct<LDodgeActionSettings>
 * @default {"dodgeKey":"f","dodgeSwitch:i":"0","isInvincible:b":"true","stepsCount:i":"2","delayBetweenStepMS:i":"100","dodgeMoveSpeed:i":"5","dodgeRestTimerFrames:i":"30","dodgeRestVariable:i":"0"}
 * @desc Настройки переката
 * 
 * @param spacer|abs @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absSettingsGroup
 * @text Система
 * 
 * @param spacer|movement @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absMovementSettingsGroup
 * @text Extended Movement
 * 
 * @param useExtendedMovementSystem:bool
 * @parent absMovementSettingsGroup
 * @text Use Extended Movement System?
 * @type boolean
 * @on Yes (extended)
 * @off No (default)
 * @default true
 * @desc Use extended (pixel-based) movement system? If false, use default RPG Maker MV movement system.
 * 
 * @param movementGridSize:int
 * @parent absMovementSettingsGroup
 * @text Movement Grid Size
 * @type select
 * @option 12
 * @value 12
 * @option 16
 * @value 16
 * @option 24
 * @value 24
 * @option 48
 * @value 48
 * @default 24
 * @desc Size of movement grid. Default is 24px. Can be 12, 16, 24, 48.
 * 
 * @param showPathfindingGridKey
 * @parent absMovementSettingsGroup
 * @text Show Pathfinding Grid Key
 * @type text
 * @default p
 * @desc Key for show pathfinding grid for debug purposes. Default is "p". You can change it to any key you want.
 * 
 * @param noMovementPassRegionIds:intA
 * @parent absMovementSettingsGroup
 * @text No Movement Pass Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The region IDs (1-255) through which the player can not pass. Global, for all maps.
 * 
 * @param noMovementPassTerrainTags:intA
 * @parent absMovementSettingsGroup
 * @text No Movement Pass Terrain Tags
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the player can not pass. Global, for all maps.
 * 
 * 
 * @param spacer|collisions @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absCollisionsGroup
 * @text Collisions
 * 
 * @param showCollisionLayerKey
 * @parent absCollisionsGroup
 * @text Show Collision Layer Key
 * @type text
 * @default c
 * @desc Key for show collision layer for debug purposes. Default is "c". You can change it to any key you want.
 * 
 * @param eventDefaultColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Event Default Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"4","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"14"}
 * @desc Default collider settings for events. If you want to set custom collider settings for event, use <aCollider: {...}> comment.
 * 
 * @param enemiesShouldHaveDefaultCollider:bool
 * @parent eventDefaultColliderConfig:struct
 * @text Enemies have default collider?
 * @type boolean
 * @on Yes (default)
 * @off No (custom or nothing)
 * @default false
 * @desc If true, all enemies will have default collider settings. If false, enemies will have custom collider settings (if set) or nothing (if not set).
 * 
 * @param actorDefaultColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Actor Default Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"12","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"10"}
 * @desc Default collider settings for actors. If you want to set custom collider settings for actor, use <aCollider: {...}> in Actor's notetag.
 * 
 * @param eventDefaultInteractionColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Event Default Interaction Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"8","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"30"}
 * @desc Default interaction collider settings for events. If you want to set custom collider settings for event, use <aInteractionArea: {...}> comment.
 * 
 * @param highlightInteractableEvents:bool
 * @parent eventDefaultInteractionColliderConfig:struct
 * @text Highlight Interactable Events
 * @type boolean
 * @on Yes (highlight)
 * @off No (no highlight)
 * @default true
 * @desc Highlight interactable events (with <aInteractionArea: {...}> comment) when player is near. If false, no highlight.
 * 
 * @param highlightInteractableEventsUnderCursor:bool
 * @parent eventDefaultInteractionColliderConfig:struct
 * @text Highlight Interactable Events Under Cursor
 * @type boolean
 * @on Yes (highlight)
 * @off No (no highlight)
 * @default true
 * @desc Highlight interactable events (with <aInteractionArea: {...}> comment) when event is under cursor. If false, no highlight.
 * 
 * @param enemyDefaultHitBoxConfig:struct
 * @parent absCollisionsGroup
 * @text Enemy Default Hit Box
 * @type struct<AAColliderConfig>
 * @default {"type":"b","dx:int":"0","dy:int":"-4","onlyForBox":"","width:int":"36","height:int":"42","onlyForCircle":"","radius:int":"16"}
 * @desc Default hit box settings for enemies. If you want to set custom hit box settings for enemy, use <aHitbox: {...}> comment.
 * 
 * @param actorDefaultHitBoxConfig:struct
 * @parent absCollisionsGroup
 * @text Actor Default Hit Box
 * @type struct<AAColliderConfig>
 * @default {"type":"b","dx:int":"0","dy:int":"-4","onlyForBox":"","width:int":"36","height:int":"42","onlyForCircle":"","radius:int":"16"}
 * @desc Default hit box settings for actors. If you want to set custom hit box settings for actor, use <aHitbox: {...}> in Actor's notetag.
 * 
 * @param spacer|projectiles @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absProjectilesSettingsGroup
 * @text Projectiles
 * 
 * @param noProjectilesPassRegionIds:intA
 * @parent absProjectilesSettingsGroup
 * @text No Projectiles Pass Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The numbers of the regions through which the projectiles can not pass. Global, for all projectiles and maps.
 * 
 * @param noProjectilesPassTerrainTags:intA
 * @parent absProjectilesSettingsGroup
 * @text No Projectiles Pass Terrain Tags
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the projectiles can not pass. Global, for all projectiles and maps.
 * 
 * @param showProjectilesCollisionLayerKey
 * @parent absProjectilesSettingsGroup
 * @text Show Collision for Projectiles Layer Key
 * @type text
 * @default j
 * @desc Key for show collision layer for debug purposes. Default is "j". You can change it to any key you want.
 * 
 * 
 * @param spacer|common @text‏‏‎ ‎@desc ===============================================
 * 
 * @param commonSettingsGroup
 * @text Общие настройки
 * 
 * @param fonts:strA
 * @parent commonSettingsGroup
 * @text Шрифты
 * @type text[]
 * @default []
 * @desc Дополнительные шрифты для Вашей игры (из папки fonts\ folder), указывать без расширения (только название)
 * 
 * @param isSaveUIEditsGlobal:bool
 * @parent commonSettingsGroup
 * @type boolean
 * @text Глобальный UI?
 * @on Да (глобальный)
 * @off Нет (файл сохранения)
 * @default false
 * @desc Если ВКЛ, то изменения UI (через UI Editor или вызовом скриптов) будут сохранены в конфиг и применены при старте игры снова
 * 
 * @param customGaugesSet:structA
 * @parent commonSettingsGroup
 * @text Custom Gauges
 * @default []
 * @type struct<CGaugeCustom>[]
 * @desc Custom gauges, used in uAPI script calls, read Wiki for more information
 * 
 * @param spacer|popUpSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param popUpDamageSettingsGroup
 * @text Всплывающие сообщения
 * 
 * @param isShowPopUp:bool
 * @parent popUpDamageSettingsGroup
 * @type boolean
 * @text Включены?
 * @on Да 
 * @off Нет 
 * @default true
 * @desc Если Нет (ВЫКЛ), то в игре не будет всплывающих сообщений боевой системы АБС
 * 
 * @param popUpTextForMiss
 * @parent popUpDamageSettingsGroup
 * @text Промах
 * @default Промах
 * @desc Текст для промаха
 * 
 * @param popUpExpSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Опыт
 * @type struct<LDPUExp>
 * @default {"active:b":"true","styleId":"Experience","textFormat":"+%1 exp","aboveChar:b":"false","bindToChar:b":"false"}
 * @desc Настройки всплывающего сообщения с опытом
 * 
 * @param popUpGoldSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Золото
 * @type struct<LDPUGold>
 * @default {"popUpStyle:s":"{\"id\":\"gold\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"right\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e6c42e\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"goldPopUpIcon\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","textFormat":" *1","bindToChar:b":"true"}
 * @desc Настройки всплывающего сообщения с золотом
 * 
 * @param popUpDamageTable:structA
 * @parent popUpDamageSettingsGroup
 * @text Таблица
 * @type struct<LDamagePopUpVisualSettings>[]
 * @default ["{\"id\":\"Miss_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"13\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"16\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#E6E6E6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Heal_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#80FF00\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FFFFFF\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"17\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e3483d\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy_Critical\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-5\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#F3E107\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player_Critical\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FF0000\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_Other_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#008080\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Experience\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-10\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#a365e6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}"]
 * @desc Настройки всплывающих сообщений для разных видов урона и навыков
 * 
 * @param spacer|buffsStatesSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param buffsStatesSettingsGroup
 * @text Бафы и состояния
 * 
 * @param isShowBuffsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text Показывать бафы на UI?
 * @on Да
 * @off Нет
 * @default true
 * @desc Показывать активные бафы персонажа игрока на экране? (левый вверхний угол - по умолчанию)
 * 
 * @param buffsIconsPositions:structA
 * @parent isShowBuffsOnUI:bool
 * @type struct<XY>[]
 * @text Позиции
 * @default ["{\"x:int\":\"4\",\"y:int\":\"4\"}","{\"x:int\":\"42\",\"y:int\":\"4\"}","{\"x:int\":\"80\",\"y:int\":\"4\"}","{\"x:int\":\"118\",\"y:int\":\"4\"}"]
 * @desc Позиции иконок текущих бафов игрока. Можно добавлять или удалять. Кол-во позиций = сколько бафов будет на экране.
 * 
 * @param buffIconSettings:struct
 * @parent isShowBuffsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text Настройки
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"-2\\\",\\\"y:int\\\":\\\"-4\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc Визуальные настройки отображения бафов
 * 
 * @param isShowStatsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text Показывать состояния на UI?
 * @on Да
 * @off Нет
 * @default true
 * @desc Показывать активные состояния персонажа игрока на экране? (левый вверхний угол - по умолчанию)
 * 
 * @param statesIconsPositions:structA
 * @parent isShowStatsOnUI:bool
 * @type struct<XY>[]
 * @text Позиции
 * @default ["{\"x:int\":\"4\",\"y:int\":\"40\"}","{\"x:int\":\"42\",\"y:int\":\"40\"}","{\"x:int\":\"80\",\"y:int\":\"40\"}","{\"x:int\":\"118\",\"y:int\":\"40\"}"]
 * @desc Позиции иконок текущих состояний игрока. Можно добавлять или удалять. Кол-во позиций = сколько состояний будет на экране.
 * 
 * @param statsIconSettings:struct
 * @parent isShowStatsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text Настройки
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc Визуальные настройки отображения состояний
 * 
 * @param stateIconsAboveChars
 * @parent buffsStatesSettingsGroup
 * @text Иконки над персонажами
 * 
 * @param isShowStateIconAbvPl:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Над игроком?
 * @on Да
 * @off Нет
 * @default false
 * @desc Показывать иконки состояний над игроком?
 * 
 * @param isShowStateIconAbvEnms:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Enemies?
 * @on Да
 * @off Нет
 * @default true
 * @desc Показывать иконки состояний над врагами?
 * 
 * @param isShowStateIconAbvAls:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text Show icon above Allies?
 * @on Да
 * @off Нет
 * @default true
 * @desc Показывать иконки состояний над сопартийцами?
 * 
 * @param stateIconsMargins:struct
 * @text Позиция
 * @parent stateIconsAboveChars
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"-64"}
 * @desc Позиция иконки состояния, относительно персонажа
 * 
 * @param stateIconsScale:int
 * @text Масштаб
 * @parent stateIconsAboveChars
 * @type number
 * @decimals 2
 * @default 0.7
 * @desc Размер (масштаб) иконки состояния. Стандартный размер 32 пикселя.
 * 
 * @param stateIconsOnEnemyInfoUI
 * @parent buffsStatesSettingsGroup
 * @text Иконки на UI противника
 * 
 * @param statesIconsPositionsForEnemy:structA
 * @parent stateIconsOnEnemyInfoUI
 * @type struct<XY>[]
 * @text Позиции иконок
 * @default ["{\"x:int\":\"8\",\"y:int\":\"64\"}","{\"x:int\":\"28\",\"y:int\":\"64\"}","{\"x:int\":\"48\",\"y:int\":\"64\"}","{\"x:int\":\"68\",\"y:int\":\"64\"}"]
 * @desc Позиции иконок текущих состояний игрока. Можно добавлять или удалять. Кол-во позиций = сколько состояний будет на экране.
 * 
 * @param stateIconsScaleOnEnUI:int
 * @text Масштаб
 * @parent stateIconsOnEnemyInfoUI
 * @type number
 * @decimals 2
 * @default 0.6
 * @desc Размер (масштаб) иконки состояния. Стандартный размер 32 пикселя.
 * 
 * @param spacer|skillPanel @text‏‏‎ ‎@desc ===============================================
 * 
 * @param skillPanelSettingsGroup
 * @text Панель навыков
 * 
 * @param isAddNewSkillsOnPanelOnLearning:bool
 * @parent skillPanelSettingsGroup
 * @text Добавлять при изучении?
 * @type boolean
 * @on Добавлять
 * @off Нет
 * @default true
 * @desc Когда игрок изучил новый навык, добавлять его автоматически на панель навыков?
 * 
 * @param isAddNewItemOnPanelOnPickup:bool
 * @parent skillPanelSettingsGroup
 * @text Добавлять предмет?
 * @type boolean
 * @on Добавлять
 * @off Нет
 * @default true
 * @desc Когда игрок получил предмет, добавлять его автоматически на панель навыков?
 * 
 * @param isRemoveItemFromPanelIfZeroCount:bool
 * @parent skillPanelSettingsGroup
 * @text Удалять предметы?
 * @type boolean
 * @default false
 * @desc Удалять предмет из панели навыков, если предмета нет больше в инвентаре? (количество = 0)
 * 
 * @param isUseOutlineEffect:bool
 * @parent skillPanelSettingsGroup
 * @text Эффект подсветки?
 * @type boolean
 * @on Да (качество)
 * @off Нет (+ производительность)
 * @default true
 * @desc Эффект подсветки слотов навыков. ВЫКЛ чтобы увеличить производительность.
 * 
 * @param primaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text Главная атака
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"218\",\"y:e\":\"583\"}","symbol":"E"}
 * @desc Обязательный. Слот навыка для главной атаки (левая кнопка мыши)
 * 
 * @param secondaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text Вторичная атака
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"255\",\"y:e\":\"583\"}","symbol":"Q"}
 * @desc Обязательный. Слот навыка для вторичной атаки (правая кнопка мыши)
 * 
 * @param allSkillSlots:structA
 * @parent skillPanelSettingsGroup
 * @text Слоты
 * @type struct<LSkillSlotItem>[]
 * @default ["{\"position:struct\":\"{\\\"x:e\\\":\\\"302\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"1\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"339\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"2\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"376\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"3\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"413\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"4\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"450\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"5\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"487\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"6\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"524\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"7\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"561\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"8\"}"]
 * @desc Опционально. Слоты для навыков. Можно удалять или добавлять.
 * 
 * @param skillSlotVisualSettings:s
 * @parent skillPanelSettingsGroup
 * @text Визуальные настройки
 * @type struct<LSkillSlotItemVisual> 
 * @desc Визуальные настройки (общие) для всех слотов навыков.
 * @default {"visible:bool":"true","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","outlineGroup":"","outlineMargins:s":"{\"x:int\":\"-2\",\"y:int\":\"-2\"}","outlinePulseSpeed:i":"40","selectedOutlineColor:str":"#fcba03","clickedOutlineColor:str":"#0b03fc","readyOutlineColor:str":"#21b53c","badOutlineColor:str":"#d61a1a","icon:s":"{\"visible:b\":\"true\",\"size:i\":\"32\",\"index:i\":\"0\"}","iconMargins:s":"{\"x:int\":\"2\",\"y:int\":\"2\"}","symbolText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"20\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"18\\\",\\\"y:int\\\":\\\"22\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"14\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#e0cfbf\"}","timeText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"2\\\",\\\"y:int\\\":\\\"2\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fcba03\"}","countText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"-6\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#eb852d\"}"}
 * 
 * 
 * @param spacer|playerAndParty @text‏‏‎ ‎@desc ===============================================
 * 
 * @param playerAndPartySettingsGroup
 * @text Игрок и партия
 * 
 * @param isShakeScreenWhenPlayerGetDamage:bool
 * @parent playerAndPartySettingsGroup
 * @text Тряска при уроне?
 * @type boolean
 * @on Тряска
 * @off Нет
 * @default true
 * @desc Активировать эффект тряски экрана когда игрок получает урон?
 * 
 * @param isShowBloodSplatterEffect:bool
 * @parent playerAndPartySettingsGroup
 * @text Эффект когда присмерти?
 * @type boolean
 * @on Показывать
 * @off Нет
 * @default true
 * @desc Эффект мерцания экрана когда у игрока мало здоровья.
 * 
 * @param boolSplatterEffectSettings:struct
 * @parent isShowBloodSplatterEffect:bool
 * @text Effect Settings
 * @type struct<LBloodSplatterEffectSettings> 
 * @default {"BS_Picture":"","BS_Color":"#cf3d23","BS_Opacity:int":"124","BS_HpRate:int":"15"}
 * @desc Настройки эффекта. Порог здоровья для активации, цвет, доп. картинка.
 * 
 * @param commonEventOnPlayerDeath:int
 * @parent playerAndPartySettingsGroup
 * @text При смерти игрока
 * @type common_event
 * @default 0
 * @desc Общее событие при смерти игрока. Если 0 - то сразу экран Game Over
 * 
 * @param characterDeadMotionType:int
 * @parent commonEventOnPlayerDeath:int
 * @text Show Death Motion
 * @type select
 * @option Нет
 * @value 0
 * @option Всегда
 * @value 1
 * @option Если нет AnimaX
 * @value 2
 * @default 1
 * @desc Показывать Dead Motion SV Battler спрайт персонажа (игрок или союзник только)
 * 
 * @param isUseCustomLevelUp:bool
 * @parent playerAndPartySettingsGroup
 * @text Is Use Custom LevelUp?
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc Показывать пользовательский эффект при новом уровне?
 * 
 * @param customLevelUpSettings:struct
 * @parent isUseCustomLevelUp:bool
 * @text Настройки эффекта
 * @type struct<LCustomLevelUpSettings>
 * @default {"databaseAnimationId:i":"0","imageSeqAnimationName:str":"","imageSeqAnimationMargins:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","extraSE:str":"","isShowPopUp:b":"true","popUpText:str":"Level %1!","popUpStyle:s":"{\"id\":\"levelUp\",\"randDX:int\":\"0\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"60\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"20\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#deb521\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","commonEvent:i":"0","scriptAction:str":""}
 * 
 * @param playerVisualSettingsGroup
 * @parent playerAndPartySettingsGroup
 * @text Интерфейс
 * 
 * @param pvsGaugesSubGroup
 * @parent playerVisualSettingsGroup
 * @text Основные хар-ки
 * 
 * @param playerHpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text Полоса здоровья HP
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"304\",\"y:e\":\"560\"}","label":"Player_HPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-33\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Визуальные настройки полосы здоровья игрока
 * 
 * @param playerMpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text Полоса маны MP
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_MPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_MPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Визуальные настройки полосы маны игрока
 * 
 * @param playerTpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text Полоса TP
 * @type struct<LActorGauge>
 * @default {"visible:bool":"false","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_TPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_TPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Визуальные настройки полосы TP игрока
 * 
 * @param playerExpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text Полоса опыта
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"273\",\"y:e\":\"528\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_EXPGauge\",\"foreground\":\"Player_EXPGaugeForeground\",\"mask\":\"Player_EXPGaugeMask\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Визуальные настройки полосы опыта игрока
 * 
 * @param spacer|enemies @text‏‏‎ ‎@desc ===============================================
 * 
 * @param enemySettingsGroup
 * @text Настройки врагов
 * 
 * @param enemyVisualSettingsGroup
 * @parent enemySettingsGroup
 * @text Интерфейс
 * 
 * @param enemyVSGaugesSubGroup
 * @parent enemyVisualSettingsGroup
 * @text Основные хар-ки
 * 
 * @param enemyMiniHpGaugeSettings:struct
 * @parent enemyVSGaugesSubGroup
 * @text Полоса HP на карте
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc Настройки полосы здоровья на карте (над головой)
 * 
 * @param enemyMiniHpGaugesCustoms:structA
 * @parent enemyVSGaugesSubGroup
 * @text Пользовательские
 * @type struct<LEnemyCustomMiniGauge>[]
 * @default []
 * @desc [PRO] Исп. параметр <miniHpGaugeStyle> чтобы назначить индивидуальную полоску здоровья для конкретного врага
 * 
 * @param enemyInfoVisualSettings:struct
 * @text Информация о враге
 * @type struct<LEnemyInfoVisual>
 * @parent enemyVisualSettingsGroup
 * @desc Визаульные настройки окошка информации о враге [когда наводишь мышку на врага]
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"640\",\"y:e\":\"66\"}","image":"Enemy_Background","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","nameFormat":" *2","hpText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"12\\\",\\\"y:int\\\":\\\"28\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:s":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}","gaugeMargins:s":"{\"x:int\":\"6\",\"y:int\":\"28\"}","face:s":"{\"visible:bool\":\"true\",\"faceName\":\"\",\"faceIndex:i\":\"0\",\"mirror:b\":\"false\",\"size:i\":\"74\",\"margins:s\":\"{\\\"x:int\\\":\\\"92\\\",\\\"y:int\\\":\\\"10\\\"}\"}","battleState:s":"{\"visible:bool\":\"true\",\"image\":\"Enemy_BattleState_Free\",\"margins:s\":\"{\\\"x:int\\\":\\\"142\\\",\\\"y:int\\\":\\\"60\\\"}\"}","foregroundImage:s":"{\"visible:bool\":\"true\",\"image\":\"\",\"margins:s\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\"}"}
 * 
 * @param enemyAIUpdateThreadMS:int
 * @parent enemySettingsGroup
 * @text AI Think Interval
 * @type number
 * @min 1
 * @max 200
 * @default 100
 * @desc Enemy AI logic update interval, in milliseconds!. Less value, AI more quicker takes decisions.
 * 
 * @param enemyAIUpdateVisionIntervalFR:int
 * @parent enemySettingsGroup
 * @text AI Vision Interval
 * @type number
 * @min 1
 * @max 32
 * @default 4
 * @desc Enemy vision check interval, in FRAMES!. Less value, AI more quicker check around for enemies
 * 
 * 
 * @param enemies_noPassVision:intA
 * @parent enemySettingsGroup
 * @text Регионы без обзора
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc Номера регионов, через которые враг НЕ видит. Глобальная настройка, для всех врагов.
 * 
 * @param enemies_noPassVision2:intA
 * @parent enemySettingsGroup
 * @text Территории без обзора
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc Тэги территорий (1-7) через которые враг НЕ видит. Глобальная настройка, для всех врагов.
 * 
 * @param enemies_afterDeathBonuses:structA
 * @parent enemySettingsGroup
 * @text Flying bonuses
 * @type struct<FlyBonus>[]
 * @default ["{\"image:str\":\"BonusGreen\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"25\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusBlue\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"25\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusYellow\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"50\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"20\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"ba_1\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}"]
 * @desc Доп. бонусы из врагов для параметра bonusOnDeadIds (см. Wiki Flying Bonuses)
 * 
 * @param enemiesSpawnSettingsGroup
 * @parent enemySettingsGroup
 * @text Настройки спавна
 * 
 * @param enemies_spawn_mapId:int
 * @parent enemiesSpawnSettingsGroup
 * @text Карта спавна
 * @type number
 * @min 0
 * @default 0
 * @desc [Необходимо] Номер карты, на которой будут хранится шаблоны событий для спавна. 0 - система не будет работать
 * 
 * @param enemies_spawn_aboveEvents:b
 * @parent enemiesSpawnSettingsGroup
 * @text Поверх событий?
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc Можно ли спавнить врагов поверх событий или других врагов?
 * 
 * @param enemies_spawn_cacheAllowed:b
 * @parent enemiesSpawnSettingsGroup
 * @text Кэш регионов
 * @type boolean
 * @on Да (производительность)
 * @off Нет
 * @default true
 * @desc Если какой-либо плагин динамически меняет номера регионов в течении игры, то ВЫКЛ этот параметр
 * 
 * @param spawn_points:structA
 * @parent enemiesSpawnSettingsGroup
 * @text Spawn Points
 * @type struct<LSpawnPoint>[]
 * @default []
 * @desc Набор точек спавна для события с <absSpawnPoint:ID>. Читайте Wiki документацию.
 * 
 * @param spacer|map @text‏‏‎ ‎@desc ===============================================
 * 
 * @param mapSettingsGroup
 * @text Карта
 * 
 * @param mapScrolling:s
 * @text Прокрутка карты
 * @parent mapSettingsGroup
 * @type struct<LMapScrollSettings>
 * @default {"isEnabled:b":"false","scrollZone:int":"10","speed:int":"5","delay:int":"60","resetOnMove:b":"true","resetOnAction:b":"true"}
 * @desc Настройки прокрутки карты
 * 
 * 
 * @param miniHpGaugeSetings:s
 * @text Мини полоска здоровья
 * @parent mapSettingsGroup
 * @type struct<LMiniHpGaugeSettings>
 * @default {"active:b":"true","showOnlyOnHover:b":"true","showOnDamage:b":"true","showWhenNotFull:b":"false"}
 * @desc Настройки отображения мини полоски здоровья над АБС событиями
 * 
 * @param mvAnimationAutoScalling:int
 * @parent mapSettingsGroup
 * @text [MV] Animation Scalling
 * @type number
 * @decimals 1
 * @default 0.3
 * @desc [Только для MV] Автоматический масштаб анимаций, которые будут вопроизводится на карте или на АБС персонаже. 1 - как в настройках анимации.
 * 
 * @param defaultBattleAutoBgm:struct
 * @parent mapSettingsGroup
 * @text Battle Auto BGM
 * @type struct<BattleAutoBGM>
 * @desc BGM для боя (autoplay). Можно задать для каждой карты через <battleAutoBgm:NAME> в заметке карты
 * @default {"name":"","delay:i":"0.50"}
 * 
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * 
 * 
 * 
 * @command ABSEventSettings
 * @text Настройки АБС врага
 * @desc Настройки АБС параметров для текущего события (не все)
 * 
 * @arg MainGroup
 * @text Основные
 * 
 * @arg viewRadius
 * @parent MainGroup
 * @text Область видимости
 * @type number
 * @min 1
 * @max 100
 * @default 5
 * @desc Как далеко (клетки карты) видит данный враг
 * 
 * @arg returnRadius
 * @parent MainGroup
 * @text Область возврата
 * @type number
 * @min 1
 * @max 100
 * @default 12
 * @desc Как далеко может отойти враг в бою от начальной точки (где он начал бой)
 * 
 * @arg noMoveInBattle
 * @parent MainGroup
 * @text Остановка в бою
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> враг не двигается во время битвы
 * 
 * @arg noApproach
 * @parent MainGroup
 * @text Нет преследованию
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> враг не преследует цель во время битвы
 * 
 * @arg onDeath
 * @parent MainGroup
 * @text Смерть
 * @type text
 * @default
 * @desc ABS скрипт (SAction), вызываемый когда враг погибает
 * 
 * @arg onSeeTarget
 * @parent MainGroup
 * @text Вижу цель
 * @type text
 * @default
 * @desc ABS скрипт (SAction), вызываемый когда враг увидел цель
 * 
 * @arg onHit
 * @parent MainGroup
 * @text Получил урон
 * @type text
 * @default
 * @desc ABS скрипт (SAction), вызываемый когда враг получил урон
 * 
 * @arg expVar
 * @parent MainGroup
 * @text Опыт из переменной
 * @type variable
 * @default 0
 * @desc Если > 0, то -> опыт игрок получит из переменной. 0 - из базы данных 
 * 
 * @arg autoExp
 * @parent MainGroup
 * @text Авто опыт
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> игрок получит опыт автоматически после убийства врага
 * 
 * @arg notAgressive
 * @parent MainGroup
 * @text Спокойный
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> враг не атакует первым, только в ответ
 * 
 * @arg teamId
 * @parent MainGroup
 * @text Команда
 * @type number
 * @min 1
 * @max 10
 * @default 1
 * @desc Враги с разным Team ID сражаются друг с другом
 * 
 * @arg onDeathVar
 * @parent MainGroup
 * @text Учёт смерти
 * @type variable
 * @default 0
 * @desc Если > 0, то -> +1 к этой переменной при смерти врага
 * 
 * @arg saveHp
 * @parent MainGroup
 * @text Сохранять здоровье
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> сохранить кол-во здоровья данному врагу (при смене карты)
 * 
 * @arg MapGroup
 * @text Карта
 * 
 * @arg shatterEffect
 * @parent MapGroup
 * @text Эффект разбития?
 * @type boolean
 * @default true
 * @desc Проигрывать эффект разбития спрайта когда враг погибает?
 * 
 * @arg deadSwitch
 * @parent MapGroup
 * @text Переключатель
 * @type select
 * @option A
 * @option B
 * @option C
 * @option D
 * @option 0
 * @default 0
 * @desc Данный переключатель будет ВКЛ, когда враг погибает (0 - ничего)
 * 
 * @arg eraseOnDead
 * @parent deadSwitch
 * @text Удалять при смерти?
 * @type boolean
 * @default true
 * @desc Удалять данное событие когда враг погибает? Только если переключатель = 0
 * 
 * @arg heavy
 * @parent MapGroup
 * @text Тяжёлый
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> нельзя сдвинуть импульсом
 * 
 * @arg weaponMotionType
 * @parent MapGroup
 * @text Weapon Motion Type
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc Weapon Motion Type для навыков, которые используют данный функционал (см. Wiki)
 * 
 * @arg lootDropOnDeath
 * @parent MapGroup
 * @text Выбросить лут
 * @type boolean
 * @default false
 * @desc Если ВКЛ -> выбросить лут (предметы) автоматически после смерти
 * 
 * @arg VisualGroup
 * @text Визаульные настройки
 * 
 * @arg UIInfo
 * @parent VisualGroup
 * @text Показывать на UI?
 * @type boolean
 * @default true
 * @desc Показывать информацию о данном противнике на UI ?
 * 
 * @arg faceName
 * @parent VisualGroup
 * @text Портрет
 * @type file
 * @required 1
 * @dir img\faces
 * @default
 * @desc Название файла изборажения с портретом для данного врага
 * 
 * @arg faceIndex
 * @parent faceName
 * @text Индекс
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc Индекс лица на файле изображения портрета
 * 
 * @arg miniHpGaugeStyle
 * @parent VisualGroup
 * @text Mini HP Gauge Style
 * @type number
 * @default
 * @desc Пользователский стиль (имя) полоски здоровья (из параметров плагина)
 * 
 * @arg AnimationGroup
 * @text Анимация
 * 
 * @arg hitAnimationId
 * @parent AnimationGroup
 * @text Анимация при ударе
 * @type animation
 * @default 1
 * @desc Анимация удара на персонаже (игроке), когда данный враг атакует его
 * 
 * @command EMPTY_HOLDER
 * @text ‏
 * @desc
 * @default
 */
/*:zh-cn
 * @plugindesc (v.0.10.0 BETA)[PRO] Active Battle System
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-abs-z/
 *
 * @help
 *
 * 注：此插件目前仍在继续研发之中

 * ----------------------------------------------------------- 
 * 官方网站: https://github.com/KageDesu/Alpha-ABS-Z
 * 说明文档: https://github.com/KageDesu/Alpha-ABS-Z/wiki
 * 新手说明：https://github.com/KageDesu/Alpha-ABS-Z/wiki/For-beginners-(if-you-just-installed-plugin)
 * (注：以上站点均为英文，浏览时可用谷歌浏览器自动翻译页面成中文)
 *
 *
 包含的文件：
 * 插件: js/plugins/Alpha_ABSZ.js
 * 字体: fonts/
 *      -AABS_0.ttf
 *      -AABS_1.ttf
 *      -AABS_2.ttf
 *      -AABS_3.ttf
 * 图片: img/Alpha/ *all files*
 * 数据（设置）：data/AABSZ/ 所有文件
 *
 * 中文翻译:古火乐(QQ:452901928)
 *
  * @requiredAssets img/Alpha/Button_SkSItemsGroup_00
* @requiredAssets img/Alpha/Button_SkSItemsGroup_01
* @requiredAssets img/Alpha/Button_SkSItemsGroup_03
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_00
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_01
* @requiredAssets img/Alpha/Button_SkSSkillsGroup_03
* @requiredAssets img/Alpha/Enemy_Background
* @requiredAssets img/Alpha/Enemy_BattleState_Free
* @requiredAssets img/Alpha/Event_HPGauge2
* @requiredAssets img/Alpha/Player_HPGauge
* @requiredAssets img/Alpha/Player_HPGaugeLabel
* @requiredAssets img/Alpha/Player_MPGauge
* @requiredAssets img/Alpha/Player_MPGaugeLabel
* @requiredAssets img/Alpha/Player_TPGauge
* @requiredAssets img/Alpha/Player_TPGaugeLabel
* @requiredAssets img/Alpha/SkillSlot_00
* @requiredAssets img/Alpha/SkillSlot_01
* @requiredAssets img/Alpha/SkillSlot_Disabled
* @requiredAssets img/Alpha/SkillSlot_Outline
* @requiredAssets img/Alpha/PlayerStateIcons
* @requiredAssets img/Alpha/Player_EXPGauge
* @requiredAssets img/Alpha/Player_EXPGaugeForeground
* @requiredAssets img/Alpha/Player_EXPGaugeMask
* @requiredAssets img/Alpha/Windows/headerLine
* @requiredAssets img/Alpha/Windows/windowCloseButton_00
* @requiredAssets img/Alpha/Windows/windowCloseButton_01
* @requiredAssets img/Alpha/Windows/windowFrame
 * @param AABSZ @text @desc
 * 
 * @param inputSettings:struct
 * @text 控制设置
 * @type struct<LInputSettings>
 * @default {"LMBMapTouchMode":"Default (move)","RMBMapTouchMode":"Turn","LMBTargetTouchMode":"Smart attack (Primary)","RMBTargetTouchMode":"Smart attack (Secondary)","moveType":"WASD and Arrows","isDiagonalMovement:b":"true","isStaticAtkRot:b":"true","keybingind":"","kbReload":"R","kbCommandMenu":"C","kbRotate":"Control"}
 * @desc 操控和键盘设置
 * 
 * @param isAllowDodge:b
 * @parent inputSettings:struct
 * @text 是否允许躲闪？
 * @type boolean
 * @default true
 * @desc 是否允许玩家进行躲闪操作？
 * @param dodgeSettings:struct
 * @parent isAllowDodge:b
 * @text 配置
 * @type struct<LDodgeActionSettings>
 * @default {"dodgeKey":"f","dodgeSwitch:i":"0","isInvincible:b":"true","stepsCount:i":"2","delayBetweenStepMS:i":"100","dodgeMoveSpeed:i":"5","dodgeRestTimerFrames:i":"30","dodgeRestVariable:i":"0"}
 * @desc 躲闪动作配置
 * 
 * @param spacer|abs @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absSettingsGroup
 * @text 战斗系统
 * 
 * @param spacer|movement @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absMovementSettingsGroup
 * @text Extended Movement
 * 
 * @param useExtendedMovementSystem:bool
 * @parent absMovementSettingsGroup
 * @text Use Extended Movement System?
 * @type boolean
 * @on Yes (extended)
 * @off No (default)
 * @default true
 * @desc Use extended (pixel-based) movement system? If false, use default RPG Maker MV movement system.
 * 
 * @param movementGridSize:int
 * @parent absMovementSettingsGroup
 * @text Movement Grid Size
 * @type select
 * @option 12
 * @value 12
 * @option 16
 * @value 16
 * @option 24
 * @value 24
 * @option 48
 * @value 48
 * @default 24
 * @desc Size of movement grid. Default is 24px. Can be 12, 16, 24, 48.
 * 
 * @param showPathfindingGridKey
 * @parent absMovementSettingsGroup
 * @text Show Pathfinding Grid Key
 * @type text
 * @default p
 * @desc Key for show pathfinding grid for debug purposes. Default is "p". You can change it to any key you want.
 * 
 * @param noMovementPassRegionIds:intA
 * @parent absMovementSettingsGroup
 * @text No Movement Pass Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The region IDs (1-255) through which the player can not pass. Global, for all maps.
 * 
 * @param noMovementPassTerrainTags:intA
 * @parent absMovementSettingsGroup
 * @text No Movement Pass Terrain Tags
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the player can not pass. Global, for all maps.
 * 
 * 
 * @param spacer|collisions @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absCollisionsGroup
 * @text Collisions
 * 
 * @param showCollisionLayerKey
 * @parent absCollisionsGroup
 * @text Show Collision Layer Key
 * @type text
 * @default c
 * @desc Key for show collision layer for debug purposes. Default is "c". You can change it to any key you want.
 * 
 * @param eventDefaultColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Event Default Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"4","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"14"}
 * @desc Default collider settings for events. If you want to set custom collider settings for event, use <aCollider: {...}> comment.
 * 
 * @param enemiesShouldHaveDefaultCollider:bool
 * @parent eventDefaultColliderConfig:struct
 * @text Enemies have default collider?
 * @type boolean
 * @on Yes (default)
 * @off No (custom or nothing)
 * @default false
 * @desc If true, all enemies will have default collider settings. If false, enemies will have custom collider settings (if set) or nothing (if not set).
 * 
 * @param actorDefaultColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Actor Default Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"12","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"10"}
 * @desc Default collider settings for actors. If you want to set custom collider settings for actor, use <aCollider: {...}> in Actor's notetag.
 * 
 * @param eventDefaultInteractionColliderConfig:struct
 * @parent absCollisionsGroup
 * @text Event Default Interaction Collider
 * @type struct<AAColliderConfig>
 * @default {"type":"c","dx:int":"0","dy:int":"8","onlyForBox":"","width:int":"48","height:int":"48","onlyForCircle":"","radius:int":"30"}
 * @desc Default interaction collider settings for events. If you want to set custom collider settings for event, use <aInteractionArea: {...}> comment.
 * 
 * @param highlightInteractableEvents:bool
 * @parent eventDefaultInteractionColliderConfig:struct
 * @text Highlight Interactable Events
 * @type boolean
 * @on Yes (highlight)
 * @off No (no highlight)
 * @default true
 * @desc Highlight interactable events (with <aInteractionArea: {...}> comment) when player is near. If false, no highlight.
 * 
 * @param highlightInteractableEventsUnderCursor:bool
 * @parent eventDefaultInteractionColliderConfig:struct
 * @text Highlight Interactable Events Under Cursor
 * @type boolean
 * @on Yes (highlight)
 * @off No (no highlight)
 * @default true
 * @desc Highlight interactable events (with <aInteractionArea: {...}> comment) when event is under cursor. If false, no highlight.
 * 
 * @param enemyDefaultHitBoxConfig:struct
 * @parent absCollisionsGroup
 * @text Enemy Default Hit Box
 * @type struct<AAColliderConfig>
 * @default {"type":"b","dx:int":"0","dy:int":"-4","onlyForBox":"","width:int":"36","height:int":"42","onlyForCircle":"","radius:int":"16"}
 * @desc Default hit box settings for enemies. If you want to set custom hit box settings for enemy, use <aHitbox: {...}> comment.
 * 
 * @param actorDefaultHitBoxConfig:struct
 * @parent absCollisionsGroup
 * @text Actor Default Hit Box
 * @type struct<AAColliderConfig>
 * @default {"type":"b","dx:int":"0","dy:int":"-4","onlyForBox":"","width:int":"36","height:int":"42","onlyForCircle":"","radius:int":"16"}
 * @desc Default hit box settings for actors. If you want to set custom hit box settings for actor, use <aHitbox: {...}> in Actor's notetag.
 * 
 * @param spacer|projectiles @text‏‏‎ ‎@desc ===============================================
 * 
 * @param absProjectilesSettingsGroup
 * @text Projectiles
 * 
 * @param noProjectilesPassRegionIds:intA
 * @parent absProjectilesSettingsGroup
 * @text No Projectiles Pass Regions
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc The numbers of the regions through which the projectiles can not pass. Global, for all projectiles and maps.
 * 
 * @param noProjectilesPassTerrainTags:intA
 * @parent absProjectilesSettingsGroup
 * @text No Projectiles Pass Terrain Tags
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc The terrains tags (1-7) through which the projectiles can not pass. Global, for all projectiles and maps.
 * 
 * @param showProjectilesCollisionLayerKey
 * @parent absProjectilesSettingsGroup
 * @text Show Collision for Projectiles Layer Key
 * @type text
 * @default j
 * @desc Key for show collision layer for debug purposes. Default is "j". You can change it to any key you want.
 * 
 * 
 * @param spacer|common @text‏‏‎ ‎@desc ===============================================
 * 
 * @param commonSettingsGroup
 * @text 通用参数
 * 
 * @param fonts:strA
 * @parent commonSettingsGroup
 * @text 字体
 * @type text[]
 * @default []
 * @desc 预加载的字体 (位置：fonts\ 文件夹), 不要带扩展名
 * 
 * @param isSaveUIEditsGlobal:bool
 * @parent commonSettingsGroup
 * @type boolean
 * @text 启用全局UI
 * @on Yes (global)
 * @off No (only savegame)
 * @default false
 * @desc 如果设置为Yes那么修改UI（UI编辑器或脚本）时将对所有游戏存档生效
 * 
 * @param customGaugesSet:structA
 * @parent commonSettingsGroup
 * @text 自定义血槽
 * @default []
 * @type struct<CGaugeCustom>[]
 * @desc 自定义血槽, 可使用uAPI脚本指令，详情参见wiki
 * 
 * 
 * @param spacer|popUpSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param popUpDamageSettingsGroup
 * @text 伤害飘字提示
 * 
 * @param isShowPopUp:bool
 * @parent popUpDamageSettingsGroup
 * @type boolean
 * @text 是否启用？
 * @on Yes (enabled)
 * @off No (disabled)
 * @default true
 * @desc 若选No则表示完全不显示伤害飘字
 * 
 * @param popUpTextForMiss
 * @parent popUpDamageSettingsGroup
 * @text 文本：【闪避】
 * @default Miss
 * @desc 闪避时的飘字内容
 * 
 * @param popUpExpSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text 获得经验
 * @type struct<LDPUExp>
 * @default {"active:b":"true","styleId":"Experience","textFormat":"+%1 exp","aboveChar:b":"false","bindToChar:b":"false"}
 * @desc 获得经验值时的飘字
 * 
 * @param popUpGoldSettings:struct
 * @parent popUpDamageSettingsGroup
 * @text Gold Pop Up
 * @type struct<LDPUGold>
 * @default {"popUpStyle:s":"{\"id\":\"gold\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"right\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e6c42e\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"goldPopUpIcon\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","textFormat":" *1","bindToChar:b":"true"}
 * @desc Settings for Gold Pop Up
 * 
 * @param popUpDamageTable:structA
 * @parent popUpDamageSettingsGroup
 * @text 伤害数字
 * @type struct<LDamagePopUpVisualSettings>[]
 * @default ["{\"id\":\"Miss_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"13\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"16\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#E6E6E6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Heal_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#80FF00\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FFFFFF\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"17\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#e3483d\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Enemy_Critical\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-5\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"26\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#F3E107\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_HP_For_Player_Critical\",\"randDX:int\":\"20\",\"randDY:int\":\"5\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"21\",\"noFlyUp:bool\":\"true\",\"noFadeOut:bool\":\"true\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#FF0000\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Damage_Other_For_All\",\"randDX:int\":\"15\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"22\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"18\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#008080\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","{\"id\":\"Experience\",\"randDX:int\":\"15\",\"randDY:int\":\"12\",\"stayTime:int\":\"14\",\"changeFontSize:int\":\"20\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"100\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"100\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"-10\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"#000000\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_1\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"24\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"true\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#a365e6\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}"]
 * @desc 伤害数字飘字设置
 * 
 * @param spacer|buffsStatesSettings @text‏‏‎ ‎@desc ===============================================
 * 
 * @param buffsStatesSettingsGroup
 * @text BUFF和状态设置
 * 
 * @param isShowBuffsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text 在UI上是否显示BUFF？
 * @on Yes (show)
 * @off No
 * @default true
 * @desc 是否显示角色BUFF (默认在左上角)?
 * 
 * @param buffsIconsPositions:structA
 * @parent isShowBuffsOnUI:bool
 * @type struct<XY>[]
 * @text BUFF图标位置
 * @default ["{\"x:int\":\"4\",\"y:int\":\"4\"}","{\"x:int\":\"42\",\"y:int\":\"4\"}","{\"x:int\":\"80\",\"y:int\":\"4\"}","{\"x:int\":\"118\",\"y:int\":\"4\"}"]
 * @desc BUFF图标位置. 可以增加或删除. 位置数量等同于可显示最大图标数
 * 
 * @param buffIconSettings:struct
 * @parent isShowBuffsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text 可视化设置
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":"%1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"-2\\\",\\\"y:int\\\":\\\"-4\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc BUFF图标可视化设置
 * 
 * @param isShowStatsOnUI:bool
 * @parent buffsStatesSettingsGroup
 * @type boolean
 * @text 在UI上是否显示状态
 * @on Yes (show)
 * @off No
 * @default true
 * @desc 是否显示角色状态 (默认在左上角)?
 * 
 * @param statesIconsPositions:structA
 * @parent isShowStatsOnUI:bool
 * @type struct<XY>[]
 * @text 状态位置
 * @default ["{\"x:int\":\"4\",\"y:int\":\"40\"}","{\"x:int\":\"42\",\"y:int\":\"40\"}","{\"x:int\":\"80\",\"y:int\":\"40\"}","{\"x:int\":\"118\",\"y:int\":\"40\"}"]
 * @desc 状态图标位置. 可以增加或删除. 位置数量等同于可显示最大图标数
 * 
 * @param statsIconSettings:struct
 * @parent isShowStatsOnUI:bool
 * @type struct<LStateIconSettings>
 * @text 属性可视化设置
 * @default {"visible:b":"true","position:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:b":"true","textFormat:str":" *1","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"38\\\",\\\"h:int\\\":\\\"14\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"16\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fafdec\"}","icon:s":"{\"visible:bool\":\"true\",\"index:i\":\"0\",\"size:i\":\"32\"}"}
 * @desc 状态图标属性设置
 * 
 * @param stateIconsAboveChars
 * @parent buffsStatesSettingsGroup
 * @text 角色上面的状态图标
 * 
 * @param isShowStateIconAbvPl:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text 在角色头顶上显示状态图标？
 * @on Yes (show)
 * @off No
 * @default false
 * @desc 是否在角色头顶上显示状态图标？
 * 
 * @param isShowStateIconAbvEnms:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text 在怪物头顶上显示状态图标？
 * @on Yes (show)
 * @off No
 * @default true
 * @desc 是否在怪物头顶上显示状态图标？
 * 
 * @param isShowStateIconAbvAls:bool
 * @parent stateIconsAboveChars
 * @type boolean
 * @text 在队友头顶上显示状态图标？
 * @on Yes (show)
 * @off No
 * @default true
 * @desc 是否在队友头顶上显示状态图标？
 * 
 * @param stateIconsMargins:struct
 * @text 对齐
 * @parent stateIconsAboveChars
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"-64"}
 * @desc 相对于角色，状态图标的偏移量
 * 
 * @param stateIconsScale:int
 * @text 图标大小
 * @parent stateIconsAboveChars
 * @type number
 * @decimals 2
 * @default 0.7
 * @desc 默认大小为32像素，实际大小=默认大小*这个比例
 * 
 * @param stateIconsOnEnemyInfoUI
 * @parent buffsStatesSettingsGroup
 * @text 怪物界面上的状态图标
 * 
 * @param statesIconsPositionsForEnemy:structA
 * @parent stateIconsOnEnemyInfoUI
 * @type struct<XY>[]
 * @text 状态图标位置
 * @default ["{\"x:int\":\"8\",\"y:int\":\"64\"}","{\"x:int\":\"28\",\"y:int\":\"64\"}","{\"x:int\":\"48\",\"y:int\":\"64\"}","{\"x:int\":\"68\",\"y:int\":\"64\"}"]
 * @desc 状态图标位置. 可以增加或删除. 位置数量等同于可显示最大图标数
 * 
 * @param stateIconsScaleOnEnUI:int
 * @text 图标大小
 * @parent stateIconsOnEnemyInfoUI
 * @type number
 * @decimals 2
 * @default 0.6
 * @desc 默认大小为32像素，实际大小=默认大小*这个比例
 * 
 * @param spacer|skillPanel @text‏‏‎ ‎@desc ===============================================
 * 
 * @param skillPanelSettingsGroup
 * @text 技能面板设置
 * 
 * @param isAddNewSkillsOnPanelOnLearning:bool
 * @parent skillPanelSettingsGroup
 * @text 学习技能后是否增加技能？
 * @type boolean
 * @on Add
 * @off No
 * @default true
 * @desc 学习技能时是否自动在技能栏上出现技能
 * 
 * @param isAddNewItemOnPanelOnPickup:bool
 * @parent skillPanelSettingsGroup
 * @text 获得物品时出现物品图标？
 * @type boolean
 * @on Add
 * @off No
 * @default true
 * @desc 当玩家获得新物品时，是否在技能栏上出现物品图标？
 * 
 * @param isRemoveItemFromPanelIfZeroCount:bool
 * @parent skillPanelSettingsGroup
 * @text 删除数量为0个的物品？
 * @type boolean
 * @default false
 * @desc 当某物品数量为0时是否从技能栏上删除？
 * 
 * @param isUseOutlineEffect:bool
 * @parent skillPanelSettingsGroup
 * @text 是否启用描边效果？
 * @type boolean
 * @on Yes (quality)
 * @off No (performance)
 * @default true
 * @desc 技能栏外描边效果，开启后会消耗一定性能
 * 
 * @param primaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text 主要攻击栏
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"218\",\"y:e\":\"583\"}","symbol":"E"}
 * @desc 必选项. 技能栏上的主要攻击（默认攻击）
 * 
 * @param secondaryAttackSlot:struct
 * @parent skillPanelSettingsGroup
 * @text 次要攻击栏
 * @type struct<LSkillSlotItem>
 * @default {"position:struct":"{\"x:e\":\"255\",\"y:e\":\"583\"}","symbol":"Q"}
 * @desc 必选项. 技能栏上的次要攻击（非默认攻击）
 * 
 * @param allSkillSlots:structA
 * @parent skillPanelSettingsGroup
 * @text 技能栏
 * @type struct<LSkillSlotItem>[]
 * @default ["{\"position:struct\":\"{\\\"x:e\\\":\\\"302\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"1\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"339\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"2\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"376\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"3\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"413\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"4\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"450\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"5\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"487\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"6\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"524\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"7\"}","{\"position:struct\":\"{\\\"x:e\\\":\\\"561\\\",\\\"y:e\\\":\\\"583\\\"}\",\"symbol\":\"8\"}"]
 * @desc 可选项. 技能栏.
 * 
 * @param skillSlotVisualSettings:s
 * @parent skillPanelSettingsGroup
 * @text 技能栏显示
 * @type struct<LSkillSlotItemVisual> 
 * @desc 技能栏显示设置
 * @default {"visible:bool":"true","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","outlineGroup":"","outlineMargins:s":"{\"x:int\":\"-2\",\"y:int\":\"-2\"}","outlinePulseSpeed:i":"40","selectedOutlineColor:str":"#fcba03","clickedOutlineColor:str":"#0b03fc","readyOutlineColor:str":"#21b53c","badOutlineColor:str":"#d61a1a","icon:s":"{\"visible:b\":\"true\",\"size:i\":\"32\",\"index:i\":\"0\"}","iconMargins:s":"{\"x:int\":\"2\",\"y:int\":\"2\"}","symbolText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"20\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"18\\\",\\\"y:int\\\":\\\"22\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"14\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#e0cfbf\"}","timeText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"2\\\",\\\"y:int\\\":\\\"2\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#fcba03\"}","countText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"32\\\",\\\"h:int\\\":\\\"32\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"-6\\\"}\",\"alignment:str\":\"right\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_1\\\",\\\"size:int\\\":\\\"12\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#eb852d\"}"}
 * 
 * 
 * @param spacer|playerAndParty @text‏‏‎ ‎@desc ===============================================
 * 
 * @param playerAndPartySettingsGroup
 * @text 角色和伙伴设置
 * 
 * @param isShakeScreenWhenPlayerGetDamage:bool
 * @parent playerAndPartySettingsGroup
 * @text 受伤时是否晃动？
 * @type boolean
 * @on Shake
 * @off No
 * @default true
 * @desc 角色受伤时是否晃动屏幕？
 * 
 * @param isShowBloodSplatterEffect:bool
 * @parent playerAndPartySettingsGroup
 * @text 角色HP过低时是否显示屏幕红色警告效果
 * @type boolean
 * @on Show
 * @off No
 * @default true
 * @desc 角色HP过低时屏幕显示警告闪烁效果/图片
 * 
 * @param boolSplatterEffectSettings:struct
 * @parent isShowBloodSplatterEffect:bool
 * @text 设置
 * @type struct<LBloodSplatterEffectSettings> 
 * @default {"BS_Picture":"","BS_Color":"#cf3d23","BS_Opacity:int":"124","BS_HpRate:int":"15"}
 * @desc
 * 
 * @param commonEventOnPlayerDeath:int
 * @parent playerAndPartySettingsGroup
 * @text 死亡时运行公共事件
 * @type common_event
 * @default 0
 * @desc 角色死亡时运行什么公共事件，为0则直接游戏结束
 * 
 * @param characterDeadMotionType:int
 * @parent commonEventOnPlayerDeath:int
 * @text 显示死亡动画
 * @type select
 * @option Never
 * @value 0
 * @option Always
 * @value 1
 * @option If not have AnimaX
 * @value 2
 * @default 1
 * @desc 是否使用SV侧面战斗图来显示角色的死亡动画
 * 
 *  @param partyExpGainMode
 *  @parent playerAndPartySettingsGroup
 *  @text 如何获得经验值？
 *  @type select
 *  @option To player only
 *  @value player
 *  @option For all
 *  @value party
 *  @option For all divided
 *  @value partyDivided
 *  @option One who kill
 *  @value killer
 *  @default partyDivided
 *  @desc 队伍杀怪后如何分配经验?(从上到下依次是：仅玩家、所有人相等、所有人均分、最后一击者)
 * 
 * 
 * @param isUseCustomLevelUp:bool
 * @parent playerAndPartySettingsGroup
 * @text 是否使用自定义的升级效果？
 * @type boolean
 * @on Yes
 * @off No
 * @default true
 * @desc 是否使用自定义的升级效果而不用默认的？
 * 
 * @param customLevelUpSettings:struct
 * @parent isUseCustomLevelUp:bool
 * @text 升级设置
 * @type struct<LCustomLevelUpSettings>
 * @default {"databaseAnimationId:i":"0","imageSeqAnimationName:str":"","imageSeqAnimationMargins:s":"{\"x:int\":\"0\",\"y:int\":\"0\"}","extraSE:str":"","isShowPopUp:b":"true","popUpText:str":"Level %1!","popUpStyle:s":"{\"id\":\"levelUp\",\"randDX:int\":\"0\",\"randDY:int\":\"10\",\"stayTime:int\":\"12\",\"changeFontSize:int\":\"16\",\"noFlyUp:bool\":\"false\",\"noFadeOut:bool\":\"false\",\"text:struct\":\"{\\\"visible:bool\\\":\\\"true\\\",\\\"size:struct\\\":\\\"{\\\\\\\"w:int\\\\\\\":\\\\\\\"60\\\\\\\",\\\\\\\"h:int\\\\\\\":\\\\\\\"20\\\\\\\"}\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"alignment:str\\\":\\\"center\\\",\\\"outline:struct\\\":\\\"{\\\\\\\"color:css\\\\\\\":\\\\\\\"\\\\\\\",\\\\\\\"width:int\\\\\\\":\\\\\\\"2\\\\\\\"}\\\",\\\"font:struct\\\":\\\"{\\\\\\\"face:str\\\\\\\":\\\\\\\"AABS_3\\\\\\\",\\\\\\\"size:int\\\\\\\":\\\\\\\"12\\\\\\\",\\\\\\\"italic:bool\\\\\\\":\\\\\\\"false\\\\\\\"}\\\",\\\"textColor:css\\\":\\\"#deb521\\\"}\",\"image:struct\":\"{\\\"name\\\":\\\"\\\",\\\"margins:struct\\\":\\\"{\\\\\\\"x:int\\\\\\\":\\\\\\\"0\\\\\\\",\\\\\\\"y:int\\\\\\\":\\\\\\\"0\\\\\\\"}\\\",\\\"fadeInSpeed:int\\\":\\\"20\\\"}\"}","commonEvent:i":"0","scriptAction:str":""}
 * 
 * @param playerVisualSettingsGroup
 * @parent playerAndPartySettingsGroup
 * @text UI元素设置
 * 
 * @param pvsGaugesSubGroup
 * @parent playerVisualSettingsGroup
 * @text 血条蓝条
 * 
 * @param playerHpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text 血条设置
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"304\",\"y:e\":\"560\"}","label":"Player_HPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-33\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 角色血条显示设置
 * 
 * @param playerMpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text 蓝条显示设置
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_MPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_MPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 角色蓝条显示设置
 * 
 * @param playerTpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text 怒条显示设置
 * @type struct<LActorGauge>
 * @default {"visible:bool":"false","position:struct":"{\"x:e\":\"454\",\"y:e\":\"560\"}","label":"Player_TPGaugeLabel","labelMargins:struct":"{\"x:int\":\"-37\",\"y:int\":\"5\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_TPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 角色怒条（TP）显示设置
 * 
 * @param playerExpGaugeVisualSettings:struct
 * @parent pvsGaugesSubGroup
 * @text 经验条设置
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"273\",\"y:e\":\"528\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"10\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_EXPGauge\",\"foreground\":\"Player_EXPGaugeForeground\",\"mask\":\"Player_EXPGaugeMask\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 角色经验条显示设置
 * 
 * @param spacer|enemies @text‏‏‎ ‎@desc ===============================================
 * 
 * @param enemySettingsGroup
 * @text 怪物设置
 * 
 * @param enemyVisualSettingsGroup
 * @parent enemySettingsGroup
 * @text UI元素设置
 * 
 * @param enemyVSGaugesSubGroup
 * @parent enemyVisualSettingsGroup
 * @text 怪物血条
 * 
 * @param enemyMiniHpGaugeSettings:struct
 * @parent enemyVSGaugesSubGroup
 * @text 怪物头顶小血条
 * @type struct<LActorGauge>
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
 * @desc 怪物头顶小血条（默认）
 * 
 * @param enemyMiniHpGaugesCustoms:structA
 * @parent enemyVSGaugesSubGroup
 * @text 自定义血条
 * @type struct<LEnemyCustomMiniGauge>[]
 * @default []
 * @desc [专业版功能] 你可以使用<miniHpGaugeStyle>标签来给特定怪物自定义血条
 * 
 * @param enemyInfoVisualSettings:struct
 * @text 怪物信息
 * @type struct<LEnemyInfoVisual>
 * @parent enemyVisualSettingsGroup
 * @desc 怪物信息面板（当选中或悬浮时）
 * @default {"visible:bool":"true","position:struct":"{\"x:e\":\"640\",\"y:e\":\"66\"}","image":"Enemy_Background","isCanBeEdited:bool":"true","isHideWithMessage:bool":"true","nameFormat":" *2","hpText:s":"{\"visible:bool\":\"true\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"12\\\",\\\"y:int\\\":\\\"28\\\"}\",\"alignment:str\":\"left\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:s":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Player_HPGauge\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}","gaugeMargins:s":"{\"x:int\":\"6\",\"y:int\":\"28\"}","face:s":"{\"visible:bool\":\"true\",\"faceName\":\"\",\"faceIndex:i\":\"0\",\"mirror:b\":\"false\",\"size:i\":\"74\",\"margins:s\":\"{\\\"x:int\\\":\\\"92\\\",\\\"y:int\\\":\\\"10\\\"}\"}","battleState:s":"{\"visible:bool\":\"true\",\"image\":\"Enemy_BattleState_Free\",\"margins:s\":\"{\\\"x:int\\\":\\\"142\\\",\\\"y:int\\\":\\\"60\\\"}\"}","foregroundImage:s":"{\"visible:bool\":\"true\",\"image\":\"\",\"margins:s\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\"}"}
 * 
 *  @param enemyAIUpdateThreadMS:int
 *  @parent enemySettingsGroup
 *  @text AI思考间隔周期
 *  @type number
 *  @min 1
 *  @max 200
 *  @default 100
 *  @desc 单位毫秒，数值越小AI思考速度越快
 * 
 *  @param enemyAIUpdateVisionIntervalFR:int
 *  @parent enemySettingsGroup
 *  @text AI视野检测周期
 *  @type number
 *  @min 1
 *  @max 32
 *  @default 4
 *  @desc 单位是游戏帧，数值越小则AI检测周围敌人越频繁
 * 
 * @param enemies_noPassVision:intA
 * @parent enemySettingsGroup
 * @text 怪物视觉盲区ID
 * @type number[]
 * @min 1
 * @max 255
 * @default []
 * @desc 所有怪物均无法看见的视觉盲区ID集合
 * 
 * @param enemies_noPassVision2:intA
 * @parent enemySettingsGroup
 * @text 怪物移动禁区ID
 * @type number[]
 * @min 1
 * @max 7
 * @default []
 * @desc 地形标记（1到7）用于标记所有怪物均无法前进的区域
 * 
 * @param enemies_afterDeathBonuses:structA
 * @parent enemySettingsGroup
 * @text Flying bonuses
 * @type struct<FlyBonus>[]
 * @default ["{\"image:str\":\"BonusGreen\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"25\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusBlue\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"25\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusYellow\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"50\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"20\",\"goldGainE\":\"0\"}","{\"image:str\":\"BonusRed\",\"actionSE:str\":\"\",\"spawnSE:str\":\"\",\"startOffsetRadiusInPx:i\":\"16\",\"stayFrames:i\":\"12\",\"flySpeed:i\":\"8\",\"actionSA:str\":\"ba_1\",\"hpGainE\":\"0\",\"mpGainE\":\"0\",\"expGainE\":\"0\",\"goldGainE\":\"0\"}"]
 * @desc Bonuses defenitions for bonusOnDeadIds ABS parameter
 * 
 * @param enemiesSpawnSettingsGroup
 * @parent enemySettingsGroup
 * @text 出怪设置
 * 
 * @param enemies_spawn_mapId:int
 * @parent enemiesSpawnSettingsGroup
 * @text 出怪模版地图ID
 * @type number
 * @min 0
 * @default 0
 * @desc [必选项] 用于生成怪物事件的模版地图， 0表示关闭出怪功能
 * 
 * @param enemies_spawn_aboveEvents:b
 * @parent enemiesSpawnSettingsGroup
 * @text 是否允许在其他事件上面出怪
 * @type boolean
 * @on Yes
 * @off No
 * @default false
 * @desc 是否允许在其他事件的位置上面出怪？
 * 
 * @param enemies_spawn_cacheAllowed:b
 * @parent enemiesSpawnSettingsGroup
 * @text 是否启用区域缓存?
 * @type boolean
 * @on Yes (more performance)
 * @off No
 * @default true
 * @desc 如果在游戏过程中动态调整区域ID那么请关闭此选项
 * 
 * @param spawn_points:structA
 * @parent enemiesSpawnSettingsGroup
 * @text 出怪点
 * @type struct<LSpawnPoint>[]
 * @default []
 * @desc 用于命令<absSpawnPoint:ID>的出怪点. （查阅wiki手册以获取更详细说明）
 * 
 * @param spacer|map @text‏‏‎ ‎@desc ===============================================
 * 
 * @param mapSettingsGroup
 * @text 地图设置
 * 
 * @param mapScrolling:s
 * @text 地图滚动
 * @parent mapSettingsGroup
 * @type struct<LMapScrollSettings>
 * @default {"isEnabled:b":"false","scrollZone:int":"10","speed:int":"5","delay:int":"60","resetOnMove:b":"true","resetOnAction:b":"true"}
 * @desc 鼠标滚动地图的功能
 * 
 * @param miniHpGaugeSetings:s
 * @text 迷你血条
 * @parent mapSettingsGroup
 * @type struct<LMiniHpGaugeSettings>
 * @default {"active:b":"true","showOnlyOnHover:b":"true","showOnDamage:b":"true","showWhenNotFull:b":"false"}
 * @desc 在ABS事件上显示的小血条
 * 
 * @param mvAnimationAutoScalling:int
 * @parent mapSettingsGroup
 * @text [MV]动画缩放
 * @type number
 * @decimals 1
 * @default 0.3
 * @desc [仅限MV]在地图和ABS事件上播放的动画的缩放比例
 * 
 * @param defaultBattleAutoBgm:struct
 * @parent mapSettingsGroup
 * @text 战斗自动播放BGM
 * @type struct<BattleAutoBGM>
 * @desc 当玩家进入战斗时是否自动播放BGM，你可以在地图的描述区使用<battleAutoBgm:NAME>为每个地图自定义BGM名称
 * @default {"name":"","delay:i":"0.50"}
 * 
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * @command ABSEventSettings
 * @text ABS怪物配置
 * @desc Configurate enemy ABS parameters for this certaint event
 * 
 * @arg MainGroup
 * @text 主要部分
 * 
 * @arg viewRadius
 * @parent MainGroup
 * @text 视野半径
 * @type number
 * @min 1
 * @max 100
 * @default 5
 * @desc 怪物默认可以看多少地图格子
 * 
 * @arg returnRadius
 * @parent MainGroup
 * @text  返回半径
 * @type number
 * @min 1
 * @max 100
 * @default 12
 * @desc 怪物追玩家多少格就会返回初始位置
 * 
 *  @arg noMoveInBattle
 *  @parent MainGroup
 *  @text 战斗时无法移动
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，则敌人在战斗中无法移动
 * 
 *  @arg noApproach
 *  @parent MainGroup
 *  @text 不会接近目标
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，则敌人在战斗中不会接近目标
 * 
 * @arg onDeath
 * @parent MainGroup
 * @text 死亡命令
 * @type text
 * @default
 * @desc 当怪物死亡时执行什么ABS脚本
 * 
 *  @arg onSeeTarget
 *  @parent MainGroup
 *  @text 检测目标触发脚本
 *  @type text
 *  @default
 *  @desc 当敌人检测到目标时执行的ABS脚本(SAction)
 * 
 *  @arg onHit
 *  @parent MainGroup
 *  @text 被击触发脚本
 *  @type text
 *  @default
 *  @desc 当敌人被击时(受到伤害＞0)检测到目标时执行的ABS脚本(SAction)
 * 
 *  @arg expVar
 *  @parent MainGroup
 *  @text 经验值变量
 *  @type variable
 *  @default 0
 *  @desc 如果设置为0，则读取数据库配置，如果不为0，则该数字为变量ID，读取该变量数值作为经验值
 * 
 *  @arg autoExp
 *  @parent MainGroup
 *  @text 自动获取经验
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，则玩家杀怪后自动获取经验值
 * 
 *  @arg notAgressive
 *  @parent MainGroup
 *  @text 无主动攻击
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，则怪物不会主动攻击玩家
 * 
 *  @arg teamId
 *  @parent MainGroup
 *  @text  队伍ID
 *  @type number
 *  @min 1
 *  @max 10
 *  @default 1
 *  @desc 拥有不同队伍ID的怪物会彼此互相攻击
 * 
 *  @arg onDeathVar
 *  @parent MainGroup
 *  @text 死亡变量
 *  @type variable
 *  @default 0
 *  @desc 如果不设置为0，则怪物死了以后这个数值会+1
 * 
 *  @arg saveHp
 *  @parent MainGroup
 *  @text 保留HP
 *  @type boolean
 *  @default false
 *  @desc 如果设置为真，玩家离开地图后再返回，怪物的HP会保留
 * 
 * 
 * @arg MapGroup
 * @text 地图部分
 * 
 * @arg shatterEffect
 * @parent MapGroup
 * @text 碎裂效果?
 * @type boolean
 * @default true
 * @desc 当怪物死亡时是否播放破碎效果？
 * 
 * @arg deadSwitch
 * @parent MapGroup
 * @text 死亡开关
 * @type select
 * @option A
 * @option B
 * @option C
 * @option D
 * @option 0
 * @default 0
 * @desc 怪物死亡后将会开启哪个自开关 (0表示不开)
 * 
 * @arg eraseOnDead
 * @parent deadSwitch
 * @text 死亡后清除？
 * @type boolean
 * @default true
 * @desc 怪物死亡后是否清除？（仅对未开启死亡开事件有效）
 * 
 *  @arg heavy
 *  @parent MapGroup
 *  @text 是否属于重物
 *  @type boolean
 *  @default false
 *  @desc 设置为重物时，无法被击退技能击退
 * 
 *  @arg weaponMotionType
 *  @parent MapGroup
 *  @text 武器动作类型
 *  @type number
 *  @min 0
 *  @max 100
 *  @default 0
 *  @desc 为武器技能设置武器动作类型
 * 
 *  @arg lootDropOnDeath
 *  @parent MapGroup
 *  @text 掉落
 *  @type boolean
 *  @default false
 *  @desc 设置为真时，怪物死后将会按照数据库的物品和金币来进行自动掉落
 * 
 * @arg VisualGroup
 * @text 可视化部分
 * 
 * @arg UIInfo
 * @parent VisualGroup
 * @text 是否显示UI面板？
 * @type boolean
 * @default true
 * @desc 当鼠标悬浮怪物时是否显示其角色UI面板？
 * 
 * @arg faceName
 * @parent VisualGroup
 * @text 脸图名称
 * @type file
 * @required 1
 * @dir img\faces
 * @default
 * @desc 显示的脸图UI文件名
 * 
 * @arg faceIndex
 * @parent faceName
 * @text 脸图索引
 * @type number
 * @min 0
 * @max 100
 * @default 0
 * @desc 显示的脸图索引值（0到7）
 * 
 *  @arg miniHpGaugeStyle
 *  @parent VisualGroup
 *  @text 迷你血槽样式
 *  @type number
 *  @default
 *  @desc 怪物的小血槽样式，自定义插件参数
 * 
 * @arg AnimationGroup
 * @text 动画部分
 * 
 * @arg hitAnimationId
 * @parent AnimationGroup
 * @text 被击动画
 * @type animation
 * @default 1
 * @desc 当怪物攻击时播放的被击动画
 * 
 * @command EMPTY_HOLDER
 * @text ‏
 * @desc
 * @default
 */

/*~struct~LStateIconSettings:

 @param visible:b
 @text Is Visible?
 @type boolean 
 @on Yes
 @off No
 @desc Will be this element visible?
 @default true 

 @param position:s
 @text Position
 @type struct<XY> 
 @desc Position on screen
 @default {"x:int":"0","y:int":"0"} 

 @param isCanBeEdited:b
 @text Is Editable?
 @type boolean
 @default true
 @desc Can player edit this element in UI Editor?

 @param textFormat:str
 @text Time Left Format
 @type text 
 @desc %1 will be replaced by remaining time (in seconds)
 @default %1 

 @param textFormatA:str
 @text Actions Count Format
 @type text 
 @desc %1 will be replaced by remaining actions count [States only]
 @default A:%1 

 @param text:struct
 @text Time Text
 @type struct<CText> 
 @desc Timer or Actions count text settings
 @default {} 

 @param icon:s
 @text Icon
 @type struct<str6> 
 @desc Icon settings
 @default {} 

*/


/*~struct~LStateIconSettings:ru

 @param visible:b
 @text Видимый?
 @type boolean 
 @on Да, видимый
 @off Нет
 @desc Является ли данный элемент видимым?
 @default true 

 @param position:s
 @text Позиция
 @type struct<XY> 
 @desc Позиция на экране в пикселях
 @default {"x:int":"0","y:int":"0"} 

 @param isCanBeEdited:b
 @text Редактируемый?
 @type boolean
 @default true
 @desc Может ли игрок редактировать этот элемент в UI редакторе?

 @param textFormat:str
 @text Осталось времени
 @type text 
 @desc Формат строки, сколько осталось времени. %1 будет заменён на оставшееся количество секунд
 @default %1 

 @param textFormatA:str
 @text Осталось действий
 @type text 
 @desc Формат строки. %1 будет заменён на оставшееся количество действия до конца состояния [Только для состояний]
 @default A:%1 

 @param text:struct
 @text Время (текст)
 @type struct<CText> 
 @desc Настройки текста остатка времени (действий)
 @default {} 

 @param icon:s
 @text Иконка
 @type struct<str6> 
 @desc Настройки иконки
 @default {} 

*/

/*~struct~LDamagePopUpVisualSettings:
 * @param id
 * @text ID
 * @default
 * @desc Unique ID for refer to this settings in <popUpStyleId:X> parameter
 *
 * @param randDX:int
 * @text Rand DX
 * @type number
 * @default 0
 * @min 0
 * @desc Random value in pixels (> 0) to add to X at Pop Up start (x +- DX)
 *
 * @param randDY:int
 * @text Rand DY
 * @type number
 * @default 0
 * @min 0
 * @desc Random value in pixels (> 0) to add to Y at Pop Up start (y + DY)
 *
 * @param stayTime:int
 * @text Life Time
 * @type number
 * @default 12
 * @min 1
 * @desc Life time before PopUp starts disapear
 *
 * @param changeFontSize:int
 * @text Final Font Size
 * @type number
 * @default 22
 * @min 1
 * @desc Final value of font size. Can be more, equal or less that in Value text settings 
 *
 *
 * @param noFlyUp:bool
 * @text Is NO Fly?
 * @type boolean
 * @default false
 * @on Stay still
 * @off Fly Up
 * @desc Will be pop up stay still? False - will fly up to disapear
 * 
 * @param noFadeOut:bool
 * @text Is NO Fade?
 * @type boolean
 * @default false
 * @on No Fade
 * @off Fade out
 * @desc Will be pop up stay opaque all time? False - will fade out to disapear
 * 
 * @param text:struct
 * @text Value Text
 * @type struct<CText>
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"100\",\"h:int\":\"100\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"3\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"14\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 * @desc Text settings. TextBox Size parameter NOT uses.
 *
 * @param image:struct
 * @text Extra image
 * @default {"name":"","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","fadeInSpeed:int":"20"}
 * @type struct<LDPUImage>
*/

/*~struct~LDamagePopUpVisualSettings:ru
 * @param id
 * @text ID
 * @default
 * @desc Уникальный ID данного стиля, ипользуется в параметре <popUpStyleId:X>
 *
 * @param randDX:int
 * @text Случ. X
 * @type number
 * @default 0
 * @min 0
 * @desc Случайное значение в пикселях, которое будет добавлено к координате Х (+-) на старте
 *
 * @param randDY:int
 * @text Случ. Y
 * @type number
 * @default 0
 * @min 0
 * @desc Случайное значение в пикселях, которое будет добавлено к координате Y (+-) на старте
 *
 * @param stayTime:int
 * @text Время жизни
 * @type number
 * @default 12
 * @min 1
 * @desc Время жизни в секундах перед тем как сообщение начнёт исчезать
 *
 * @param changeFontSize:int
 * @text Размер текста (конец)
 * @type number
 * @default 22
 * @min 1
 * @desc Конечное значение размера текста. Может быть больше, меньше, или равно (чтобы не изменялсь) значение в настройках текста
 *
 *
 * @param noFlyUp:bool
 * @text Статическое?
 * @type boolean
 * @default false
 * @on На месте
 * @off Летит
 * @desc Будет ли сообщение стоять на месте? ВЫКЛ - будет взлетать вверх при истечении срока жизни
 * 
 * @param noFadeOut:bool
 * @text Всегда видимое?
 * @type boolean
 * @default false
 * @on Всегда
 * @off Исчезает
 * @desc Будет ли сообщение всегда НЕ прозрачным? ВЫКЛ - будет исчезать при истечении срока жизни
 * 
 * @param text:struct
 * @text Текст
 * @type struct<CText>
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"100\",\"h:int\":\"100\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"3\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"14\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 * @desc Настройки текста. Параметр - размер текста не используется.
 *
 * @param image:struct
 * @text Доп. изображение
 * @default {"name":"","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","fadeInSpeed:int":"20"}
 * @type struct<LDPUImage>
*/


/*~struct~LDPUImage:
 * @param name
 * @text Name
 * @type file
 * @dir img/pictures/
 * @require 1
 * @default
 * @desc Optional. Addition image file for Pop Up Item.
 * 
 * @param margins:struct
 * @text Margin
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"0"}
 * @desc Position of image, relative Pop Up item
 *
 * @param fadeInSpeed:int
 * @text Fade speed
 * @type number
 * @default 20
 * @min 1
 * @desc Image fade in speed. Image starts transparent. Set to 255 to show image opaque immediately
 */

 /*~struct~LDPUExp:

    @param active:b
    @text Is Enabled?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc Is need show Pop Up when EXP given to character? No - disable at all

    @param styleId
    @text Settings ID
    @default Experience
    @desc Pop Up Settings ID from Pop Up Table parameter

    @param textFormat
    @text Text Format
    @default +%1 exp
    @desc Pop Up Text, %1 will be replaced to experience value

    @param aboveChar:b
    @text Is Above Character?
    @type boolean
    @on Yes (above char)
    @off No (above enemy)
    @default false
    @desc Exp Pop Up show above character or above killed enemy?

    @param bindToChar:b
    @text Bind to char?
    @type boolean
    @on Yes (stay above char)
    @off No (stay on screen)
    @default false
    @desc Pop Up will stay above character or (if false) on screen (and moved with screen)
 */

/*~struct~LDPUGold:

    @param popUpStyle:s
    @text Settings
    @type struct<LDamagePopUpVisualSettings> 
    @desc Pop Up Style settings
    @default {}

    @param textFormat
    @text Text Format
    @default %2%1
    @desc Pop Up Text, %1 will be replaced to gold value, %2 with - or +

    @param bindToChar:b
    @text Bind to char?
    @type boolean
    @on Yes (stay above char)
    @off No (stay on screen)
    @default false
    @desc Pop Up will stay above character or (if false) on screen (and moved with screen)
 */


/*~struct~LMiniHpGaugeSettings:
    @param active:b
    @text Is Enabled?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc Is need show Mini HP gauges for ABS events on map? No - disable at all

    @param showOnlyOnHover:b
    @text Is Show only on Hover?
    @type boolean
    @on Yes (hover)
    @off No (always)
    @default true
    @desc Is show Mini HP gauge only when event hovered? No - always

    @param showOnDamage:b
    @text Is Show on Damage?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc Is show Mini HP gauge for short time when ABS event receive damage?

    @param showWhenNotFull:b
    @text Is for damaged only?
    @type boolean
    @on Yes
    @off No
    @default false
    @desc Is show Mini HP gauge for only for damaged ABS events (HP != 100%)?
*/
/*~struct~LMapScrollSettings:
    @param isEnabled:b
    @text Is Enabled?
    @type boolean
    @on Yes
    @off No
    @default false
    @desc Is Map Scrolling enabled by default? For enable or disable during game you can use uAPI script calls.

    @param scrollZone:int
    @text Activation Border Size
    @type number
    @min 10
    @max 50
    @default 10
    @desc Scroll activation borders size on screen edges, in pixels

    @param speed:int
    @text Scrolling speed
    @type number
    @min 1
    @max 10
    @default 5
    @desc Camera scrolling speed

    @param delay:int
    @text Delay
    @type number
    @min 0
    @default 30
    @desc Delay in frames (60 = 1 second) before starts scrolling

    @param resetOnMove:b
    @text Reset when moving?
    @type boolean
    @on Reset
    @off No
    @default true
    @desc Center camera (reset scroll) when player starts moving?

    @param resetOnAction:b
    @text Reset on action?
    @type boolean
    @on Reset
    @off No
    @default true
    @desc Center camera (reset scroll) when player affected by any skill (get damage, attacked)?
*/
/*~struct~LSkillSlotItem:
 * @param position:struct
 * @text Position
 * @type struct<XY2>
 * @default
 * @desc Skill slot position on screen
 *
 * @param symbol
 * @text Key
 * @default
 * @desc Keyboard key for activate skill slot
 *
 * @param isEditable:b
 * @text Is editable?
 * @type boolean
 * @default true
 * @desc Can player edit slot? Open skills or items select menu
 *
 * @param isAutoset:b
 * @text Is auto?
 * @type boolean
 * @default true
 * @desc Can skill or item automatically been assign to this slot?
 *
 * @param filter:str
 * @text Filter
 * @parent isAutoset:b
 * @type combo
 * @option Any
 * @option Items
 * @option Skills
 * @default Any
 * @desc Filter works for auto assign only. (Is Auto - ON)
 *
 * @param specifiedIds:str
 * @text Specified Ids
 * @parent isAutoset:b
 * @default
 * @desc Slot can accept only this items or skill (depends on filter) ID's (separated by comma). Empty - all
 *
 * @param style:struct
 * @text Visual Settings
 * @type struct<LSkillSlotItemVisual> 
 * @default
 * @desc Skill Slot can have own visual settings. Or leave empty for default settings (Parameter: Skill Slot Visual)
 */

/*~struct~LInputSettings:

    @param LMBMapTouchMode
    @text LMB Map Touch
    @type select
    @option Primary attack
    @option Default (move)
    @option Nothing
    @default Default (move)
    @desc TODO: wiki page?

    @param RMBMapTouchMode
    @text RMB Map Touch
    @type select
    @option Default (menu)
    @option Secondary attack
    @option Move
    @option Turn
    @option Nothing
    @default Turn
    @desc TODO: wiki page?

    @param LMBTargetTouchMode
    @text LMB Target Touch
    @type select
    @option Primary attack
    @option Default (move)
    @option Smart attack (Primary)
    @option Turn
    @default Smart attack (Primary)
    @desc TODO: wiki page?

    @param RMBTargetTouchMode
    @text RMB Target Touch
    @type select
    @option Secondary attack
    @option Move
    @option Smart attack (Secondary)
    @option Turn
    @default Smart attack (Secondary)
    @desc TODO: wiki page?

    @param moveType
    @text Movement
    @type select
    @option WASD and Arrows
    @option Arrows only
    @default WASD and Arrows
    @desc Keyboard keys for character movement

    @param isDiagonalMovement:b
    @text Diagonal Movement?
    @type boolean
    @default true
    @on Yes
    @off No
    @desc Moving in 8 directions? (For Player and Allies)

    @param isDiagonalMovementAI:b
    @text Diagonal Movement for AI?
    @type boolean
    @default true
    @on Yes
    @off No
    @desc Moving in 8 directions? (for Enemies (Events))

    @param isStaticAtkRot:b
    @text Attack when rotation?
    @type boolean
    @default true
    @on Yes
    @off No
    @desc Always only attack (no move) when rotating if mouse clicked on map?

    @param multiTouch:b
    @text Allow MultiTouch?
    @type boolean
    @default false
    @on Yes
    @off No
    @desc [For devices with touchscreen] Allow multitouch control?

    @param keybingind
    @text Key Bindings

    @param kbReload
    @text Reload
    @parent keybingind
    @default R
    @desc TODO:

    @param kbCommandMenu
    @text Commands
    @parent keybingind
    @default C
    @desc TODO:

    @param kbRotate
    @text Rotate
    @parent keybingind
    @default Control
    @desc TODO:

*/
/*~struct~LActorGauge:
 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this gauge visible at start?
 * 
 * @param position:struct
 * @text Position
 * @type struct<XY2>
 * @default
 * @desc Position on screen
 * 
 * @param label
 * @text Label
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Label image for gauge, optional
 * 
 * @param labelMargins:struct
 * @text Label Margins
 * @type struct<XY>
 * @default
 * @desc Position of label, relative gauge
 *
 * @param isCanBeEdited:bool
 * @text Is Editable?
 * @type boolean
 * @default true
 * @desc Can player edit this gauge in UI Editor?
 *
 * @param isHideWithMessage:bool
 * @text Is Hide by Msg?
 * @type boolean
 * @default true
 * @desc Hide this UI element when message window appears?
 * 
 * @param text:struct
 * @text Value Text
 * @type struct<CText>
 * 
 * @param gauge:struct
 * @text Gauge
 * @type struct<CGauge>
 * 
 * 
*/
/*~struct~CGauge:
 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this gauge visible?
 *
 * @param vertical:bool
 * @text Is Vertical?
 * @type boolean
 * @default false
 * @desc Gauge will use vertical fill?
 * 
 * @param fill
 * @text Fill Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Gaguge fill image, required!
 * 
 * @param foreground
 * @text Foreground Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Image above gauge fill, optional
 * 
 * @param mask
 * @text Mask Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Whole gauge image mask, optional
 * 
 * @param backColor:css
 * @type string
 * @text Background Color
 * @default #000000
 * @desc Text color in HEX format (#000000)
 * 
 * @param backOpacity:int
 * @type number
 * @min 0
 * @max 255
 * @text Background Opacity
 * @default 255
 * @desc from 0 to 255, 0 - transparent, 255 - opaque
 */
/*~struct~CText:
 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this text visible?
 * 
 * @param size:struct
 * @text TextBox Size
 * @type struct<WH>
 * @default
 * @desc Size of text zone
 * 
 * @param margins:struct
 * @text Margin
 * @type struct<XY>
 * @default
 * @desc Position of text, relative parent
 * 
 * @param alignment:str
 * @text Alignment
 * @type combo
 * @option center
 * @option right
 * @option left
 * @default center
 * @desc Text alignment
 * 
 * @param outline:struct
 * @text Text Outline
 * @type struct<Outline>
 * @default
 * @desc Text outline settings
 * 
 * @param font:struct
 * @type struct<Font>
 * @text Font Settings
 * @default
 * @desc Text font settings
 * 
 * @param textColor:css
 * @type string
 * @text Text Color
 * @default #FFFFFF
 * @desc Text color in HEX format (#000000)
 * 
 */
/*~struct~XY:
 * @param x:int
 * @text X
 * @type number
 * @default 0
 * @min -1000
 *
 * @param y:int
 * @text Y
 * @type number
 * @default 0
 * @min -1000
 */
/*~struct~XY2:
 * @param x:e
 * @text X
 * @type text
 * @default 0
 * @desc Number or script (example: Graphics.width / 2)
 *
 * @param y:e
 * @text Y
 * @type text
 * @default 0
 * @desc Number or script (example: $gameVariables.value(12) * 2)
 */
/*~struct~WH:
 * @param w:int
 * @text Width
 * @type number
 * @default 100
 * @min 0
 *
 * @param h:int
 * @text Height
 * @type number
 * @default 100
 * @min 0
 */
/*~struct~Font:
 * @param face:str
 * @text Face
 * @type combo
 * @option AABS_0
 * @option AABS_1
 * @option AABS_2
 * @option AABS_3
 * @default AABS_0
 *
 * @param size:int
 * @text Size
 * @type number
 * @default 24
 * @min 1
 * 
 * @param italic:bool
 * @text IsItalic
 * @type boolean
 * @default false
 */
/*~struct~Outline:
 * @param color:css
 * @text Color
 * @type text
 * @default #000000
 * @desc Outline color in HEX (#000000) or empty "" (black)
 *
 * @param width:int
 * @text Width
 * @type number
 * @default 3
 * @min 0
 * @desc Outline stroke width in px
 */
 /*~struct~str6:

 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this element visible? 


 @param index:i
 @text Icon Index
 @type number 
 @min 0
 @desc Icon index on IconSet
 @default 0 

 @param size:i
 @text Icon Size
 @type number 
 @min 2
 @desc Icon Size in PX (default icons size is 32)
 @default 32 

*/

/*~struct~LEnemyCustomMiniGauge:
    @param id
    @text ID
    @desc Use in parameter <miniHpGaugeStyle:ID>
    @default custom1

    @param gauge:struct
    @text Settings
    @type struct<LActorGauge>
    @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
    @desc Mini HP gauge settings for this style
*/

/*~struct~LSkillSLotItemVisualIcon:

 @param visible:b
 @text 
 @type boolean 
 @on Yes
 @off No
 @desc 
 @default true 


 @param size:i
 @text 
 @type number 
 @min 0
 @desc 
 @default 32 


 @param index:i
 @text 
 @type number 
 @min 0
 @desc 
 @default 0 

*/

/*~struct~LSkillSlotItemVisual:

 * @param visible:bool
 * @text Is Visible?
 * @type boolean
 * @default true
 * @desc Will be this skill slot visible?


 * @param isCanBeEdited:bool
 * @text Is Editable?
 * @type boolean
 * @default true
 * @desc Can player edit this skill slot in UI Editor? 


 * @param isHideWithMessage:bool
 * @text Is Hide by Msg?
 * @type boolean
 * @default true
 * @desc Hide this UI element when message window appears? 

 @param outlineGroup
 @text Outline

 @param outlineMargins:s
 @parent outlineGroup
 @text Outline Margin
 @type struct<XY> 
 @desc Outline effect color margin
 @default {} 


 @param outlinePulseSpeed:i
 @parent outlineGroup
 @text Pulse Speed
 @type number 
 @min 1
 @max 255
 @desc Pulse effect speed in frames
 @default 40 


 @param selectedOutlineColor:str
 @parent outlineGroup
 @text Selected
 @type text 
 @desc Color for outline when skill slot is selected (in HEX format)
 @default #fcba03 


 @param clickedOutlineColor:str
 @parent outlineGroup
 @text Click
 @type text 
 @desc Color for outline when skill slot is clicked \ activated (in HEX format)
 @default #0b03fc 


 @param readyOutlineColor:str
 @parent outlineGroup
 @text Ready
 @type text 
 @desc Color for outline when skill slot is ready to use (in HEX format)
 @default #21b53c 


 @param badOutlineColor:str
 @parent outlineGroup
 @text Forbidden
 @type text 
 @desc Color for outline when skill slot is can't be used (in HEX format)
 @default #d61a1a 


 @param icon:s
 @text Icon settings
 @type struct<LSkillSLotItemVisualIcon> 
 @desc Skill and Item icons on skill slot settings. Icon Index is ignored.
 @default {} 

 @param iconMargins:s
 @text Icon Margin
 @parent icon:s
 @type struct<XY> 
 @desc Icon margins
 @default {} 

 @param symbolText:s
 @text Symbol Text
 @type struct<CText> 
 @desc Symbol (key) text settings
 @default {} 


 @param timeText:s
 @text Time Text
 @type struct<CText> 
 @desc Timer text settings
 @default {} 


 @param countText:s
 @text Count Text
 @type struct<CText> 
 @desc Count text settings
 @default {} 

*/


/*~struct~LUIFaceElement:

 @param visible:bool
 @text Is Visible?
 @type boolean
 @default true
 @desc Will be this element visible?


 @param faceName
 @text Face Image
 @type file
 @require 1
 @dir img/face/
 @desc Face image name
 @default  


 @param faceIndex:i
 @parent faceName
 @text Index
 @type number 
 @min 0
 @desc Index on Face Image
 @default 0 


 @param mirror:b
 @text Mirror
 @type boolean 
 @on Yes
 @off No
 @desc Is mirror face image (from left to right)?
 @default false 


 @param size:i
 @text Size
 @type number 
 @desc Face size in px (default RPG Maker faces size is 144)
 @default 74 


 @param margins:s
 @text Margins
 @type struct<XY> 
 @desc Face image margins
 @default {}

*/
/*~struct~LUIImageElement:

 @param visible:bool
 @text Is Visible?
 @type boolean
 @default true
 @desc Will be this element visible? 


 @param image
 @text Image
 @type file
 @require 1
 @dir img/Alpha/
 @desc
 @default 


 @param margins:s
 @text Margins
 @type struct<XY> 
 @desc Image margins
 @default {}

*/

/*~struct~LEnemyInfoVisual:

 @param visible:bool
 @text Is Visible?
 @type boolean
 @default true
 @desc Will be this element visible? 


 @param position:struct
 @text Position
 @type struct<XY2>
 @default
 @desc Position on screen


 @param image
 @text Background
 @type file
 @require 1
 @dir img/Alpha/
 @desc
 @default Enemy_Background 


 @param isCanBeEdited:bool
 @text Is Editable?
 @type boolean
 @default true
 @desc Can player edit this element in UI Editor? 


 @param isHideWithMessage:bool
 @text Is Hide by Msg?
 @type boolean
 @default true
 @desc Hide this UI element when message window appears? 


 @param nameFormat
 @text Name Format
 @type text 
 @desc %1 will be replaced by Enemy Name
 @default %1


 @param levelFormat
 @text Level Format
 @type text 
 @desc %1 will be replaced by Enemy Level
 @default Lv. %1 


 @param hpTextFormat
 @text HP Format
 @type text 
 @desc %1 - HP, %2 - MHP, %3 - Rate in %
 @default %1 / %2 


 @param nameText:s
 @parent nameFormat
 @text Text
 @type struct<CText> 
 @desc Enemy name text style
 @default {} 


 @param hpText:s
 @parent hpTextFormat
 @text Text
 @type struct<CText> 
 @desc Enemy HP text style
 @default {} 


 @param levelText:s
 @parent levelFormat
 @text Text
 @type struct<CText> 
 @desc Enemy level text style
 @default {} 


 @param gauge:s
 @text HP gauge
 @type struct<CGauge> 
 @desc Enemy HP gauge style
 @default {} 

 @param gaugeMargins:s
 @parent gauge:s
 @text Margins
 @type struct<XY> 
 @desc HP gauge margins
 @default {}

 @param face:s
 @text Face
 @type struct<LUIFaceElement> 
 @desc Enemy Face settings. Face Name and Index not used.
 @default {} 


 @param battleState:s
 @text Battle Icon
 @type struct<LUIImageElement> 
 @desc Enemy In Battle State Icon Image
 @default {} 


 @param foregroundImage:s
 @text Foreground
 @type struct<LUIImageElement> 
 @desc Foreground image
 @default {} 

*/

/*~struct~LSpawnPoint:

 @param id:str
 @text ID
 @type text 
 @desc Unique spawn point ID for <absSpawnPoint:ID> event comment
 @default spawnPoint

 @param spawnPointType:str
 @text Spawn Type
 @type select
 @option self
 @option region
 @option player
 @desc Self - spawn around self (event). Region - spawn in certain region. Player - spawn around player.
 @default self 

 @param spawnRadius:str
 @parent spawnPointType:str
 @text Radius or Region
 @type text
 @desc Radius (self, player) or Region (for region type) [Extended Value]
 @default 3

 @param spawnMax:str
 @text Max
 @type text 
 @desc Maximum spawned enemies count. 0 - not limits. [Extended Value]
 @default 3


 @param spawnAliveMax:str
 @parent spawnMax:str
 @text Max alive
 @type text 
 @desc Max. alive spawned enemies at same time. 0 - not limits. [Extended Value]
 @default 2 


 @param spawnRate:str
 @text Rate
 @type text 
 @desc Spawn once at (Rate) seconds. Minimum 1. [Extended Value]
 @default 4

 @param spawnEnemiesId:str
 @text Events to spawn
 @type text 
 @desc Enemies events (from Spawn Map) id's for spawn. [Extended Value]
 @default 1, 2, 3


 @param conditionSwitch:i
 @text Switch
 @type switch 
 @desc 0 - no any. If Switch if FALSE -> not spawn.
 @default 0

 @param visorRadius:i
 @text Visor
 @type number 
 @min 0
 @desc 0 - always. X - player should be in this range from spawn point for spawning process.
 @default 3


 @param endCommonEvent:i
 @text On Reach Max
 @type common_event 
 @desc Call common event when spawned Max count is reached
 @default 0

*/


/*~struct~LCustomLevelUpSettings:

 @param databaseAnimationId:i
 @text Animation [DB]
 @type animation 
 @min 0
 @desc 0 - no animation.
 @default 0

 @param imageSeqAnimationName:str
 @text Animation [File]
 @type file
 @dir img/pictures/
 @desc Optional, Rule: filename(frames,delay).png
 @default

 @param imageSeqAnimationMargins:s
 @parent imageSeqAnimationName:str
 @text Margins
 @type struct<XY> 
 @desc 
 @default {} 

 @param extraSE:str
 @text Sound Effect
 @type file
 @dir audio/se/
 @require 1
 @desc Optional, leave empty for nothing
 @default

 @param isShowPopUp:b
 @text Is Show PopUp?
 @type boolean 
 @on Yes
 @off No
 @desc 
 @default true 

 @param popUpText:str
 @parent isShowPopUp:b
 @text Text
 @type text
 @desc %1 will be replaced by new level value (number)
 @default Level %1! 

 @param popUpStyle:s
 @parent isShowPopUp:b
 @text Settings
 @type struct<LDamagePopUpVisualSettings> 
 @desc Pop Up Style settings
 @default {} 

 @param commonEvent:i
 @text Common Event
 @type common_event 
 @min 0
 @desc Common event call on Level Up
 @default 0 

 @param scriptAction:str
 @text Script Action
 @type text 
 @desc Script action on Level Up (relative to character)
 @default

*/



/*~struct~LBloodSplatterEffectSettings:
 @param BS_Picture
 @text Effect Image
 @type file
 @dir img/pictures/
 @require 1
 @desc Optional. Image for effect.
 
 @param BS_Color
 @text Effect Color
 @type string
 @default #F98822
 @desc HEX value or empty
 
 @param BS_Opacity:int
 @text Effect Opacity
 @type number
 @min 0
 @max 255
 @default 124
 @desc From 0 (transparent) to 255 (opaque)
 
 @param BS_HpRate:int
 @text HP Rate
 @type number
 @min 1
 @max 99
 @default 15
 @desc Percentage of health at which the effect is activated
 */

 /*~struct~FlyBonus:
    @param image:str
    @text Image
    @type file
    @dir img/pictures/
    @require 1 
    @desc Bonus image, supports animated
    @default bonusGreen 

    @param actionSE:str
    @text Action SE
    @type file
    @dir audio/se
    @require 1
    @desc Sound effect when player got bonus
    @default  

    @param spawnSE:str
    @text Appear SE
    @type file
    @dir audio/se
    @require 1
    @desc Sound effect when bonus is appears
    @default  

    @param startOffsetRadiusInPx:i
    @text Offset
    @type number 
    @min 0
    @max 48
    @desc Appear position max offset in PX from start point
    @default 16 

    @param stayFrames:i
    @text Delay
    @type number 
    @min 0
    @desc Delay in frames! before bonus fly to the player
    @default 12 

    @param flySpeed:i
    @text Speed
    @type number 
    @min 1
    @max 100
    @desc Fly speed (in PX)
    @default 8

    @param actionSA:str
    @text SAction
    @type text 
    @desc Optional. SAction executed on player when received this bonuse.
    @default

    @param hpGainE
    @text HP Gain
    @desc Optional. How many HP this bonus gain to the player. EVal supported.
    @default 25 

    @param mpGainE
    @text MP Gain
    @desc Optional. How many MP this bonus gain to the player. EVal supported.
    @default 0

    @param expGainE
    @text EXP Gain
    @desc Optional. How many EXP this bonus gain to the player. EVal supported.
    @default 0 

    @param goldGainE
    @text Gold Gain
    @desc Optional. How many Gold this bonus gain to the player. EVal supported.
    @default 0
 */

 /*~struct~LDodgeActionSettings:

@param dodgeKey
@text Keyboard key
@default f

@param dodgeSwitch:i
@text Enable Switch
@type switch
@desc When this Switch is TRUE, player can do Dodge. 0 - always can

@param isInvincible:b
@text Is Invincible?
@type boolean
@desc If TRUE, player can't receive any damage while in Dodge motion

@param stepsCount:i
@text Move steps
@type number
@min 1
@max 2
@default 2
@desc How far player will move while dodge (1 or 2)

@param delayBetweenStepMS:i
@text Delay MS
@type number
@min 0
@default 100
@desc Delay (in miliseconds) between every move step in dodge

@param dodgeMoveSpeed:i
@text Speed
@type number
@min 4
@default 5
@desc Player move speed in dodge action

@param dodgeRestTimerFrames:i
@text Recharge Time
@type number
@min 0
@default 30
@desc Dodge action recharge time (in FRAMES)

@param dodgeRestVariable:i
@parent dodgeRestTimerFrames:i
@text Recharge Var
@type variable
@default 0
@desc If > 0, then will be used recharge time (in FRAMES) from this Variable.
 */


/*~struct~BattleAutoBGM:

 @param name
 @text BGM
 @type file
 @require 1
 @dir audio/BGM/
 @desc Leave empty if you don't need battle auto BGM at all or want use from Map's notetag
 @default

@param delay:i
@text Delay
@type number
@decimals 2
@min 0
@default 0.5
@desc Delay IN SECONDS (fade in / out) music before starts or ends

 */

 /*~struct~CGaugeCustom:
 * @param id
 * @text Unique ID
 * @default myGauge
 * @desc ID for refer to this gauge settings from uAPI script call
 *
 * @param vertical:bool
 * @text Is Vertical?
 * @type boolean
 * @default false
 * @desc Gauge will use vertical fill?
 * 
 * @param fill
 * @text Fill Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Gaguge fill image, required!
 * 
 * @param foreground
 * @text Foreground Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Image above gauge fill, optional
 * 
 * @param mask
 * @text Mask Image
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc Whole gauge image mask, optional
 * 
 * @param backColor:css
 * @type string
 * @text Background Color
 * @default #000000
 * @desc Text color in HEX format (#000000)
 * 
 * @param backOpacity:int
 * @type number
 * @min 0
 * @max 255
 * @text Background Opacity
 * @default 255
 * @desc from 0 to 255, 0 - transparent, 255 - opaque
 *
 *
 * @param gaugeCaption
 * @text Caption
 *
 * @param text:struct
 * @parent gaugeCaption
 * @type struct<CText> 
 * @text Text Settings
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"200\",\"h:int\":\"30\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"2\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"24\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 *
 * @param textFormat
 * @parent gaugeCaption
 * @text Format
 * @default $1 / $2
 * @desc Write $1 for current value, $2 for max value, $3 for %
 */

 
 /*~struct~AAColTerrain:
 
 * @param terrainTag:int
 * @type number
 * @min 1
 * @max 7
 * @text Terrain Tag
 * @default 1

 * @param colliderConfig:struct
 * @type struct<AAColliderConfig> 
 * @text Collider
 * @default
 * @desc Collider for all map cells with specified terrain tag

 */

 /*~struct~AAColRegion:
 
 * @param regionId:int
 * @type number
 * @min 1
 * @max 255
 * @text Region Id
 * @default 1

 * @param colliderConfig:struct
 * @type struct<AAColliderConfig> 
 * @text Collider
 * @default
 * @desc Collider for all map cells with specified region id

 */

 /*~struct~AAColliderConfig:
 *  
 * @param type
 * @type select
 * @option Box (rectangle)
 * @value b
 * @option Circle
 * @value c
 * @text Type
 * @default b
 * @desc Collider type. Box (rectangle) or Circle
 *
 * @param dx:int
 * @type number
 * @text Offset by X
 * @min -1000
 * @default 0
 *
 * @param dy:int
 * @type number
 * @text Offset by Y
 * @min -1000
 * @default 0
 *
 * @param onlyForBox
 * @text Only for Box
 *
 * @param width:int
 * @parent onlyForBox
 * @type number
 * @text Width
 * @min 1
 * @default 48
 *
 * @param height:int
 * @parent onlyForBox
 * @type number
 * @min 1
 * @text Height
 * @default 48
 *
 * @param onlyForCircle
 * @text Only for Circle
 *
 * @param radius:int
 * @parent onlyForCircle
 * @type number
 * @min 1
 * @text Radius
 * @default 16
 */

/*~struct~LStateIconSettings:zh-cn

 @param visible:b
 @text 是否可见？
 @type boolean 
 @on Yes
 @off No
 @desc 此元素是否可见？
 @default true 

 @param position:s
 @text 位置
 @type struct<XY> 
 @desc 屏幕上的位置
 @default {"x:int":"0","y:int":"0"} 

 @param isCanBeEdited:b
 @text 是否可编辑？
 @type boolean
 @default true
 @desc 玩家是否可以在UI编辑器里编辑此元素？

 @param textFormat:str
 @text 剩余时间格式
 @type text 
 @desc 显示剩余时间时，%1符号将被替换为XX秒
 @default %1

 @param textFormatA:str
 @text 动作数量格式
 @type text 
 @desc %1 将被剩余动作数量替代 [仅限状态]
 @default A:%1

 @param text:struct
 @text 时间文本
 @type struct<CText> 
 @desc 计时器和动作显示数量格式
 @default {} 

 @param icon:s
 @text 图标
 @type struct<str6> 
 @desc 图标设置
 @default {} 

*/


/*~struct~LDamagePopUpVisualSettings:zh-cn
 * @param id
 * @text ID
 * @default
 * @desc 在<popUpStyleId:X>参数中使用的唯一标识
 *
 * @param randDX:int
 * @text 随机DX距离（水平）
 * @type number
 * @default 0
 * @min 0
 * @desc 在弹出时随机追加的X轴距离（像素）
 *
 * @param randDY:int
 * @text 随机DY
距离（垂直）
 * @type number
 * @default 0
 * @min 0
 * @desc 在弹出时随机追加的Y轴距离（像素）
 *
 * @param stayTime:int
 * @text 持续时间
 * @type number
 * @default 12
 * @min 1
 * @desc 弹出数字的持续时间（帧数）
 *
 * @param changeFontSize:int
 * @text 最终字体大小
 * @type number
 * @default 22
 * @min 1
 * @desc 最终字体大小，可以比设置中的字体大或者小
 *
 *
 * @param noFlyUp:bool
 * @text 是否往上飘？
 * @type boolean
 * @default false
 * @on Stay still
 * @off Fly Up
 * @desc 选是则表示会往上飘，反之则原地不动
 * 
 * @param noFadeOut:bool
 * @text 是否取消淡出效果？
 * @type boolean
 * @default false
 * @on No Fade
 * @off Fade out
 * @desc 选是则表示固定可见度，选否则表示有淡出效果
 * 
 * @param text:struct
 * @text 文本值
 * @type struct<CText>
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"100\",\"h:int\":\"100\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"3\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"14\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 * @desc 文本设置. 文本框大小并未使用
 *
 * @param image:struct
 * @text 额外图片
 * @default {"name":"","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","fadeInSpeed:int":"20"}
 * @type struct<LDPUImage>
*/


/*~struct~LDPUImage:zh-cn
 * @param name
 * @text 名称
 * @type file
 * @dir img/pictures/
 * @require 1
 * @default
 * @desc 可选项. 弹出物品提示时的额外图片
 * 
 * @param margins:struct
 * @text 对齐
 * @type struct<XY>
 * @default {"x:int":"0","y:int":"0"}
 * @desc 相对的弹出物品提示的图片相对位置
 *
 * @param fadeInSpeed:int
 * @text 消失速度
 * @type number
 * @default 20
 * @min 1
 * @desc 图片消失速度，图片开始是透明的，设置为255表示一直可见
 */

 /*~struct~LDPUExp:zh-cn

    @param active:b
    @text 是否启用？
    @type boolean
    @on Yes
    @off No
    @default true
    @desc 角色获得经验时是否有提示? 选No表示关闭此功能

    @param styleId
    @text 设置ID
    @default Experience
    @desc 按照设置的参数ID弹出的样式

    @param textFormat
    @text 文本格式
    @default +%1 exp
    @desc 弹出文字, %1会被替换成经验值

    @param aboveChar:b
    @text 是否在角色上面?
    @type boolean
    @on Yes (above char)
    @off No (above enemy)
    @default false
    @desc 是在角色头上还是在怪物头上出现?

    @param bindToChar:b
    @text 与角色绑定?
    @type boolean
    @on Yes (stay above char)
    @off No (stay on screen)
    @default false
    @desc 飘出的数字是跟随角色还是跟随屏幕？
 */

    /*~struct~LDPUGold:zh-cn

    @param popUpStyle:s
    @text Settings
    @type struct<LDamagePopUpVisualSettings> 
    @desc Pop Up Style settings
    @default {}

    @param textFormat
    @text Text Format
    @default %2%1
    @desc Pop Up Text, %1 will be replaced to gold value, %2 with - or +

    @param bindToChar:b
    @text 与角色绑定?
    @type boolean
    @on Yes (stay above char)
    @off No (stay on screen)
    @default false
    @desc 飘出的数字是跟随角色还是跟随屏幕？
 */


/*~struct~LMiniHpGaugeSettings:zh-cn
    @param active:b
    @text 是否启用?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc 在ABS事件上是否显示血条? 选No关闭此功能

    @param showOnlyOnHover:b
    @text 是否仅在悬浮状态下显示?
    @type boolean
    @on Yes (hover)
    @off No (always)
    @default true
    @desc 选是表示仅为悬浮显示? 选No表示永远显示

    @param showOnDamage:b
    @text 在受伤时显示?
    @type boolean
    @on Yes
    @off No
    @default true
    @desc 在ABS事件受伤时显示一小段时间？

    @param showWhenNotFull:b
    @text 是否只为不满血的显示?
    @type boolean
    @on Yes
    @off No
    @default false
    @desc 是否只显示非满血的事件?
*/
/*~struct~LMapScrollSettings:zh-cn
    @param isEnabled:b
    @text 是否启用?
    @type boolean
    @on Yes
    @off No
    @default false
    @desc 默认是否启用鼠标滚屏？（游戏中可通过uAPi脚本来开关控制）

    @param scrollZone:int
    @text 激活边缘大小
    @type number
    @min 10
    @max 50
    @default 10
    @desc 在屏幕边缘时激活滚屏功能的像素大小

    @param speed:int
    @text 滚屏速度
    @type number
    @min 1
    @max 10
    @default 5
    @desc 镜头滚动速度

    @param delay:int
    @text 延迟
    @type number
    @min 0
    @default 30
    @desc 滚屏延迟帧数(60帧 = 1秒)

    @param resetOnMove:b
    @text 当角色移动时是否恢复？
    @type boolean
    @on Reset
    @off No
    @default true
    @desc 当角色开始移动时是否镜头恢复到角色为中心？

    @param resetOnAction:b
    @text 当角色有动作时是否恢复？
    @type boolean
    @on Reset
    @off No
    @default true
    @desc 当角色开始动作时（攻击或被攻击）是否镜头恢复到角色为中心？
*/
/*~struct~LSkillSlotItem:zh-cn
 * @param position:struct
 * @text 位置
 * @type struct<XY2>
 * @default
 * @desc 技能栏在屏幕中的位置
 *
 * @param symbol
 * @text 快捷键
 * @default
 * @desc 激活技能栏的快捷键
 *
 * @param isEditable:b
 * @text 是否可编辑?
 * @type boolean
 * @default true
 * @desc 角色是否可以编辑技能栏? 也就是打开技能或物品的选择菜单
 *
 * @param isAutoset:b
 * @text 是否自动装配快捷栏?
 * @type boolean
 * @default true
 * @desc 技能或物品是否会自动的装配到这个快捷栏中？
 *
 * @param filter:str
 * @text 筛选
 * @parent isAutoset:b
 * @type combo
 * @option Any
 * @option Items
 * @option Skills
 * @default Any
 * @desc 筛选功能仅为开启自动装配功能时有用. (自动筛选=开启此功能)
 *
 * @param specifiedIds:str
 * @text 指定的ID集合
 * @parent isAutoset:b
 * @default
 * @desc 技能栏只能放置某些特定的物品或技能（用半角逗号分隔），不填表示都接受
 *
 * @param style:struct
 * @text 可视化设置
 * @type struct<LSkillSlotItemVisual> 
 * @default
 * @desc 技能栏可以有自定义的显示效果。留空表示不用此功能 (参数: 技能栏可视化)
 */

/*~struct~LInputSettings:zh-cn

    @param LMBMapTouchMode
    @text 鼠标左键（点地图）
    @type select
    @option Primary attack
    @option Default (move)
    @option Nothing
    @default Default (move)
    @desc 

    @param RMBMapTouchMode
    @text 鼠标右键（点地图）
    @type select
    @option Default (menu)
    @option Secondary attack
    @option Move
    @option Turn
    @option Nothing
    @default Turn
    @desc 

    @param LMBTargetTouchMode
    @text 鼠标左键（点怪）
    @type select
    @option Primary attack
    @option Default (move)
    @option Smart attack (Primary)
    @option Turn
    @default Smart attack (Primary)
    @desc 

    @param RMBTargetTouchMode
    @text 鼠标右键（点怪）
    @type select
    @option Secondary attack
    @option Move
    @option Smart attack (Secondary)
    @option Turn
    @default Smart attack (Secondary)
    @desc 

    @param moveType
    @text 移动
    @type select
    @option WASD and Arrows
    @option Arrows only
    @default WASD and Arrows
    @desc 控制角色移动的快捷键

    @param isDiagonalMovement:b
    @text 斜向移动？
    @type boolean
    @default true
    @on Yes
    @off No
    @desc 是否允许8方向移动

    @param isDiagonalMovementAI:b
    @text Diagonal Movement for AI?
    @type boolean
    @default true
    @on Yes
    @off No
    @desc Moving in 8 directions? (for Enemies (Events))

    @param isStaticAtkRot:b
    @text 角色转身时是否可攻击？
    @type boolean
    @default true
    @on Yes
    @off No
    @desc 当用鼠标点击地图时是否只攻击不移动（转身时）

    @param multiTouch:b
    @text 是否允许多点触控？
    @type boolean
    @default false
    @on Yes
    @off No
    @desc [仅限触摸屏]是否允许多点触控式的操作？

    @param keybingind
    @text 键位绑定

    @param kbReload
    @text 装填子弹
    @parent keybingind
    @default R
    @desc

    @param kbCommandMenu
    @text 命令
    @parent keybingind
    @default C
    @desc

    @param kbRotate
    @text 转向
    @parent keybingind
    @default Control
    @desc

*/
/*~struct~LActorGauge:zh-cn
 * @param visible:bool
 * @text 是否可见？
 * @type boolean
 * @default true
 * @desc 初始时此能量槽是否可见？
 * 
 * @param position:struct
 * @text 位置
 * @type struct<XY2>
 * @default
 * @desc 屏幕位置
 * 
 * @param label
 * @text 标签
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 可选项，能量槽的标签图片
 * 
 * @param labelMargins:struct
 * @text 标签偏移量
 * @type struct<XY>
 * @default
 * @desc 相对于能量槽标签图片的偏移量
 *
 * @param isCanBeEdited:bool
 * @text 是否可编辑?
 * @type boolean
 * @default true
 * @desc 玩家是否可以在UI编辑器中编辑？
 *
 * @param isHideWithMessage:bool
 * @text 是否隐藏？
 * @type boolean
 * @default true
 * @desc 当对话窗口弹出时是否
隐藏？
 * 
 * @param text:struct
 * @text 文本值
 * @type struct<CText>
 * 
 * @param gauge:struct
 * @text 能量槽
 * @type struct<CGauge>
 * 
 * 
*/
/*~struct~CGauge:zh-cn
 * @param visible:bool
 * @text 是否可见?
 * @type boolean
 * @default true
 * @desc 此能量槽是否可见?
 *
 * @param vertical:bool
 * @text 是否为垂直显示?
 * @type boolean
 * @default false
 * @desc 此能量槽是否为垂直填充?
 * 
 * @param fill
 * @text 填充图像
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 需要提供一个填充图像
 * 
 * @param foreground
 * @text 前景图片
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 在能量槽上方的图片, 可选项
 * 
 * @param mask
 * @text 遮罩图片
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 整体遮罩图片, 可选项
 * 
 * @param backColor:css
 * @type string
 * @text 背景色
 * @default #000000
 * @desc 16进制颜色 (#000000)
 * 
 * @param backOpacity:int
 * @type number
 * @min 0
 * @max 255
 * @text 背景可见度
 * @default 255
 * @desc 输入0到255的值, 0=透明, 255=不透明
 */
/*~struct~CText:zh-cn
 * @param visible:bool
 * @text 是否可见?
 * @type boolean
 * @default true
 * @desc 当前文本是否可见?
 * 
 * @param size:struct
 * @text 文本框大小
 * @type struct<WH>
 * @default
 * @desc 文本框区域大小
 * 
 * @param margins:struct
 * @text 偏移
 * @type struct<XY>
 * @default
 * @desc 基于父类的文本框偏移位置
 * 
 * @param alignment:str
 * @text 对齐方式
 * @type combo
 * @option center
 * @option right
 * @option left
 * @default center
 * @desc 居中，右对齐，左对齐
 * 
 * @param outline:struct
 * @text 文本描边
 * @type struct<Outline>
 * @default
 * @desc 文本描边设定
 * 
 * @param font:struct
 * @type struct<Font>
 * @text 字体设定
 * @default
 * @desc 字体设定
 * 
 * @param textColor:css
 * @type string
 * @text 字体颜色
 * @default #FFFFFF
 * @desc 字体颜色16进制代码 (#000000)
 * 
 */
/*~struct~XY:zh-cn
 * @param x:int
 * @text X
 * @type number
 * @default 0
 * @min -1000
 *
 * @param y:int
 * @text Y
 * @type number
 * @default 0
 * @min -1000
 */
/*~struct~XY2:zh-cn
 * @param x:e
 * @text X
 * @type text
 * @default 0
 * @desc 此处应输入脚本 (例如: Graphics.width / 2)
 *
 * @param y:e
 * @text Y
 * @type text
 * @default 0
 * @desc 此处应输入脚本 (例如: $gameVariables.value(12) * 2)
 */
/*~struct~WH:zh-cn
 * @param w:int
 * @text 宽度
 * @type number
 * @default 100
 * @min 0
 *
 * @param h:int
 * @text 高度
 * @type number
 * @default 100
 * @min 0
 */
/*~struct~Font:zh-cn
 * @param face:str
 * @text 字体
 * @type combo
 * @option AABS_0
 * @option AABS_1
 * @option AABS_2
 * @option AABS_3
 * @default AABS_0
 *
 * @param size:int
 * @text 大小
 * @type number
 * @default 24
 * @min 1
 * 
 * @param italic:bool
 * @text 斜体
 * @type boolean
 * @default false
 */
/*~struct~Outline:zh-cn
 * @param color:css
 * @text 颜色
 * @type text
 * @default #000000
 * @desc Outline color in HEX (#000000) or empty "" (black)
 *
 * @param width:int
 * @text 宽度
 * @type number
 * @default 3
 * @min 0
 * @desc 字体描边厚度
 */
 /*~struct~str6:zh-cn

 * @param visible:bool
 * @text 是否可见?
 * @type boolean
 * @default true
 * @desc 此元素是否可见? 


 @param index:i
 @text 图标索引
 @type number 
 @min 0
 @desc 在图标集中的索引值
 @default 0 

 @param size:i
 @text 图标大小
 @type number 
 @min 2
 @desc 图标大小 (默认是32)
 @default 32 

*/

/*~struct~LEnemyCustomMiniGauge:zh-cn
    @param id
    @text ID
    @desc 在此命令中使用：<miniHpGaugeStyle:ID>
    @default custom1

    @param gauge:struct
    @text 设置
    @type struct<LActorGauge>
    @default {"visible:bool":"true","position:struct":"{\"x:e\":\"-19\",\"y:e\":\"-56\"}","label":"","labelMargins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","isCanBeEdited:bool":"false","isHideWithMessage:bool":"false","text:struct":"{\"visible:bool\":\"false\",\"size:struct\":\"{\\\"w:int\\\":\\\"100\\\",\\\"h:int\\\":\\\"20\\\"}\",\"margins:struct\":\"{\\\"x:int\\\":\\\"0\\\",\\\"y:int\\\":\\\"0\\\"}\",\"alignment:str\":\"center\",\"outline:struct\":\"{\\\"color:css\\\":\\\"#000000\\\",\\\"width:int\\\":\\\"2\\\"}\",\"font:struct\":\"{\\\"face:str\\\":\\\"AABS_0\\\",\\\"size:int\\\":\\\"13\\\",\\\"italic:bool\\\":\\\"false\\\"}\",\"textColor:css\":\"#edead8\"}","gauge:struct":"{\"visible:bool\":\"true\",\"vertical:bool\":\"false\",\"fill\":\"Event_HPGauge2\",\"foreground\":\"\",\"mask\":\"\",\"backColor:css\":\"#000000\",\"backOpacity:int\":\"160\"}"}
    @desc 当前样式的迷你HP血条显示设置
*/

/*~struct~LSkillSLotItemVisualIcon:zh-cn

 @param visible:b
 @text 
 @type boolean 
 @on Yes
 @off No
 @desc 可视化
 @default true 


 @param size:i
 @text 
 @type number 
 @min 0
 @desc 尺寸
 @default 32 


 @param index:i
 @text 
 @type number 
 @min 0
 @desc 索引
 @default 0 

*/

/*~struct~LSkillSlotItemVisual:zh-cn

 * @param visible:bool
 * @text 是否可见?
 * @type boolean
 * @default true
 * @desc 此技能栏是否可见?


 * @param isCanBeEdited:bool
 * @text 是否可编辑?
 * @type boolean
 * @default true
 * @desc 玩家是否可通过UI编辑器来编辑此技能栏? 


 * @param isHideWithMessage:bool
 * @text 显示文本时是否隐藏?
 * @type boolean
 * @default true
 * @desc 当显示对话文本时，此界面是否隐藏? 

 @param outlineGroup
 @text 描边

 @param outlineMargins:s
 @parent outlineGroup
 @text 描边偏移量
 @type struct<XY> 
 @desc 描边颜色的偏移量设置
 @default {} 


 @param outlinePulseSpeed:i
 @parent outlineGroup
 @text 脉冲速度
 @type number 
 @min 1
 @max 255
 @desc 描边的脉冲速度（游戏帧）
 @default 40 


 @param selectedOutlineColor:str
 @parent outlineGroup
 @text 已选中
 @type text 
 @desc 已选中的技能栏描边效果的颜色，16进制代码
 @default #fcba03 


 @param clickedOutlineColor:str
 @parent outlineGroup
 @text 已点击
 @type text 
 @desc 已激活/已点击的技能栏描边效果的颜色，16进制代码
 @default #0b03fc 


 @param readyOutlineColor:str
 @parent outlineGroup
 @text 已准备
 @type text 
 @desc 已准备就绪的技能栏描边效果的颜色，16进制代码
 @default #21b53c 


 @param badOutlineColor:str
 @parent outlineGroup
 @text 已禁用
 @type text 
 @desc 已禁用的技能栏描边效果的颜色，16进制代码
 @default #d61a1a 


 @param icon:s
 @text 图标设置
 @type struct<LSkillSLotItemVisualIcon> 
 @desc 技能栏上的技能和物品的图标设置，图标索引已被忽略
 @default {} 

 @param iconMargins:s
 @text 图标偏移量
 @parent icon:s
 @type struct<XY> 
 @desc 图标偏移量
 @default {} 

 @param symbolText:s
 @text 符号文本
 @type struct<CText> 
 @desc 符号 (键位) 文本设置
 @default {} 


 @param timeText:s
 @text 时间文本
 @type struct<CText> 
 @desc 计时文本设置
 @default {} 


 @param countText:s
 @text 计数文本
 @type struct<CText> 
 @desc 计数文本设置
 @default {} 

*/


/*~struct~LUIFaceElement:zh-cn

 @param visible:bool
 @text 是否可见?
 @type boolean
 @default true
 @desc 此元素是否可见?


 @param faceName
 @text 脸图
 @type file
 @require 1
 @dir img/face/
 @desc 脸图文件名
 @default  


 @param faceIndex:i
 @parent faceName
 @text 索引
 @type number 
 @min 0
 @desc 脸图索引
 @default 0 


 @param mirror:b
 @text 镜像
 @type boolean 
 @on Yes
 @off No
 @desc 是否镜像显示脸图？
 @default false 


 @param size:i
 @text 大小
 @type number 
 @desc 脸图大小（RM默认是144）
 @default 74 


 @param margins:s
 @text 偏移量
 @type struct<XY> 
 @desc 脸图偏移量
 @default {}

*/
/*~struct~LUIImageElement:zh-cn

 @param visible:bool
 @text 是否可见?
 @type boolean
 @default true
 @desc 此元素是否可见? 


 @param image
 @text 图片
 @type file
 @require 1
 @dir img/Alpha/
 @desc
 @default 


 @param margins:s
 @text 偏移量
 @type struct<XY> 
 @desc 图片偏移量
 @default {}

*/

/*~struct~LEnemyInfoVisual:zh-cn

 @param visible:bool
 @text 是否可见?
 @type boolean
 @default true
 @desc 此元素是否可见? 


 @param position:struct
 @text 位置
 @type struct<XY2>
 @default
 @desc 位于屏幕中的位置


 @param image
 @text 背景
 @type file
 @require 1
 @dir img/Alpha/
 @desc
 @default Enemy_Background 


 @param isCanBeEdited:bool
 @text 是否可编辑?
 @type boolean
 @default true
 @desc 玩家是否可通过UI编辑器来编辑此元素? 


 @param isHideWithMessage:bool
 @text 是否在对话时隐藏?
 @type boolean
 @default true
 @desc 当对话界面出现时此元素是否被隐藏? 


 @param nameFormat
 @text 名称格式
 @type text 
 @desc %1将会被怪物名称替换掉
 @default %1


 @param levelFormat
 @text 等级格式
 @type text 
 @desc %1将会被怪物等级替换掉
 @default Lv. %1 


 @param hpTextFormat
 @text 血量格式
 @type text 
 @desc %1 - HP, %2 - 最大HP, %3 - 百分比%
 @default %1 / %2 


 @param nameText:s
 @parent nameFormat
 @text 文本
 @type struct<CText> 
 @desc 怪物名称文本样式
 @default {} 


 @param hpText:s
 @parent hpTextFormat
 @text 文本
 @type struct<CText> 
 @desc 怪物HP文本样式
 @default {} 


 @param levelText:s
 @parent levelFormat
 @text 文本
 @type struct<CText> 
 @desc 怪物等级文本样式
 @default {} 


 @param gauge:s
 @text HP血条
 @type struct<CGauge> 
 @desc 怪物HP血条显示样式
 @default {} 

 @param gaugeMargins:s
 @parent gauge:s
 @text 偏移量
 @type struct<XY> 
 @desc HP血条偏移量
 @default {}

 @param face:s
 @text 怪物脸图
 @type struct<LUIFaceElement> 
 @desc 怪物脸图设置，文件名和索引未被使用
 @default {} 


 @param battleState:s
 @text 战斗状态图标
 @type struct<LUIImageElement> 
 @desc 怪物进入战斗状态时的图标
 @default {} 


 @param foregroundImage:s
 @text 前景图
 @type struct<LUIImageElement> 
 @desc 前景图图片
 @default {} 

*/

/*~struct~LSpawnPoint:zh-cn

 @param id:str
 @text ID
 @type text 
 @desc 用于<absSpawnPoint:ID>命令的唯一的出生点ID
 @default spawnPoint

 @param spawnPointType:str
 @text 出生类型
 @type select
 @option self
 @option region
 @option player
 @desc Self=出生在自身周围. Region=出生在特定区域. Player=出生在玩家周围.
 @default self 

 @param spawnRadius:str
 @parent spawnPointType:str
 @text 半径和区域
 @type text
 @desc 半径（自身，玩家）或区域（用于区域类型）的[扩展属性]
 @default 3

 @param spawnMax:str
 @text 最大值
 @type text 
 @desc 可出生的最大数值. 0=不限制. [扩展属性]
 @default 3


 @param spawnAliveMax:str
 @parent spawnMax:str
 @text 最大存活怪物数量
 @type text 
 @desc 可出现的最大的存活的怪物数量. 0=不限制. [扩展属性]
 @default 2 


 @param spawnRate:str
 @text 出生速度
 @type text 
 @desc 每隔多少秒出生一次，最少为1秒 [扩展属性]
 @default 4

 @param spawnEnemiesId:str
 @text 出生的事件ID
 @type text 
 @desc 在出生地图中的用于出生的事件ID合集 [扩展属性]
 @default 1, 2, 3


 @param conditionSwitch:i
 @text 开关
 @type switch 
 @desc 0=无开关限制. 如果开关为关闭则表示不出生
 @default 0

 @param visorRadius:i
 @text 出生视野
 @type number 
 @min 0
 @desc 0=一直出生. 其他数字表示玩家在此半径内才会开始出生
 @default 3


 @param endCommonEvent:i
 @text 达到最大数量时
 @type common_event 
 @desc 达到最大数量时执行的公共事件
 @default 0

*/


/*~struct~LCustomLevelUpSettings:zh-cn

 @param databaseAnimationId:i
 @text 动画 [数据库]
 @type animation 
 @min 0
 @desc 0=无动画.
 @default 0

 @param imageSeqAnimationName:str
 @text 动画 [文件]
 @type file
 @dir img/pictures/
 @desc 可选项, 文件命名规则: 文件名(帧数,延迟).png
 @default

 @param imageSeqAnimationMargins:s
 @parent imageSeqAnimationName:str
 @text 偏移量
 @type struct<XY> 
 @desc 
 @default {} 

 @param extraSE:str
 @text 音效
 @type file
 @dir audio/se/
 @require 1
 @desc 可选项, 留空表示不显示
 @default

 @param isShowPopUp:b
 @text 是否显示飘字?
 @type boolean 
 @on Yes
 @off No
 @desc 
 @default true 

 @param popUpText:str
 @parent isShowPopUp:b
 @text 文本
 @type text
 @desc %1 将被新等级（数字）的值所覆盖
 @default Level %1! 

 @param popUpStyle:s
 @parent isShowPopUp:b
 @text 设置
 @type struct<LDamagePopUpVisualSettings> 
 @desc 飘字样式设置
 @default {} 

 @param commonEvent:i
 @text 公共事件
 @type common_event 
 @min 0
 @desc 升级时执行的公共事件
 @default 0 

 @param scriptAction:str
 @text 脚本命令
 @type text 
 @desc 升级时执行的脚本命令（相对于玩家角色）
 @default

*/

/*~struct~LBloodSplatterEffectSettings:zh-cn
 @param BS_Picture
 @text 血量过低闪烁效果图片
 @type file
 @dir img/pictures/
 @require 1
 @desc 可以选择不设置此选项
 
 @param BS_Color
 @text 血量过低时闪烁颜色值
 @type string
 @default #F98822
 @desc 输入十六进制数字，或者留空表示不使用此功能
 
 @param BS_Opacity:int
 @text 血量过低时屏幕闪烁透明度
 @type number
 @min 0
 @max 255
 @default 124
 @desc 输入0到255的数字
 
 @param BS_HpRate:int
 @text 角色血量过低比例
 @type number
 @min 1
 @max 99
 @default 15
 @desc 血量达到百分之多少时显示血量警告效果
 */

 /*~struct~FlyBonus:zh-cn
    @param image:str
    @text Image
    @type file
    @dir img/pictures/
    @require 1 
    @desc Bonus image, supports animated
    @default bonusGreen 

    @param actionSE:str
    @text Action SE
    @type file
    @dir audio/se
    @require 1
    @desc Sound effect when player got bonus
    @default  

    @param spawnSE:str
    @text Appear SE
    @type file
    @dir audio/se
    @require 1
    @desc Sound effect when bonus is appears
    @default  

    @param startOffsetRadiusInPx:i
    @text Offset
    @type number 
    @min 0
    @max 48
    @desc Appear position max offset in PX from start point
    @default 16 

    @param stayFrames:i
    @text Delay
    @type number 
    @min 0
    @desc Delay in frames! before bonus fly to the player
    @default 12 

    @param flySpeed:i
    @text Speed
    @type number 
    @min 1
    @max 100
    @desc Fly speed (in PX)
    @default 8

    @param actionSA:str
    @text SAction
    @type text 
    @desc Optional. SAction executed on player when received this bonuse.
    @default

    @param hpGainE
    @text HP Gain
    @desc Optional. How many HP this bonus gain to the player. EVal supported.
    @default 25 

    @param mpGainE
    @text MP Gain
    @desc Optional. How many MP this bonus gain to the player. EVal supported.
    @default 0

    @param expGainE
    @text EXP Gain
    @desc Optional. How many EXP this bonus gain to the player. EVal supported.
    @default 0 

    @param goldGainE
    @text Gold Gain
    @desc Optional. How many Gold this bonus gain to the player. EVal supported.
    @default 0
 */
 
 /*~struct~LDodgeActionSettings:zh-cn
@param dodgeKey
@text 热键
@default f

@param dodgeSwitch:i
@text 开启开关
@type switch
@desc 当此开关打开后玩家将永久可以使用闪躲动作

@param isInvincible:b
@text 是否无敌？
@type boolean
@desc 设置为真时，玩家在躲闪过程中将处于无敌状态

@param stepsCount:i
@text 前冲距离
@type number
@min 1
@max 2
@default 2
@desc 玩家躲闪时可前冲多少距离（1格或者2格）

@param delayBetweenStepMS:i
@text 每格间隔毫秒
@type number
@min 0
@default 100
@desc 躲闪时每格的间隔时间，单位毫秒

@param dodgeMoveSpeed:i
@text 速度
@type number
@min 4
@default 5
@desc 玩家前冲时的移动速度

@param dodgeRestTimerFrames:i
@text CD时间
@type number
@min 0
@default 30
@desc 躲闪动作的CD时间（游戏帧）

@param dodgeRestVariable:i
@parent dodgeRestTimerFrames:i
@text CD时间变量
@type variable
@default 0
@desc 如果设置为非0，则此数字对应的变量数值将作为躲闪CD时间（游戏帧）
 */

/*~struct~BattleAutoBGM:zh-cn

 @param name
 @text 背景音乐BGM
 @type file
 @require 1
 @dir audio/BGM/
 @desc 如果留空则表示不启用此功能，否则将启用地图描述区的BGM设置
 @default

@param delay:i
@text 延迟
@type number
@decimals 2
@min 0
@default 0.5
@desc BGM淡出淡入的时间（单位秒）
 */
/*~struct~CGaugeCustom:zh-cn
 * @param id
 * @text 独有ID
 * @default myGauge
 * @desc 从uAPI脚本调用引用此血槽的独有ID
 *
 * @param vertical:bool
 * @text 是否垂直显示
 * @type boolean
 * @default false
 * @desc 血槽是否是垂直显示的？
 *
 * @param fill
 * @text 填充图片
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 血槽的填充图片，必选项
 *
 * @param foreground
 * @text 血槽前景图
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 位于血槽上层显示的前景图，非必选项
 *
 * @param mask
 * @text 蒙板图片
 * @type file
 * @dir img/Alpha/
 * @require 1
 * @default
 * @desc 整体血槽的蒙板遮罩，非必选项
 *
 * @param backColor:css
 * @type string
 * @text 背景色
 * @default #000000
 * @desc 文字颜色的十六进制代码，格式(#000000)
 *
 * @param backOpacity:int
 * @type 数字
 * @min 0
 * @max 255
 * @text 背景可见度
 * @default 255
 * @desc 0表示不可见，255表示正常显示
 *
 * @param gaugeCaption
 * @text 标题
 *
 * @param text:struct
 * @parent gaugeCaption
 * @type struct<CText>
 * @text 文本设置
 * @default {"visible:bool":"true","size:struct":"{\"w:int\":\"200\",\"h:int\":\"30\"}","margins:struct":"{\"x:int\":\"0\",\"y:int\":\"0\"}","alignment:str":"center","outline:struct":"{\"color:css\":\"#000000\",\"width:int\":\"2\"}","font:struct":"{\"face:str\":\"AABS_0\",\"size:int\":\"24\",\"italic:bool\":\"false\"}","textColor:css":"#FFFFFF"}
 *
 * @param textFormat
 * @parent gaugeCaption
 * @text 格式
 * @default $1 / $2
 * @desc $1表示当前值，$2表示最大值，$3表示百分比
 */
 
 /*~struct~AAColTerrain:zh-cn
 
 * @param terrainTag:int
 * @type number
 * @min 1
 * @max 7
 * @text 地形标记
 * @default 1

 * @param colliderConfig:struct
 * @type struct<AAColliderConfig>
 * @text 碰撞体
 * @default
 * @desc 所有地图格子的碰撞体地形标志ID
 */
 /*~struct~AAColRegion:zh-cn
 
 * @param regionId:int
 * @type number
 * @min 1
 * @max 255
 * @text 区域ID
 * @default 1

 * @param colliderConfig:struct
 * @type struct<AAColliderConfig>
 * @text Collider
 * @default
 * @desc 所有地图格子的碰撞体区域ID
 */

 /*~struct~AAColliderConfig:zh-cn
 * 
 * @param type
 * @type select
 * @option Box (rectangle)
 * @value b
 * @option Circle
 * @value c
 * @text 类型
 * @default b
 * @desc 碰撞体类型（B=方形，C=圆形）
 *
 * @param dx:int
 * @type number
 * @text X偏移
 * @default 0
 *
 * @param dy:int
 * @type number
 * @text Y偏移
 * @default 0
 *
 * @param onlyForBox
 * @text 仅方形有效
 *
 * @param width:int
 * @parent onlyForBox
 * @type number
 * @text 宽度
 * @min 1
 * @default 48
 *
 * @param height:int
 * @parent onlyForBox
 * @type number
 * @min 1
 * @text 高度
 * @default 48
 *
 * @param onlyForCircle
 * @text 仅圆形有效
 *
 * @param radius:int
 * @parent onlyForCircle
 * @type number
 * @min 1
 * @text 半径
 * @default 16
 */


var Imported = Imported || {};
Imported.Alpha_ABSZ = true;

// * ALPHA FAMILY PLUGINS GLOBAL DEFINITION
var AA = AA || {};

AA.Utils = {};

AA.warning = function(e, msg) {
    KDCore.warning(e, msg);
};

AA.w = (e, mgs) => AA.warning(e, mgs);

AA.link = function (library) {
    this[library.name] = library;
};

AA.Version = 94;

// * Данный символ переопределяется в 1_DevSymbol_TEST как dev
AA._define = 'build'; // * По умолчанию -> сборка

// * Критическая ошибка, стоп игры
AA.cre = function(e, msg) {
    AA.w(e, msg);
    window.alert(msg || "Critical error occur!");
    SceneManager.update = () => {};
};

// * Если карта (Scene_Map) и включён режим АБС
AA.isABSMap = function() {
    return AA.isABSActive() && AA.isMap();
};

// * АБС в активном режиме
AA.isABSActive = function() {
    return AA.System.isABSActive();
};

AA.isMap = function() {
    return AAUtils.isSceneMap();
};

AA.isDEV = function() {
    return AA._define == 'dev';
};

AA.isPro = function() {
    return true;
};
(function(){



// Copyright (c) 2019 - Alvaro Montoro (alvaromontoro@gmail.com)
//
// Released under the MIT License - https://github.com/alvaromontoro/gamecontroller.js
//
// pGameController
(()=>{"use strict";const t=(t,e="log")=>{"error"===e?console&&"function"==typeof console.error&&console.error(t):console&&"function"==typeof console.info&&console.info(t)},e=e=>t(e,"error"),n=()=>navigator.getGamepads&&"function"==typeof navigator.getGamepads||navigator.getGamepads&&"function"==typeof navigator.webkitGetGamepads||!1,o="Invalid property.",i="Invalid value. It must be a number between 0.00 and 1.00.",s="Button does not exist.",a="Unknown event name.",c=function(t){let n={id:t.index,buttons:t.buttons.length,axes:Math.floor(t.axes.length/2),axeValues:[],axeThreshold:[1],hapticActuator:null,vibrationMode:-1,vibration:!1,mapping:t.mapping,buttonActions:{},axesActions:{},pressed:{},set:function(t,n){if(["axeThreshold"].indexOf(t)>=0){if("axeThreshold"===t&&(!parseFloat(n)||n<0||n>1))return void e(i);this[t]=n}else e(o)},vibrate:function(t=.75,e=500){if(this.hapticActuator)switch(this.vibrationMode){case 0:return this.hapticActuator.pulse(t,e);case 1:return this.hapticActuator.playEffect("dual-rumble",{duration:e,strongMagnitude:t,weakMagnitude:t})}},triggerDirectionalAction:function(t,e,n,o,i){n&&o%2===i?(this.pressed[`${t}${e}`]||(this.pressed[`${t}${e}`]=!0,this.axesActions[e][t].before()),this.axesActions[e][t].action()):this.pressed[`${t}${e}`]&&o%2===i&&(delete this.pressed[`${t}${e}`],this.axesActions[e][t].after())},checkStatus:function(){let t={};const e=navigator.getGamepads?navigator.getGamepads():navigator.webkitGetGamepads?navigator.webkitGetGamepads():[];if(e.length){if(t=e[this.id],t.buttons)for(let e=0;e<this.buttons;e++)!0===t.buttons[e].pressed?(this.pressed[`button${e}`]||(this.pressed[`button${e}`]=!0,this.buttonActions[e].before()),this.buttonActions[e].action()):this.pressed[`button${e}`]&&(delete this.pressed[`button${e}`],this.buttonActions[e].after());if(t.axes){const e=t.axes.length%2;for(let n=0;n<2*this.axes;n++){const o=t.axes[n+e].toFixed(4),i=Math.floor(n/2);this.axeValues[i][n%2]=o,this.triggerDirectionalAction("right",i,o>=this.axeThreshold[0],n,0),this.triggerDirectionalAction("left",i,o<=-this.axeThreshold[0],n,0),this.triggerDirectionalAction("down",i,o>=this.axeThreshold[0],n,1),this.triggerDirectionalAction("up",i,o<=-this.axeThreshold[0],n,1)}}}},associateEvent:function(t,n,o){if(t.match(/^button\d+$/)){const i=parseInt(t.match(/^button(\d+)$/)[1]);i>=0&&i<this.buttons?this.buttonActions[i][o]=n:e(s)}else if("start"===t)this.buttonActions[9][o]=n;else if("select"===t)this.buttonActions[8][o]=n;else if("r1"===t)this.buttonActions[5][o]=n;else if("r2"===t)this.buttonActions[7][o]=n;else if("l1"===t)this.buttonActions[4][o]=n;else if("l2"===t)this.buttonActions[6][o]=n;else if("power"===t)this.buttons>=17?this.buttonActions[16][o]=n:e(s);else if(t.match(/^(up|down|left|right)(\d+)$/)){const i=t.match(/^(up|down|left|right)(\d+)$/),a=i[1],c=parseInt(i[2]);c>=0&&c<this.axes?this.axesActions[c][a][o]=n:e(s)}else if(t.match(/^(up|down|left|right)$/)){const e=t.match(/^(up|down|left|right)$/)[1];this.axesActions[0][e][o]=n}return this},on:function(t,e){return this.associateEvent(t,e,"action")},off:function(t){return this.associateEvent(t,(function(){}),"action")},after:function(t,e){return this.associateEvent(t,e,"after")},before:function(t,e){return this.associateEvent(t,e,"before")}};for(let t=0;t<n.buttons;t++)n.buttonActions[t]={action:()=>{},after:()=>{},before:()=>{}};for(let t=0;t<n.axes;t++)n.axesActions[t]={down:{action:()=>{},after:()=>{},before:()=>{}},left:{action:()=>{},after:()=>{},before:()=>{}},right:{action:()=>{},after:()=>{},before:()=>{}},up:{action:()=>{},after:()=>{},before:()=>{}}},n.axeValues[t]=[0,0];return t.hapticActuators?"function"==typeof t.hapticActuators.pulse?(n.hapticActuator=t.hapticActuators,n.vibrationMode=0,n.vibration=!0):t.hapticActuators[0]&&"function"==typeof t.hapticActuators[0].pulse&&(n.hapticActuator=t.hapticActuators[0],n.vibrationMode=0,n.vibration=!0):t.vibrationActuator&&"function"==typeof t.vibrationActuator.playEffect&&(n.hapticActuator=t.vibrationActuator,n.vibrationMode=1,n.vibration=!0),n},r={gamepads:{},axeThreshold:[1],isReady:n(),onConnect:function(){},onDisconnect:function(){},onBeforeCycle:function(){},onAfterCycle:function(){},getGamepads:function(){return this.gamepads},getGamepad:function(t){return this.gamepads[t]?this.gamepads[t]:null},set:function(t,n){if(["axeThreshold"].indexOf(t)>=0){if("axeThreshold"===t&&(!parseFloat(n)||n<0||n>1))return void e(i);if(this[t]=n,"axeThreshold"===t){const t=this.getGamepads(),e=Object.keys(t);for(let n=0;n<e.length;n++)t[e[n]].set("axeThreshold",this.axeThreshold)}}else e(o)},checkStatus:function(){const t=window.requestAnimationFrame||window.webkitRequestAnimationFrame,e=Object.keys(r.gamepads);r.onBeforeCycle();for(let t=0;t<e.length;t++)r.gamepads[e[t]].checkStatus();r.onAfterCycle(),e.length>0&&t(r.checkStatus)},init:function(){window.addEventListener("gamepadconnected",(e=>{const n=e.gamepad||e.detail.gamepad;if(t("Gamepad detected."),window.gamepads||(window.gamepads={}),n){if(!window.gamepads[n.index]){window.gamepads[n.index]=n;const t=c(n);t.set("axeThreshold",this.axeThreshold),this.gamepads[t.id]=t,this.onConnect(this.gamepads[t.id])}1===Object.keys(this.gamepads).length&&this.checkStatus()}})),window.addEventListener("gamepaddisconnected",(e=>{const n=e.gamepad||e.detail.gamepad;t("Gamepad disconnected."),n&&(delete window.gamepads[n.index],delete this.gamepads[n.index],this.onDisconnect(n.index))}))},on:function(t,n){switch(t){case"connect":this.onConnect=n;break;case"disconnect":this.onDisconnect=n;break;case"beforeCycle":case"beforecycle":this.onBeforeCycle=n;break;case"afterCycle":case"aftercycle":this.onAfterCycle=n;break;default:e(a)}return this},off:function(t){switch(t){case"connect":this.onConnect=function(){};break;case"disconnect":this.onDisconnect=function(){};break;case"beforeCycle":case"beforecycle":this.onBeforeCycle=function(){};break;case"afterCycle":case"aftercycle":this.onAfterCycle=function(){};break;default:e(a)}return this}};r.init();const h=r;n()?window.pGameController=h:e("Your web browser does not support the Gamepad API.")})();

/*
# ==========================================================================
# ==========================================================================
#
#   EMBEDDED PHEONIX KAGEDESU PLUGINS CORE LIBRARY
#   (This plugin may not use the entire code of this library)
#
# ==========================================================================
# ==========================================================================
 * 
 * 
 */



/*!
 * pixi-filters - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:51:27 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(e,n,t,r,o,i,l,a){"use strict";var s=function(e,n){return(s=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(e,n)};function u(e,n){function t(){this.constructor=e}s(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}var f=function(){return(f=Object.assign||function(e){for(var n,t=arguments,r=1,o=arguments.length;r<o;r++)for(var i in n=t[r])Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i]);return e}).apply(this,arguments)};Object.create;Object.create;var c="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",m=function(e){function n(n){var t=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n")||this;return t.gamma=1,t.saturation=1,t.contrast=1,t.brightness=1,t.red=1,t.green=1,t.blue=1,t.alpha=1,Object.assign(t,n),t}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.gamma=Math.max(this.gamma,1e-4),this.uniforms.saturation=this.saturation,this.uniforms.contrast=this.contrast,this.uniforms.brightness=this.brightness,this.uniforms.red=this.red,this.uniforms.green=this.green,this.uniforms.blue=this.blue,this.uniforms.alpha=this.alpha,e.applyFilter(this,n,t,r)},n}(n.Filter),p=function(e){function n(n){void 0===n&&(n=.5);var t=e.call(this,c,"\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n")||this;return t.threshold=n,t}return u(n,e),Object.defineProperty(n.prototype,"threshold",{get:function(){return this.uniforms.threshold},set:function(e){this.uniforms.threshold=e},enumerable:!1,configurable:!0}),n}(n.Filter),d=function(e){function n(n,r,o){void 0===n&&(n=4),void 0===r&&(r=3),void 0===o&&(o=!1);var i=e.call(this,c,o?"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n":"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}")||this;return i._kernels=[],i._blur=4,i._quality=3,i.uniforms.uOffset=new Float32Array(2),i._pixelSize=new t.Point,i.pixelSize=1,i._clamp=o,Array.isArray(n)?i.kernels=n:(i._blur=n,i.quality=r),i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i=this._pixelSize.x/n._frame.width,l=this._pixelSize.y/n._frame.height;if(1===this._quality||0===this._blur)o=this._kernels[0]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,n,t,r);else{for(var a=e.getFilterTexture(),s=n,u=a,f=void 0,c=this._quality-1,m=0;m<c;m++)o=this._kernels[m]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,s,u,1),f=s,s=u,u=f;o=this._kernels[c]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,s,t,r),e.returnFilterTexture(a)}},n.prototype._updatePadding=function(){this.padding=Math.ceil(this._kernels.reduce((function(e,n){return e+n+.5}),0))},n.prototype._generateKernels=function(){var e=this._blur,n=this._quality,t=[e];if(e>0)for(var r=e,o=e/n,i=1;i<n;i++)r-=o,t.push(r);this._kernels=t,this._updatePadding()},Object.defineProperty(n.prototype,"kernels",{get:function(){return this._kernels},set:function(e){Array.isArray(e)&&e.length>0?(this._kernels=e,this._quality=e.length,this._blur=Math.max.apply(Math,e)):(this._kernels=[0],this._quality=1)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"clamp",{get:function(){return this._clamp},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"pixelSize",{get:function(){return this._pixelSize},set:function(e){"number"==typeof e?(this._pixelSize.x=e,this._pixelSize.y=e):Array.isArray(e)?(this._pixelSize.x=e[0],this._pixelSize.y=e[1]):e instanceof t.Point?(this._pixelSize.x=e.x,this._pixelSize.y=e.y):(this._pixelSize.x=1,this._pixelSize.y=1)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"quality",{get:function(){return this._quality},set:function(e){this._quality=Math.max(1,Math.round(e)),this._generateKernels()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blur",{get:function(){return this._blur},set:function(e){this._blur=e,this._generateKernels()},enumerable:!1,configurable:!0}),n}(n.Filter),h=function(e){function n(t){var o=e.call(this,c,"uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n")||this;o.bloomScale=1,o.brightness=1,o._resolution=r.settings.FILTER_RESOLUTION,"number"==typeof t&&(t={threshold:t});var i=Object.assign(n.defaults,t);o.bloomScale=i.bloomScale,o.brightness=i.brightness;var l=i.kernels,a=i.blur,s=i.quality,u=i.pixelSize,f=i.resolution;return o._extractFilter=new p(i.threshold),o._extractFilter.resolution=f,o._blurFilter=l?new d(l):new d(a,s),o.pixelSize=u,o.resolution=f,o}return u(n,e),n.prototype.apply=function(e,n,t,r,o){var i=e.getFilterTexture();this._extractFilter.apply(e,n,i,1,o);var l=e.getFilterTexture();this._blurFilter.apply(e,i,l,1),this.uniforms.bloomScale=this.bloomScale,this.uniforms.brightness=this.brightness,this.uniforms.bloomTexture=l,e.applyFilter(this,n,t,r),e.returnFilterTexture(l),e.returnFilterTexture(i)},Object.defineProperty(n.prototype,"resolution",{get:function(){return this._resolution},set:function(e){this._resolution=e,this._extractFilter&&(this._extractFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"threshold",{get:function(){return this._extractFilter.threshold},set:function(e){this._extractFilter.threshold=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"kernels",{get:function(){return this._blurFilter.kernels},set:function(e){this._blurFilter.kernels=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blur",{get:function(){return this._blurFilter.blur},set:function(e){this._blurFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"quality",{get:function(){return this._blurFilter.quality},set:function(e){this._blurFilter.quality=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"pixelSize",{get:function(){return this._blurFilter.pixelSize},set:function(e){this._blurFilter.pixelSize=e},enumerable:!1,configurable:!0}),n.defaults={threshold:.5,bloomScale:1,brightness:1,kernels:null,blur:8,quality:4,pixelSize:1,resolution:r.settings.FILTER_RESOLUTION},n}(n.Filter),g=function(e){function n(n){void 0===n&&(n=8);var t=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor( coord / size ) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod( coord , size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the rounded color..\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // determine the character to use\n    float gray = (color.r + color.g + color.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}\n")||this;return t.size=n,t}return u(n,e),Object.defineProperty(n.prototype,"size",{get:function(){return this.uniforms.pixelSize},set:function(e){this.uniforms.pixelSize=e},enumerable:!1,configurable:!0}),n}(n.Filter),v=function(e){function n(n){var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n")||this;return t._thickness=2,t._angle=0,t.uniforms.lightColor=new Float32Array(3),t.uniforms.shadowColor=new Float32Array(3),Object.assign(t,{rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7},n),t.padding=1,t}return u(n,e),n.prototype._updateTransform=function(){this.uniforms.transformX=this._thickness*Math.cos(this._angle),this.uniforms.transformY=this._thickness*Math.sin(this._angle)},Object.defineProperty(n.prototype,"rotation",{get:function(){return this._angle/t.DEG_TO_RAD},set:function(e){this._angle=e*t.DEG_TO_RAD,this._updateTransform()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"thickness",{get:function(){return this._thickness},set:function(e){this._thickness=e,this._updateTransform()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lightColor",{get:function(){return o.rgb2hex(this.uniforms.lightColor)},set:function(e){o.hex2rgb(e,this.uniforms.lightColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lightAlpha",{get:function(){return this.uniforms.lightAlpha},set:function(e){this.uniforms.lightAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"shadowColor",{get:function(){return o.rgb2hex(this.uniforms.shadowColor)},set:function(e){o.hex2rgb(e,this.uniforms.shadowColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"shadowAlpha",{get:function(){return this.uniforms.shadowAlpha},set:function(e){this.uniforms.shadowAlpha=e},enumerable:!1,configurable:!0}),n}(n.Filter),y=function(e){function n(n,o,s,u){void 0===n&&(n=2),void 0===o&&(o=4),void 0===s&&(s=r.settings.FILTER_RESOLUTION),void 0===u&&(u=5);var f,c,m=e.call(this)||this;return"number"==typeof n?(f=n,c=n):n instanceof t.Point?(f=n.x,c=n.y):Array.isArray(n)&&(f=n[0],c=n[1]),m.blurXFilter=new a.BlurFilterPass(!0,f,o,s,u),m.blurYFilter=new a.BlurFilterPass(!1,c,o,s,u),m.blurYFilter.blendMode=i.BLEND_MODES.SCREEN,m.defaultFilter=new l.AlphaFilter,m}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this.defaultFilter.apply(e,n,t,r),this.blurXFilter.apply(e,n,o,1),this.blurYFilter.apply(e,o,t,0),e.returnFilterTexture(o)},Object.defineProperty(n.prototype,"blur",{get:function(){return this.blurXFilter.blur},set:function(e){this.blurXFilter.blur=this.blurYFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blurX",{get:function(){return this.blurXFilter.blur},set:function(e){this.blurXFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blurY",{get:function(){return this.blurYFilter.blur},set:function(e){this.blurYFilter.blur=e},enumerable:!1,configurable:!0}),n}(n.Filter),b=function(e){function n(t){var r=e.call(this,c,"uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n")||this;return r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.strength},set:function(e){this.uniforms.strength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.center},set:function(e){this.uniforms.center=e},enumerable:!1,configurable:!0}),n.defaults={center:[.5,.5],radius:100,strength:1},n}(n.Filter),x=function(e){function t(n,t,r){void 0===t&&(t=!1),void 0===r&&(r=1);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}")||this;return o.mix=1,o._size=0,o._sliceSize=0,o._slicePixelSize=0,o._sliceInnerSize=0,o._nearest=!1,o._scaleMode=null,o._colorMap=null,o._scaleMode=null,o.nearest=t,o.mix=r,o.colorMap=n,o}return u(t,e),t.prototype.apply=function(e,n,t,r){this.uniforms._mix=this.mix,e.applyFilter(this,n,t,r)},Object.defineProperty(t.prototype,"colorSize",{get:function(){return this._size},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"colorMap",{get:function(){return this._colorMap},set:function(e){var t;e&&(e instanceof n.Texture||(e=n.Texture.from(e)),(null===(t=e)||void 0===t?void 0:t.baseTexture)&&(e.baseTexture.scaleMode=this._scaleMode,e.baseTexture.mipmap=i.MIPMAP_MODES.OFF,this._size=e.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms._size=this._size,this.uniforms._sliceSize=this._sliceSize,this.uniforms._slicePixelSize=this._slicePixelSize,this.uniforms._sliceInnerSize=this._sliceInnerSize,this.uniforms.colorMap=e),this._colorMap=e)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"nearest",{get:function(){return this._nearest},set:function(e){this._nearest=e,this._scaleMode=e?i.SCALE_MODES.NEAREST:i.SCALE_MODES.LINEAR;var n=this._colorMap;n&&n.baseTexture&&(n.baseTexture._glTextures={},n.baseTexture.scaleMode=this._scaleMode,n.baseTexture.mipmap=i.MIPMAP_MODES.OFF,n._updateID++,n.baseTexture.emit("update",n.baseTexture))},enumerable:!1,configurable:!0}),t.prototype.updateColorMap=function(){var e=this._colorMap;e&&e.baseTexture&&(e._updateID++,e.baseTexture.emit("update",e.baseTexture),this.colorMap=e)},t.prototype.destroy=function(n){void 0===n&&(n=!1),this._colorMap&&this._colorMap.destroy(n),e.prototype.destroy.call(this)},t}(n.Filter),_=function(e){function n(n,t){void 0===n&&(n=0),void 0===t&&(t=1);var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 color;\nuniform float alpha;\n\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(mix(currentColor.rgb, color.rgb, currentColor.a * alpha), currentColor.a);\n}\n")||this;return r._color=0,r._alpha=1,r.uniforms.color=new Float32Array(3),r.color=n,r.alpha=t,r}return u(n,e),Object.defineProperty(n.prototype,"color",{get:function(){return this._color},set:function(e){var n=this.uniforms.color;"number"==typeof e?(o.hex2rgb(e,n),this._color=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._color=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this._alpha},set:function(e){this.uniforms.alpha=e,this._alpha=e},enumerable:!1,configurable:!0}),n}(n.Filter),C=function(e){function n(n,t,r){void 0===n&&(n=16711680),void 0===t&&(t=0),void 0===r&&(r=.4);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n")||this;return o._originalColor=16711680,o._newColor=0,o.uniforms.originalColor=new Float32Array(3),o.uniforms.newColor=new Float32Array(3),o.originalColor=n,o.newColor=t,o.epsilon=r,o}return u(n,e),Object.defineProperty(n.prototype,"originalColor",{get:function(){return this._originalColor},set:function(e){var n=this.uniforms.originalColor;"number"==typeof e?(o.hex2rgb(e,n),this._originalColor=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._originalColor=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"newColor",{get:function(){return this._newColor},set:function(e){var n=this.uniforms.newColor;"number"==typeof e?(o.hex2rgb(e,n),this._newColor=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._newColor=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"epsilon",{get:function(){return this.uniforms.epsilon},set:function(e){this.uniforms.epsilon=e},enumerable:!1,configurable:!0}),n}(n.Filter),S=function(e){function n(n,t,r){void 0===t&&(t=200),void 0===r&&(r=200);var o=e.call(this,c,"precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n")||this;return o.uniforms.texelSize=new Float32Array(2),o.uniforms.matrix=new Float32Array(9),void 0!==n&&(o.matrix=n),o.width=t,o.height=r,o}return u(n,e),Object.defineProperty(n.prototype,"matrix",{get:function(){return this.uniforms.matrix},set:function(e){var n=this;e.forEach((function(e,t){n.uniforms.matrix[t]=e}))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"width",{get:function(){return 1/this.uniforms.texelSize[0]},set:function(e){this.uniforms.texelSize[0]=1/e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"height",{get:function(){return 1/this.uniforms.texelSize[1]},set:function(e){this.uniforms.texelSize[1]=1/e},enumerable:!1,configurable:!0}),n}(n.Filter),F=function(e){function n(){return e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n")||this}return u(n,e),n}(n.Filter),z=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n")||this;return r.time=0,r.seed=0,r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.seed=this.seed,this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"curvature",{get:function(){return this.uniforms.curvature},set:function(e){this.uniforms.curvature=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lineWidth",{get:function(){return this.uniforms.lineWidth},set:function(e){this.uniforms.lineWidth=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lineContrast",{get:function(){return this.uniforms.lineContrast},set:function(e){this.uniforms.lineContrast=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"verticalLine",{get:function(){return this.uniforms.verticalLine},set:function(e){this.uniforms.verticalLine=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noise",{get:function(){return this.uniforms.noise},set:function(e){this.uniforms.noise=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noiseSize",{get:function(){return this.uniforms.noiseSize},set:function(e){this.uniforms.noiseSize=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignetting",{get:function(){return this.uniforms.vignetting},set:function(e){this.uniforms.vignetting=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingAlpha",{get:function(){return this.uniforms.vignettingAlpha},set:function(e){this.uniforms.vignettingAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingBlur",{get:function(){return this.uniforms.vignettingBlur},set:function(e){this.uniforms.vignettingBlur=e},enumerable:!1,configurable:!0}),n.defaults={curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,seed:0,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0},n}(n.Filter),O=function(e){function n(n,t){void 0===n&&(n=1),void 0===t&&(t=5);var r=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n")||this;return r.scale=n,r.angle=t,r}return u(n,e),Object.defineProperty(n.prototype,"scale",{get:function(){return this.uniforms.scale},set:function(e){this.uniforms.scale=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"angle",{get:function(){return this.uniforms.angle},set:function(e){this.uniforms.angle=e},enumerable:!1,configurable:!0}),n}(n.Filter),P=function(e){function i(o){var l=e.call(this)||this;l.angle=45,l._distance=5,l._resolution=r.settings.FILTER_RESOLUTION;var a=o?f(f({},i.defaults),o):i.defaults,s=a.kernels,u=a.blur,m=a.quality,p=a.pixelSize,h=a.resolution;l._tintFilter=new n.Filter(c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}"),l._tintFilter.uniforms.color=new Float32Array(4),l._tintFilter.uniforms.shift=new t.Point,l._tintFilter.resolution=h,l._blurFilter=s?new d(s):new d(u,m),l.pixelSize=p,l.resolution=h;var g=a.shadowOnly,v=a.rotation,y=a.distance,b=a.alpha,x=a.color;return l.shadowOnly=g,l.rotation=v,l.distance=y,l.alpha=b,l.color=x,l._updatePadding(),l}return u(i,e),i.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this._tintFilter.apply(e,n,o,1),this._blurFilter.apply(e,o,t,r),!0!==this.shadowOnly&&e.applyFilter(this,n,t,0),e.returnFilterTexture(o)},i.prototype._updatePadding=function(){this.padding=this.distance+2*this.blur},i.prototype._updateShift=function(){this._tintFilter.uniforms.shift.set(this.distance*Math.cos(this.angle),this.distance*Math.sin(this.angle))},Object.defineProperty(i.prototype,"resolution",{get:function(){return this._resolution},set:function(e){this._resolution=e,this._tintFilter&&(this._tintFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"distance",{get:function(){return this._distance},set:function(e){this._distance=e,this._updatePadding(),this._updateShift()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"rotation",{get:function(){return this.angle/t.DEG_TO_RAD},set:function(e){this.angle=e*t.DEG_TO_RAD,this._updateShift()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"alpha",{get:function(){return this._tintFilter.uniforms.alpha},set:function(e){this._tintFilter.uniforms.alpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"color",{get:function(){return o.rgb2hex(this._tintFilter.uniforms.color)},set:function(e){o.hex2rgb(e,this._tintFilter.uniforms.color)},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"kernels",{get:function(){return this._blurFilter.kernels},set:function(e){this._blurFilter.kernels=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"blur",{get:function(){return this._blurFilter.blur},set:function(e){this._blurFilter.blur=e,this._updatePadding()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"quality",{get:function(){return this._blurFilter.quality},set:function(e){this._blurFilter.quality=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"pixelSize",{get:function(){return this._blurFilter.pixelSize},set:function(e){this._blurFilter.pixelSize=e},enumerable:!1,configurable:!0}),i.defaults={rotation:45,distance:5,color:0,alpha:.5,shadowOnly:!1,kernels:null,blur:2,quality:3,pixelSize:1,resolution:r.settings.FILTER_RESOLUTION},i}(n.Filter),A=function(e){function n(n){void 0===n&&(n=5);var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n\tvec2 onePixel = vec2(1.0 / filterArea);\n\n\tvec4 color;\n\n\tcolor.rgb = vec3(0.5);\n\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\n\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n")||this;return t.strength=n,t}return u(n,e),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.strength},set:function(e){this.uniforms.strength=e},enumerable:!1,configurable:!0}),n}(n.Filter),T=function(e){function r(t){var o=e.call(this,c,"// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n")||this;return o.offset=100,o.fillMode=r.TRANSPARENT,o.average=!1,o.seed=0,o.minSize=8,o.sampleSize=512,o._slices=0,o._offsets=new Float32Array(1),o._sizes=new Float32Array(1),o._direction=-1,o.uniforms.dimensions=new Float32Array(2),o._canvas=document.createElement("canvas"),o._canvas.width=4,o._canvas.height=o.sampleSize,o.texture=n.Texture.from(o._canvas,{scaleMode:i.SCALE_MODES.NEAREST}),Object.assign(o,r.defaults,t),o}return u(r,e),r.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.aspect=l/i,this.uniforms.seed=this.seed,this.uniforms.offset=this.offset,this.uniforms.fillMode=this.fillMode,e.applyFilter(this,n,t,r)},r.prototype._randomizeSizes=function(){var e=this._sizes,n=this._slices-1,t=this.sampleSize,r=Math.min(this.minSize/t,.9/this._slices);if(this.average){for(var o=this._slices,i=1,l=0;l<n;l++){var a=i/(o-l),s=Math.max(a*(1-.6*Math.random()),r);e[l]=s,i-=s}e[n]=i}else{i=1;var u=Math.sqrt(1/this._slices);for(l=0;l<n;l++){s=Math.max(u*i*Math.random(),r);e[l]=s,i-=s}e[n]=i}this.shuffle()},r.prototype.shuffle=function(){for(var e=this._sizes,n=this._slices-1;n>0;n--){var t=Math.random()*n>>0,r=e[n];e[n]=e[t],e[t]=r}},r.prototype._randomizeOffsets=function(){for(var e=0;e<this._slices;e++)this._offsets[e]=Math.random()*(Math.random()<.5?-1:1)},r.prototype.refresh=function(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()},r.prototype.redraw=function(){var e,n=this.sampleSize,t=this.texture,r=this._canvas.getContext("2d");r.clearRect(0,0,8,n);for(var o=0,i=0;i<this._slices;i++){e=Math.floor(256*this._offsets[i]);var l=this._sizes[i]*n,a=e>0?e:0,s=e<0?-e:0;r.fillStyle="rgba("+a+", "+s+", 0, 1)",r.fillRect(0,o>>0,n,l+1>>0),o+=l}t.baseTexture.update(),this.uniforms.displacementMap=t},Object.defineProperty(r.prototype,"sizes",{get:function(){return this._sizes},set:function(e){for(var n=Math.min(this._slices,e.length),t=0;t<n;t++)this._sizes[t]=e[t]},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"offsets",{get:function(){return this._offsets},set:function(e){for(var n=Math.min(this._slices,e.length),t=0;t<n;t++)this._offsets[t]=e[t]},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"slices",{get:function(){return this._slices},set:function(e){this._slices!==e&&(this._slices=e,this.uniforms.slices=e,this._sizes=this.uniforms.slicesWidth=new Float32Array(e),this._offsets=this.uniforms.slicesOffset=new Float32Array(e),this.refresh())},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"direction",{get:function(){return this._direction},set:function(e){if(this._direction!==e){this._direction=e;var n=e*t.DEG_TO_RAD;this.uniforms.sinDir=Math.sin(n),this.uniforms.cosDir=Math.cos(n)}},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"red",{get:function(){return this.uniforms.red},set:function(e){this.uniforms.red=e},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"green",{get:function(){return this.uniforms.green},set:function(e){this.uniforms.green=e},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"blue",{get:function(){return this.uniforms.blue},set:function(e){this.uniforms.blue=e},enumerable:!1,configurable:!0}),r.prototype.destroy=function(){var e;null===(e=this.texture)||void 0===e||e.destroy(!0),this.texture=this._canvas=this.red=this.green=this.blue=this._sizes=this._offsets=null},r.defaults={slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:[0,0],green:[0,0],blue:[0,0],minSize:8,sampleSize:512},r.TRANSPARENT=0,r.ORIGINAL=1,r.LOOP=2,r.CLAMP=3,r.MIRROR=4,r}(n.Filter),w=function(e){function n(t){var r=this,o=Object.assign({},n.defaults,t),i=o.outerStrength,l=o.innerStrength,a=o.color,s=o.knockout,u=o.quality,f=Math.round(o.distance);return(r=e.call(this,c,"varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n    \n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n".replace(/__ANGLE_STEP_SIZE__/gi,""+(1/u/f).toFixed(7)).replace(/__DIST__/gi,f.toFixed(0)+".0"))||this).uniforms.glowColor=new Float32Array([0,0,0,1]),Object.assign(r,{color:a,outerStrength:i,innerStrength:l,padding:f,knockout:s}),r}return u(n,e),Object.defineProperty(n.prototype,"color",{get:function(){return o.rgb2hex(this.uniforms.glowColor)},set:function(e){o.hex2rgb(e,this.uniforms.glowColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"outerStrength",{get:function(){return this.uniforms.outerStrength},set:function(e){this.uniforms.outerStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"innerStrength",{get:function(){return this.uniforms.innerStrength},set:function(e){this.uniforms.innerStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"knockout",{get:function(){return this.uniforms.knockout},set:function(e){this.uniforms.knockout=e},enumerable:!1,configurable:!0}),n.defaults={distance:10,outerStrength:4,innerStrength:0,color:16777215,quality:.1,knockout:!1},n}(n.Filter),D=function(e){function n(r){var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\nuniform float alpha;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n\n}\n".replace("${perlin}","vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n"))||this;o.parallel=!0,o.time=0,o._angle=0,o.uniforms.dimensions=new Float32Array(2);var i=Object.assign(n.defaults,r);return o._angleLight=new t.Point,o.angle=i.angle,o.gain=i.gain,o.lacunarity=i.lacunarity,o.alpha=i.alpha,o.parallel=i.parallel,o.center=i.center,o.time=i.time,o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.light=this.parallel?this._angleLight:this.center,this.uniforms.parallel=this.parallel,this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.aspect=l/i,this.uniforms.time=this.time,this.uniforms.alpha=this.alpha,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"angle",{get:function(){return this._angle},set:function(e){this._angle=e;var n=e*t.DEG_TO_RAD;this._angleLight.x=Math.cos(n),this._angleLight.y=Math.sin(n)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gain",{get:function(){return this.uniforms.gain},set:function(e){this.uniforms.gain=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lacunarity",{get:function(){return this.uniforms.lacunarity},set:function(e){this.uniforms.lacunarity=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.alpha},set:function(e){this.uniforms.alpha=e},enumerable:!1,configurable:!0}),n.defaults={angle:30,gain:.5,lacunarity:2.5,time:0,parallel:!0,center:[0,0],alpha:1},n}(n.Filter),j=function(e){function n(n,r,o){void 0===n&&(n=[0,0]),void 0===r&&(r=5),void 0===o&&(o=0);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n")||this;return i.kernelSize=5,i.uniforms.uVelocity=new Float32Array(2),i._velocity=new t.ObservablePoint(i.velocityChanged,i),i.setVelocity(n),i.kernelSize=r,i.offset=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=this.velocity,i=o.x,l=o.y;this.uniforms.uKernelSize=0!==i||0!==l?this.kernelSize:0,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"velocity",{get:function(){return this._velocity},set:function(e){this.setVelocity(e)},enumerable:!1,configurable:!0}),n.prototype.setVelocity=function(e){if(Array.isArray(e)){var n=e[0],t=e[1];this._velocity.set(n,t)}else this._velocity.copyFrom(e)},n.prototype.velocityChanged=function(){this.uniforms.uVelocity[0]=this._velocity.x,this.uniforms.uVelocity[1]=this._velocity.y,this.padding=1+(Math.max(Math.abs(this._velocity.x),Math.abs(this._velocity.y))>>0)},Object.defineProperty(n.prototype,"offset",{get:function(){return this.uniforms.uOffset},set:function(e){this.uniforms.uOffset=e},enumerable:!1,configurable:!0}),n}(n.Filter),M=function(e){function n(n,t,r){void 0===t&&(t=.05),void 0===r&&(r=n.length);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n".replace(/%maxColors%/g,r.toFixed(0)))||this;return o._replacements=[],o._maxColors=0,o.epsilon=t,o._maxColors=r,o.uniforms.originalColors=new Float32Array(3*r),o.uniforms.targetColors=new Float32Array(3*r),o.replacements=n,o}return u(n,e),Object.defineProperty(n.prototype,"replacements",{get:function(){return this._replacements},set:function(e){var n=this.uniforms.originalColors,t=this.uniforms.targetColors,r=e.length;if(r>this._maxColors)throw new Error("Length of replacements ("+r+") exceeds the maximum colors length ("+this._maxColors+")");n[3*r]=-1;for(var i=0;i<r;i++){var l=e[i],a=l[0];"number"==typeof a?a=o.hex2rgb(a):l[0]=o.rgb2hex(a),n[3*i]=a[0],n[3*i+1]=a[1],n[3*i+2]=a[2];var s=l[1];"number"==typeof s?s=o.hex2rgb(s):l[1]=o.rgb2hex(s),t[3*i]=s[0],t[3*i+1]=s[1],t[3*i+2]=s[2]}this._replacements=e},enumerable:!1,configurable:!0}),n.prototype.refresh=function(){this.replacements=this._replacements},Object.defineProperty(n.prototype,"maxColors",{get:function(){return this._maxColors},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"epsilon",{get:function(){return this.uniforms.epsilon},set:function(e){this.uniforms.epsilon=e},enumerable:!1,configurable:!0}),n}(n.Filter),R=function(e){function n(t,r){void 0===r&&(r=0);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n")||this;return o.seed=0,o.uniforms.dimensions=new Float32Array(2),"number"==typeof t?(o.seed=t,t=void 0):o.seed=r,Object.assign(o,n.defaults,t),o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,this.uniforms.seed=this.seed,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"sepia",{get:function(){return this.uniforms.sepia},set:function(e){this.uniforms.sepia=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noise",{get:function(){return this.uniforms.noise},set:function(e){this.uniforms.noise=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noiseSize",{get:function(){return this.uniforms.noiseSize},set:function(e){this.uniforms.noiseSize=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratch",{get:function(){return this.uniforms.scratch},set:function(e){this.uniforms.scratch=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratchDensity",{get:function(){return this.uniforms.scratchDensity},set:function(e){this.uniforms.scratchDensity=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratchWidth",{get:function(){return this.uniforms.scratchWidth},set:function(e){this.uniforms.scratchWidth=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignetting",{get:function(){return this.uniforms.vignetting},set:function(e){this.uniforms.vignetting=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingAlpha",{get:function(){return this.uniforms.vignettingAlpha},set:function(e){this.uniforms.vignettingAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingBlur",{get:function(){return this.uniforms.vignettingBlur},set:function(e){this.uniforms.vignettingBlur=e},enumerable:!1,configurable:!0}),n.defaults={sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3},n}(n.Filter),E=function(e){function n(t,r,o){void 0===t&&(t=1),void 0===r&&(r=0),void 0===o&&(o=.1);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 thickness;\nuniform vec4 outlineColor;\nuniform vec4 filterClamp;\n\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\n\nvoid main(void) {\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float maxAlpha = 0.;\n    vec2 displaced;\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, curColor.a);\n    }\n    float resultAlpha = max(maxAlpha, ownColor.a);\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\n}\n".replace(/\$\{angleStep\}/,n.getAngleStep(o)))||this;return i._thickness=1,i.uniforms.thickness=new Float32Array([0,0]),i.uniforms.outlineColor=new Float32Array([0,0,0,1]),Object.assign(i,{thickness:t,color:r,quality:o}),i}return u(n,e),n.getAngleStep=function(e){var t=Math.max(e*n.MAX_SAMPLES,n.MIN_SAMPLES);return(2*Math.PI/t).toFixed(7)},n.prototype.apply=function(e,n,t,r){this.uniforms.thickness[0]=this._thickness/n._frame.width,this.uniforms.thickness[1]=this._thickness/n._frame.height,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"color",{get:function(){return o.rgb2hex(this.uniforms.outlineColor)},set:function(e){o.hex2rgb(e,this.uniforms.outlineColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"thickness",{get:function(){return this._thickness},set:function(e){this._thickness=e,this.padding=e},enumerable:!1,configurable:!0}),n.MIN_SAMPLES=1,n.MAX_SAMPLES=100,n}(n.Filter),I=function(e){function n(n){void 0===n&&(n=10);var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n")||this;return t.size=n,t}return u(n,e),Object.defineProperty(n.prototype,"size",{get:function(){return this.uniforms.size},set:function(e){"number"==typeof e&&(e=[e,e]),this.uniforms.size=e},enumerable:!1,configurable:!0}),n}(n.Filter),k=function(e){function n(n,t,r,o){void 0===n&&(n=0),void 0===t&&(t=[0,0]),void 0===r&&(r=5),void 0===o&&(o=-1);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n")||this;return i._angle=0,i.angle=n,i.center=t,i.kernelSize=r,i.radius=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"angle",{get:function(){return this._angle},set:function(e){this._angle=e,this.uniforms.uRadian=e*Math.PI/180},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.uCenter},set:function(e){this.uniforms.uCenter=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.uRadius},set:function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},enumerable:!1,configurable:!0}),n}(n.Filter),L=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n")||this;return r.time=0,r.uniforms.amplitude=new Float32Array(2),r.uniforms.waveLength=new Float32Array(2),r.uniforms.alpha=new Float32Array(2),r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"mirror",{get:function(){return this.uniforms.mirror},set:function(e){this.uniforms.mirror=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"boundary",{get:function(){return this.uniforms.boundary},set:function(e){this.uniforms.boundary=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"amplitude",{get:function(){return this.uniforms.amplitude},set:function(e){this.uniforms.amplitude[0]=e[0],this.uniforms.amplitude[1]=e[1]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"waveLength",{get:function(){return this.uniforms.waveLength},set:function(e){this.uniforms.waveLength[0]=e[0],this.uniforms.waveLength[1]=e[1]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.alpha},set:function(e){this.uniforms.alpha[0]=e[0],this.uniforms.alpha[1]=e[1]},enumerable:!1,configurable:!0}),n.defaults={mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0},n}(n.Filter),N=function(e){function n(n,t,r){void 0===n&&(n=[-10,0]),void 0===t&&(t=[0,10]),void 0===r&&(r=[0,0]);var o=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n")||this;return o.red=n,o.green=t,o.blue=r,o}return u(n,e),Object.defineProperty(n.prototype,"red",{get:function(){return this.uniforms.red},set:function(e){this.uniforms.red=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"green",{get:function(){return this.uniforms.green},set:function(e){this.uniforms.green=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blue",{get:function(){return this.uniforms.blue},set:function(e){this.uniforms.blue=e},enumerable:!1,configurable:!0}),n}(n.Filter),X=function(e){function n(t,r,o){void 0===t&&(t=[0,0]),void 0===o&&(o=0);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n")||this;return i.center=t,Object.assign(i,n.defaults,r),i.time=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.center},set:function(e){this.uniforms.center=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"amplitude",{get:function(){return this.uniforms.amplitude},set:function(e){this.uniforms.amplitude=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"wavelength",{get:function(){return this.uniforms.wavelength},set:function(e){this.uniforms.wavelength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"brightness",{get:function(){return this.uniforms.brightness},set:function(e){this.uniforms.brightness=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"speed",{get:function(){return this.uniforms.speed},set:function(e){this.uniforms.speed=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),n.defaults={amplitude:30,wavelength:160,brightness:1,speed:500,radius:-1},n}(n.Filter),B=function(e){function n(n,t,r){void 0===t&&(t=0),void 0===r&&(r=1);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n")||this;return o._color=0,o.uniforms.dimensions=new Float32Array(2),o.uniforms.ambientColor=new Float32Array([0,0,0,r]),o.texture=n,o.color=t,o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"texture",{get:function(){return this.uniforms.uLightmap},set:function(e){this.uniforms.uLightmap=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"color",{get:function(){return this._color},set:function(e){var n=this.uniforms.ambientColor;"number"==typeof e?(o.hex2rgb(e,n),this._color=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],this._color=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.ambientColor[3]},set:function(e){this.uniforms.ambientColor[3]=e},enumerable:!1,configurable:!0}),n}(n.Filter),G=function(e){function n(n,r,o,i){void 0===n&&(n=100),void 0===r&&(r=600);var l=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n")||this;return l.uniforms.blur=n,l.uniforms.gradientBlur=r,l.uniforms.start=o||new t.Point(0,window.innerHeight/2),l.uniforms.end=i||new t.Point(600,window.innerHeight/2),l.uniforms.delta=new t.Point(30,30),l.uniforms.texSize=new t.Point(window.innerWidth,window.innerHeight),l.updateDelta(),l}return u(n,e),n.prototype.updateDelta=function(){this.uniforms.delta.x=0,this.uniforms.delta.y=0},Object.defineProperty(n.prototype,"blur",{get:function(){return this.uniforms.blur},set:function(e){this.uniforms.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gradientBlur",{get:function(){return this.uniforms.gradientBlur},set:function(e){this.uniforms.gradientBlur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"start",{get:function(){return this.uniforms.start},set:function(e){this.uniforms.start=e,this.updateDelta()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"end",{get:function(){return this.uniforms.end},set:function(e){this.uniforms.end=e,this.updateDelta()},enumerable:!1,configurable:!0}),n}(n.Filter),K=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return u(n,e),n.prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,n=this.uniforms.end.y-this.uniforms.start.y,t=Math.sqrt(e*e+n*n);this.uniforms.delta.x=e/t,this.uniforms.delta.y=n/t},n}(G),q=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return u(n,e),n.prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,n=this.uniforms.end.y-this.uniforms.start.y,t=Math.sqrt(e*e+n*n);this.uniforms.delta.x=-n/t,this.uniforms.delta.y=e/t},n}(G),W=function(e){function n(n,t,r,o){void 0===n&&(n=100),void 0===t&&(t=600);var i=e.call(this)||this;return i.tiltShiftXFilter=new K(n,t,r,o),i.tiltShiftYFilter=new q(n,t,r,o),i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this.tiltShiftXFilter.apply(e,n,o,1),this.tiltShiftYFilter.apply(e,o,t,r),e.returnFilterTexture(o)},Object.defineProperty(n.prototype,"blur",{get:function(){return this.tiltShiftXFilter.blur},set:function(e){this.tiltShiftXFilter.blur=this.tiltShiftYFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gradientBlur",{get:function(){return this.tiltShiftXFilter.gradientBlur},set:function(e){this.tiltShiftXFilter.gradientBlur=this.tiltShiftYFilter.gradientBlur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"start",{get:function(){return this.tiltShiftXFilter.start},set:function(e){this.tiltShiftXFilter.start=this.tiltShiftYFilter.start=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"end",{get:function(){return this.tiltShiftXFilter.end},set:function(e){this.tiltShiftXFilter.end=this.tiltShiftYFilter.end=e},enumerable:!1,configurable:!0}),n}(n.Filter),Y=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n")||this;return Object.assign(r,n.defaults,t),r}return u(n,e),Object.defineProperty(n.prototype,"offset",{get:function(){return this.uniforms.offset},set:function(e){this.uniforms.offset=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"angle",{get:function(){return this.uniforms.angle},set:function(e){this.uniforms.angle=e},enumerable:!1,configurable:!0}),n.defaults={radius:200,angle:4,padding:20,offset:new t.Point},n}(n.Filter),Z=function(e){function n(t){var r,o=Object.assign(n.defaults,t),i=o.maxKernelSize,l=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&n.indexOf(r)<0&&(t[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(e);o<r.length;o++)n.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(e,r[o])&&(t[r[o]]=e[r[o]])}return t}(o,["maxKernelSize"]);return r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = ${maxKernelSize};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n".replace("${maxKernelSize}",i.toFixed(1)))||this,Object.assign(r,l),r}return u(n,e),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.uCenter},set:function(e){this.uniforms.uCenter=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.uStrength},set:function(e){this.uniforms.uStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"innerRadius",{get:function(){return this.uniforms.uInnerRadius},set:function(e){this.uniforms.uInnerRadius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.uRadius},set:function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},enumerable:!1,configurable:!0}),n.defaults={strength:.1,center:[0,0],innerRadius:0,radius:-1,maxKernelSize:32},n}(n.Filter);return e.AdjustmentFilter=m,e.AdvancedBloomFilter=h,e.AsciiFilter=g,e.BevelFilter=v,e.BloomFilter=y,e.BulgePinchFilter=b,e.CRTFilter=z,e.ColorMapFilter=x,e.ColorOverlayFilter=_,e.ColorReplaceFilter=C,e.ConvolutionFilter=S,e.CrossHatchFilter=F,e.DotFilter=O,e.DropShadowFilter=P,e.EmbossFilter=A,e.GlitchFilter=T,e.GlowFilter=w,e.GodrayFilter=D,e.KawaseBlurFilter=d,e.MotionBlurFilter=j,e.MultiColorReplaceFilter=M,e.OldFilmFilter=R,e.OutlineFilter=E,e.PixelateFilter=I,e.RGBSplitFilter=N,e.RadialBlurFilter=k,e.ReflectionFilter=L,e.ShockwaveFilter=X,e.SimpleLightmapFilter=B,e.TiltShiftAxisFilter=G,e.TiltShiftFilter=W,e.TiltShiftXFilter=K,e.TiltShiftYFilter=q,e.TwistFilter=Y,e.ZoomBlurFilter=Z,Object.defineProperty(e,"__esModule",{value:!0}),e}({},PIXI,PIXI,PIXI,PIXI.utils,PIXI,PIXI.filters,PIXI.filters);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=pixi-filters.js.map


// Generated by CoffeeScript 2.6.1
// ==========================================================================
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ KDCore.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
// * LIBRARY WITH MZ AND MZ SUPPORT
//! {OUTER FILE}

//?rev 18.06.24
var KDCore;

window.Imported = window.Imported || {};

Imported.KDCore = true;

KDCore = KDCore || {};

// * Двузначные числа нельзя в версии, сравнение идёт по первой цифре поулчается (3.43 - нельзя, можно 3.4.3)
//%[МЕНЯТЬ ПРИ ИЗМЕНЕНИИ]
KDCore._fileVersion = '3.5.4';

KDCore.nuiVersion = '1.1.0';

// * Методы и библиотеки данной версии
KDCore._loader = 'loader_' + KDCore._fileVersion;

KDCore[KDCore._loader] = [];

// * Добавить библиотеку на загрузку
KDCore.registerLibraryToLoad = function(lib) {
  return KDCore[KDCore._loader].push(lib);
};

if ((KDCore.Version != null) && KDCore.Version >= KDCore._fileVersion) {
  // * ПРОПУСКАЕМ ЗАГРУЗКУ, так как уже загруженна более новая
  console.log('XDev KDCore ' + KDCore._fileVersion + ' skipped by new or exists version');
  KDCore._requireLoadLibrary = false;
} else {
  KDCore.Version = KDCore._fileVersion;
  KDCore.LIBS = KDCore.LIBS || {};
  KDCore.register = function(library) {
    return this.LIBS[library.name] = library;
  };
  window.KDCore = KDCore;
  // * ТРЕБУЕТСЯ ЗАГРУЗКА БИБЛИОТЕК
  KDCore._requireLoadLibrary = true;
}


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  Array.prototype.delete = function() {
    var L, a, ax, what;
    what = void 0;
    a = arguments;
    L = a.length;
    ax = void 0;
    while (L && this.length) {
      what = a[--L];
      while ((ax = this.indexOf(what)) !== -1) {
        this.splice(ax, 1);
      }
    }
    return this;
  };
  Array.prototype.max = function() {
    return Math.max.apply(null, this);
  };
  Array.prototype.min = function() {
    return Math.min.apply(null, this);
  };
  Array.prototype.sample = function() {
    if (this.length === 0) {
      return [];
    }
    return this[KDCore.SDK.rand(0, this.length - 1)];
  };
  Array.prototype.first = function() {
    return this[0];
  };
  Array.prototype.last = function() {
    return this[this.length - 1];
  };
  Array.prototype.shuffle = function() {
    var k, n, v;
    n = this.length;
    while (n > 1) {
      n--;
      k = KDCore.SDK.rand(0, n + 1);
      v = this[k];
      this[k] = this[n];
      this[n] = v;
    }
  };
  Array.prototype.count = function() {
    return this.length;
  };
  Array.prototype.isEmpty = function() {
    return this.length === 0;
  };
  // * Ищет элемент, у которого поле ID == id
  Array.prototype.getById = function(id) {
    return this.getByField('id', id);
  };
  // * Ищет элемент, у которого поле FIELD (имя поля) == value
  Array.prototype.getByField = function(field, value) {
    var e;
    try {
      return this.find(function(item) {
        return item[field] === value;
      });
    } catch (error) {
      e = error;
      console.warn(e);
      return null;
    }
  };
  Object.defineProperty(Array.prototype, "delete", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "max", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "min", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "sample", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "first", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "last", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "shuffle", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "count", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "isEmpty", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "getById", {
    enumerable: false
  });
  return Object.defineProperty(Array.prototype, "getByField", {
    enumerable: false
  });
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  Number.prototype.do = function(method) {
    return KDCore.SDK.times(this, method);
  };
  Number.prototype.clamp = function(min, max) {
    return Math.min(Math.max(this, min), max);
  };
  return Number.prototype.any = function(number) {
    return (number != null) && typeof number === 'number' && number > 0;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  String.prototype.toCss = function() {
    return KDCore.Color.FromHex(this).CSS;
  };
  String.prototype.toCSS = function() {
    return this.toCss();
  };
  String.prototype.isEmpty = function() {
    return this.length === 0 || !this.trim();
  };
  String.isNullOrEmpty = function(str) {
    if (str != null) {
      return str.toString().isEmpty();
    } else {
      return true;
    }
  };
  String.any = function(str) {
    return !String.isNullOrEmpty(str);
  };
  return String.prototype.replaceAll = function(search, replacement) {
    var target;
    target = this;
    return target.split(search).join(replacement);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  KDCore.isMV = function() {
    return Utils.RPGMAKER_NAME.contains("MV");
  };
  KDCore.isMZ = function() {
    return !KDCore.isMV();
  };
  KDCore.warning = function(msg, error) {
    if (msg != null) {
      console.warn(msg);
    }
    if (error != null) {
      console.warn(error);
    }
  };
  KDCore.makeid = function(length) {
    var characters, charactersLength, i, result;
    result = '';
    characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    charactersLength = characters.length;
    i = 0;
    while (i < length) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
      i++;
    }
    return result;
  };
  return KDCore.makeId = function() {
    return KDCore.makeid(...arguments);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var SDK;
  //?[DEPRECATED]
  // * SDK
  //------------------------------------------------------------------------------
  SDK = function() {
    throw new Error('This is a static class');
  };
  SDK.rand = function(min, max) {
    return Math.round(Math.random() * (max - min)) + min;
  };
  SDK.setConstantToObject = function(object, constantName, constantValue) {
    object[constantName] = constantValue;
    if (typeof object[constantName] === 'object') {
      Object.freeze(object[constantName]);
    }
    Object.defineProperty(object, constantName, {
      writable: false
    });
  };
  SDK.convertBitmapToBase64Data = function(bitmap) {
    return bitmap._canvas.toDataURL('image/png');
  };
  SDK.times = function(times, method) {
    var i, results;
    i = 0;
    results = [];
    while (i < times) {
      method(i);
      results.push(i++);
    }
    return results;
  };
  SDK.toGlobalCoord = function(layer, coordSymbol = 'x') {
    var node, t;
    t = layer[coordSymbol];
    node = layer;
    while (node) {
      t -= node[coordSymbol];
      node = node.parent;
    }
    return (t * -1) + layer[coordSymbol];
  };
  SDK.canvasToLocalX = function(layer, x) {
    while (layer) {
      x -= layer.x;
      layer = layer.parent;
    }
    return x;
  };
  SDK.canvasToLocalY = function(layer, y) {
    while (layer) {
      y -= layer.y;
      layer = layer.parent;
    }
    return y;
  };
  SDK.isInt = function(n) {
    return Number(n) === n && n % 1 === 0;
  };
  SDK.isFloat = function(n) {
    return Number(n) === n && n % 1 !== 0;
  };
  SDK.checkSwitch = function(switchValue) {
    if (switchValue === 'A' || switchValue === 'B' || switchValue === 'C' || switchValue === 'D') {
      return true;
    }
    return false;
  };
  SDK.toNumber = function(string, none = 0) {
    var number;
    if (string == null) {
      return none;
    }
    number = Number(string);
    if (isNaN(number)) {
      return none;
    }
    return number;
  };
  SDK.isString = function(value) {
    return typeof value === "string";
  };
  SDK.isArray = function(value) {
    return Array.isArray(value);
  };
  //@[EXTEND]
  return KDCore.SDK = SDK;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var __alias_Bitmap_blt_kdCore, __alias_Bitmap_fillAll_kdCore;
  //@[ALIAS]
  __alias_Bitmap_fillAll_kdCore = Bitmap.prototype.fillAll;
  Bitmap.prototype.fillAll = function(color) {
    if (color instanceof KDCore.Color) {
      return this.fillRect(0, 0, this.width, this.height, color.CSS);
    } else {
      return __alias_Bitmap_fillAll_kdCore.call(this, color);
    }
  };
  //@[ALIAS]
  __alias_Bitmap_blt_kdCore = Bitmap.prototype.blt;
  Bitmap.prototype.blt = function(source, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (this._needModBltDWH > 0) {
      dh = dw = this._needModBltDWH;
      __alias_Bitmap_blt_kdCore.call(this, source, sx, sy, sw, sh, dx, dy, dw, dh);
      this._needModBltDWH = null;
    } else {
      __alias_Bitmap_blt_kdCore.call(this, ...arguments);
    }
  };
  Bitmap.prototype.drawIcon = function(x, y, icon, size = 32, noSmoth = false) {
    var bitmap;
    bitmap = null;
    if (icon instanceof Bitmap) {
      bitmap = icon;
    } else {
      bitmap = KDCore.BitmapSrc.LoadFromIconIndex(icon).bitmap;
    }
    this._context.imageSmoothingEnabled = !noSmoth;
    this.drawOnMe(bitmap, x, y, size, size);
    this._context.imageSmoothingEnabled = true;
  };
  Bitmap.prototype.drawOnMe = function(bitmap, x = 0, y = 0, sw = 0, sh = 0) {
    if (sw <= 0) {
      sw = bitmap.width;
    }
    if (sh <= 0) {
      sh = bitmap.height;
    }
    this.blt(bitmap, 0, 0, bitmap.width, bitmap.height, x, y, sw, sh);
  };
  Bitmap.prototype.drawInMe = function(bitmap) {
    return Bitmap.prototype.drawOnMe(bitmap, 0, 0, this.width, this.height);
  };
  return Bitmap.prototype.drawTextFull = function(text, position = 'center') {
    return this.drawText(text, 0, 0, this.width, this.height, position);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  KDCore.EasingFuncs = KDCore.EasingFuncs || {};
  return (function() {
    var _;
    _ = KDCore.EasingFuncs;
    _.linear = function(t, b, c, d) {
      return c * t / d + b;
    };
    _.easeInQuad = function(t, b, c, d) {
      return c * (t /= d) * t + b;
    };
    _.easeOutQuad = function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    };
    _.easeInOutQuad = function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      } else {
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
      }
    };
    _.easeInCubic = function(t, b, c, d) {
      return c * (t /= d) * t * t + b;
    };
    _.easeOutCubic = function(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    };
    return _.easeInOutCubic = function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t + b;
      } else {
        return c / 2 * ((t -= 2) * t * t + 2) + b;
      }
    };
  })();
});


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  // * Нахожусь ли Я в точке по диагонале (рядом), относительно char
  _.kdInDiagonalPointRelativeTo = function(char) {
    var e, x, y;
    try {
      if (char == null) {
        return false;
      }
      ({x, y} = char);
      if (x === this.x - 1 && ((y === this.y - 1) || (y === this.y + 1))) {
        return true; // * left up or down
      }
      if (x === this.x + 1 && (y === this.y - 1 || y === this.y + 1)) {
        return true; // * right up or down
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * В MZ нету данной функции, а она часто используется в моих плагинах
  if (!KDCore.isMZ()) {
    return;
  }
  //?[NEW] (from MV)
  return ImageManager.loadEmptyBitmap = function() {
    if (this._emptyBitmap != null) {
      return this._emptyBitmap;
    } else {
      return new Bitmap();
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var _input_onKeyDown, _input_onKeyUp, i, j, k, l;
  Input.KeyMapperPKD = {};
//Numbers
  for (i = j = 48; j <= 57; i = ++j) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i);
  }
//Letters Upper
  for (i = k = 65; k <= 90; i = ++k) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
  }
//Letters Lower (for key code events)
  for (i = l = 97; l <= 122; i = ++l) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
  }
  
  //@[ALIAS]
  _input_onKeyDown = Input._onKeyDown;
  Input._onKeyDown = function(event) {
    _input_onKeyDown.call(this, event);
    if (Input.keyMapper[event.keyCode]) {
      return;
    }
    Input._setStateWithMapperPKD(event.keyCode);
  };
  //@[ALIAS]
  _input_onKeyUp = Input._onKeyUp;
  Input._onKeyUp = function(event) {
    _input_onKeyUp.call(this, event);
    if (Input.keyMapper[event.keyCode]) {
      return;
    }
    Input._setStateWithMapperPKD(event.keyCode, false);
  };
  //?NEW
  Input._setStateWithMapperPKD = function(keyCode, state = true) {
    var symbol;
    symbol = Input.KeyMapperPKD[keyCode];
    if (symbol != null) {
      return this._currentState[symbol] = state;
    }
  };
  //?NEW
  Input.isCancel = function() {
    return Input.isTriggered('cancel') || TouchInput.isCancelled();
  };
  //?NEW
  return TouchInput.toPoint = function() {
    return new KDCore.Point(TouchInput.x, TouchInput.y);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  PluginManager.getPluginParametersByRoot = function(rootName) {
    var pluginParameters, property;
    for (property in this._parameters) {
      if (this._parameters.hasOwnProperty(property)) {
        pluginParameters = this._parameters[property];
        if (PluginManager.isPluginParametersContentKey(pluginParameters, rootName)) {
          return pluginParameters;
        }
      }
    }
    return PluginManager.parameters(rootName);
  };
  return PluginManager.isPluginParametersContentKey = function(pluginParameters, key) {
    return pluginParameters[key] != null;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ___Sprite_alias_Move_KDCORE_2;
  Sprite.prototype.moveToCenter = function(dx = 0, dy = 0) {
    return this.move(-this.bitmap.width / 2 + dx, -this.bitmap.height / 2 + dy);
  };
  Sprite.prototype.setStaticAnchor = function(floatX = 1, floatY = 1) {
    this.x -= Math.round(this.width * floatX);
    this.y -= Math.round(this.height * floatY);
  };
  Sprite.prototype.moveToParentCenter = function() {
    if (!this.parent) {
      return;
    }
    return this.move(this.parent.width / 2, this.parent.height / 2);
  };
  ___Sprite_alias_Move_KDCORE_2 = Sprite.prototype.move;
  Sprite.prototype.move = function(x, y) {
    if (x instanceof Array) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x[0], x[1]);
    } else if (x instanceof KDCore.Point || ((x != null ? x.x : void 0) != null)) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x.x, x.y);
    } else if ((x != null) && (x._x != null)) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x._x, x._y);
    } else {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x, y);
    }
  };
  Sprite.prototype.isContainsPoint = function(point) {
    var rect, rx, ry;
    if (this.width === 0 || this.height === 0) {
      return false;
    }
    rx = KDCore.SDK.toGlobalCoord(this, 'x');
    ry = KDCore.SDK.toGlobalCoord(this, 'y');
    rect = this._getProperFullRect(rx, ry);
    return rect.contains(point.x, point.y);
  };
  // * Возвращает Rect с учётом Scale и Anchor спрайта
  Sprite.prototype._getProperFullRect = function(rx, ry) {
    var height, width, x, y;
    width = this.width * Math.abs(this.scale.x);
    height = this.height * Math.abs(this.scale.y);
    x = rx - this.anchor.x * width;
    y = ry - this.anchor.y * height;
    if (this.anchor.x === 0 && this.scale.x < 0) {
      x += this.width * this.scale.x;
    }
    if (this.anchor.y === 0 && this.scale.y < 0) {
      y += this.height * this.scale.y;
    }
    return new PIXI.Rectangle(x, y, width, height);
  };
  Sprite.prototype.fillAll = function(color) {
    if (color != null) {
      return this.bitmap.fillAll(color);
    } else {
      return this.fillAll(KDCore.Color.WHITE);
    }
  };
  return Sprite.prototype.removeFromParent = function() {
    if (this.parent != null) {
      return this.parent.removeChild(this);
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return TouchInput.toMapPoint = function() {
    return this.toPoint().convertToMap();
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  KDCore.Utils = KDCore.Utils || {};
  return (function() {
    var _;
    _ = KDCore.Utils;
    _.getJDataById = function(id, source) {
      var d, j, len;
      for (j = 0, len = source.length; j < len; j++) {
        d = source[j];
        if (d.id === id) {
          return d;
        }
      }
      return null;
    };
    _.hasMeta = function(symbol, obj) {
      return (obj != null) && (obj.meta != null) && (obj.meta[symbol] != null);
    };
    _.getValueFromMeta = function(symbol, obj) {
      if (!_.hasMeta(symbol, obj)) {
        return null;
      }
      return obj.meta[symbol];
    };
    _.getNumberFromMeta = function(symbol, obj) {
      var value;
      if (!_.hasMeta(symbol, obj)) {
        return null;
      }
      if (obj.meta[symbol] === true) {
        return 0;
      } else {
        value = KDCore.SDK.toNumber(obj.meta[symbol], 0);
      }
      return value;
    };
    _.isSceneMap = function() {
      try {
        return !SceneManager.isSceneChanging() && SceneManager._scene instanceof Scene_Map;
      } catch (error) {
        return false;
      }
    };
    _.isMapScene = function() {
      return this.isSceneMap();
    };
    _.isSceneBattle = function() {
      try {
        return !SceneManager.isSceneChanging() && SceneManager._scene instanceof Scene_Battle;
      } catch (error) {
        return false;
      }
    };
    _.isBattleScene = function() {
      return this.isSceneBattle();
    };
    _.getEventCommentValue = function(commentCode, list) {
      var comment, e, i, item;
      try {
        if (list && list.length > 1) {
          i = 0;
          while (i < list.length) {
            item = list[i++];
            if (!item) {
              continue;
            }
            if (item.code === 108) {
              comment = item.parameters[0];
              if (comment.contains(commentCode)) {
                return comment;
              }
            }
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return null;
    };
    _.getEventCommentValueArray = function(commentCode, list) {
      var comment, comments, e, i, item;
      try {
        comments = [];
        if (list && list.length > 1) {
          i = 0;
          while (i < list.length) {
            item = list[i++];
            if (!item) {
              continue;
            }
            if (item.code === 108) {
              comment = item.parameters[0];
              if (comment.contains(commentCode)) {
                comments.push(comment);
              }
            }
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return comments;
    };
    _.getPositionPointFromJSON = function(jsonSettings) {
      return _.convertPositionPointFromJSON(jsonSettings.position);
    };
    _.convertPositionPointFromJSON = function(position) {
      var e, x, y;
      try {
        x = position[0];
        y = position[1];
        if (!KDCore.SDK.isInt(x)) {
          x = eval(x);
        }
        if (!KDCore.SDK.isInt(y)) {
          y = eval(y);
        }
        return new KDCore.Point(x, y);
      } catch (error) {
        e = error;
        console.warn('Utils.getPositionPointFromJSON', e);
        return KDCore.Point.Empty;
      }
    };
    _.jsonPos = function(jsonPosition) {
      return _.convertPositionPointFromJSON(jsonPosition);
    };
    _.jsonPosXY = function(jsonPosition) {
      var e, x, y;
      try {
        ({x, y} = jsonPosition);
        return new KDCore.Point(eval(x), eval(y));
      } catch (error) {
        e = error;
        console.warn('Utils.jsonPosXY', e);
        return KDCore.Point.Empty;
      }
    };
    _.getVar = function(id) {
      return $gameVariables.value(id);
    };
    _.setVar = function(id, value) {
      return $gameVariables.setValue(id, value);
    };
    _.addToVar = function(id, value) {
      var prevVal;
      prevVal = _.getVar(id);
      return _.setVar(id, prevVal + value);
    };
    _.playSE = function(seFileName, pitch = 100, volume = 100) {
      var sound;
      if (seFileName == null) {
        return;
      }
      if (seFileName === "") {
        return;
      }
      sound = {
        name: seFileName,
        pan: 0,
        pitch: pitch,
        volume: volume
      };
      AudioManager.playStaticSe(sound);
    };
    _.getItemTypeId = function(item) {
      if (DataManager.isWeapon(item)) {
        return 1;
      } else if (DataManager.isArmor(item)) {
        return 2;
      }
      return 0;
    };
    _.getItemByType = function(itemId, typeId) {
      var data, e;
      try {
        if ((typeId != null) && !isFinite(typeId) && KDCore.SDK.isString(typeId) && String.any(typeId)) {
          if (typeId[0] === "w") {
            typeId = 1;
          } else if (typeId[0] === "a") {
            typeId = 2;
          } else {
            typeId = 0;
          }
        }
        data = [$dataItems, $dataWeapons, $dataArmors];
        return data[typeId][itemId];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    _.loadFont = function(name) {
      if (typeof FontManager === "undefined" || FontManager === null) {
        return;
      }
      if (String.isNullOrEmpty(name)) {
        return;
      }
      if (FontManager._states[name] != null) {
        return;
      }
      FontManager.load(name, name + ".ttf");
    };
    _.convertTimeShort = function(seconds) {
      var e;
      try {
        if (seconds > 59) {
          return Math.floor(seconds / 60) + 'm';
        } else {
          return seconds;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        return seconds;
      }
    };
    _.isPointInScreen = function(point, margin = 10) {
      var maxH, maxW, screenMargin, x, y;
      ({x, y} = point);
      maxW = Graphics.width;
      maxH = Graphics.height;
      // * Граница от краёв экрана
      screenMargin = margin;
      if (x < screenMargin) {
        return false;
      }
      if (y < screenMargin) {
        return false;
      }
      if (x > (maxW - screenMargin)) {
        return false;
      }
      if (y > (maxH - screenMargin)) {
        return false;
      }
      return true;
    };
    // * Ассинхронная загрузка изображения, возвращает bitmap, когда загружен
    // * Пример использования loadImageAsync(a, b).then(метод)
    // в метод будет передан bitmap первым аргументом
    _.loadImageAsync = async function(folder, filename) {
      var promise;
      promise = new Promise(function(resolve, reject) {
        var b;
        b = ImageManager.loadBitmap("img/" + folder + "/", filename);
        return b.addLoadListener(function() {
          return resolve(b);
        });
      });
      return (await promise);
    };
    // * Преобразовать расширенное значение
    // * Значение может быть X -> X
    // * "X" -> X (цифра)
    // * "X,Y,Z,..." -> [X, Y, Z]
    // * "[X, Y, Z,...]" -> [X, Y, Z]
    // * "X|V" -> из переменной X
    // * [Y] -> случайное число из массива (рекурсивно)
    //@[2.8.1] since
    _.getEValue = function(value) {
      var e, items, randomValue, variableId;
      try {
        if (value == null) {
          return null;
        }
        if (KDCore.SDK.isString(value)) {
          if (isFinite(value)) { // * Число представленно строкой
            return Number(value);
          }
          // * Массив представлен строкой (может быть без квадратных скобок)
          if (value.contains(',') || (value.contains("[") && value.contains("]"))) {
            value = value.replace("[", "");
            value = value.replace("]", "");
            // * Преобразуем в число или строку (например если extended |V)
            items = value.split(",").map(function(item) {
              var itemT;
              itemT = item.trim();
              if (isFinite(itemT)) {
                return Number(itemT);
              } else {
                return itemT;
              }
            });
            // * Вызываем снова эту функцию, но уже с массивом
            return KDCore.Utils.getEValue(items);
          }
          if (value.contains("|V")) {
            variableId = parseInt(value);
            return $gameVariables.value(variableId);
          }
          return value; // * Просто значение в итоге
        } else if (KDCore.SDK.isArray(value)) {
          randomValue = value.sample();
          return KDCore.Utils.getEValue(randomValue);
        } else {
          return value;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return value;
      }
    };
    //@[2.8.2] since
    _.isChanceIsGood = function(chance) {
      var e;
      try {
        if (chance > 1) {
          chance /= 100;
        }
        return chance > Math.random();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    //@[2.8.2] since
    //KEY:w:3:1:50 , KEY:i:10:2:1|V
    //OUTPUT: [GameItem, COUNT]
    _.parseItemFromConditionStr = function(conditionLine) {
      var amount, e, itemChance, itemId, parts, typeId;
      try {
        if (!conditionLine.contains(":")) {
          return null;
        }
        parts = conditionLine.split(":");
        typeId = parts[1];
        itemId = KDCore.Utils.getEValue(parts[2]);
        amount = KDCore.Utils.getEValue(parts[3]);
        if (amount <= 0) {
          return null;
        }
        try {
          itemChance = String.any(parts[4]) ? parts[4] : 100;
          itemChance = KDCore.Utils.getEValue(itemChance) / 100;
        } catch (error) {
          e = error;
          KDCore.warning(e);
          itemChance = 0;
        }
        if (itemChance <= 0) {
          return null;
        }
        if (KDCore.Utils.isChanceIsGood(itemChance)) {
          return [KDCore.Utils.getItemByType(itemId, typeId), amount];
        } else {
          return null;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    //@[3.2.1] since
    _.isValidCE = function(commonEventId) {
      var e;
      try {
        return commonEventId > 0 && ($dataCommonEvents[commonEventId] != null);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    //@[3.2.1] since
    _.startCE = function(commonEventId) {
      var e;
      try {
        if (this.isValidCE(commonEventId)) {
          return $gameTemp.reserveCommonEvent(commonEventId);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //@[3.2.1] since
    _.checkSwitch = function(value) {
      if (value == null) {
        return false;
      }
      if (isFinite(value)) {
        return false;
      }
      return KDCore.SDK.checkSwitch(value);
    };
    //@[3.2.1] since
    // * Вызвать с задержкой в time миллисекунд
    // * Не забываем про bind
    _.callDelayed = function(method, time = 1) {
      var e;
      try {
        if (method == null) {
          return;
        }
        setTimeout((function() {
          var e;
          try {
            return method();
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        }), time);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    //@[3.2.1] since
    //<meta:1,2,3,4> -> [1,2,3,4]
    _.getArrayOfNumbersFromMeta = function(symbol, obj) {
      var e, values;
      try {
        values = this.getArrayOfValuesFromMeta(symbol, obj);
        return values.map(function(v) {
          return Number(v);
        });
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    //@[3.2.1] since
    //<meta:a,b,c> -> ["a", "b", "c"]
    //<meta:a> -> ["a"]
    _.getArrayOfValuesFromMeta = function(symbol, obj) {
      var e, items, values;
      try {
        values = this.getValueFromMeta(symbol, obj);
        if (String.any(values)) {
          if (values.contains(',')) {
            items = values.split(',');
            return items || [];
          } else {
            return [values];
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    //@[3.2.1] since
    // * Когда содержит одинаковый набор ключей
    //<meta:value1>
    //<meta:value2>
    //...
    // -> [value1,value2,...]
    _.getArrayOfValuesOfSameMeta = function(symbol, obj) {
      var e, j, len, line, lines, result;
      try {
        if (!this.hasMeta(symbol, obj)) {
          return [];
        }
        lines = obj.note.split("\n").filter(function(l) {
          return l.contains(symbol);
        });
        result = [];
        for (j = 0, len = lines.length; j < len; j++) {
          line = lines[j];
          try {
            line = line.replace("<" + symbol + ":", "");
            line = line.replace(">", "");
            result.push(line);
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
        return result;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return [];
    };
    //@[3.2.7] since
    _.getIndexIn2DArrayByIJ = function(row, col, cols) {
      return row * cols + col;
    };
    //@[3.2.7] since
    // * row - строка
    // * col - столбец
    _.getIJByIndexIn2DArray = function(index, cols) {
      var col, e, row;
      try {
        row = Math.floor(index / cols);
        col = index % cols;
        return [row, col];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0, 0];
      }
    };
    //@[3.2.7] since
    _.isSwitchIsTRUE = function(switchId) {
      var e;
      if (switchId == null) {
        return true;
      }
      if (switchId <= 0) {
        return true;
      }
      try {
        return $gameSwitches.value(switchId) === true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
    //@[3.5] since
    _.convertBindingValue = function(sourceObj, bindingValue, element = null) {
      var e;
      try {
        return KDCore.UI.Builder._convertBindingValue(...arguments);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    //@[3.5] since
    _.getRealSpriteSize = function(forField = 'x', sprite = null) {
      var e, h, w;
      try {
        if (sprite == null) {
          return 0;
        }
        if (forField === 'x' || forField === 'width') {
          if (sprite.realWidth != null) {
            w = sprite.realWidth();
          } else {
            w = sprite.width;
          }
          return w;
        } else if (forField === 'y' || forField === 'height') {
          if (sprite.realHeight != null) {
            h = sprite.realHeight();
          } else {
            h = sprite.height;
          }
          return h;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    //@[3.5] since
    _.string2hex = function(string) {
      var e;
      try {
        if (typeof string === 'string' && string[0] === '#') {
          string = string.substr(1);
        }
        return parseInt(string, 16);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0xffffff;
    };
    //@[3.5] since
    _.convertDP = function(value = 0, isHalf = false) {
      var d, e, mod, modX, modY;
      try {
        if (Graphics.width === 816 && Graphics.height === 624) {
          return value;
        }
        modX = Graphics.width / 816;
        modY = Graphics.height / 624;
        // Aprox
        mod = (modX + modY) / 2;
        if (mod === 0) {
          return 0;
        }
        if (isHalf === true) {
          if (mod < 1) {
            d = 1 - mod;
            mod += d / 2;
          } else if (mod > 1) {
            d = mod - 1;
            mod = 1 + (d / 2);
          }
        }
        return Math.round(value * mod);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    //@[2.9.7] since
    // * Shrink number 100000 to "100k" and ect, returns STRING
    _.formatNumberToK = function(num) {
      var e;
      try {
        if (num >= 1000000000) {
          return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'G';
        }
        if (num >= 1000000) {
          return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
        }
        if (num >= 1000) {
          return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
        }
        return num;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return num;
      }
    };
  })();
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return Window_Base.prototype.drawFaceWithCustomSize = function(faceName, faceIndex, x, y, finalSize) {
    this.contents._needModBltDWH = finalSize;
    this.drawFace(faceName, faceIndex, x, y);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Selectable.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__select, _;
    //@[DEFINES]
    _ = Window_Selectable.prototype;
    //@[ALIAS]
    ALIAS__select = _.select;
    _.select = function(index) {
      var e;
      ALIAS__select.call(this, ...arguments);
      try {
        return this._pOnSelectionChanged(index);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._pOnSelectionChanged = function(newIndex) {
      var e;
      try {
        if (this._pkdLastSelectedIndex == null) {
          this._pkdLastSelectedIndex = newIndex;
          return this.pOnSelectionChanged();
        } else {
          if (this._pkdLastSelectedIndex !== newIndex) {
            this._pkdLastSelectedIndex = newIndex;
            return this.pOnSelectionChanged();
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.safeSelect = function(index = 0) {
      var e;
      try {
        if (this.maxItems() > index) {
          return this.select(index);
        } else {
          return this.select(-1);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    
    // * Called only when new (different) index is selected
    _.pOnSelectionChanged = function() {};
  })();
});

// ■ END Window_Selectable.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return (function() {    // * Input Extension: KDGamepad
    //------------------------------------------------------------------------------
    // * Поддержка расширенного управления через геймпад (свой модуль)
    var ALIAS___updateGamepadState, _;
    //@[DEFINES]
    _ = Input;
    // * Активировать работу модуля KDGamepad
    _.activateExtendedKDGamepad = function() {
      return _._kdIsGamepadExtended = true;
    };
    //@[ALIAS]
    ALIAS___updateGamepadState = _._updateGamepadState;
    _._updateGamepadState = function(gamepad) {
      if (Input._kdIsGamepadExtended === true) {
        KDGamepad.update();
      }
      if ((typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp.__kdgpStopDefaultGamepad : void 0) === true) {
        return;
      }
      // * Режим перемещения без DPad
      // * В оригинале игрок также ходит по DPad клавишам, что может быть не удобно
      // * например при работе с инвентарём
      if (KDGamepad.isNoDPadMoving()) {
        if (KDGamepad.isDPadAny()) {
          Input.clear();
          return;
        }
      }
      ALIAS___updateGamepadState.call(this, gamepad);
    };
    window.KDGamepad = function() {
      return new Error("This is static class");
    };
    window.addEventListener("gamepadconnected", function(event) {
      var e;
      try {
        return KDGamepad.refresh();
      } catch (error) {
        // * Можно напрямую
        //unless KDGamepad.isExists()
        //    if event.gamepad? and event.gamepad.mapping == 'standard'
        //        KDGamepad.init(event.gamepad)
        e = error;
        KDCore.warning(e);
        return KDGamepad.stop();
      }
    });
    window.addEventListener("gamepaddisconnected", function(event) {
      var e;
      if (!KDGamepad.isExists()) {
        return;
      }
      try {
        if ((event.gamepad != null) && event.gamepad === KDGamepad.gamepad) {
          return KDGamepad.stop();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return KDGamepad.stop();
      }
    });
    KDGamepad.stopDefaultGamepad = function() {
      $gameTemp.__kdgpStopDefaultGamepad = true;
    };
    KDGamepad.resumeDefaultGamepad = function() {
      $gameTemp.__kdgpStopDefaultGamepad = null;
    };
    // * Ссылка на геймпад
    KDGamepad.gamepad = null;
    // * Подключён ли Gamepad ?
    KDGamepad.isExists = function() {
      return KDGamepad.gamepad != null;
    };
    // * Инициализация состояния кнопок
    // * Этот метод вызывается автоматически из Refresh или при подключении Gamepad
    KDGamepad.init = function(gamepad) {
      KDGamepad.gamepad = gamepad;
      this._isActive = true;
      this.buttonNames = [
        'A', // 0
        'B', // 1
        'X', // 2
        'Y', // 3
        'LB', // 4
        'RB', // 5
        'LTrigger', // 6
        'RTrigger', // 7
        'Back', // 8
        'Start', // 9
        'LStick', // 10
        'RStick', // 11
        'dUp', // 12
        'dDown', // 13
        'dLeft', // 14
        'dRight' // 15
      ];
      this.reset();
    };
    // * Аналог Input.clear
    KDGamepad.clear = function() {
      return KDGamepad.reset();
    };
    // * Сбросить состояние кнопок
    KDGamepad.reset = function() {
      this.leftStick = {
        x: 0,
        y: 0
      };
      this.rightStick = {
        x: 0,
        y: 0
      };
      this.buttons = {};
      this.buttonsPressed = {};
      this.prevButtons = {};
    };
    
    // * Остановить учёт геймпада
    KDGamepad.stop = function() {
      KDGamepad.reset();
      KDGamepad.gamepad = null;
    };
    // * Функция проверки что нажата кнопка на геймпаде
    KDGamepad._buttonPressed = function(gamepad, index) {
      var b, e;
      try {
        if (!gamepad || !gamepad.buttons || index >= gamepad.buttons.length) {
          return false;
        }
        b = gamepad.buttons[index];
        if (b == null) {
          return false;
        }
        if (typeof b === 'object') {
          // * Можно упростить
          return b.pressed;
        }
        return b === 1.0;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    // * Каждый кадр (обновление состояний)
    KDGamepad.update = function() {
      var e, gp, i, isDown, j, len, name, ref;
      if (!KDGamepad.isActive()) {
        return;
      }
      KDGamepad.refresh();
      if (!KDGamepad.isExists()) {
        return;
      }
      try {
        gp = KDGamepad.gamepad;
        ref = this.buttonNames;
        // * Проверка состояний кнопок
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          name = ref[i];
          this.buttons[name] = false;
          isDown = KDGamepad._buttonPressed(gp, i);
          if (isDown === true) {
            this.prevButtons[name] = true;
          } else {
            // * Срабатываение только при нажал - отпустил
            if (this.prevButtons[name] === true) {
              this.buttons[name] = true;
              this.prevButtons[name] = false;
            }
          }
        }
        // * Проверка стиков
        this.leftStick.x = gp.axes[0];
        this.leftStick.y = gp.axes[1];
        this.rightStick.x = gp.axes[2];
        this.rightStick.y = gp.axes[3];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        KDGamepad.stop();
      }
    };
    // * Обновить и проверить состояние Gamepad
    // * Надо каждый раз это вызывать
    KDGamepad.refresh = function() {
      var e, gamepads, gp, i, isGamepadRefreshed, j, ref;
      try {
        isGamepadRefreshed = false;
        if (navigator.getGamepads) {
          gamepads = navigator.getGamepads();
        } else if (navigator.webkitGetGamepads) {
          gamepads = navigator.webkitGetGamepads();
        }
        if (gamepads != null) {
          for (i = j = 0, ref = gamepads.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
            gp = gamepads[i];
            if ((gp != null) && gp.mapping === 'standard') {
              isGamepadRefreshed = true;
              if (KDGamepad.buttonNames != null) {
                KDGamepad.gamepad = gp;
              } else {
                KDGamepad.init(gp);
              }
              break;
            }
          }
        }
        if (!isGamepadRefreshed) {
          // * Если не был найден не один gamepad - отключаем систему
          KDGamepad.stop();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        KDGamepad.stop();
      }
    };
    // * Любое нажатие кнопки
    KDGamepad.isKeyAny = function(name) {
      return KDGamepad.isKey(name) || KDGamepad.isKeyPressed(name);
    };
    // * Нажата ли кнопка (trigger нажал - отпустил)
    KDGamepad.isKey = function(name) {
      if (!KDGamepad.isExists()) {
        return false;
      }
      if (this.buttons == null) {
        return false;
      }
      return this.buttons[name] === true;
    };
    // * Нажата ли кнопка (continues зажата)
    KDGamepad.isKeyPressed = function(name) {
      if (!KDGamepad.isExists()) {
        return false;
      }
      if (this.buttons == null) {
        return false;
      }
      return this.prevButtons[name] === true;
    };
    KDGamepad.isDPadAny = function() {
      return KDGamepad.isKeyAny("dLeft") || KDGamepad.isKeyAny("dRight") || KDGamepad.isKeyAny("dUp") || KDGamepad.isKeyAny("dDown");
    };
    KDGamepad.isActive = function() {
      return this._isActive === true;
    };
    // * Временно отключить обработку KDGamepad
    KDGamepad.setActive = function(_isActive) {
      this._isActive = _isActive;
      if (KDGamepad.isActive()) {
        KDGamepad.refresh();
      } else {
        KDGamepad.stop();
      }
    };
    // * Отключить перемещение игрока на DPad
    KDGamepad.setNoDPadMovingMode = function(_noDpadMoving) {
      this._noDpadMoving = _noDpadMoving;
    };
    return KDGamepad.isNoDPadMoving = function() {
      return this._noDpadMoving === true;
    };
  })();
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var BitmapSrc;
  BitmapSrc = (function() {
    //?[DEPRECATED]
    class BitmapSrc {
      constructor() {
        this.bitmap = null;
      }

      static LoadFromIconIndex(iconIndex) {
        var bs, icon_bitmap, iconset, ph, pw, sx, sy;
        bs = new BitmapSrc();
        if (BitmapSrc.CACHE[iconIndex] == null) {
          iconset = ImageManager.loadSystem('IconSet');
          if (KDCore.isMV()) {
            pw = Window_Base._iconWidth;
            ph = Window_Base._iconHeight;
          } else {
            pw = ImageManager.iconWidth;
            ph = ImageManager.iconHeight;
          }
          sx = iconIndex % 16 * pw;
          sy = Math.floor(iconIndex / 16) * ph;
          icon_bitmap = new Bitmap(pw, ph);
          icon_bitmap.addLoadListener(function() {
            icon_bitmap.blt(iconset, sx, sy, pw, ph, 0, 0);
          });
          BitmapSrc.CACHE[iconIndex] = icon_bitmap;
        }
        bs.bitmap = BitmapSrc.CACHE[iconIndex];
        return bs;
      }

      static LoadFromImageFolder(filename) {
        var bs;
        bs = new BitmapSrc();
        bs.bitmap = ImageManager.loadPicture(filename);
        return bs;
      }

      static LoadFromBase64(data, name) {
        var bs;
        bs = new BitmapSrc();
        if (name != null) {
          if (BitmapSrc.CACHE[name] != null) {
            bs.bitmap = BitmapSrc.CACHE[name];
          } else {
            BitmapSrc.CACHE[name] = Bitmap.load(data);
            bs.bitmap = BitmapSrc.CACHE[name];
          }
        } else {
          bs.bitmap = Bitmap.load(data);
        }
        return bs;
      }

      static LoadFromMemory(symbol) {
        var bs;
        bs = new BitmapSrc();
        if (BitmapSrc.CACHE[symbol] != null) {
          bs.bitmap = BitmapSrc.CACHE[symbol];
        } else {
          bs.bitmap = ImageManager.loadEmptyBitmap();
        }
        return bs;
      }

    };

    BitmapSrc.CACHE = {};

    return BitmapSrc;

  }).call(this);
  //@[EXTEND]
  return KDCore.BitmapSrc = BitmapSrc;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Changer;
  // * Класс который может плавно изменять какой-либо параметр
  // * Работает в стиле chain методов

    // * ------------------ ПРИМЕР ----------------------------------

    // * Меняем прозрачность 4 раза, туда-сюда, затем выводим done в консоль

    //@changer = new KDCore.Changer(someSprite)
  //@changer.change('opacity').from(255)
  //            .to(0).step(5).speed(1).delay(30).repeat(4).reverse()
  //            .start().done(() -> console.log('done'))
  //@changer.update()

    // * -------------------------------------------------------------
  Changer = class Changer {
    constructor(obj) {
      this.obj = obj;
      // * Количество кадров, в которые будет обновление
      this._field = null; // * название поля
      this._speed = 1; // * frames
      this._step = 1; // * шаг изменения значения
      this._from = 0; // * Начальное значение
      this._to = 0; // * Конечное значение
      this._thread = null;
      this._orienation = true; // * Направление + или - step (true = +)
      this._delay = 0; // * Задержка старта
      this._changer = null; // * Ссылка на следующий changer
      this._isRepeat = false; // * Надо ли поторить себя снова
      this._onDoneMethod = null; // * Метод будет выполнен в конце (при завершении)
      this._isPrepared = false; // * Элемента был подготовлен (установлено значение from)
    }

    start() {
      if (this._field == null) {
        return;
      }
      if (this._from === this._to) {
        return;
      }
      if (this._delay > 0) {
        this._delayThread = new KDCore.TimedUpdate(this._delay, this._startThread.bind(this));
        this._delayThread.once();
      } else {
        this._startThread();
      }
      return this;
    }

    isStarted() {
      return (this._thread != null) || (this._delayThread != null);
    }

    from(_from) {
      this._from = _from;
      return this;
    }

    to(_to) {
      this._to = _to;
      return this;
    }

    step(_step) {
      this._step = _step;
      return this;
    }

    speed(_speed) {
      this._speed = _speed;
      return this;
    }

    change(_field) {
      this._field = _field;
      return this;
    }

    // * Снова повторить (не совместим с then)
    // * Если ничего не указать, или <= 0 -> то бескончно
    repeat(_repeatCount = 0) {
      this._repeatCount = _repeatCount;
      if (this._repeatCount <= 0) {
        this._repeatCount = null;
      }
      this._isRepeat = true;
      this._changer = null;
      return this;
    }

    // * Снова повторить, но поменять местами to и from (работает только с repeat >= 2)
    reverse() {
      this._isReverse = true;
      return this;
    }

    isDone() {
      if (!this._isPrepared) {
        // * Чтобы не было выхода пока ждёт Delay
        return false;
      }
      // * Если от 255 до 0 (например)
      if (this._orienation === false) {
        // * То может быть меньше нуля (т.к. @step динамический)
        return this.value() <= this._to;
      } else {
        return this.value() >= this._to;
      }
    }

    value() {
      return this.obj[this._field];
    }

    stop() {
      this._thread = null;
      this._delayThread = null;
      if (this._changer == null) {
        // * Если есть связанный Changer, то не выполняем метод завршения
        return this._callDoneMethod();
      }
    }

    // * При ожидании, значения устанавливаются не сразу
    delay(_delay) {
      this._delay = _delay;
      return this;
    }

    // * Выполнить другой Changer после этого
    // * Не совместим с Repeat
    // * НЕЛЬЗЯ зацикливать, не будет работать
    // * Соединённый не надо обновлять вне, он обновляется в этом
    then(_changer) {
      this._changer = _changer;
      this._isRepeat = false;
      return this;
    }

    // * Этот метод будт выполнене в конце
    done(_onDoneMethod) {
      this._onDoneMethod = _onDoneMethod;
      return this;
    }

    // * Шаг можно выполнить и в ручную
    makeStep() {
      if (!this.isStarted()) {
        this._prepare();
      }
      this._makeStep();
      return this;
    }

    update() {
      var ref;
      if (this.isStarted()) {
        if (this._delay > 0) {
          if ((ref = this._delayThread) != null) {
            ref.update();
          }
        }
        if (this._thread != null) {
          this._updateMainThread();
        }
      } else {
        // * Если хоть раз был запущен
        if (this._isBeenStarted === true) {
          if (this._changer != null) {
            this._updateChainedChanger();
          }
        }
      }
    }

    static CreateForOpacityUp(sprite, step = 35, onDone = null, isAutoStart = true) {
      var changer;
      changer = new Changer(sprite);
      changer.change('opacity').from(0).to(255).step(step);
      changer.done(function() {
        sprite.opacity = 255;
        if (onDone != null) {
          return onDone();
        }
      });
      if (isAutoStart) {
        changer.start();
      }
      return changer;
    }

    static CreateForOpacityDown(sprite, step = 35, onDone = null, isAutoStart = true) {
      var changer;
      changer = new Changer(sprite);
      changer.change('opacity').from(sprite.opacity).to(0).step(step);
      changer.done(function() {
        sprite.opacity = 0;
        if (onDone != null) {
          return onDone();
        }
      });
      if (isAutoStart) {
        changer.start();
      }
      return changer;
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Changer.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Changer.prototype;
    _._prepare = function() {
      if (this._field == null) {
        return;
      }
      this._orienation = this._from < this._to;
      if (!this._orienation) {
        this._step *= -1;
      }
      // * Устанавливаем начальное значение
      this.obj[this._field] = this._from;
      this._isPrepared = true;
    };
    _._makeStep = function() {
      var value;
      if (this.isDone()) {
        return;
      }
      value = this.value();
      value += this._step;
      this.obj[this._field] = value;
    };
    _._startThread = function() {
      this._prepare();
      if (this.isDone()) {
        return;
      }
      this._thread = new KDCore.TimedUpdate(this._speed, this._makeStep.bind(this));
      return this._isBeenStarted = true;
    };
    _._updateChainedChanger = function() {
      if (this._changer.isStarted()) {
        this._changer.update();
        if (this._changer.isDone()) {
          this._callDoneMethod();
          this._changer.stop();
          return this._changer = null;
        }
      } else {
        return this._changer.start();
      }
    };
    _._restart = function() {
      if (!this._isCanRepeatMore()) {
        return;
      }
      if (this._repeatCount == null) {
        // * Если указано! число повторений, то onDone метод не вызываем
        this._callDoneMethod();
      }
      if (this._isReverse === true) {
        this._swapFromTo();
      }
      this._prepare();
      return this.start();
    };
    _._swapFromTo = function() {
      var t;
      t = this._from;
      this._from = this._to;
      this._to = t;
      // * Инвентируем число step
      this._step *= -1;
    };
    _._callDoneMethod = function() {
      if (this._onDoneMethod != null) {
        return this._onDoneMethod();
      }
    };
    _._isCanRepeatMore = function() {
      if (this._repeatCount == null) {
        return true;
      }
      this._repeatCount--;
      if (this._repeatCount <= 0) {
        this.stop();
        return false;
      }
      return true;
    };
    _._updateMainThread = function() {
      this._thread.update();
      if (this.isDone()) {
        if (this._isRepeat === true) {
          this._restart();
        } else {
          if (this._changer != null) {
            this._updateChainedChanger();
          }
          this.stop();
        }
      }
    };
  })();
  // ■ END Changer.coffee
  //---------------------------------------------------------------------------

  //@[EXTEND]
  return KDCore.Changer = Changer;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Color;
  Color = (function() {
    //rev 29.04.2024
    class Color {
      constructor(r1 = 255, g1 = 255, b1 = 255, a1 = 255) {
        this.r = r1;
        this.g = g1;
        this.b = b1;
        this.a = a1;
      }

      getLightestColor(lightLevel) {
        var bf, newColor, p;
        bf = 0.3 * this.R + 0.59 * this.G + 0.11 * this.B;
        p = 0;
        newColor = [0, 0, 0, 0];
        if (bf - lightLevel >= 0) {
          if (bf >= 0) {
            p = Math.abs(bf - lightLevel) / lightLevel;
          }
          newColor = this.ARR.map(function(c) {
            return c - (p * c);
          });
        } else {
          if (bf >= 0) {
            p = (lightLevel - bf) / (255 - bf);
          }
          newColor = this.ARR.map(function(c) {
            return [(255 - c) * p + c, 255].min();
          });
        }
        return new Color(newColor[0], newColor[1], newColor[2], newColor[3]);
      }

      clone() {
        return this.reAlpha(this.a);
      }

      reAlpha(newAlpha) {
        return new Color(this.r, this.g, this.b, newAlpha || 255);
      }

      static AddConstantColor(name, color) {
        color.toHex();
        color.toArray();
        color.toCSS();
        KDCore.SDK.setConstantToObject(Color, name, color);
      }

      toHex() {
        var b, g, r;
        if (this._colorHex != null) {
          return this._colorHex;
        }
        r = Math.floor(this.r).toString(16).padZero(2);
        g = Math.floor(this.g).toString(16).padZero(2);
        b = Math.floor(this.b).toString(16).padZero(2);
        return this._colorHex = '#' + r + g + b;
      }

      toArray() {
        if (this._colorArray != null) {
          return this._colorArray;
        }
        return this._colorArray = [this.r, this.g, this.b, this.a];
      }

      toCSS() {
        var na, nb, ng, nr;
        if (this._colorCss != null) {
          return this._colorCss;
        }
        nr = Math.round(this.r);
        ng = Math.round(this.g);
        nb = Math.round(this.b);
        na = this.a / 255;
        return this._colorCss = `rgba(${nr},${ng},${nb},${na})`;
      }

      toNumber() {
        return Number(this.toHex().replace("#", "0x"));
      }

      static Random() {
        var a, b, c;
        a = KDCore.SDK.rand(1, 254);
        b = KDCore.SDK.rand(1, 254);
        c = KDCore.SDK.rand(1, 254);
        return new Color(a, b, c, 255);
      }

      static FromHex(hexString) {
        var color, result, shorthandRegex;
        //Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hexString = hexString.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });
        result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexString);
        color = null;
        if (result != null) {
          color = {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          };
        }
        if (color != null) {
          return new Color(color.r, color.g, color.b, 255);
        } else {
          return Color.NONE;
        }
      }

    };

    Object.defineProperties(Color.prototype, {
      R: {
        get: function() {
          return this.r;
        },
        configurable: true
      },
      G: {
        get: function() {
          return this.g;
        },
        configurable: true
      },
      B: {
        get: function() {
          return this.b;
        },
        configurable: true
      },
      A: {
        get: function() {
          return this.a;
        },
        configurable: true
      },
      ARR: {
        get: function() {
          return this.toArray();
        },
        configurable: true
      },
      CSS: {
        get: function() {
          return this.toCSS();
        },
        configurable: true
      },
      HEX: {
        get: function() {
          return this.toHex();
        },
        configurable: true
      },
      OX: {
        get: function() {
          return this.toNumber();
        },
        configurable: true
      }
    });

    Color.AddConstantColor('NONE', new Color(0, 0, 0, 0));

    Color.AddConstantColor('BLACK', new Color(0, 0, 0, 255));

    Color.AddConstantColor('WHITE', new Color(255, 255, 255, 255));

    Color.AddConstantColor('RED', new Color(255, 0, 0, 255));

    Color.AddConstantColor('GREEN', new Color(0, 255, 0, 255));

    Color.AddConstantColor('BLUE', new Color(0, 0, 255, 255));

    Color.AddConstantColor('AQUA', new Color(128, 255, 255, 255));

    Color.AddConstantColor('MAGENTA', new Color(128, 0, 128, 255));

    Color.AddConstantColor('YELLOW', new Color(255, 255, 0, 255));

    Color.AddConstantColor('ORANGE', new Color(255, 128, 0, 255));

    return Color;

  }).call(this);
  //@[EXTEND]
  return KDCore.Color = Color;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Color, DevLog, __TMP_LOGS__;
  Color = KDCore.Color;
  __TMP_LOGS__ = [];
  DevLog = class DevLog {
    constructor(prefix = "") {
      this.prefix = prefix;
      this._isShow = typeof DEV !== 'undefined';
      this._color = Color.BLACK;
      this._backColor = Color.WHITE;
      __TMP_LOGS__.push(this);
    }

    on() {
      this._isShow = true;
      return this;
    }

    off() {
      this._isShow = false;
      return this;
    }

    applyRandomColors() {
      this.applyRandomWithoutBackgroundColors();
      this.setBackColor(Color.Random());
      return this;
    }

    applyRandomWithoutBackgroundColors() {
      this.setColor(Color.Random());
      return this;
    }

    setColor(color) {
      this._color = color;
      return this;
    }

    setBackColor(backColor) {
      this._backColor = backColor;
      return this;
    }

    applyLibraryColors() {
      this.setColors(new Color(22, 120, 138, 0), Color.BLACK);
      return this;
    }

    setColors(color, backColor) {
      this.setColor(color);
      this.setBackColor(backColor);
      return this;
    }

    applyExtensionColors() {
      this.setColors(new Color(22, 143, 137, 0), Color.BLACK.getLightestColor(60));
      return this;
    }

    applyWarningColors() {
      this.setColors(Color.ORANGE, Color.BLACK.getLightestColor(100));
      return this;
    }

    p(text) {
      if (!this._isShow) {
        return;
      }
      if (text == null) {
        console.log("");
      }
      this._printText(text);
    }

    _printText(text) {
      text = this.prefix + " : " + text;
      if (this._isUsingColor()) {
        return this._printTextWithColors(text);
      } else {
        return console.log(text);
      }
    }

    _isUsingColor() {
      return this._color !== Color.BLACK || this._backColor !== Color.WHITE;
    }

    _printTextWithColors(text) {
      var args;
      args = ['%c' + text, `color: ${this._color.HEX} ; background: ${this._backColor.HEX};`];
      return window.console.log.apply(console, args);
    }

    static CreateForLib(library) {
      var dlog;
      dlog = new DevLog(library.name);
      dlog.applyLibraryColors();
      return dlog;
    }

    static EnableAllLogs() {
      return __TMP_LOGS__.forEach(function(log) {
        return log.on();
      });
    }

  };
  //@[EXTEND]
  return KDCore.DevLog = DevLog;
});


// Generated by CoffeeScript 2.6.1
// * Класс для глобального события игры (НЕ события на карте)
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.GEvent = class GEvent {
    constructor(name) {
      this.name = name;
      this.clear();
    }

    addListener(listener, isSingle = false) {
      if (listener == null) {
        return;
      }
      if (isSingle === true) {
        this.listeners = [listener];
      } else {
        this.listeners.push(listener);
      }
    }

    removeListener(listener) {
      if (listener == null) {
        return;
      }
      return this.listener.delete(listener);
    }

    call() {
      var i, l, len, ref;
      ref = this.listeners;
      for (i = 0, len = ref.length; i < len; i++) {
        l = ref[i];
        l();
      }
    }

    clear() {
      return this.listeners = [];
    }

  };
});


// Generated by CoffeeScript 2.6.1
// * Менеджер для управления глобальными событиями игры (GEvent) (НЕ события на карте)
KDCore.registerLibraryToLoad(function() {
  var GEventsManager;
  // * Данный менеджер глобальный, т.е. с ним работают ВСЕ плагины, которые его используют!
  GEventsManager = function() {};
  (function() {
    var _;
    _ = GEventsManager;
    // * Существует ли событие с данным именем
    _.isEventExists = function(gEventName) {
      return this._getEventByName(gEventName) != null;
    };
    // * Получить список всех зарегестрированных событий (имён)
    _.getAllEvents = function() {
      if (this.events == null) {
        return [];
      }
      return this.events.map(function(ev) {
        return ev.name;
      });
    };
    // * Зарегестрировать событие (используется только имя события)
    _.register = function(gEventName) {
      if (this.events == null) {
        this.events = [];
      }
      this.events.push(new KDCore.GEvent(gEventName));
    };
    // * Подписаться на событие (имя события) и слушатель
    // * если isSingle == true - то у события может быть только один исполнитель
    _.subscribeFor = function(evName, listener, isSingle = false) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.addListener(listener, isSingle) : void 0;
    };
    // * Подписаться на событие (уникально) для объекта
    // * Т.е. при вызове этого метода ещё раз, если объект
    // * уже подписан на событие, ничего не будет (без дубликатов)
    //? ВНИМАНИЕ ! Если объект подписался через subscribeForX, то
    // выполнив clear по данному evName, он уже не подпишится!
    _.subscribeForX = function(context, evName, listener) {
      var e, key;
      try {
        key = "__kdCoreGEvent_" + evName;
        if (context[key] == null) {
          this.subscribeFor(evName, listener);
          return context[key] = true;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Вызвать событие (по имени)
    _.call = function(evName) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.call() : void 0;
    };
    _.clear = function(evName) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.clear() : void 0;
    };
    _._getEventByName = function(name) {
      if (!this.events) {
        return null;
      }
      return this.events.find(function(ev) {
        return ev.name === name;
      });
    };
  })();
  //@[EXTEND]
  return KDCore.GEventsManager = GEventsManager;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.MapAnchorPoint = class MapAnchorPoint {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this._realX = this.x;
      this._realY = this.y;
    }

    shiftY() {
      return 0;
    }

    jumpHeight() {
      return 0;
    }

    scrolledX() {
      return Game_CharacterBase.prototype.scrolledX.call(this);
    }

    scrolledY() {
      return Game_CharacterBase.prototype.scrolledY.call(this);
    }

    screenX() {
      return Game_CharacterBase.prototype.screenX.call(this);
    }

    screenY() {
      return Game_CharacterBase.prototype.screenY.call(this);
    }

    moveTo(x, y) {
      this.x = x;
      this.y = y;
      this._realX = this.x;
      this._realY = this.y;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  //?[DEPRECATED]
  return KDCore.ParametersManager = class ParametersManager {
    constructor(pluginName) {
      this.pluginName = pluginName;
      this._cache = {};
      this._parameters = PluginManager.getPluginParametersByRoot(this.pluginName);
    }

    isLoaded() {
      return (this._parameters != null) && this._parameters.hasOwnProperty(this.pluginName);
    }

    isHasParameter(name) {
      return this._parameters[name] != null;
    }

    getString(name) {
      return this._parameters[name];
    }

    convertField(object, fieldName) {
      var e;
      try {
        object[fieldName] = JSON.parse(object[fieldName] || 'false');
      } catch (error) {
        e = error;
        console.error('Error while convert field ' + e.name);
        object[fieldName] = false;
      }
      return object;
    }

    convertImage(object, fieldName) {
      return object[fieldName] = this.loadImage(object[fieldName]);
    }

    loadImage(filename, smooth) {
      var e, path;
      try {
        if (filename) {
          path = filename.split('/');
          filename = path.last();
          path = path.first() + '/';
          return ImageManager.loadBitmap('img/' + path, filename, 0, smooth || true);
        } else {
          return ImageManager.loadEmptyBitmap();
        }
      } catch (error) {
        e = error;
        console.error(e);
        return ImageManager.loadEmptyBitmap();
      }
    }

    getFromCacheOrInit(name, func) {
      var object;
      if (!this.isInCache(name)) {
        if (func != null) {
          object = func.call(this);
          this.putInCache(name, object);
        }
      }
      return this.getFromCache(name);
    }

    isInCache(name) {
      return this._cache.hasOwnProperty(name);
    }

    putInCache(name, object) {
      return this._cache[name] = object;
    }

    getFromCache(name) {
      return this._cache[name];
    }

    getNumber(name) {
      var number;
      number = this.getObject(name);
      if (KDCore.SDK.isInt(number)) {
        return number;
      }
      return 0;
    }

    getObject(name) {
      if (this.isHasParameter(name)) {
        return JSON.parse(this.getString(name) || '{}');
      } else {
        return {};
      }
    }

    getBoolean(name) {
      if (this.isHasParameter(name)) {
        return JSON.parse(this.getString(name) || false);
      } else {
        return false;
      }
    }

    getBooleanFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getBooleanFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getNumberFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getNumberFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getStringFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getStringFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getBooleanFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getBoolean(name);
      });
    }

    getNumberFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getNumber(name);
      });
    }

    getStringFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getString(name);
      });
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.ParamLoader = class ParamLoader {
    constructor(pluginName) {
      this.pluginName = pluginName;
      this.paramsRaw = PluginManager.getPluginParametersByRoot(this.pluginName);
      this.params = this.parseParameters(this.paramsRaw);
    }

    parseParameters(paramSet) {
      var clearKey, key, params, typeKey, value;
      params = {};
      for (key in paramSet) {
        value = paramSet[key];
        KDCore.__ppNameToParseNext = key;
        clearKey = this.parseKey(key);
        typeKey = this.parseKeyType(key);
        params[clearKey] = this.parseParamItem(typeKey, value);
      }
      return params;
    }

    parseKey(keyRaw) {
      return keyRaw.split(":")[0];
    }

    parseKeyType(keyRaw) {
      return keyRaw.split(":")[1];
    }

    writeDetailedError() {
      var e;
      try {
        if (!String.any(KDCore.__ppNameToParseNext)) {
          return;
        }
        return console.warn("Please, check Plugin Parameter " + KDCore.__ppNameToParseNext + " in plugin " + this.pluginName);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Проверка, загружены ли параметры плагина
    isLoaded() {
      return (this.paramsRaw != null) && this.paramsRaw.hasOwnProperty(this.pluginName);
    }

    // * Имя параметра без ключа
    isHasParameter(paramName) {
      return this.params[paramName] != null;
    }

    
      // * Возвращает значение параметра (def - по умолчанию, если не найден)
    getParam(paramName, def) {
      var value;
      if (this.isHasParameter(paramName)) {
        value = this.params[paramName];
        if (value != null) {
          return value;
        }
      }
      return def;
    }

    // * Данные ключи должны идти после названия параметра через :
    // * Пример: @param ShowDelay:int, @param TestBool:bool
    // * Текстовые параметры, которые надо вернуть как есть, можно без типа (text, file, combo, ...)
    parseParamItem(type, item) {
      var e;
      if (type == null) {
        return item;
      }
      try {
        switch (type) {
          case "int":
          case "i":
            return Number(item);
          case "intA":
            return this.parseArray(item, "int");
          case "bool":
          case "b":
          case "e":
            return eval(item);
          case "struct":
          case "s":
            return this.parseStruct(item);
          case "structA":
            return this.parseStructArray(item);
          case "str":
            return item;
          case "strA":
            return this.parseArray(item, "str");
          case "note":
            return this.parseNote(item);
          case "css":
            return item.toCss();
          case "color":
            return KDCore.Color.FromHex(item);
          case "json":
          case "j":
            return this.parseJson(item);
          case "jA":
            return this.parseArray(item, 'json');
          default:
            return item;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
        return item;
      }
    }

    parseArray(items, type) {
      var e, elements, i, len, p, parsed;
      try {
        elements = [];
        parsed = JsonEx.parse(items);
        for (i = 0, len = parsed.length; i < len; i++) {
          p = parsed[i];
          try {
            elements.push(this.parseParamItem(type, p));
          } catch (error) {
            e = error;
            console.warn(e);
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return elements;
    }

    parseStruct(item) {
      var e, parsed;
      try {
        if (item == null) {
          return null;
        }
        if (!String.any(item)) {
          return null;
        }
        parsed = JsonEx.parse(item);
        if (parsed != null) {
          return this.parseParameters(parsed);
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return null;
    }

    parseStructArray(items) {
      var e, elements, i, len, p, parsed;
      try {
        elements = [];
        parsed = JsonEx.parse(items);
        for (i = 0, len = parsed.length; i < len; i++) {
          p = parsed[i];
          try {
            elements.push(this.parseStruct(p));
          } catch (error) {
            e = error;
            console.warn(e);
            this.writeDetailedError();
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return elements;
    }

    parseNote(item) {
      var e, parsed;
      try {
        parsed = JsonEx.parse(item);
        if (parsed != null) {
          return parsed;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return item;
    }

    parseJson(item) {
      var cx, e, element, elements, i, json, key, len, parsed, value;
      try {
        json = {};
        parsed = JsonEx.parse(item);
        elements = parsed.split('\n');
        for (i = 0, len = elements.length; i < len; i++) {
          element = elements[i];
          cx = "{" + element + "}";
          try {
            item = JsonEx.parse(cx);
            for (key in item) {
              value = item[key];
              json[key] = value;
            }
          } catch (error) {
            e = error;
            KDCore.warning("Parameter " + element + " have syntax errors, ignored");
          }
        }
        return json;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.writeDetailedError();
        return null; // * Чтобы default value был возвращён
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Point;
  Point = (function() {
    class Point {
      constructor(_x = 0, _y = 0) {
        this._x = _x;
        this._y = _y;
      }

      clone() {
        return new Point(this._x, this._y);
      }

      toString() {
        return "[" + this._x + " ; " + this._y + "]";
      }

      isSame(anotherPoint) {
        return this.x === anotherPoint.x && this.y === anotherPoint.y;
      }

      convertToCanvas() {
        return new Point(Graphics.pageToCanvasX(this._x), Graphics.pageToCanvasY(this._y));
      }

      convertToMap() {
        return new Point($gameMap.canvasToMapX(this._x), $gameMap.canvasToMapY(this._y));
      }

      convertToScreen() {
        return new Point(this.screenX(), this.screenY());
      }

      screenX() {
        var t, tw;
        t = $gameMap.adjustX(this._x);
        tw = $gameMap.tileWidth();
        return Math.round(t * tw + tw / 2);
      }

      screenY() {
        var t, th;
        t = $gameMap.adjustY(this._y);
        th = $gameMap.tileHeight();
        return Math.round(t * th + th);
      }

      round() {
        return new Point(Math.round(this._x), Math.round(this._y));
      }

      floor() {
        return new Point(Math.floor(this._x), Math.floor(this._y));
      }

      mapPointOnScreen() {
        var nx, ny;
        nx = (this._x * $gameMap.tileWidth()) - ($gameMap.displayX() * $gameMap.tileWidth());
        ny = (this._y * $gameMap.tileHeight()) - ($gameMap.displayY() * $gameMap.tileHeight());
        return new Point(nx, ny);
      }

      multiplyBy(val) {
        return new Point(this._x * val, this._y * val);
      }

      simple() {
        return new PIXI.Point(this.x, this.y);
      }

      delta(point) {
        var dx, dy;
        dx = point.x - this._x;
        dy = point.y - this._y;
        return new KDCore.Point(dx, dy);
      }

      static _getEmpty() {
        if (Point._emptyPoint == null) {
          Point._emptyPoint = new Point(0, 0);
        }
        return Point._emptyPoint;
      }

    };

    Object.defineProperties(Point.prototype, {
      x: {
        get: function() {
          return this._x;
        },
        configurable: true
      },
      y: {
        get: function() {
          return this._y;
        },
        configurable: true
      }
    });

    Object.defineProperties(Point, {
      Empty: {
        get: function() {
          return Point._getEmpty();
        },
        configurable: false
      }
    });

    Array.prototype.toPoint = function() {
      return new Point(this[0], this[1]);
    };

    Object.defineProperty(Array.prototype, "toPoint", {
      enumerable: false
    });

    Sprite.prototype.toPoint = function() {
      return new Point(this.x, this.y);
    };

    Game_CharacterBase.prototype.toPoint = function() {
      return new Point(this.x, this.y);
    };

    return Point;

  }).call(this);
  //@[EXTEND]
  return KDCore.Point = Point;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return KDCore.Sprite = (function(superClass) {
    //rev 07.05.22

      //@[AUTO EXTEND]
    class Sprite extends superClass {
      constructor() {
        super(...arguments);
        this.pHandledIndex = 0;
        this._create2();
        return;
      }

      _create2() {} // * FOR CHILDRENS

      pIsSupportKeyboardHandle() {
        return false;
      }

      pIsVerticalKeyboardNavigation() {
        return true;
      }

      // * For Childrens
      isLoaded() {
        return true;
      }

      realWidth() {
        var child;
        if (this.width === 0) {
          child = this.zeroChild();
          if (child != null) {
            if (child.realWidth != null) {
              return child.realWidth();
            } else {
              return child.width;
            }
          }
        }
        return this.width;
      }

      realHeight() {
        var child;
        if (this.height === 0) {
          child = this.zeroChild();
          if (child != null) {
            if (child.realHeight != null) {
              return child.realHeight();
            } else {
              return child.height;
            }
          }
        }
        return this.height;
      }

      dataBindings() {
        return {
          x: function(v) {
            if (v != null) {
              return this.setPosition(v, this.y);
            }
          },
          y: function(v) {
            if (v != null) {
              return this.setPosition(this.x, v);
            }
          },
          position: function(v) {
            if (v != null) {
              return this.setPosition(v);
            }
          },
          anchor: function(v) {
            if (v != null) {
              return this.setCommonAnchor(v);
            }
          },
          animation: function(v) {
            if (v != null) {
              return this.addAnimationRule(v);
            }
          },
          opacity: function(v) {
            if (v != null) {
              return this.opacity = v;
            }
          },
          visible: function(v) {
            if (v != null) {
              return this.visible = v;
            }
          },
          scale: function(v) {
            if (v != null) {
              return this.scale.set(v);
            }
          },
          rotation: function(v) {
            if (v != null) {
              return this.rotation = v;
            }
          }
        };
      }

      callBinding(binding, value) {
        var e, func;
        try {
          func = this.dataBindings()[binding];
          if (func != null) {
            return func.call(this, value);
          } else {
            return console.warn("Binding " + binding + " not found!");
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      refreshBindings(dataObject = null, recursive = true) {
        var child, e, j, len, ref, results;
        try {
          if (dataObject == null) {
            dataObject = this;
          }
          KDCore.UI.Builder.RefreshBindings(this, dataObject);
          if (recursive === true) {
            ref = this.children;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              try {
                if (child.refreshBindings != null) {
                  results.push(child.refreshBindings(dataObject, true));
                } else {
                  results.push(void 0);
                }
              } catch (error) {
                e = error;
                results.push(KDCore.warning(e));
              }
            }
            return results;
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      uiConstant(name) {
        var e;
        try {
          if (this.uiConstants != null) {
            return this.uiConstants[name];
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      addLoadListener(listener) {
        var e;
        try {
          if (listener == null) {
            return;
          }
          if (this.isLoaded()) {
            try {
              return listener();
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          } else {
            return this._addLoadListener(listener);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      setPosition(x = 0, y = null, bindedObj = null) {
        var _x, _y, e;
        try {
          if (!this.isLoaded()) {
            this._requireFunc('setPosition', arguments);
            return;
          }
          // * Check first Argument as Object
          if (typeof x === 'object') {
            if (x.x != null) {
              _x = x.x;
              if (x.y != null) {
                _y = x.y;
              }
              x = _x;
              y = _y;
            } else if (x.position != null) {
              this.setPosition(x.position, null, bindedObj);
              return;
            } else if (x.margins != null) {
              this.setPosition(x.margins, null, bindedObj);
              return;
            }
          }
          if (typeof x === 'string') {
            this.x = this._getValueByStr(x, 'x', bindedObj);
            if (y == null) {
              y = x;
            }
          } else {
            this.x = x; // * Number
          }
          if (typeof y === 'string') {
            return this.y = this._getValueByStr(y, 'y', bindedObj);
          } else {
            if (y != null) {
              return this.y = y;
            }
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _getValueByStr(value = '0', forField = 'x', owner = null) {
        var dpValue, e, exValue, parentRefSize, percentValue, r, result, resultValue, v;
        try {
          if (typeof value === 'number') {
            return value;
          }
          if (isFinite(value)) {
            return Number(value);
          }
          if (typeof value !== 'string') {
            return 0;
          }
          // * NO REPLACEMENT
          if (value[0] === '$' || value[0] === '@') {
            v = KDCore.Utils.convertBindingValue(owner, value, this);
            return this._getValueByStr(v, forField, owner);
          }
          if (value.contains("prevX")) {
            value = value.replace("prevX", this._getPreviousChildData('x'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevY")) {
            value = value.replace("prevY", this._getPreviousChildData('y'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevHeight")) {
            value = value.replace("prevHeight", this._getPreviousChildData('height'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevWidth")) {
            value = value.replace("prevWidth", this._getPreviousChildData('width'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevEndX")) {
            value = value.replace("prevEndX", "prevX + prevWidth");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevEndY")) {
            value = value.replace("prevEndY", "prevY + prevHeight");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("end")) {
            value = value.replace("end", "100%");
          }
          if (value.contains("begin")) {
            if (forField === 'y') {
              value = value.replace("begin", "-height");
            } else {
              value = value.replace("begin", "-width");
            }
          }
          if (value.contains("right")) {
            value = value.replace("right", "100% - width");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("left")) {
            value = value.replace("left", "0");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("top")) {
            value = value.replace("top", "0");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("bottom")) {
            value = value.replace("bottom", "100% - height");
            return this._getValueByStr(value, forField, owner);
          }
          // * Replace all X%
          if (value.contains("%")) {
            r = new RegExp("(\\d+)%", "g");
            result = r.exec(value);
            while ((result != null)) {
              percentValue = Number(result[1]);
              resultValue = 0;
              if (this.parent != null) {
                parentRefSize = KDCore.Utils.getRealSpriteSize(forField, this.parent);
                resultValue = parentRefSize * (percentValue / 100.0);
              }
              value = value.replace(/(\d+)%/, resultValue);
              result = r.exec(value);
            }
          }
          // * Replace all HDP
          if (value.contains("hdp")) {
            r = new RegExp("(\\d+)hdp", "g");
            result = r.exec(value);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, true);
              value = value.replace(/(\d+)hdp/, resultValue);
              result = r.exec(value);
            }
          }
          // * Replace all DP
          if (value.contains("dp")) {
            r = new RegExp("(\\d+)dp", "g");
            result = r.exec(value);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, false);
              value = value.replace(/(\d+)dp/, resultValue);
              result = r.exec(value);
            }
          }
          if (value.contains('center')) {
            v = this._getValueByStr('50%', forField, owner);
            exValue = KDCore.Utils.getRealSpriteSize(forField, this);
            exValue = v - (exValue / 2);
            value = value.replace("center", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("height")) {
            exValue = KDCore.Utils.getRealSpriteSize("height", this);
            value = value.replace("height", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("width")) {
            exValue = KDCore.Utils.getRealSpriteSize("width", this);
            value = value.replace("width", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          v = eval(value);
          return this._getValueByStr(v, forField, owner);
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return 0;
      }

      _getPreviousChildData(forField) {
        var e, myIndex, prevChild;
        try {
          if (this.parent == null) {
            return 0;
          }
          if (this.parent.children.length <= 1) {
            return 0;
          }
          myIndex = this.parent.children.indexOf(this);
          prevChild = this.parent.children[myIndex - 1];
          if (prevChild == null) {
            return 0;
          }
          if (forField === "x") {
            return prevChild.x;
          } else if (forField === "y") {
            return prevChild.y;
          } else {
            return KDCore.Utils.getRealSpriteSize(forField, prevChild);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return 0;
      }

      setCommonAnchor(x, y) {
        var c, e, j, len, ref;
        try {
          if (y == null) {
            y = x;
          }
          this.anchor.x = x;
          this.anchor.y = y;
          ref = this.children;
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            if (c.setCommonAnchor != null) {
              c.setCommonAnchor(x, y);
            } else {
              c.anchor.x = x;
              c.anchor.y = y;
            }
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }

      zeroChild() {
        return this.children[0];
      }

      appear(step, delay = 0) {
        this.opacity = 0;
        this._opChanger = KDCore.Changer.CreateForOpacityUp(this, step, () => {
          this._opChanger = null;
          return this._updateOpChanger = function() {}; // * EMPTY
        }, false); // * Not autostart for Delay
        if (delay > 0) {
          this._opChanger.delay(delay);
        }
        this._opChanger.start();
        this._updateOpChanger = () => {
          var ref;
          return (ref = this._opChanger) != null ? ref.update() : void 0;
        };
      }

      disapper(step, delay = 0) {
        this._opChanger = KDCore.Changer.CreateForOpacityDown(this, step, () => {
          this._opChanger = null;
          return this._updateOpChanger = function() {}; // * EMPTY
        }, false); // * Not autostart for Delay
        if (delay > 0) {
          this._opChanger.delay(delay);
        }
        this._opChanger.start();
        this._updateOpChanger = () => {
          var ref;
          return (ref = this._opChanger) != null ? ref.update() : void 0;
        };
      }

      moveWithAnimation(dx, dy, duration = 30, easingType = 2) {
        var e;
        try {
          this._moveAnimationItem = new Game_Picture();
          this._moveAnimationItem._x = this.x;
          this._moveAnimationItem._y = this.y;
          this._moveAnimationItem.move(0, this.x + dx, this.y + dy, 1, 1, 255, 0, duration, easingType);
          this.updateMovingAnimation = this.updateMovingAnimationBody;
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }

      assignTooltip(content, params) {
        if (this._tooltip != null) {
          this.removeChild(this._tooltip);
        }
        this._tooltip = new KDCore.UI.Sprite_UITooltip(params);
        this._tooltip.addContent(content);
        this.updateTooltip = this.updateTooltipBody;
      }

      destroyTooltip() {
        if (this._tooltip == null) {
          return;
        }
        this.hideTooltip();
        this.removeChild(this._tooltip);
        this._tooltip = null;
        return this.updateTooltip = function() {}; // * EMPTY
      }

      showTooltip() {
        if (this._tooltip == null) {
          return;
        }
        // * Position 0, 0, becouse cursorRelative by default
        this._tooltip.activateTooltip(0, 0, this);
      }

      hideTooltip() {
        if (this._tooltip == null) {
          return;
        }
        this._tooltip.deactivateTooltip();
      }

      //@[DYNAMIC]
      updateTooltip() {} // * EMPTY

      updateTooltipBody() {
        if (this.isUnderMouse()) {
          if (this._tooltip.isTooltipActive()) {

          } else {
            if (this.isReady() && this.visible === true && this.opacity >= 255) {
              return this.showTooltip();
            }
          }
        } else {
          if (this._tooltip.isTooltipActive()) {
            return this.hideTooltip();
          }
        }
      }

      //@[DYNAMIC]
      updateMovingAnimation() {} // * EMPTY

      updateMovingAnimationBody() {
        var e;
        try {
          if (this._moveAnimationItem == null) {
            return;
          }
          this._moveAnimationItem.update();
          this.x = this._moveAnimationItem._x;
          this.y = this._moveAnimationItem._y;
          if (this._moveAnimationItem._duration <= 0) {
            this._moveAnimationItem = null;
            this.updateMovingAnimation = function() {};
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
          this.updateMovingAnimation = function() {};
        }
      }

      addAnimationRule(rule) {
        var e, r;
        try {
          if (rule == null) {
            return;
          }
          if (this._animationRules == null) {
            this._animationRules = [];
          }
          if (typeof rule === 'object' && (rule.animationConfig != null) && (rule.update != null)) {
            r = rule;
          } else {
            r = new KDCore.AnimationRule(rule, this);
          }
          this._animationRules.push(r);
          return r;
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      setAnimationRule(rule) {
        var e;
        try {
          this._animationRules = [];
          return this.addAnimationRule(rule);
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      update() {
        super.update();
        this._updateOpChanger();
        this.updateTooltip();
        if (this.updateMovingAnimation != null) {
          this.updateMovingAnimation();
        }
        if (this.pIsHandlerActive()) {
          this._pHandleKeyboardInputs();
        }
        if (this.devdrag === true) {
          this._pUpdateDevDrag();
        }
        if (this._animationRules != null) {
          this._pUpdateAnimationRules();
        }
      }

      _pUpdateAnimationRules() {
        var e, j, len, ref, results, rule;
        try {
          ref = this._animationRules;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            rule = ref[j];
            rule.update();
            results.push(rule.applyAnimation(this));
          }
          return results;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      //@[DYNAMIC]
      _updateOpChanger() {} // * EMPTY

      b() {
        return this.bitmap;
      }

      clear() {
        return this.bitmap.clear();
      }

      add() {
        return this.addChild(...arguments);
      }

      bNew(w, h) {
        if (h == null) {
          h = w;
        }
        return this.bitmap = new Bitmap(w, h);
      }

      bImg(filename, sourceFolder) {
        var getterFunc;
        getterFunc = function(filename) {
          return ImageManager.loadPicture(filename);
        };
        if (sourceFolder != null) {
          getterFunc = function(filename) {
            return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
          };
        }
        return this.bitmap = getterFunc(filename);
      }

      onReady(method) {
        if (method != null) {
          return this.bitmap.addLoadListener(method);
        }
      }

      drawText() {
        return this.bitmap.drawText(...arguments);
      }

      drawTextFull(text, position = "center") {
        if (this.textSettingsPosition != null) {
          position = this.textSettingsPosition;
        }
        return this.bitmap.drawTextFull(text, position);
      }

      //?DEPRECATED
      drawTextWithSettings(text) {
        this.clear();
        this.drawTextFull(text, this.textSettingsPosition);
      }

      //? x, y, icon, size
      drawIcon() {
        return this.bitmap.drawIcon(...arguments);
      }

      moveByJson(settings) {
        var pos;
        pos = KDCore.Utils.getPositionPointFromJSON(settings);
        return this.move(pos.x, pos.y);
      }

      applyTextSettingsByJson(sprite, settings) {
        this.applyTextSettingsByExtraSettings(sprite, settings.text);
      }

      applyTextSettingsByExtraSettings(sprite, s) {
        sprite.move(s.marginX, s.marginY);
        sprite.b().fontSize = s.fontSize;
        sprite.b().textColor = KDCore.Color.FromHex(s.textColor).CSS;
        sprite.b().outlineWidth = s.outlineWidth;
        if (s.outlineColor != null) {
          sprite.b().outlineColor = KDCore.Color.FromHex(s.outlineColor).CSS;
        }
        if (s.fontFace != null) {
          sprite.b().fontFace = s.fontFace;
        }
        sprite.b().fontItalic = s.fontItalic;
        sprite.visible = s.visible;
      }

      isReady() {
        var i, j, ref;
        if (this.bitmap != null) {
          if (!this.bitmap.isReady()) {
            return false;
          }
        }
        for (i = j = 0, ref = this.children.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (!this.children[i].bitmap.isReady()) {
            return false;
          }
        }
        return true;
      }

      isCheckAlpha() {
        return false;
      }

      inPosition(point) {
        var e, gx, gy, pixel, result, x, y;
        result = this.isContainsPoint(point);
        if (result && this.isCheckAlpha()) {
          try {
            ({x, y} = point);
            gx = KDCore.SDK.toGlobalCoord(this, 'x');
            gy = KDCore.SDK.toGlobalCoord(this, 'y');
            pixel = this.bitmap.getAlphaPixel(x - gx, y - gy);
            result = pixel > 100;
          } catch (error) {
            e = error;
            KDCore.warning(e);
            result = true; // * ignor Alpha if error
          }
        }
        return result;
      }

      isUnderMouse() {
        return this.inPosition(TouchInput);
      }

      // * Из параметров плагина
      applyFontParam(font) {
        var b;
        if (font == null) {
          return;
        }
        b = this.b();
        if (font.size != null) {
          b.fontSize = font.size;
        }
        if (!String.isNullOrEmpty(font.face)) {
          b.fontFace = font.face;
        }
        if (font.italic != null) {
          b.fontItalic = font.italic;
        }
      }

      applyOutlineParam(outline) {
        var b;
        if (outline == null) {
          return;
        }
        b = this.b();
        if (outline.width != null) {
          b.outlineWidth = outline.width;
        }
        if (!String.isNullOrEmpty(outline.color)) {
          b.outlineColor = outline.color;
        }
      }

      activateHandlerManagment() {
        var e;
        try {
          this.handleUpAction = this.selectPreviousHandlerItem;
          this.handleDownAction = this.selectNextHandlerItem;
          return this._handleManagerActive = true;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      deactivateHandlerManagment() {
        var ref;
        this._handleManagerActive = false;
        this.handleUpAction = function() {}; // * EMPTY
        this.handleDownAction = function() {}; // * EMPTY
        if ((ref = $gameTemp.__pkdActiveKeyboardHandler) != null) {
          ref.pDeactivateHandler();
        }
        $gameTemp.__pkdActiveKeyboardHandler = null;
      }

      addChild(item) {
        var c, handlers;
        c = super.addChild(...arguments);
        if (item instanceof KDCore.Sprite && (item.pIsSupportKeyboardHandle != null) && item.pIsSupportKeyboardHandle()) {
          handlers = this._pGetAllHandlers();
          item.pHandledIndex = handlers.length - 1;
        }
        return c;
      }

      pIsAnyHandlerSelected() {
        return $gameTemp.__pkdActiveKeyboardHandler != null;
      }

      selectPreviousHandlerItem() {
        var e;
        try {
          if (!this.pIsAnyHandlerSelected()) {
            return this._trySelectHandler(0);
          } else {
            return this._trySelectHandler(this._selectedHandlerIndex() - 1);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _selectedHandlerIndex() {
        return $gameTemp.__pkdActiveKeyboardHandler.pHandledIndex;
      }

      _trySelectHandler(index) {
        var e, handlerItemToSelect;
        try {
          handlerItemToSelect = this._pGetAllHandlers().find(function(i) {
            return i.pHandledIndex === index;
          });
          if (handlerItemToSelect != null) {
            handlerItemToSelect.pActivateHandler();
          }
          return this._pOnHandled();
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pGetAllHandlers() {
        return this.children.filter(function(i) {
          return i instanceof KDCore.Sprite && (i.pIsSupportKeyboardHandle != null) && i.pIsSupportKeyboardHandle();
        });
      }

      selectNextHandlerItem() {
        var e;
        try {
          if (!this.pIsAnyHandlerSelected()) {
            return this._trySelectHandler(0);
          } else {
            return this._trySelectHandler(this._selectedHandlerIndex() + 1);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      activeItemFilterOptions() {
        return {
          distance: 15,
          outerStrength: 4
        };
      }

      pIsHandlerActive() {
        return this._handleManagerActive === true || this._handlerActive === true;
      }

      destroy() {
        if ($gameTemp.__pkdActiveKeyboardHandler === this) {
          $gameTemp.__pkdActiveKeyboardHandler = null;
        }
        return super.destroy();
      }

      _pOnHandled() {
        return Input.clear();
      }

      _pHandleKeyL(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleLeftAction != null) {
              this.handleLeftAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyU(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyR(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleRightAction != null) {
              this.handleRightAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyD(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyU(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleUpAction != null) {
              this.handleUpAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyL(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyD(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleDownAction != null) {
              this.handleDownAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyR(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyOK() {
        var e;
        try {
          if (this.handleOKAction != null) {
            this.handleOKAction();
            return this._pOnHandled();
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      pActivateHandler() {
        if (!this.pIsSupportKeyboardHandle()) {
          return;
        }
        if (($gameTemp.__pkdActiveKeyboardHandler != null) && $gameTemp.__pkdActiveKeyboardHandler !== this) {
          $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
        }
        this._handlerActive = true;
        this._activateHandlerVisually();
        $gameTemp.__pkdActiveKeyboardHandler = this;
      }

      _activateHandlerVisually() {
        var e;
        try {
          //@filters = [new PIXI.filters.OutlineFilter(0.8, 0x99ff99, 0.5)]
          //@filters = [new PIXI.filters.GlowFilter(2, 0.8, 0, 0x09f9, 0.5)]
          return this.filters = [new PIXI.filters.GlowFilter(this.activeItemFilterOptions())];
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      pDeactivateHandler() {
        if ($gameTemp.__pkdActiveKeyboardHandler === this) {
          $gameTemp.__pkdActiveKeyboardHandler = null;
        }
        this._handlerActive = false;
        this.filters = [];
      }

      _pHandleKeyboardInputs() {
        var e;
        try {
          if (Input.isTriggered('left')) {
            return this._pHandleKeyL();
          } else if (Input.isTriggered('right')) {
            return this._pHandleKeyR();
          } else if (Input.isTriggered('up')) {
            return this._pHandleKeyU();
          } else if (Input.isTriggered('down')) {
            return this._pHandleKeyD();
          } else if (Input.isTriggered('ok')) {
            return this._pHandleKeyOK();
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _applyRequiredData() {
        var _n, e, func, j, len, ref;
        try {
          if (this._requiredFuncs == null) {
            return;
          }
          ref = this._requiredFuncs;
          for (j = 0, len = ref.length; j < len; j++) {
            func = ref[j];
            try {
              _n = func[0];
              if ((_n != null) && (this[_n] != null)) {
                this[_n](...func[1]);
              }
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
          }
          return this._requiredFuncs = null;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _requireFunc(name, args) {
        var e;
        try {
          if (this._requiredFuncs == null) {
            this._requiredFuncs = [];
          }
          return this._requiredFuncs.push([name, args]);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _addLoadListener(listener) {
        var e;
        try {
          if (this._loadListeners == null) {
            this._loadListeners = [];
          }
          return this._loadListeners.push(listener);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _executeLoadListeners() {
        var e, j, l, len, ref;
        try {
          if (!this._loadListeners) {
            return;
          }
          ref = this._loadListeners;
          for (j = 0, len = ref.length; j < len; j++) {
            l = ref[j];
            try {
              l();
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
          }
          return this._loadListeners = null;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      // * DEVELOPER TOOL ====================================
      _pUpdateDevDrag() {
        if (TouchInput.isLongPressed()) {
          if (this.__ddIn === true) {
            return this._pDD_moving();
          } else {
            if (this.isUnderMouse()) {
              return this._pDD_startMove();
            }
          }
        } else {
          if (this.__ddIn === true) {
            return this._pDD_stopMove();
          }
        }
      }

      _pDD_moving() {
        this.x = TouchInput.x - this._pDDTDelta.x;
        return this.y = TouchInput.y - this._pDDTDelta.y;
      }

      _pDD_startMove() {
        var x, y;
        ({x, y} = TouchInput);
        this._pDDTDelta = {x, y};
        this.__ddIn = true;
      }

      _pDD_stopMove() {
        this.__ddIn = false;
        console.log("DD DRAG POS: ");
        return console.log(this.x, this.y);
      }

      // * STATIC ==================================================
      static WhiteRect(w, h) {
        return KDCore.Sprite.ColorRect(w, h, '#FFF');
      }

      static BlackRect(w, h) {
        return KDCore.Sprite.ColorRect(w, h, '#000');
      }

      static ColorRect(w, h, color) {
        var s;
        s = KDCore.Sprite.FromBitmap(w, h);
        s.b().fillAll(color);
        return s;
      }

      static FromImg(filename, sourceFolder) {
        var s;
        s = new KDCore.Sprite();
        s.bImg(filename, sourceFolder);
        return s;
      }

      static FromBitmap(w, h) {
        var s;
        s = new KDCore.Sprite();
        s.bNew(w, h);
        return s;
      }

      static FromTextSettings(settings) {
        var s;
        s = KDCore.Sprite.FromBitmap(settings.textBoxWidth, settings.textBoxHeight);
        s.applyTextSettingsByExtraSettings(s, settings);
        s.textSettingsPosition = settings.position;
        return s;
      }

      // * Загрузчик из параметров плагина (безопасный)
      static FromParams(pluginParams) {
        var e, h, height, margins, s, size, w, width;
        try {
          size = pluginParams.size;
          ({w, h} = size);
          try {
            if (String.any(w)) {
              if (isFinite(w)) {
                w = Number(w);
              } else {
                w = eval(w);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            w = 100;
          }
          try {
            if (String.any(h)) {
              if (isFinite(h)) {
                h = Number(h);
              } else {
                h = eval(h);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            h = 100;
          }
          ({width, height} = size);
          try {
            if (String.any(width)) {
              if (isFinite(width)) {
                w = Number(width);
              } else {
                w = eval(width);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            w = 100;
          }
          try {
            if (String.any(height)) {
              if (isFinite(height)) {
                h = Number(height);
              } else {
                h = eval(height);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            h = 100;
          }
          s = KDCore.Sprite.FromBitmap(w, h);
          s.textSettingsPosition = pluginParams.alignment;
          margins = pluginParams.margins;
          if (margins != null) {
            s.move(margins.x, margins.y);
          }
          s.applyFontParam(pluginParams.font);
          s.applyOutlineParam(pluginParams.outline);
          if (!String.isNullOrEmpty(pluginParams.textColor)) {
            s.b().textColor = pluginParams.textColor;
          }
          if (pluginParams.visible != null) {
            s.visible = pluginParams.visible;
          }
          return s;
        } catch (error) {
          e = error;
          console.warn('Something wrong with Text Settings!', e);
          return KDCore.Sprite.FromBitmap(60, 30);
        }
      }

    };

    return Sprite;

  }).call(this, Sprite);
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.TimedUpdate = class TimedUpdate {
    constructor(interval, method) {
      this.interval = interval;
      this.method = method;
      this._timer = 0;
      this._once = false;
    }

    update() {
      if (this.interval == null) {
        return;
      }
      if (this._timer++ >= this.interval) {
        this.call();
        this._timer = 0;
        if (this._once === true) {
          return this.stop();
        }
      }
    }

    once() {
      return this._once = true;
    }

    onUpdate(method) {
      this.method = method;
    }

    stop() {
      return this.interval = null;
    }

    isAlive() {
      return this.interval != null;
    }

    // * Рандомизировать интервал @interval (-min, +max)
    applyTimeRange(min, max) {
      var value;
      if (!this.isAlive()) {
        return;
      }
      value = KDCore.SDK.rand(min, max);
      return this.interval += value;
    }

    call() {
      if (this.method != null) {
        return this.method();
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationKeyFrame = class AnimationKeyFrame {
    constructor(startValue, endValue, duration = 1, func = 'linear') {
      this.startValue = startValue;
      this.endValue = endValue;
      this.func = func;
      this._t = 0; // * Timer
      this._d = duration * 60; // * Convert to Frames
      this._c = this.endValue - this.startValue; // * Change
      if (this.func == null) {
        this.func = 'linear';
      }
      return;
    }

    reset() {
      return this._t = 0;
    }

    update() {
      if (this._t < this._d) {
        return this._t += 1;
      }
    }

    isEnd() {
      return this._t >= this._d || this._d <= 0;
    }

    getValue() {
      if (this._d <= 0) {
        return this.endValue;
      } else {
        return this.easingFunc()(this._t, this.startValue, this._c, this._d);
      }
    }

    easingFunc() {
      if ((this.func != null) && (KDCore.EasingFuncs[this.func] != null)) {
        return KDCore.EasingFuncs[this.func];
      } else {
        console.warn("Easing func " + this.func + " not found!");
        return this.linear;
      }
    }

    // * Default one
    linear(t, b, c, d) {
      return c * t / d + b;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationKeyLine = class AnimationKeyLine {
    constructor(keyFramesList, totalDuration = 1, func = 'linear') {
      this.totalDuration = totalDuration;
      this.keyFrames = this._parseKeyFrames(keyFramesList, func);
      this.repeatsLeftBase = 0;
      this.repeatsLeft = 0;
      this.keyIndex = 0;
      this._relativeValue = 0;
      this._isStarted = false;
      return;
    }

    setRelativeValue(_relativeValue) {
      this._relativeValue = _relativeValue;
    }

    setRepeatsCount(repeatsLeftBase) {
      this.repeatsLeftBase = repeatsLeftBase;
      return this.repeatsLeft = this.repeatsLeftBase;
    }

    setLoop() {
      return this.setRepeatsCount(-1);
    }

    start(startDelay = 0) {
      this.startDelay = startDelay;
      if (this.startDelay === 0) {
        return this._isStarted = true;
      } else {
        return this._startTimer = this.startDelay * 60;
      }
    }

    pause() {
      this._isStarted = false;
      this._startTimer = null;
    }

    isStarted() {
      return this._isStarted === true;
    }

    complete() {
      this.keyIndex = this.keyFrames.length;
      this.repeatsLeft = 0;
    }

    reset() {
      this.repeatsLeft = this.repeatsLeftBase;
      this._resetKeyframes();
    }

    update() {
      if (this._startTimer != null) {
        this._updateStartTimer();
      }
      if (!this.isStarted()) {
        return;
      }
      if (this.isEnd()) {
        if (this.repeatsLeft === 0) { // * No repeats at all
          return;
        } else if (this.repeatsLeft < 0) { // * Infinite Loop
          this._resetKeyframes();
        } else {
          this.repeatsLeft -= 1;
          this._resetKeyframes();
        }
      }
      this.keyFrames[this.keyIndex].update();
      if (this.keyFrames[this.keyIndex].isEnd()) {
        //console.log("NEXT")
        this.keyIndex++;
      }
    }

    isEnd() {
      return this.keyIndex > this.keyFrames.length - 1;
    }

    getValue() {
      var value;
      if (this.isEnd()) {
        value = this.keyFrames.last().getValue();
      } else {
        value = this.keyFrames[this.keyIndex].getValue();
      }
      return value + this._relativeValue;
    }

    _parseKeyFrames(keyframes, func) {
      var duration, e, endValue, endValues, index, key, keyframesOutput, keys, kf, prevKey, startValue, value;
      try {
        keyframesOutput = [];
        endValues = [];
        keys = [];
        index = 0;
        for (key in keyframes) {
          value = keyframes[key];
          if (endValues.length > 0) {
            startValue = endValues[index - 1];
          } else {
            startValue = 0;
          }
          endValue = value;
          if (key === "0") {
            duration = 0;
          } else {
            prevKey = keys[index - 1];
            duration = this._calculateDuration(prevKey, key);
          }
          kf = new KDCore.AnimationKeyFrame(startValue, endValue, duration, func);
          keys[index] = key;
          endValues[index] = value;
          keyframesOutput.push(kf);
          index++;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return keyframesOutput;
    }

    _calculateDuration(rateA, rateB) {
      var d, e, timeA, timeB;
      try {
        rateA = Number(rateA) / 100.0;
        rateB = Number(rateB) / 100.0;
        timeA = this.totalDuration * rateA;
        timeB = this.totalDuration * rateB;
        d = timeB - timeA;
        return d;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    }

    _resetKeyframes() {
      var e, f, i, len, ref, results;
      try {
        this.keyIndex = 0;
        ref = this.keyFrames;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          f = ref[i];
          results.push(f.reset());
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _updateStartTimer() {
      var e;
      try {
        if (this._startTimer == null) {
          return;
        }
        this._startTimer -= 1;
        if (this._startTimer <= 0) {
          this._isStarted = true;
          return this._startTimer = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationRule = class AnimationRule {
    constructor(animationConfig, obj) {
      var delay, duration, func, keyframes, repeats;
      if (typeof animationConfig === "string") {
        animationConfig = KDCore.UI.Builder.ConvertShortcut(animationConfig);
      }
      this.animationConfig = Object.assign(this.defaultConfig(), animationConfig);
      ({keyframes, duration, func, repeats, delay} = this.animationConfig);
      this.keyLine = new KDCore.AnimationKeyLine(keyframes, duration, func);
      if (repeats == null) {
        repeats = 0;
      }
      this.keyLine.setRepeatsCount(repeats);
      if (this.animationConfig.relative === true && (obj != null)) {
        this.keyLine.setRelativeValue(obj[this.animationConfig.field]);
      }
      this.keyLine.start(delay);
      if ((obj != null) && delay <= 0) {
        this.applyAnimation(obj);
      }
      return;
    }

    setEndCallback(onEndCallback) {
      this.onEndCallback = onEndCallback;
    }

    isHaveEndCallback() {
      var e;
      try {
        if (this.animationConfig.repeats !== 0) {
          // * Callback works only for single-shot animations
          return false;
        }
        return this.onEndCallback != null;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    defaultConfig() {
      return {
        field: "opacity",
        duration: 1,
        func: "linear",
        delay: 0,
        repeats: 0,
        relative: false,
        keyFrames: {
          "0": 0,
          "100": 255
        }
      };
    }

    update() {
      var e;
      this.keyLine.update();
      if (this.isHaveEndCallback()) {
        if (this.keyLine.isEnd()) {
          try {
            this.onEndCallback();
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
          this.onEndCallback = null;
        }
      }
    }

    applyAnimation(obj) {
      var e;
      try {
        if (obj == null) {
          return;
        }
        return obj[this.animationConfig.field] = this.keyLine.getValue();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  
    // * Button (Sprite_XButton)

    //@[AUTO EXTEND]
  //?DEPRECATED
  return KDCore.Button = class Button extends Sprite {
    constructor() {
      super();
      this._mouseIn = false;
      this._touching = false;
      this._slowUpdateActive = false;
      this._localMode = false;
      this._images = [];
      this._checkAlpha = false;
      this._textSprite = null;
      this._textPosition = 0;
      this._override = false; // * TouchClick in game messages not work anymore if TRUE
      this._clickHandlers = [];
      this._manualHided = false;
      this._manualDisabled = false;
      this._condition = null; // * Условие для Visible
      this._condition2 = null; // * Условие для Enable \ Disable
      this._disabled = false;
      this._infoData = null;
      this._isNeedShowText = false;
      return;
    }

    isMouseInButton() {
      return this._mouseIn === true;
    }

    isActive() {
      return this.visible === true;
    }

    activateSlowUpdate() {
      return this._slowUpdateActive = true;
    }

    setLocalMode() {
      this._realX = this.x;
      this._realY = this.y;
      return this._localMode = true;
    }

    setAlphaMode() {
      return this._checkAlpha = true;
    }

    // * above, below
    setTextPosition(position) {
      return this._textPosition = position;
    }

    setHelpText(text, size) {
      return this._createText(text, size);
    }

    setInfoData(data) {
      return this._infoData = data;
    }

    setOverrideMode() {
      return this._override = true;
    }

    isOverride() {
      return this._override === true && this.isActive() && this.touchInButton();
    }

    isDisabled() {
      return this._disabled === true;
    }

    isEnabled() {
      return !this.isDisabled();
    }

    isNeedShowText() {
      return this._isNeedShowText === true;
    }

    addClickHandler(method) {
      return this._clickHandlers.push(method);
    }

    clearClickHandlers() {
      return this._clickHandlers = [];
    }

    isLocalMode() {
      return this._localMode === true;
    }

    setCondition(method) {
      return this._condition = method;
    }

    setConditionForDisable(method) {
      return this._condition2 = method;
    }

    getInfoData() {
      return this._infoData;
    }

    simulateClick() { //?NEW
      return this.applyClickedState();
    }

    simulateClickManual() { //?NEW
      this.simulateClick();
      return setTimeout((() => {
        try {
          return this.applyNormalState();
        } catch (error) {

        }
      }), 50);
    }

    prepare() { //?NEW
      return this.slowUpdate();
    }

    realX() {
      if (this.isLocalMode()) {
        return this._realX;
      } else {
        return this.x;
      }
    }

    realY() {
      if (this.isLocalMode()) {
        return this._realY;
      } else {
        return this.y;
      }
    }

    show() {
      this.visible = true;
      return this._manualHided = false;
    }

    hide() {
      this.visible = false;
      return this._manualHided = true;
    }

    disable() {
      this._disabled = true;
      this._manualDisabled = true;
      this.refreshEnDisState();
      return this._mouseIn = false;
    }

    enable() {
      this._disabled = false;
      this._manualDisabled = false;
      return this.refreshEnDisState();
    }

    update() {
      super.update();
      if (this._destroyed === true) {
        return;
      }
      this.updateMouseClick();
      this.updatePosition();
      if (!this._slowUpdateActive) {
        this.slowUpdate();
      }
      return this.updateComplexTextVisible();
    }

    slowUpdate() {
      if (this._destroyed === true) {
        return;
      }
      this.updateMouseTracking();
      this.updateConditionForVisible();
      return this.updateConditionForEnabling();
    }

    updateMouseTracking() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (this.cursorInButton()) {
        this._onMouseEnter();
        return this._mouseIn = true;
      } else {
        this._onMouseLeave();
        return this._mouseIn = false;
      }
    }

    // * In MZ TouchInput always have X,Y
    cursorInButton() {
      return this.touchInButton();
    }

    xyInButton(x, y) {
      var inRect, rect, rx, ry;
      rx = KDCore.SDK.toGlobalCoord(this, 'x');
      ry = KDCore.SDK.toGlobalCoord(this, 'y');
      rect = new PIXI.Rectangle(rx, ry, this._realWidth(), this._realHeight());
      inRect = rect.contains(x, y);
      if (inRect === true && this._checkAlpha === true) {
        return this._checkAlphaPixel(x - rx, y - ry);
      } else {
        return inRect;
      }
    }

    _realWidth() {
      if (this._hasImage()) {
        return this._mainImage().width;
      } else {
        return this.width;
      }
    }

    _hasImage() {
      return this._mainImage() != null;
    }

    _mainImage() {
      return this._images[0];
    }

    _realHeight() {
      if (this._hasImage()) {
        return this._mainImage().height;
      } else {
        return this.height;
      }
    }

    _checkAlphaPixel(x, y) {
      var pixel;
      pixel = this._hasImage() ? this._mainImage().bitmap.getAlphaPixel(x, y) : this.bitmap.getAlphaPixel(x, y);
      return pixel >= 200;
    }

    _onMouseEnter() {
      if (this._mouseIn === true) {
        return;
      }
      if (!this.isDisabled()) {
        this.applyCoverState();
      }
      this._showText();
      if (this.getInfoData() != null) {
        return this._startComplexTimer();
      }
    }

    _onMouseLeave() {
      if (this._mouseIn === false) {
        return;
      }
      if (!this.isDisabled()) {
        this.applyNormalState();
      }
      this._hideText();
      return this._stopComplexTimer();
    }

    _showText() {
      if (this._textSprite == null) {
        return;
      }
      this._updateTextPosition();
      return this._textSprite.visible = true;
    }

    _hideText() {
      if (this._textSprite == null) {
        return;
      }
      return this._textSprite.visible = false;
    }

    _startComplexTimer() {
      this._stopComplexTimer();
      return this._cTimer = setTimeout((() => {
        if (this._mouseIn === true) {
          return this._isNeedShowText = true;
        }
      }), 1000);
    }

    _stopComplexTimer() {
      if (this._cTimer != null) {
        clearTimeout(this._cTimer);
      }
      return this._isNeedShowText = false;
    }

    updateMouseClick() {
      if (!this.isActive()) {
        this._unTouch();
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (TouchInput.isTriggered() && this.touchInButton()) {
        this._touching = true;
        this.applyClickedState();
      }
      if (this._touching === true) {
        if (TouchInput.isReleased() || !this.touchInButton()) {
          this._unTouch();
          if (TouchInput.isReleased()) {
            return this.callClickHandler();
          }
        }
      }
    }

    _unTouch() {
      this._touching = false;
      if (this.touchInButton()) {
        return this.applyCoverState();
      } else {
        return this.applyNormalState();
      }
    }

    touchInButton() {
      return this.xyInButton(TouchInput.x, TouchInput.y);
    }

    callClickHandler() {
      if (this._clickHandlers.length > 0) {
        return this._clickHandlers.forEach(function(method) {
          return method();
        });
      }
    }

    updatePosition() {
      var p;
      if (!this._localMode) {
        return;
      }
      p = new KDCore.Point(this._realX, this._realY);
      return this.move(p.screenX(), p.screenY());
    }

    updateConditionForVisible() {
      var result;
      if (this._condition == null) {
        return;
      }
      if (this._manualHided === true) {
        return;
      }
      try {
        result = this._condition();
        return this.visible = !result;
      } catch (error) {
        console.warn('wrong condition in button');
        return this.visible = true;
      }
    }

    updateConditionForEnabling() {
      if (!this._condition2) {
        return;
      }
      if (this._manualDisabled === true) {
        return;
      }
      try {
        this._disabled = this._condition2();
        return this.refreshEnDisState();
      } catch (error) {
        console.warn('wrong condition in button for enable state');
        return this.disable();
      }
    }

    setButtonImages(img1, img2, img3, img4) {
      if (this._images != null) {
        this._images.forEach(function(img) {
          if (img != null) {
            return img.parent.removeChild(img);
          }
        });
      }
      this._images = [new Sprite(img1), img2 != null ? new Sprite(img2) : void 0, img3 != null ? new Sprite(img3) : void 0, img4 != null ? new Sprite(img4) : void 0];
      this._images.forEach((img) => {
        if (img != null) {
          return this.addChild(img);
        }
      });
      return this.applyNormalState();
    }

    applyNormalState() {
      var ref;
      this.refreshImages();
      return (ref = this._images[0]) != null ? ref.visible = true : void 0;
    }

    refreshImages() {
      return this._images.forEach(function(img) {
        return img != null ? img.visible = false : void 0;
      });
    }

    applyCoverState() {
      this.refreshImages();
      if (this._images[1] != null) {
        return this._images[1].visible = true;
      } else {
        return this.applyNormalState();
      }
    }

    applyClickedState() {
      this.refreshImages();
      if (this._images[2] != null) {
        return this._images[2].visible = true;
      } else {
        return this.applyNormalState();
      }
    }

    _createText(text, size) {
      var h, w;
      if (this._textSprite) {
        this.removeChild(this._textSprite);
      }
      w = Math.round(((size / 10) + 1) * 5 * text.length);
      h = size + 4;
      this._textSprite = new Sprite(new Bitmap(w, h));
      this._textSprite.bitmap.fontSize = size;
      this._textSprite.bitmap.drawText(text, 0, h / 2, w, 1, 'center');
      this._textSprite.visible = false;
      return this.addChild(this._textSprite);
    }

    _updateTextPosition() {
      var nx, ny;
      if (!this._textSprite) {
        return;
      }
      nx = this._realWidth() / 2 - this._textSprite.width / 2;
      if (this._textPosition === 0) {
        ny = -this._textSprite.height;
      } else {
        ny = this._realHeight() + this._textSprite.height / 2;
      }
      return this._textSprite.move(nx, ny);
    }

    applyDisableState() {
      var ref;
      this.refreshImages();
      return (ref = this._images[3]) != null ? ref.visible = true : void 0;
    }

    refreshEnDisState() {
      if (this.isDisabled()) {
        this.applyDisableState();
        return this._hideText();
      } else {
        if (this._mouseIn === false) {
          return this.applyNormalState();
        }
      }
    }

    //else
    //    do @applyCoverState
    updateComplexTextVisible() {}

    applyScale(mod) {
      var i, img, len, ref;
      ref = this._images;
      for (i = 0, len = ref.length; i < len; i++) {
        img = ref[i];
        if (img != null) {
          img.scale.x = mod;
          img.scale.y = mod;
        }
      }
    }

    static FromSet(imgName, sourceFolder = null) {
      var button, getterFunc, img0, img1;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder != null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
        };
      }
      img0 = getterFunc(imgName + "_00");
      img1 = getterFunc(imgName + "_01");
      button = new KDCore.Button();
      button.setButtonImages(img0, img1, img0, img0);
      return button;
    }

    static FromSetFull(imgName, sourceFolder = null) {
      var button, getterFunc, img0, img1, img2, img3;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder != null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
        };
      }
      img0 = getterFunc(imgName + "_00");
      img1 = getterFunc(imgName + "_01");
      img2 = getterFunc(imgName + "_02");
      img3 = getterFunc(imgName + "_03");
      button = new KDCore.Button();
      button.setButtonImages(img0, img1, img2, img3);
      return button;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_BaseCircle;
  //NUI 1.0
  //rev 28.04.24

    //"type": "circle"
  Sprite_BaseCircle = class Sprite_BaseCircle extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      this._applySettings();
      this._onResize();
      return;
    }

    defaultSettings() {
      return {
        width: 100,
        height: 100,
        fillGradient: null, // { gradient stops }
        gradientStart: {
          x: 0,
          y: 100,
          r: 30
        },
        gradientEnd: {
          x: 100,
          y: 100,
          r: 70
        },
        fillColor: 0xffffff,
        fillAlpha: 1,
        strokeWidth: 4,
        strokeColor: 0x000000,
        strokeAlpha: 1
      };
    }

    defaultGradientSettings() {
      return {
        "0": "#9ff",
        "1": "#033"
      };
    }

    isHaveGradient() {
      return false; //@settings.fillGradient?
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        stroke: function(v) {
          if (v != null) {
            return this.setStroke(v.width, v.color, v.alpha);
          }
        },
        fill: function(v) {
          if (v != null) {
            return this.setFill(v.color, v.alpha);
          }
        }
      });
    }

    setFill(color = "#FFF", alpha = 1) {
      var e;
      try {
        this.settings.fillColor = color;
        this.settings.fillAlpha = alpha;
        this.settings.fillGradient = null;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setStroke(color = "#FFF", width = 0, alpha = 1) {
      var e;
      try {
        this.settings.strokeColor = color;
        this.settings.strokeAlpha = alpha;
        this.settings.strokeWidth = width;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 100, height = 100) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        this._applySettings();
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.graphics = new PIXI.Graphics();
        return this.addChild(this.graphics);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var e, gradientSettings;
      try {
        if (this.graphics == null) {
          return;
        }
        this.graphics.clear();
        if (this.settings.fillGradient != null) {
          gradientSettings = Object.assign(this.defaultGradientSettings(), this.settings.fillGradient);
        }
        this._applyGradientTexture(gradientSettings);
        return this._drawBaseCircle();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyGradientTexture(fillGradient) {
      var e;
      try {

      } catch (error) {
        /*{ width, height } = @settings
        c = document.createElement("canvas")
        ctx = c.getContext("2d")*/
        /*grd = ctx.createRadialGradient(
            @settings.gradientStart.x,
            @settings.gradientStart.y,
            @settings.gradientStart.r,
            @settings.gradientEnd.x,
            @settings.gradientEnd.y,
            @settings.gradientEnd.r
        )*/
        //grd = ctx.createRadialGradient(110, 90, 30, 100, 100, 70)
        /*for key, value of fillGradient
        try
            grd.addColorStop(Number(key), value)
        catch e
            KDCore.warning e*/
        /*grd.addColorStop(0, "pink")
        grd.addColorStop(0.9, "white")
        grd.addColorStop(1, "green")

        ctx.fillStyle = grd
        ctx.fillRect(0, 0, 400, 400)
        texture = new PIXI.Texture.from(c)
        @graphics.beginTextureFill(texture)*/
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawBaseCircle() {
      var colorData, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, width;
      try {
        ({width, height} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          // * Base Fill
          this._drawElipse(0, 0, width, height, colorData);
          // * Stroke
          return this._drawStroke(0, 0, width, height, d, strokeColorData);
        } else {
          // * Base Fill only
          return this._drawElipse(0, 0, width, height, colorData);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _buildColorData(c = 0xfff, a = 1) {
      var e;
      try {
        if (typeof c === 'string') {
          c = KDCore.Utils.string2hex(c);
        }
        return [c, a];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0xfff, 1];
      }
    }

    _drawElipse(x, y, w, h, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        if (!this.isHaveGradient()) {
          g.beginFill(...colorData);
        }
        g.drawEllipse(x, y, w / 2, h / 2);
        if (!this.isHaveGradient()) {
          return g.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawStroke(x, y, w, h, d, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        g.lineStyle(d, ...colorData);
        return g.drawEllipse(x, y, w / 2, h / 2);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        // * Круг (элипс) рисуется от центра, что не удобно
        // при расчёте координат, поэтому сдвигаем в левый вверхний угол
        this.graphics.x = this.settings.width * 0.5;
        return this.graphics.y = this.settings.height * 0.5;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_BaseCircle = Sprite_BaseCircle;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_BaseRect;
  //NUI 1.0
  //rev 28.04.24

    //"type": "rect"
  Sprite_BaseRect = class Sprite_BaseRect extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      this._applySettings();
      this._onResize();
      return;
    }

    defaultSettings() {
      return {
        width: 100,
        height: 100,
        corners: 0, // {  topLeft, topRight, bottomRight, bottomLeft }
        fillGradient: null, // { gradient stops }
        gradientStart: {
          x: 0,
          y: 0
        },
        gradientEnd: {
          x: 0,
          y: 100
        },
        fillColor: 0xffffff,
        fillAlpha: 1,
        strokeWidth: 4,
        strokeColor: 0x000000,
        strokeAlpha: 1
      };
    }

    defaultGradientSettings() {
      return {
        "0": "#9ff",
        "1": "#033"
      };
    }

    defaultCornersSettings() {
      return {
        topLeft: 0,
        topRight: 0,
        bottomRight: 0,
        bottomLeft: 0
      };
    }

    isHaveGradient() {
      return this.settings.fillGradient != null;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        stroke: function(v) {
          if (v != null) {
            return this.setStroke(v.width, v.color, v.alpha);
          }
        },
        fill: function(v) {
          if (v != null) {
            return this.setFill(v.color, v.alpha);
          }
        },
        gradientStart: function(v) {
          if (v != null) {
            return this.setGradientStartEnd(v, this.settings.gradientEnd);
          }
        },
        gradientEnd: function(v) {
          if (v != null) {
            return this.setGradientStartEnd(this.settings.gradientStart, v);
          }
        }
      });
    }

    setGradientStartEnd(start, end) {
      var e;
      try {
        if (start != null) {
          start.x = this._getValueByStr(start.x, 'width', this);
          start.y = this._getValueByStr(start.y, 'height', this);
        }
        if (end != null) {
          end.x = this._getValueByStr(end.x, 'width', this);
          end.y = this._getValueByStr(end.y, 'height', this);
        }
        if (start != null) {
          this.settings.gradientStart = start;
        }
        if (end != null) {
          this.settings.gradientEnd = end;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFill(color = "#FFF", alpha = 1) {
      var e;
      try {
        this.settings.fillColor = color;
        this.settings.fillAlpha = alpha;
        this.settings.fillGradient = null;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setStroke(color = "#FFF", width = 0, alpha = 1) {
      var e;
      try {
        this.settings.strokeColor = color;
        this.settings.strokeAlpha = alpha;
        this.settings.strokeWidth = width;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 100, height = 100) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        this._applySettings();
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.graphics = new PIXI.Graphics();
        return this.addChild(this.graphics);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var cornersSettings, e, gradientSettings;
      try {
        if (this.graphics == null) {
          return;
        }
        this.graphics.clear();
        if (this.settings.fillGradient != null) {
          gradientSettings = Object.assign(this.defaultGradientSettings(), this.settings.fillGradient);
        }
        this._applyGradientTexture(gradientSettings);
        if (typeof this.settings.corners === "number") {
          return this._drawBaseRoundedRect();
        } else if (this.settings.corners != null) {
          cornersSettings = Object.assign(this.defaultCornersSettings(), this.settings.corners);
          return this._drawComplexRoundedRect(cornersSettings);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyGradientTexture(fillGradient) {
      var c, convertedValue, ctx, e, grd, height, key, texture, value, width;
      try {
        if (KDCore.isMV()) {
          return;
        }
        ({width, height} = this.settings);
        c = document.createElement("canvas");
        ctx = c.getContext("2d");
        grd = ctx.createLinearGradient(this.settings.gradientStart.x, this.settings.gradientStart.y, this.settings.gradientEnd.x, this.settings.gradientEnd.y);
        for (key in fillGradient) {
          value = fillGradient[key];
          try {
            convertedValue = this._convertGradientStopColor(value);
            grd.addColorStop(Number(key), convertedValue);
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);
        texture = new PIXI.Texture.from(c);
        return this.graphics.beginTextureFill(texture);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _convertGradientStopColor(color) {
      var alpha, c, e, parts;
      try {
        if (color == null) {
          return "#FFF";
        }
        if (!String.any(color)) {
          return "#FFF";
        }
        if (color.contains("%")) {
          parts = color.split("%");
          color = parts[0];
          alpha = Number(parts[1]);
          c = KDCore.Color.FromHex(color);
          c = c.reAlpha(alpha * 255);
          return c.CSS;
        } else {
          return color;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "#FFF";
      }
    }

    _drawBaseRoundedRect() {
      var colorData, corners, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, width;
      try {
        ({width, height, corners} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          // * Base Fill
          this._drawRect(0, 0, width, height, corners, colorData);
          // * Stroke
          return this._drawStroke(-d / 2, -d / 2, width + d / 2, height + d / 2, corners, d, strokeColorData);
        } else {
          // * Base Fill only
          return this._drawRect(0, 0, width, height, corners, colorData);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _buildColorData(c = 0xfff, a = 1) {
      var e;
      try {
        if (typeof c === 'string') {
          c = KDCore.Utils.string2hex(c);
        }
        return [c, a];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0xfff, 1];
      }
    }

    _drawRect(x, y, w, h, r, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        if (!this.isHaveGradient()) {
          g.beginFill(...colorData);
        }
        if (r > 0) {
          g.drawRoundedRect(x, y, w, h, r);
        } else {
          g.drawRect(x, y, w, h);
        }
        if (!this.isHaveGradient()) {
          return g.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawStroke(x, y, w, h, r, d, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        g.lineStyle(d, ...colorData);
        if (r > 0) {
          return g.drawRoundedRect(x, y, w, h, r);
        } else {
          return g.drawRect(x, y, w, h);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexRoundedRect(cornersSettings) {
      var bottomLeft, bottomRight, colorData, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, topLeft, topRight, width;
      try {
        if (cornersSettings == null) {
          return;
        }
        ({width, height} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        ({topLeft, topRight, bottomRight, bottomLeft} = cornersSettings);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          this._drawComplexRect(0, 0, width, height, colorData, topLeft, topRight, bottomRight, bottomLeft);
          return this._drawComplexStroke(-d / 2, -d / 2, width + (d / 2), height + (d / 2), strokeColorData, d, topLeft, topRight, bottomRight, bottomLeft);
        } else {
          return this._drawComplexRect(0, 0, width, height, colorData, topLeft, topRight, bottomRight, bottomLeft);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexRect(x, y, width, height, colorData, topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius) {
      var e;
      try {
        if (!this.isHaveGradient()) {
          this.graphics.beginFill(...colorData);
        }
        // Starting from the top left corner.
        this.graphics.moveTo(x + topLeftRadius, y);
        // Drawing the top line with top right corner.
        this.graphics.lineTo(x + width - topRightRadius, y);
        if (topRightRadius > 0) {
          this.graphics.quadraticCurveTo(x + width, y, x + width, y + topRightRadius);
        }
        // Drawing the right line with bottom right corner.
        this.graphics.lineTo(x + width, y + height - bottomRightRadius);
        if (bottomRightRadius > 0) {
          this.graphics.quadraticCurveTo(x + width, y + height, x + width - bottomRightRadius, y + height);
        }
        // Drawing the bottom line with bottom left corner.
        this.graphics.lineTo(x + bottomLeftRadius, y + height);
        if (bottomLeftRadius > 0) {
          this.graphics.quadraticCurveTo(x, y + height, x, y + height - bottomLeftRadius);
        }
        // Drawing the left line with top left corner and closing the shape.
        this.graphics.lineTo(x, y + topLeftRadius);
        if (topLeftRadius > 0) {
          this.graphics.quadraticCurveTo(x, y, x + topLeftRadius, y);
        }
        if (!this.isHaveGradient()) {
          return this.graphics.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexStroke(x, y, width, height, colorData, d, topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius) {
      var e, graphics;
      try {
        graphics = this.graphics;
        graphics.lineStyle(d, ...colorData);
        // Starting from the top left corner.
        graphics.moveTo(x + topLeftRadius, y);
        // Drawing the top line with top right corner.
        graphics.lineTo(x + width - topRightRadius, y);
        if (topRightRadius > 0) {
          graphics.quadraticCurveTo(x + width, y, x + width, y + topRightRadius);
        }
        // Drawing the right line with bottom right corner.
        graphics.lineTo(x + width, y + height - bottomRightRadius);
        if (bottomRightRadius > 0) {
          graphics.quadraticCurveTo(x + width, y + height, x + width - bottomRightRadius, y + height);
        }
        // Drawing the bottom line with bottom left corner.
        graphics.lineTo(x + bottomLeftRadius, y + height);
        if (bottomLeftRadius > 0) {
          graphics.quadraticCurveTo(x, y + height, x, y + height - bottomLeftRadius);
        }
        // Drawing the left line with top left corner and closing the shape.
        graphics.lineTo(x, y + topLeftRadius);
        if (topLeftRadius > 0) {
          graphics.quadraticCurveTo(x, y, x + topLeftRadius, y);
        }
        return graphics.closePath();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        return this.height = this.settings.height;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_BaseRect = Sprite_BaseRect;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ButtonsGroup;
  // * Класс для реализации набора кнопок переключателей (Tabs)
  // * Когда только одна кнопка может быть нажата (выбрана)

    //rev 07.10.21
  Sprite_ButtonsGroup = class Sprite_ButtonsGroup extends KDCore.Sprite {
    // buttonsArray = [
    //       {image: NAME, position: [X,Y]}, ...
    //    ]
    constructor(buttonsArray, activeIndex, clickCallback) {
      var button, i, len;
      super();
      this.clickCallback = clickCallback;
      this._buttons = [];
      for (i = 0, len = buttonsArray.length; i < len; i++) {
        button = buttonsArray[i];
        this._createButton(button);
      }
      this._onButtonClick(activeIndex);
      return;
    }

    getSelectedIndex() {
      return this._buttons.findIndex(function(btn) {
        return !btn.isEnabled();
      });
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ButtonsGroup.prototype;
    _._createButton = function({image, position}) {
      var btn, index, method;
      // * Так как кнопки работают как переключатели, то 03 должен быть всегда
      index = this._buttons.length;
      btn = new KDCore.ButtonM(image, true, "Alpha");
      btn.move(position);
      method = () => {
        return this._onButtonClick(index);
      };
      btn.addClickHandler(method);
      this._buttons.push(btn);
      this.add(btn);
    };
    _._onButtonClick = function(index = 0) {
      var ref;
      this._resetAllButtons();
      if ((ref = this._buttons[index]) != null) {
        ref.disable(); // * Нажата
      }
      if (this.clickCallback != null) {
        this.clickCallback(index);
      }
    };
    _._resetAllButtons = function() {
      var btn, i, len, ref;
      ref = this._buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        btn = ref[i];
        if (btn != null) {
          btn.enable();
        }
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ButtonsGroup = Sprite_ButtonsGroup;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ButtonsGroupHandler;
  // * Класс для реализации набора кнопок переключателей (Tabs)
  // * Когда только одна кнопка может быть нажата (выбрана)
  // * В отличии от Sprite_ButtonsGroup, принимает массив
  // * уже созданных кнопок

    //rev 10.07.22
  Sprite_ButtonsGroupHandler = class Sprite_ButtonsGroupHandler extends KDCore.Sprite {
    // _buttons = [Button object with enable, disable, isEnable, addClickHandler methods]
    constructor(_buttons, clickCallback, activeIndex = 0) {
      var button, i, index, len, ref;
      super();
      this._buttons = _buttons;
      this.clickCallback = clickCallback;
      ref = this._buttons;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        button = ref[index];
        this._processButton(button, index);
      }
      this._onButtonClick(activeIndex);
      return;
    }

    getSelectedIndex() {
      return this._buttons.findIndex(function(btn) {
        return !btn.isEnabled();
      });
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ButtonsGroupHandler.prototype;
    _._processButton = function(btn, index) {
      var method;
      // * Так как кнопки работают как переключатели, то 03 должен быть всегда
      method = () => {
        return this._onButtonClick(index);
      };
      btn.addClickHandler(method);
      this.add(btn);
    };
    _._onButtonClick = function(index = 0) {
      var ref;
      this._resetAllButtons();
      if ((ref = this._buttons[index]) != null) {
        ref.disable(); // * Нажата
      }
      if (this.clickCallback != null) {
        this.clickCallback(index);
      }
    };
    _._resetAllButtons = function() {
      var btn, i, len, ref;
      ref = this._buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        btn = ref[i];
        if (btn != null) {
          btn.enable();
        }
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ButtonsGroupHandler = Sprite_ButtonsGroupHandler;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Gauge;
  //NUI 1.1
  //rev 16.06.24

    //"type": "gauge"
  Sprite_Gauge = class Sprite_Gauge extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._loaded = false;
      this._lastValue = 1;
      this._gaugeBaseLayer = new KDCore.Sprite();
      this.add(this._gaugeBaseLayer);
      this._applySettings();
      return;
    }

    defaultSettings() {
      return {
        fillMode: "color", //image, plane, color
        fillColor: "#ffffff",
        fillOpacity: 255,
        imageName: "", // * for fill, if fillMode is image, for plane if fillMode is plane
        folderName: "pictures",
        margins: 2, // * For plane image
        width: "auto",
        height: "auto",
        mask: "",
        backColor: "#000000",
        backImage: "",
        backOpacity: 255,
        vertical: false
      };
    }

    isLoaded() {
      var e;
      try {
        return this._loaded === true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    realWidth() {
      var e;
      try {
        if (this.settings.width !== "auto") {
          return this.settings.width;
        } else if (this._gaugeSpr != null) {
          return this._gaugeSpr.realWidth(); //TODO: Gauge Modes
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.width;
    }

    realHeight() {
      var e;
      try {
        if (this.settings.height !== "auto") {
          return this.settings.height;
        } else if (this._gaugeSpr != null) {
          return this._gaugeSpr.realHeight(); //TODO: Gauge Modes
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        rate: function(v) {
          if (v != null) {
            return this.draw(v);
          }
        },
        fillImage: function(v) {
          if (v != null) {
            return this.setFillImage(v);
          }
        },
        fillColor: function(v) {
          if (v != null) {
            return this.setFillColor(v);
          }
        },
        fillOpacity: function(v) {
          if (v != null) {
            return this.setFillOpacity(v);
          }
        }
      });
    }

    //TODO:!
    //backImage: (v) ->
    //backColor: (v) ->
    //backOpacity: (v) ->
    draw(percent = 1) {
      var e;
      try {
        if (!this.isLoaded()) {
          this._requireFunc('draw', arguments);
          return;
        }
        this._lastValue = percent;
        return this._drawGauge(percent);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillOpacity(opacity) {
      var e, ref;
      try {
        this.settings.fillOpacity = opacity;
        return (ref = this.fillLayer) != null ? ref.opacity = opacity : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillColor(color) {
      var e;
      try {
        this.settings.fillColor = color;
        if (this.fillColorBitmap != null) {
          this._createColorGaugeFillColorBitmap();
          return this._drawGauge(this._lastValue);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillImage(imageName) {
      var e;
      try {

      } catch (error) {
        //TODO:
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var e;
      try {
        this._loaded = false;
        this._destroyExistGauge();
        this._createGaugeFromSettings();
        return this.draw(this._lastValue);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyExistGauge() {
      var e;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        this._gaugeSpr.removeFromParent();
        return this._gaugeSpr = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createGaugeFromSettings() {
      var e;
      try {
        this._gaugeSpr = new KDCore.Sprite();
        this._gaugeBaseLayer.add(this._gaugeSpr);
        switch (this.settings.fillMode) {
          case "image":
            return this._createImageGauge();
          case "plane":
            return this._createPlaneGauge();
          case "color":
            return this._createColorGauge();
          default:
            return console.warn("Unknown Gauge fillMode: " + this.settings.fillMode);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createImageGauge() {
      var e;
      try {
        this._gaugeSourceImage = new KDCore.Sprite_Image({
          imageName: this.settings.imageName,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
        return this._gaugeSourceImage.addLoadListener(this._onGaugeFillImageLoaded.bind(this));
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onGaugeFillImageLoaded() {
      var e;
      try {
        this._addBackground(this._gaugeSourceImage.realWidth(), this._gaugeSourceImage.realHeight());
        this.fillLayer = KDCore.Sprite.FromBitmap(this._gaugeSourceImage.realWidth(), this._gaugeSourceImage.realHeight());
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onGaugeLoadedAndReady() {
      var e;
      try {
        this._loaded = true;
        this.width = this.realWidth();
        this.height = this.realHeight();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createPlaneGauge() {
      var e;
      try {
        if (this.settings.width === "auto") {
          // * Нельзя создать Plane Gauge с auto размером, поэтому задаём стандартные значения
          this.settings.width = 80;
        }
        if (this.settings.height === "auto") {
          this.settings.height = 20;
        }
        this._addBackground(this.settings.width, this.settings.height);
        this.fillLayer = new KDCore.Sprite_Plane({
          imageName: this.settings.imageName,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height,
          margins: this.settings.margins
        });
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createColorGauge() {
      var e;
      try {
        if (this.settings.width === "auto") {
          // * Нельзя создать цветную Gauge с auto размером, поэтому задаём стандартные значения
          this.settings.width = 80;
        }
        if (this.settings.height === "auto") {
          this.settings.height = 20;
        }
        this._addBackground(this.settings.width, this.settings.height);
        this.fillLayer = KDCore.Sprite.FromBitmap(this.settings.width, this.settings.height);
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._createColorGaugeFillColorBitmap();
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createColorGaugeFillColorBitmap() {
      var e;
      try {
        this.fillColorBitmap = new Bitmap(this.settings.width, this.settings.height);
        return this.fillColorBitmap.fillAll(this.settings.fillColor);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _addBackground(width, height) {
      var background, e;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        background = null;
        if (String.any(this.settings.backImage)) {
          background = this._createGaugeBackgroundImage();
        } else if (String.any(this.settings.backColor)) {
          background = this._createGaugeBackgroundColor(width, height, this.settings.backColor);
        }
        if (background != null) {
          if (this.settings.backOpacity != null) {
            background.opacity = this.settings.backOpacity;
          }
          return this._gaugeSpr.add(background);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _addMask() {
      var e, gaugeMask;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        if (String.isNullOrEmpty(this.settings.mask)) {
          return;
        }
        gaugeMask = new KDCore.Sprite_Image({
          imageName: this.settings.mask,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
        this._gaugeSpr.mask = gaugeMask.image;
        this._gaugeSpr.add(gaugeMask);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this._gaugeSpr.mask = null;
      }
    }

    _createGaugeBackgroundColor(width, height, color) {
      var background, e;
      try {
        background = KDCore.Sprite.FromBitmap(width, height);
        background.b().fillAll(color);
        return background;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite();
      }
    }

    _createGaugeBackgroundImage() {
      var e;
      try {
        return new KDCore.Sprite_Image({
          imageName: this.settings.backImage,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite();
      }
    }

    _drawGauge(percent) {
      var e;
      try {
        if (this.fillLayer == null) {
          return;
        }
        // * See COE, Fill Indicator
        //if @settings.vertical is true
        //TODO: VERTICAL
        //else
        return this._drawHorizontal(percent);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawHorizontal(percent) {
      var e;
      try {
        switch (this.settings.fillMode) {
          case "image":
            return this._drawImageGauge(percent);
          case "plane":
            return this._drawPlaneGauge(percent);
          case "color":
            return this._drawColorGauge(percent);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawImageGauge(percent) {
      var e, fillBitmap;
      try {
        this.fillLayer.clear();
        fillBitmap = this._gaugeSourceImage.image.bitmap;
        return this._drawGaugeBitmapBased(percent, fillBitmap);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawGaugeBitmapBased(percent, fillBitmap) {
      var e, h, w;
      try {
        w = this.realWidth() * percent;
        h = this.realHeight();
        return this.fillLayer.b().blt(fillBitmap, 0, 0, w, h, 0, 0);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawColorGauge(percent) {
      var e, fillBitmap;
      try {
        this.fillLayer.clear();
        fillBitmap = this.fillColorBitmap;
        return this._drawGaugeBitmapBased(percent, fillBitmap);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawPlaneGauge(percent) {
      var e, h, w;
      try {
        w = this.realWidth() * percent;
        h = this.realHeight();
        return this.fillLayer.setSize(w, h);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Gauge = Sprite_Gauge;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Group;
  //NUI 1.0
  //rev 30.04.24
  Sprite_Group = class Sprite_Group extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      if (this.settings.horizontalNavigation === true) {
        this.pIsVerticalKeyboardNavigation = function() {
          return false;
        };
      }
      this._applySettings();
      this._onResize();
      return;
    }

    update() {
      var e;
      super.update();
      try {
        if (this._isNeedWaitLoadingChild === true) {
          //console.log("REFRESH BY LOAD")
          return this.refreshBindings(this._dataObjectRef, true);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    refreshBindings(dataObject, recursive) {
      var c, i, len, ref;
      super.refreshBindings(...arguments);
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if ((c.isLoaded != null) && !c.isLoaded()) {
          this._startWaitLoading(dataObject);
          return;
        }
      }
      this._isNeedWaitLoadingChild = false;
    }

    _startWaitLoading(_dataObjectRef) {
      var e;
      this._dataObjectRef = _dataObjectRef;
      try {
        return this._isNeedWaitLoadingChild = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    defaultSettings() {
      return {
        keyboardHandling: false,
        horizontalNavigation: false,
        width: "auto",
        height: "auto"
      };
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    realWidth() {
      var e;
      try {
        if (this.settings.width === "auto") {
          return this._calculateMax("x", "width");
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.width;
    }

    realHeight() {
      var e;
      try {
        if (this.settings.height === "auto") {
          return this._calculateMax("y", "height");
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.height;
    }

    _calculateMax(a, b) {
      var child, e, i, len, ref, size, value;
      try {
        value = 0;
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          size = child[a] + KDCore.Utils.getRealSpriteSize(b, child);
          if (size > value) {
            value = size;
          }
        }
        if (value < 0) {
          value = 0;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return 0;
      }
      return value;
    }

    _applySettings() {
      var e;
      try {
        if (this.settings.keyboardHandling === true) {
          return this.activateHandlerManagment();
        } else {
          return this.deactivateHandlerManagment();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.realWidth();
        return this.height = this.realHeight();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Group = Sprite_Group;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Image;
  //NUI 1.0
  //rev 29.04.24

    //"type": "image"
  Sprite_Image = class Sprite_Image extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._loaded = false;
      this._create();
      this._onResize();
      this.draw(this.settings.imageName);
      return;
    }

    isLoaded() {
      var e;
      try {
        if (this.settings.width !== "auto" && this.settings.height !== "auto") {
          return true;
        } else {
          return this._loaded === true;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    defaultSettings() {
      return {
        imageName: "",
        folderName: "pictures",
        width: "auto",
        height: "auto",
        keepAspect: false
      };
    }

    realWidth() {
      var e;
      try {
        if (this.settings.width === "auto") {
          if (this._srcBitmap != null) {
            return this._srcBitmap.width;
          } else {
            if ((this.image.bitmap != null) && this.image.bitmap.isReady()) {
              return this.image.bitmap.width;
            }
          }
        } else {
          return this.settings.width;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.width;
    }

    realHeight() {
      var e;
      try {
        if (this.settings.height === "auto") {
          if (this._srcBitmap != null) {
            return this._srcBitmap.height;
          } else {
            if ((this.image.bitmap != null) && this.image.bitmap.isReady()) {
              return this.image.bitmap.height;
            }
          }
        } else {
          return this.settings.height;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        image: function(v) {
          return this.draw(v);
        },
        icon: function(v) {
          return this.drawIcon(v);
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setImage(imageName, folderName = null) {
      var e;
      try {
        if (String.any(folderName)) {
          this.settings.folderName = folderName;
        }
        return this.draw(imageName);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Если не иконка (число), то ничего не рисует (защита)
    drawIcon(iconIndex) {
      var e;
      try {
        if (isFinite(iconIndex)) {
          return this.draw(iconIndex);
        } else {
          return this.draw("");
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    draw(imageName = "") {
      var e;
      try {
        if (isFinite(imageName)) {
          return this._drawIcon(imageName);
        } else if (String.any(imageName)) {
          return this._drawImage(imageName);
        } else {
          this._srcBitmap = null;
          return this._onResize();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.image = new KDCore.Sprite(new Bitmap(1, 1));
        return this.addChild(this.image);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawIcon(iconIndex) {
      var e, w;
      try {
        w = this.settings.width;
        if (w === "auto") {
          w = 32;
        }
        this.settings.height = w;
        this._srcBitmap = new Bitmap(w, w);
        this._srcBitmap.drawIcon(0, 0, iconIndex, w, true);
        this._loaded = true;
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawImage(imageName) {
      var e, folderName;
      try {
        ({folderName} = this.settings);
        this._loaded = false;
        this._srcBitmap = ImageManager.loadBitmap('img/' + folderName + "/", imageName);
        return this._srcBitmap.addLoadListener(this._onBitmapLoaded.bind(this));
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onBitmapLoaded() {
      var e;
      try {
        this._loaded = true;
        this._onResize();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var b, e, fh, fw, height, width;
      try {
        this.image.bitmap = new Bitmap(this.realWidth(), this.realHeight());
        if (this._srcBitmap == null) {
          return;
        }
        b = this._srcBitmap;
        if (this.settings.keepAspect === true) {
          ({width, height} = this._calculateAspectRatio(this.image.bitmap.width, this.image.bitmap.height, this._srcBitmap.width, this._srcBitmap.height));
          fw = width;
          fh = height;
        } else {
          fw = this.realWidth();
          fh = this.realHeight();
        }
        return this.image.bitmap.blt(b, 0, 0, b.width, b.height, 0, 0, fw, fh);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _calculateAspectRatio(containerWidth, containerHeight, width, height) {
      var aspectRatio, containerAspectRatio, e;
      try {
        aspectRatio = width / height;
        containerAspectRatio = containerWidth / containerHeight;
        if (aspectRatio > containerAspectRatio) {
          width = containerWidth;
          height = width / aspectRatio;
        } else {
          height = containerHeight;
          width = height * aspectRatio;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return {width, height};
    }

  };
  return KDCore.Sprite_Image = Sprite_Image;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ImgButton;
  //NUI 1.0
  //rev 25.04.24

    //"type": "legacyButton"
  Sprite_ImgButton = class Sprite_ImgButton extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      return;
    }

    defaultSettings() {
      return {
        width: "auto",
        height: "auto",
        imageName: "",
        isFull: false,
        folderName: "pictures",
        isCheckAlpha: false,
        handler: null
      };
    }

    isLoaded() {
      var e;
      try {
        if (this.settings.width !== "auto" && this.settings.height !== "auto") {
          return true;
        } else {
          return this._loaded === true;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    realWidth() {
      var e;
      try {
        if (this.settings.width === "auto") {
          return this.button.realWidth();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.width;
    }

    realHeight() {
      var e;
      try {
        if (this.settings.height === "auto") {
          return this.button.realHeight();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        image: function(v) {
          return this.setImage(v);
        },
        enable: function(v) {
          if (v != null) {
            return this.setEnabledState(v);
          }
        },
        handler: function(v) {
          return this.setClickHandler(v);
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setImage(imageName = "") {
      var e;
      try {
        if (this.button != null) {
          this._lastButtonState = this.button.isEnabled();
          this._lastButtonHandler = this.button._handler;
        }
        this.settings.imageName = imageName;
        this._create();
        // * Может не быть кнопки, если imageName == ""
        if (this.button == null) {
          return;
        }
        if (this._lastButtonState != null) {
          this.setEnabledState(this._lastButtonState);
          this._lastButtonState = null;
        }
        if (this._lastButtonHandler != null) {
          this.setClickHandler(this._lastButtonHandler);
          return this._lastButtonHandler = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setEnabledState(state = true) {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        if (state === true) {
          return this.button.enable();
        } else {
          return this.button.disable();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * В отличии от AddClickHandler, удаляет все предидущие
    setClickHandler(handler) {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        this.button.clearClickHandler();
        if ((handler != null) && typeof handler === "function") {
          return this.button.addClickHandler(handler);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * EXPAND FIELDS
    click() {
      var ref;
      return (ref = this.button) != null ? ref.click() : void 0;
    }

    setManualHover() {
      var ref;
      return (ref = this.button) != null ? ref.setManualHover() : void 0;
    }

    disableManualHover() {
      var ref;
      return (ref = this.button) != null ? ref.disableManualHover() : void 0;
    }

    setManualSelected() {
      var ref;
      return (ref = this.button) != null ? ref.setManualSelected(...arguments) : void 0;
    }

    enableClick() {
      var ref;
      return (ref = this.button) != null ? ref.enableClick() : void 0;
    }

    disableClick() {
      var ref;
      return (ref = this.button) != null ? ref.disableClick() : void 0;
    }

    desaturate() {
      var ref;
      return (ref = this.button) != null ? ref.desaturate() : void 0;
    }

    isMouseIn() {
      return (this.button != null) && this.button.isMouseIn();
    }

    isActive() {
      return (this.button != null) && this.button.isActive();
    }

    isDisabled() {
      return this.isEnabled();
    }

    isEnabled() {
      return (this.button != null) && this.button.isEnabled();
    }

    addClickHandler() {
      return this.setClickHandler(...arguments);
    }

    clearClickHandler() {
      var ref;
      return (ref = this.button) != null ? ref.clearClickHandler() : void 0;
    }

    simulateClick() {
      var ref;
      return (ref = this.button) != null ? ref.simulateClick() : void 0;
    }

    refreshState() {
      var ref;
      return (ref = this.button) != null ? ref.refreshState(...arguments) : void 0;
    }

    disable() {
      var ref;
      return (ref = this.button) != null ? ref.disable() : void 0;
    }

    enable() {
      var ref;
      return (ref = this.button) != null ? ref.disable() : void 0;
    }

    // * ==============
    _create() {
      var e;
      try {
        this._loaded = false;
        if (this.button != null) {
          this._destroyButton();
        }
        if (!String.any(this.settings.imageName)) {
          return;
        }
        this.button = new KDCore.ButtonM(this.settings.imageName, this.settings.isFull, this.settings.folderName);
        if (this.settings.isCheckAlpha === true) {
          this.button.isCheckAlpha = function() {
            return true;
          };
        }
        if (this.settings.handler != null) {
          this.setClickHandler(this.settings.handler);
        }
        this.button.addLoadListener(this._onLoaded.bind(this));
        return this.addChild(this.button);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onLoaded() {
      var e;
      try {
        this._loaded = true;
        this._onResize();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyButton() {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        this.button.removeFromParent();
        this._loaded = false;
        if ($gameTemp.kdButtonUnderMouse === this.button) {
          return $gameTemp.kdButtonUnderMouse = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.realWidth();
        return this.height = this.realHeight();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_ImgButton = Sprite_ImgButton;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsList;
  // * Класс который позволяет сделать список (на основе Window_Selectable), но из Sprite элементов, а не Draw на Bitmap

    //rev 02.05.24

    //TODO: Dynamic items height, controls handlers support
  Sprite_ItemsList = class Sprite_ItemsList extends Window_Selectable {
    constructor(r, settings = {}) {
      if (KDCore.isMV()) {
        super(r.x, r.y, r.width, r.height);
      } else {
        super(r);
      }
      this.settings = Object.assign(this.defaultSetting(), settings);
      this.padding = this.settings.itemsPadding;
      this._prevSelectedIndex = -1;
      this._createItemsContainer();
      this._createWindowContentMask();
      this._setupBackgroundType();
      return;
    }

    defaultSetting() {
      return {
        maxCols: 1,
        isHaveSelectionEffect: false,
        selectionEffects: ["glow;distance:12;outerStrength:3"],
        scaleItemsWidth: false,
        scaleItemsHeight: false,
        defautItemHeight: 36,
        isDrawDefaultItemBack: false,
        backgroundType: 2,
        itemsPadding: 12,
        isHaveInOutAnimation: false,
        inAnimation: "field:x;duration:0.15;keyframes:0=0,100=4",
        outAnimation: "field:x;duration:0.15;keyframes:0=4,100=0"
      };
    }

    activate(index) {
      var e;
      try {
        this.refresh();
        if (index != null) {
          this.safeSelect(index);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return super.activate();
    }

    maxItems() {
      return this.getAllItems().length;
    }

    maxCols() {
      if (this.settings != null) {
        return this.settings.maxCols || 1;
      } else {
        return 1;
      }
    }

    getAllItems() {
      return this.itemsSet || [];
    }

    setItems(itemsSet, singleItemHeight = null) {
      this.itemsSet = itemsSet;
      this.singleItemHeight = singleItemHeight;
      this._prevSelectedIndex = -1;
      this.setTopRow(0);
      this._clearPreviousItems();
      if (this.singleItemHeight == null) {
        this._adjustAutoItemsHeight(this.itemsSet[0]);
      }
      this.refresh();
      this._drawNewItems();
    }

    selectedItem() {
      return this.itemAt(this.index());
    }

    setOkHandler(handler) {
      return this.setHandler('ok', handler);
    }

    setCancelHandler(handler) {
      return this.setHandler('cancel', handler);
    }

    setSelectionHandler(handler) {
      return this.pOnSelectionChanged = handler;
    }

    itemAt(index) {
      return this.getAllItems()[index];
    }

    isNeedScaleItemsW() {
      return this.settings.scaleItemsWidth === true;
    }

    isNeedScaleItemsH() {
      return this.settings.scaleItemsHeight === true;
    }

    // * NOT WORKS!!!
    isUseDynamicHeight() {
      return false;
    }

    lineHeight(index) {
      if (this.settings != null) {
        return this.singleItemHeight || this.settings.defautItemHeight;
      } else {
        return this.singleItemHeight || 36;
      }
    }

    isDrawWindowDefaultItemsBack() {
      return this.settings.isDrawDefaultItemBack === true;
    }

    //$[OVER]
    _updateCursor() {
      if (KDCore.isMV()) {
        return this.setCursorRect(0, 0, 0, 0);
      } else {
        return this._cursorSprite.visible = false;
      }
    }

    update() {
      super.update();
      this._itemsContainer.y = -this._scrollY;
      return this._updateItemsSelectionState();
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ItemsList.prototype;
    _._createItemsContainer = function() {
      var ref;
      if (!this.isDrawWindowDefaultItemsBack()) {
        if ((ref = this._contentsBackSprite) != null) {
          ref.visible = false;
        }
      }
      this._windowItemsContentLayer = new Sprite();
      this._windowItemsContentLayer.move(this._padding, this._padding);
      this.addChild(this._windowItemsContentLayer);
      this._itemsContainer = new KDCore.Sprite();
      this._windowItemsContentLayer.addChild(this._itemsContainer);
      this.addChild(this._downArrowSprite);
      return this.addChild(this._upArrowSprite);
    };
    _._setupBackgroundType = function() {
      return this.setBackgroundType(this.settings.backgroundType);
    };
    _._createWindowContentMask = function() {
      var e, m, maskBitmap;
      try {
        maskBitmap = new Bitmap(this.width - this._padding * 2, this.height - this._padding * 2);
        maskBitmap.fillAll("#FFF");
        m = new Sprite(maskBitmap);
        this._windowItemsContentLayer.mask = m;
        return this._windowItemsContentLayer.addChild(m);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._adjustAutoItemsHeight = function(item) {
      var e;
      try {
        if (item == null) {
          this.singleItemHeight = 36;
          return;
        }
        if (item.realHeight != null) {
          this.singleItemHeight = item.realHeight();
        } else {
          if (item.height > 0) {
            this.singleItemHeight = item.height;
          }
        }
        if (this.singleItemHeight === 0 || !this.singleItemHeight) {
          return this.singleItemHeight = 36;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._clearPreviousItems = function() {
      var c, e, i, j, len, len1, ref, results, toRemove;
      try {
        toRemove = [];
        ref = this._itemsContainer.children;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          toRemove.push(c);
        }
        results = [];
        for (j = 0, len1 = toRemove.length; j < len1; j++) {
          c = toRemove[j];
          results.push(c.removeFromParent());
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._drawNewItems = function() {
      var e, i, index, item, len, ref, results;
      try {
        ref = this.getAllItems();
        results = [];
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          item = ref[index];
          results.push(this._addNewItemToList(item, index));
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._addNewItemToList = function(item, index) {
      var e, rect;
      try {
        if (item == null) {
          return;
        }
        rect = this.itemRect(index);
        item.x = rect.x;
        item.y = rect.y;
        this._adjustItemWidthAndHeight(item);
        return this._itemsContainer.addChild(item);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._adjustItemWidthAndHeight = function(item) {
      var e, scaleFactor;
      try {
        if (item == null) {
          return;
        }
        if (this.isNeedScaleItemsW()) {
          scaleFactor = this._defaultItemWidth() / this._getItemWidth(item);
          item.scale.x = scaleFactor;
        }
        if (this.isNeedScaleItemsH()) {
          scaleFactor = this.lineHeight() / this._getItemHeight(item);
          return item.scale.y = scaleFactor;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getItemWidth = function(item) {
      var e, v;
      v = this._defaultItemWidth();
      try {
        if (item == null) {
          return v;
        }
        if (item.realWidth != null) {
          v = item.realWidth();
        } else {
          if (item.width > 0) {
            v = item.width;
          }
        }
        if (v === 0 || !v) {
          v = this._defaultItemWidth();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return v;
    };
    _._defaultItemWidth = function() {
      return this.width - this._padding * 2;
    };
    _._getItemHeight = function(item) {
      var e, v;
      v = 36;
      try {
        if (item == null) {
          return v;
        }
        if (item.realHeight != null) {
          v = item.realHeight();
        } else {
          if (item.height > 0) {
            v = item.height;
          }
        }
        if (v === 0 || !v) {
          v = 36;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return v;
    };
    _._updateItemsSelectionState = function() {
      var e;
      try {
        if (KDCore.isMZ()) {
          if (!this.active || this.index() < 0 || !this.cursorVisible) {
            this._disableSelectionForAll();
            return;
          }
        } else {
          if (!this.active || this.index() < 0 || !this.isCursorVisible()) {
            this._disableSelectionForAll();
            return;
          }
        }
        return this._selectItemAtIndex(this.index());
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._disableSelectionForAll = function() {
      var e, i, item, len, ref, results;
      try {
        if (this._prevSelectedIndex === -2) {
          return;
        }
        this._prevSelectedIndex = -2;
        ref = this.getAllItems();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(this._deselectItem(item));
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItem = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if ((this._prevSelectedIndex != null) && this._prevSelectedIndex >= 0) {
          this._deselectItem(this.itemAt(this._prevSelectedIndex));
        }
        this._playItemInAnimation(item);
        if (item.activateInList != null) {
          return item.activateInList();
        } else {
          return this._selectItemVisually(item);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemInAnimation = function(item) {
      var e;
      try {
        if (!this.settings.isHaveInOutAnimation) {
          return;
        }
        if (this.settings.inAnimation == null) {
          return;
        }
        if (item == null) {
          return;
        }
        this._playItemAnimation(item, this.settings.inAnimation);
        return this._isHaveInAnimation = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItemVisually = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if (!this.settings.isHaveSelectionEffect) {
          return;
        }
        //item.filters = [new PIXI.filters.GlowFilter({ distance: 15, outerStrength: 4 })]
        if (this.settings.selectionEffects == null) {
          return;
        }
        if (this.settings.selectionEffects.length === 0) {
          return;
        }
        KDCore.UI.Builder.ApplyEffects(item, this.settings.selectionEffects);
        return this._isSelectionEffectBeenAdded = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._deselectItem = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        this._playItemOutAnimation(item);
        if (item.deactivateInList != null) {
          return item.deactivateInList();
        } else {
          return this._deselectItemVisually(item);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemOutAnimation = function(item) {
      var e;
      try {
        if (!this.settings.isHaveInOutAnimation) {
          return;
        }
        if (!this._isHaveInAnimation) {
          return;
        }
        if (this.settings.outAnimation == null) {
          return;
        }
        if (item == null) {
          return;
        }
        this._playItemAnimation(item, this.settings.outAnimation);
        return this._isHaveInAnimation = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemAnimation = function(item, animation) {
      var e, root;
      try {
        if (item == null) {
          return;
        }
        root = item.children[0];
        if (root == null) {
          return;
        }
        if (typeof animation === "string") {
          animation = KDCore.UI.Builder.ConvertShortcut(animation);
        }
        return root.setAnimationRule(animation);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._deselectItemVisually = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if (this._isSelectionEffectBeenAdded === true) {
          item.filters = [];
          return this._isSelectionEffectBeenAdded = false;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItemAtIndex = function(index) {
      var e, item;
      try {
        if (this._prevSelectedIndex !== index) {
          item = this.itemAt(index);
          if (item == null) {
            return;
          }
          this._selectItem(item);
          return this._prevSelectedIndex = index;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ItemsList = Sprite_ItemsList;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsListN;
  //NUI 1.0
  //rev 03.05.24

    //type: "list"
  // * Этот класс служит только как Wrapper, чтобы можно было задавать настроки List через NUI схему
  Sprite_ItemsListN = class Sprite_ItemsListN extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign(this.defaultSettings(), settings);
      this._applySettings();
      return;
    }

    defaultSettings() {
      return Object.assign({
        width: 240,
        height: 420
      }, KDCore.Sprite_ItemsList.prototype.defaultSetting());
    }

    /* (See parent class, this is just for reference)
           defaultSetting: -> {
               maxCols: 1,
               isHaveSelectionEffect: false,
               selectionEffects: ["glow;distance:12;outerStrength:3"],
               scaleItemsWidth: false,
               scaleItemsHeight: false,
               defautItemHeight: 36,
               isDrawDefaultItemBack: false,
               backgroundType: 2,
               itemsPadding: 12,
               isHaveInOutAnimation: false,
               inAnimation: "field:x;duration:0.15;keyframes:0=0,100=4",
               outAnimation: "field:x;duration:0.15;keyframes:0=4,100=0"
           }*/
    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        maxCols: function(v) {
          if (v != null) {
            return this.setMaxCols(v);
          }
        }
      });
    }

    realWidth() {
      return this.settings.width;
    }

    realHeight() {
      return this.settings.height;
    }

    setSize(width, height) {
      var e;
      try {
        width = this._getValueByStr(width, 'width', this);
        height = this._getValueByStr(height, 'height', this);
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setMaxCols(maxCols) {
      var e;
      try {
        this.settings.maxCols = maxCols;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    clear() {
      var ref;
      return (ref = this.list) != null ? ref.setItems([]) : void 0;
    }

    // * WRAPPED
    setItems() {
      var ref;
      return (ref = this.list) != null ? ref.setItems(...arguments) : void 0;
    }

    activate() {
      var ref;
      return (ref = this.list) != null ? ref.activate(...arguments) : void 0;
    }

    deactivate() {
      var ref;
      return (ref = this.list) != null ? ref.deactivate(...arguments) : void 0;
    }

    setOkHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setOkHandler(...arguments) : void 0;
    }

    setCancelHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setCancelHandler(...arguments) : void 0;
    }

    setSelectionHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setSelectionHandler(...arguments) : void 0;
    }

    refresh() {
      var ref;
      return (ref = this.list) != null ? ref.refresh(...arguments) : void 0;
    }

    selectedItem() {
      var ref;
      return (ref = this.list) != null ? ref.selectedItem() : void 0;
    }

    itemAt() {
      var ref;
      return (ref = this.list) != null ? ref.itemAt(...arguments) : void 0;
    }

    maxItems() {
      var ref;
      return (ref = this.list) != null ? ref.maxItems() : void 0;
    }

    getAllItems() {
      var ref;
      return (ref = this.list) != null ? ref.getAllItems() : void 0;
    }

    maxCols() {
      var ref;
      return (ref = this.list) != null ? ref.maxCols() : void 0;
    }

    // * END WRAPPED

      // * Dev, (not use settings) , чтобы визуально видеть размеры окна при подгонке
    setBackgroundType() {
      var ref;
      return (ref = this.list) != null ? ref.setBackgroundType(...arguments) : void 0;
    }

    // * Shortcut
    showBack() {
      return this.setBackgroundType(0);
    }

    _applySettings() {
      var e;
      try {
        this._destroyList();
        this._createListWithSettings(this.settings);
        if (this._isHaveStoredData === true) {
          return this._restoreData();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyList() {
      var e;
      try {
        if (this.list == null) {
          return;
        }
        this._isHaveStoredData = true;
        this._lastItems = this.list.getAllItems();
        this._isBeenActive = this.list.active === true;
        this._lastSelectedIndex = this.list.index();
        this._lastHandlers = this.list._handlers;
        this.removeChild(this.list);
        return this.list = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createListWithSettings(settings) {
      var e;
      try {
        this.list = new KDCore.Sprite_ItemsList({
          x: 0,
          y: 0,
          width: settings.width,
          height: settings.height
        }, settings);
        return this.addChild(this.list);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _restoreData() {
      var e;
      try {
        if (this.list == null) {
          return;
        }
        if (this._lastHandlers != null) {
          this.list._handlers = this._lastHandlers;
        }
        if (this._lastItems == null) {
          return;
        }
        this.list.setItems(this._lastItems);
        if (this._lastSelectedIndex != null) {
          this.list.safeSelect(this._lastSelectedIndex);
        }
        if (this._isBeenActive === true) {
          this.list.activate();
        }
        return this._isHaveStoredData = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_ItemsListN = Sprite_ItemsListN;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_NUI;
  //NUI 1.0
  //rev 06.05.24
  Sprite_NUI = class Sprite_NUI extends KDCore.Sprite {
    constructor(nuiScheme, owner = null) {
      super();
      this.nuiScheme = nuiScheme;
      if (this.nuiScheme != null) {
        this.loadNuiScheme(this.nuiScheme, owner);
      }
      return;
    }

    // * DIRECT nuiElement,без Sprite_NUI (надо присоединять к OWNER)
    static FromScheme(scheme, owner) {
      var e, spr;
      try {
        spr = new Sprite_NUI(scheme, owner);
        if (owner != null) {
          owner.addChild(spr.nuiElement);
        }
        return spr.nuiElement;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite_NUI();
      }
    }

    _afterLoadNuiAutoRefreshTime() {
      return 100;
    }

    loadNuiScheme(scheme, owner = null) {
      var e;
      try {
        if (this.nuiElement != null) {
          this.destroyNuiElement();
        }
        if (scheme == null) {
          return;
        }
        if (owner == null) {
          owner = this;
        }
        if (scheme["type"] != null) {
          this.nuiElement = KDCore.UI.Builder.Make(scheme, owner, this);
        } else {
          this.nuiElement = KDCore.UI.Builder.Factory(scheme, owner, this._afterLoadNuiAutoRefreshTime())[0];
        }
        this.addChild(this.nuiElement);
        return this.refreshBindings(owner, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    destroyNuiElement() {
      var e;
      try {
        if (this.nuiElement == null) {
          return;
        }
        this.nuiElement.removeFromParent();
        return this.nuiElement = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_NUI = Sprite_NUI;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Plane;
  //NUI 1.0
  //rev 25.04.24

    //type: "plane"
  Sprite_Plane = class Sprite_Plane extends KDCore.Sprite {
    constructor(settings) {
      var bottom, folderName, imageName, left, margins, right, textureSource, top;
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this.plane = null;
      this.planeContainer = new KDCore.Sprite();
      this.addChild(this.planeContainer);
      ({imageName, margins, folderName} = this.settings);
      if (isFinite(margins)) {
        left = top = right = bottom = margins;
      } else {
        ({left, top, right, bottom} = margins);
      }
      textureSource = ImageManager.loadBitmap('img/' + folderName + '/', imageName);
      textureSource.addLoadListener(() => {
        var texture;
        texture = new PIXI.Texture(textureSource._baseTexture);
        if (KDCore.isMV()) {
          this.plane = new PIXI.mesh.NineSlicePlane(texture, left, top, right, bottom);
        } else {
          this.plane = new PIXI.NineSlicePlane(texture, left, top, right, bottom);
        }
        this.planeContainer.addChild(this.plane);
        return this._onResize();
      });
      this._onResize();
      return;
    }

    realWidth() {
      return this.settings.width;
    }

    realHeight() {
      return this.settings.height;
    }

    defaultSettings() {
      return {
        imageName: "",
        width: 100,
        height: 100,
        margins: 20,
        folderName: "pictures"
      };
    }

    setSize(w = 100, h = 100) {
      var e;
      try {
        w = this._getValueByStr(w, 'width', this);
        h = this._getValueByStr(h, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.plane.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.plane.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        }
      });
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        if (this.plane == null) {
          return;
        }
        this.plane.width = this.settings.width;
        return this.plane.height = this.settings.height;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Plane = Sprite_Plane;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_SButton;
  //NUI 1.0
  //rev 30.04.24
  //"type": "button"
  Sprite_SButton = class Sprite_SButton extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._isEnabled = true;
      this._isUnderMouse = false;
      this._isPressActive = false;
      this._isMouseOver = false;
      this._create();
      this._refreshSettings();
      return;
    }

    realWidth() {
      return this.settings.width;
    }

    realHeight() {
      return this.settings.height;
    }

    isDisabled() {
      return !this.isEnabled();
    }

    isEnabled() {
      return this._isEnabled === true;
    }

    _enable() {
      var e;
      try {
        if (this._desaturated === true) {
          this.filters = [];
          this._desaturated = false;
        }
        if ((this.settings.disabledTint != null) && this._isEnabled === false) { // * Return to normal Tint
          this.applyTint(this.settings.activeTint, this.settings.tintAlpha);
        }
        this._isEnabled = true;
        return this._refreshTint();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _disable() {
      var e;
      try {
        this._applyDisabledEffect();
        return this._isEnabled = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyDisabledEffect() {
      var e;
      try {
        if (this.settings.desaturateWhenDisabled === true) {
          return this.desaturate();
        } else if (this.settings.disabledTint != null) {
          return this.applyTint(this.settings.disabledTint, this.settings.disabledTintAlpha);
        } else {
          return this.applyTint(this.settings.tint, this.settings.tintAlpha);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    isActive() {
      return this._isEnabled === true && this.visible === true && this.opacity !== 0;
    }

    pIsSupportKeyboardHandle() {
      return this.settings.keyboardHandled === true;
    }

    desaturate() {
      this.filters = [new PIXI.filters.ColorMatrixFilter()];
      this.filters[0].desaturate();
      this._desaturated = true;
    }

    defaultSettings() {
      return {
        imageName: '',
        folderName: 'pictures',
        imageMargins: 20,
        width: 160,
        height: 60,
        clickSe: "Cursor1",
        desaturateWhenDisabled: false,
        tint: "",
        overTint: 0xFFFFDD,
        activeTint: 0xAAAAAA,
        tintAlpha: 0.5,
        disabledTint: 0xAAAAAA,
        disabledTintAlpha: 0.5,
        keyboardKey: "",
        keyboardHandled: true,
        enabled: true
      };
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        style: function(v) {
          if (v != null) {
            return this.updateStyle(v);
          }
        },
        handler: function(v) {
          return this.setClickHandler(v);
        },
        enable: function(v) {
          if (v != null) {
            return this.setEnabledState(v);
          }
        }
      });
    }

    setEnabledState(state = true) {
      var e;
      try {
        this.settings.enabled = state;
        if (state === true) {
          return this._enable();
        } else {
          return this._disable();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    enable() {
      return this.setEnabledState(true);
    }

    disable() {
      return this.setEnabledState(false);
    }

    updateStyle(style) {
      var e;
      try {
        this.settings = Object.assign(this.settings, style);
        return this._refreshSettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    addClickHandler() {
      return this.setClickHandler(...arguments);
    }

    setClickHandler(handler = null) {
      var e;
      try {
        this.settings.onClick = null;
        if ((handler != null) && typeof handler === 'function') {
          return this.settings.onClick = handler;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 160, height = 60) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        return this._refreshSettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    executeAction() {
      var e;
      try {
        KDCore.Utils.playSE(this.settings.clickSe);
        if (this.settings.onClick != null) {
          return this.settings.onClick();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onTap() {
      var e;
      try {
        return this.executeAction();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    //console.log("TAP")
    _onOver() {
      this._isMouseOver = true;
      return this._refreshSettings();
    }

    //console.log("OVER")
    _onOut() {
      this._isMouseOver = false;
      return this._refreshSettings();
    }

    //console.log("OUT")
    _onDown() {
      this._isPressActive = true;
      return this._refreshSettings();
    }

    //console.log("DOWN")
    _onUp() {
      this._isPressActive = false;
      return this._refreshSettings();
    }

    //console.log("UP")
    _create() {
      var e, height, width;
      try {
        this.buttonPlane = new KDCore.Sprite_Plane({
          imageName: this.settings.imageName,
          margins: this.settings.imageMargins,
          folderName: this.settings.folderName
        });
        ({width, height} = this.settings);
        this.buttonPlane.setSize(width, height);
        return this.addChild(this.buttonPlane);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _refreshSettings() {
      var e;
      try {
        this._refreshTint();
        if (this.settings.keyboardHandled === true) {
          this.handleOKAction = this._onTap;
        } else {
          this.handleOKAction = null;
        }
        this.setEnabledState(this.settings.enabled);
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _refreshTint() {
      var e;
      try {
        if (this._isPressActive === true) {
          return this.applyTint(this.settings.activeTint, this.settings.tintAlpha);
        } else if (this._isMouseOver === true) {
          return this.applyTint(this.settings.overTint, this.settings.tintAlpha);
        } else {
          return this.applyTint(this.settings.tint, this.settings.tintAlpha);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    applyTint(tintValue, tintAlpha = 0.5) {
      var e;
      try {
        if (tintValue == null) {
          this._resetTintFilter();
          return;
        }
        if (typeof tintValue === "string") {
          if (!String.any(tintValue)) {
            this._resetTintFilter();
            return;
          }
          tintValue = KDCore.Utils.string2hex(tintValue);
        }
        return this.buttonPlane.filters = [new PIXI.filters.ColorOverlayFilter(tintValue, tintAlpha)];
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _resetTintFilter() {
      var e;
      try {
        return this.buttonPlane.filters = [];
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _activateHandlerVisually() {
      var e;
      try {
        return this.applyTint(this.settings.overTint);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    pDeactivateHandler() {
      super.pDeactivateHandler();
      return this.applyTint(this.settings.tint);
    }

    update() {
      super.update();
      if (this.isActive()) {
        this._updateKeyboardHandling();
        this._updateMouseHandling();
      } else {
        if (this._isUnderMouse === true) {
          this._onOut();
        }
        if ($gameTemp.kdButtonUnderMouse === this) {
          $gameTemp.kdButtonUnderMouse = null;
        }
      }
    }

    _updateKeyboardHandling() {
      var e;
      try {
        if (String.any(this.settings.keyboardKey)) {
          if (Input.isTriggered(this.settings.keyboardKey)) {
            Input.clear();
            return this._onTap();
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _updateMouseHandling() {
      var e;
      try {
        if (this.isUnderMouse()) {
          if (!this._isUnderMouse) {
            this._onOver();
            $gameTemp.kdButtonUnderMouse = this;
            try {
              if ($gameTemp.__pkdActiveKeyboardHandler != null) {
                $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
              }
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
            this._isUnderMouse = true;
          }
        } else {
          if (this._isUnderMouse === true) {
            this._onOut();
            if ($gameTemp.kdButtonUnderMouse === this) {
              $gameTemp.kdButtonUnderMouse = null;
            }
            this._isUnderMouse = false;
          }
        }
        if (TouchInput.isPressed()) {
          if (this._isUnderMouse === true) {
            if (!this._isMousePressed) {
              this._onDown();
              this._isMousePressed = true;
            }
          }
        }
        if (TouchInput.isReleased()) {
          if (this._isMousePressed === true) {
            this._onUp();
            if (this._isUnderMouse === true) {
              this._onTap();
            }
            return this._isMousePressed = false;
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e, ref;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        return (ref = this.buttonPlane) != null ? ref.setSize(this.width, this.height) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_SButton = Sprite_SButton;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad((function() {
  var Sprite_TilingFrame;
  Sprite_TilingFrame = class Sprite_TilingFrame extends KDCore.Sprite {
    constructor(width, height, skinBitmap) {
      super();
      this.width = width;
      this.height = height;
      this.skinBitmap = skinBitmap;
      this._createParts();
      this._refreshAll();
    }

    _createParts() {
      var i, j;
      this.backSprite = new Sprite();
      this.addChild(this.backSprite);
      this.content = new Sprite();
      this.addChild(this.content);
      this._outFrame = new Sprite();
      for (i = j = 0; j < 8; i = ++j) {
        this._outFrame.addChild(new Sprite());
      }
      return this.addChild(this._outFrame);
    }

    // * Отступ, чтобы за рамку не выходить
    _fillPadding() {
      return 2;
    }

    // * Размер частей на картинке
    _fillImagePartWidth() {
      return 96;
    }

    _fillImagePartHeight() {
      return 96;
    }

    // * Толщина рамки
    _frameThickness() {
      return 12;
    }

    _refreshAll() {
      this._refreshBack();
      return this._refreshTFrame();
    }

    _refreshBack() {
      var fh, fw, h, m, sprite, w;
      m = this._fillPadding();
      w = Math.max(0, this.width - m * 2);
      h = Math.max(0, this.height - m * 2);
      sprite = this.backSprite;
      sprite.bitmap = this.skinBitmap;
      // * Координаты фона из картинки
      fw = this._fillImagePartWidth();
      fh = this._fillImagePartHeight();
      sprite.setFrame(0, 0, fw, fh);
      sprite.move(m, m);
      sprite.scale.x = w / fw;
      return sprite.scale.y = h / fh;
    }

    _refreshTFrame() {
      var drect, fh, fw, j, len, m, ref, spr, srect;
      fw = this._fillImagePartWidth();
      fh = this._fillImagePartHeight();
      // * Положение назначения
      drect = {
        x: 0,
        y: 0,
        width: this.width,
        height: this.height
      };
      // * Координаты рамки на картинке
      srect = {
        x: fw,
        y: 0,
        width: fw,
        height: fh
      };
      m = this._frameThickness(); // * Толщина
      ref = this._outFrame.children;
      for (j = 0, len = ref.length; j < len; j++) {
        spr = ref[j];
        spr.bitmap = this.skinBitmap;
      }
      if (KDCore.isMZ()) {
        Window.prototype._setRectPartsGeometry.call(this, this._outFrame, srect, drect, m);
      } else {
        this._setRectPartsGeometry(this._outFrame, srect, drect, m);
      }
    }

    // * Этот метод существует в MZ, но нет в MV
    //? From MZ
    _setRectPartsGeometry(sprite, srect, drect, m) {
      var child, children, dh, dmh, dmw, dw, dx, dy, j, len, sh, smh, smw, sw, sx, sy;
      sx = srect.x;
      sy = srect.y;
      sw = srect.width;
      sh = srect.height;
      dx = drect.x;
      dy = drect.y;
      dw = drect.width;
      dh = drect.height;
      smw = sw - m * 2;
      smh = sh - m * 2;
      dmw = dw - m * 2;
      dmh = dh - m * 2;
      children = sprite.children;
      sprite.setFrame(0, 0, dw, dh);
      sprite.move(dx, dy);
      // corner
      children[0].setFrame(sx, sy, m, m);
      children[1].setFrame(sx + sw - m, sy, m, m);
      children[2].setFrame(sx, sy + sw - m, m, m);
      children[3].setFrame(sx + sw - m, sy + sw - m, m, m);
      children[0].move(0, 0);
      children[1].move(dw - m, 0);
      children[2].move(0, dh - m);
      children[3].move(dw - m, dh - m);
      // edge
      children[4].move(m, 0);
      children[5].move(m, dh - m);
      children[6].move(0, m);
      children[7].move(dw - m, m);
      children[4].setFrame(sx + m, sy, smw, m);
      children[5].setFrame(sx + m, sy + sw - m, smw, m);
      children[6].setFrame(sx, sy + m, m, smh);
      children[7].setFrame(sx + sw - m, sy + m, m, smh);
      children[4].scale.x = dmw / smw;
      children[5].scale.x = dmw / smw;
      children[6].scale.y = dmh / smh;
      children[7].scale.y = dmh / smh;
      // center
      if (children[8] != null) {
        children[8].setFrame(sx + m, sy + m, smw, smh);
        children[8].move(m, m);
        children[8].scale.x = dmw / smw;
        children[8].scale.y = dmh / smh;
      }
      for (j = 0, len = children.length; j < len; j++) {
        child = children[j];
        child.visible = dw > 0 && dh > 0;
      }
    }

  };
  return KDCore.Sprite_TilingFrame = Sprite_TilingFrame;
}));


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Window_ExtTextLineBase;
  // * Данное окно используется как основа для Sprite_UITextExt
  //rev 07.10.21
  Window_ExtTextLineBase = class Window_ExtTextLineBase extends Window_Base {
    constructor(rect, fontSettings) {
      super(rect);
      this.fontSettings = fontSettings;
      this.createContents();
      // * Всегда прозрачное окно
      this.setBackgroundType(2);
    }

    // * Нет отступов
    updatePadding() {
      return this.padding = 0;
    }

    // * Нет отступов
    itemPadding() {
      return 0;
    }

    textPadding() {
      return 0;
    }

    standardPadding() {
      return 0;
    }

    contentsWidth() {
      return this.width;
    }

    contentsHeight() {
      return this.height;
    }

    // * Более гибкая настройка размера текста при { }
    makeFontBigger() {
      return this.contents.fontSize += 1;
    }

    makeFontSmaller() {
      if (this.contents.fontSize > 1) {
        return this.contents.fontSize -= 1;
      }
    }

    // * Применение своих шрифта и размера текста
    resetFontSettings() {
      super.resetFontSettings();
      if (this.fontSettings == null) {
        return;
      }
      if (String.any(this.fontSettings.face)) {
        this.contents.fontFace = this.fontSettings.face;
      }
      if (this.fontSettings.size > 0) {
        this.contents.fontSize = this.fontSettings.size;
      }
      if (this.fontSettings.italic != null) {
        this.contents.fontItalic = this.fontSettings.italic;
      }
    }

  };
  return KDCore.Window_ExtTextLineBase = Window_ExtTextLineBase;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Button M
  //------------------------------------------------------------------------------
  //@[AUTO EXTEND]
  // * Button Mini - упрощённый класс Sprite_XButton (KDCore.Button)

    // * Принимает название файла изображения кнопки без _00
  // * Названия изображения должны быть в стандартном формате _00, _01, [_03]
  // * _02 - не используются в этом классе

    // * Класс использует глобальную временную переменную для определения находится ли мышь в зоне кнопки

    //TODO: ADD ALPHA CHECK!

    // * Если isFull - true, значит нужен _03
  KDCore.ButtonM = class ButtonM extends KDCore.Sprite {
    constructor(filename, isFull = false, sourceFolder = null) {
      super();
      this._bitmaps = [];
      this._disabled = false;
      this._isTriggered = false;
      // * Когда произошло нажатие на кнопку
      this._handler = null;
      this._isCanBeClicked = true;
      this._isManualHoverMode = false;
      this._isManualSelected = false;
      this._loadBitmaps(filename, isFull, sourceFolder);
      this._setImageState(0);
      this._createThread();
    }

    realWidth() {
      return this._bitmaps[0].width;
    }

    realHeight() {
      return this._bitmaps[0].height;
    }

    setManualHover() {
      return this._isManualHoverMode = true;
    }

    disableManualHover() {
      return this._isManualHoverMode = false;
    }

    setManualSelected(_isManualSelected) {
      this._isManualSelected = _isManualSelected;
    }

    enableClick() {
      return this._isCanBeClicked = true;
    }

    disableClick() {
      return this._isCanBeClicked = false;
    }

    desaturate() {
      this.filters = [new PIXI.filters.ColorMatrixFilter()];
      this.filters[0].desaturate();
    }

    isLoaded() {
      var ref;
      return (ref = this._bitmaps[0]) != null ? ref.isReady() : void 0;
    }

    isMouseIn() {
      if (this._isManualHoverMode === true) {
        return this._isManualSelected;
      } else {
        return this.isUnderMouse() && this.visible === true;
      }
    }

    isAllParentsActive() {
      var e, parent;
      try {
        parent = this.parent;
        while (parent != null) {
          if (parent.visible === false) {
            return false;
          }
          if (parent.opacity === 0) {
            return false;
          }
          parent = parent.parent;
        }
        return true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    }

    isActive() {
      if (this._isCanBeClicked === false) {
        return false;
      }
      if (this.visible === false) {
        return false;
      }
      if (this.opacity === 0) {
        return false;
      }
      return this.isAllParentsActive();
    }

    isDisabled() {
      return this._disabled === true;
    }

    addClickHandler(_handler) {
      this._handler = _handler;
    }

    clearClickHandler() {
      return this._handler = null;
    }

    // * Воспроизводит визуальный эффект нажатия
    simulateClick() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (this.isMouseIn()) {
        return;
      }
      this._startSimulation();
    }

    isEnabled() {
      return !this.isDisabled();
    }

    refreshState(isEnable = true) {
      if (isEnable === true) {
        if (this.isDisabled()) {
          this.enable();
        }
      } else {
        if (this.isEnabled()) {
          this.disable();
        }
      }
    }

    disable() {
      this._disabled = true;
      return this._setImageState(2);
    }

    enable() {
      this._disabled = false;
      return this._setImageState(0);
    }

    click() {
      if (this._handler != null) {
        return this._handler();
      }
    }

    update() {
      super.update();
      return this._updateMain();
    }

  };
  return (function() {    
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ ButtonM Implementation
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _, alias_SM_isAnyButtonPressed, alias_SM_onMapLoaded;
    //@[DEFINES]
    _ = KDCore.ButtonM.prototype;
    _._loadBitmaps = function(filename, isFull = false, sourceFolder = null) {
      var getterFunc;
      getterFunc = this._getGetter(sourceFolder);
      this._bitmaps.push(getterFunc(filename + '_00'));
      this._bitmaps[0].addLoadListener(this._onBitmapLoaded.bind(this));
      this._bitmaps.push(getterFunc(filename + '_01'));
      if (isFull) {
        this._bitmaps.push(getterFunc(filename + '_03'));
      }
    };
    _._onBitmapLoaded = function() {
      var e;
      try {
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getGetter = function(sourceFolder = null) {
      var getterFunc;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder !== null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap('img/' + sourceFolder + '/', filename);
        };
      }
      return getterFunc;
    };
    _._setImageState = function(index = 0) {
      if (this._bitmaps[index] == null) {
        index = 0;
      }
      this.bitmap = this._bitmaps[index];
      this._lastState = index;
    };
    _._createThread = function() {
      this.hoverThread = new KDCore.TimedUpdate(3, this._updateHover.bind(this));
      this.hoverThread.applyTimeRange(-1, 1);
      this.hoverThread.call();
    };
    //?[DYNAMIC]
    _._updateMain = function() {
      this._updateMouseLogic();
      if (!this.isActive()) {
        if (($gameTemp.kdButtonUnderMouse != null) && $gameTemp.kdButtonUnderMouse === this) {
          return $gameTemp.kdButtonUnderMouse = null;
        }
      }
    };
    _._updateMouseLogic = function() {
      this.hoverThread.update();
      return this._updateMouseClick();
    };
    _._updateHover = function() {
      var e;
      if (!this.isActive()) {
        return;
      }
      // * чтобы эффект нажатия не прекратить
      if (this._isTriggered === true) {
        return;
      }
      if (this.isMouseIn()) {
        if (this._lastState !== 1) {
          if (!this.isDisabled()) {
            this._setImageState(1);
          }
          $gameTemp.kdButtonUnderMouse = this;
          try {
            if ($gameTemp.__pkdActiveKeyboardHandler != null) {
              $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
      } else {
        if (this._lastState !== 0) {
          if (!this.isDisabled()) {
            this._setImageState(0);
          }
          if ($gameTemp.kdButtonUnderMouse === this) {
            $gameTemp.kdButtonUnderMouse = null;
          }
        } else if ($gameTemp.kdButtonUnderMouse === this) {
          $gameTemp.kdButtonUnderMouse = null;
        }
      }
    };
    _._updateMouseClick = function() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (TouchInput.isTriggered() && this.isUnderMouse()) {
        this._isTriggered = true;
        this._setImageState(0);
      }
      if (this._isTriggered === true) {
        if (TouchInput.isReleased()) {
          this._isTriggered = false;
          if (this.isMouseIn()) {
            this.click();
          }
        }
      }
    };
    _._startSimulation = function() {
      this._setImageState(1);
      this._simulateThread = new KDCore.TimedUpdate(10, () => {
        return this._setImageState(0);
      });
      this._simulateThread.once();
      return this._updateMain = this._updateMouseClickSimulated;
    };
    _._updateMouseClickSimulated = function() {
      this._simulateThread.update();
      if (!this._simulateThread.isAlive()) {
        this._simulateThread = null;
        this._updateMain = this._updateMouseLogic;
      }
    };
    // * Теперь при нажатии на любую кнопку, игрок не будет ходить по карте

    //@[ALIAS]
    alias_SM_isAnyButtonPressed = Scene_Map.prototype.isAnyButtonPressed;
    Scene_Map.prototype.isAnyButtonPressed = function() {
      if ($gameTemp.kdButtonUnderMouse != null) {
        return true;
      } else {
        return alias_SM_isAnyButtonPressed.call(this);
      }
    };
    //TODO: Добавить доп. проверку?
    //@[ALIAS]
    alias_SM_onMapLoaded = Scene_Map.prototype.onMapLoaded;
    Scene_Map.prototype.onMapLoaded = function() {
      $gameTemp.kdButtonUnderMouse = null;
      setTimeout((function() {
        return $gameTemp.kdButtonUnderMouse = null;
      }), 50);
      return alias_SM_onMapLoaded.call(this);
    };
  })();
});

// ■ END ButtonM Implementation
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Button Mini User - класс с определением файла каждого состояния отдельно
  // * Принимает теже аргументы, только заместо имени файла, три изображения (имени)
  // ? states = { main, hover, disabled }
  return KDCore.ButtonMU = class ButtonMU extends KDCore.ButtonM {
    constructor() {
      super(...arguments);
    }

    //$[OVER]
    _loadBitmaps(states, isFull = true, sourceFolder = null) {
      var getterFunc;
      getterFunc = this._getGetter(sourceFolder);
      this._bitmaps.push(getterFunc(states.main));
      this._bitmaps.push(getterFunc(states.hover));
      // * Optional 03
      if (String.any(states.disabled)) {
        this._bitmaps.push(getterFunc(states.disabled));
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_TilingLine;
  Sprite_TilingLine = class Sprite_TilingLine extends KDCore.Sprite_TilingFrame {
    constructor() {
      super(...arguments);
    }

    //$[OVER BASE ALL BELOW]
    _fillPadding() {
      return 0;
    }

    _refreshTFrame() {} // * EMPTY

    _fillImagePartWidth() {
      return 4;
    }

    _fillImagePartHeight() {
      return 26;
    }

  };
  return KDCore.Sprite_TilingLine = Sprite_TilingLine;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Пространство имён для всех UIElements
  KDCore.UI = KDCore.UI || {};
  (function() {    // * Общий класс для всех UI элементов
    //?rev 07.02.2024
    var Sprite_UIElement;
    Sprite_UIElement = (function() {
      // * ABSTRACT значит что класс сам по себе ничего не создаёт, не хранит данные
      //@[ABSTRACT]
      class Sprite_UIElement extends KDCore.Sprite {
        constructor(params) {
          super();
          this.params = params;
          this._init();
        }

        // * Стандартный набор настроек
        defaultParams() {
          return {
            visible: true
          };
        }

        // * Общий метод (есть у всех элементов)
        // * По умолчанию вызывает drawText, но потомки могут переопределить
        draw() {
          return this.drawText(...arguments);
        }

        // * Общий метод
        drawText() {} // * EMPTY

        
          // * Если изначально невидимый (из параметров), то не активный вообще
        isActive() {
          return this.params.visible === true;
        }

        rootImageFolder() {
          if (String.any(this.params.rootImageFolder)) {
            return this.params.rootImageFolder;
          } else {
            return Sprite_UIElement.RootImageFolder;
          }
        }

        // * Сделать чёрно белым
        desaturate() {
          this.filters = [new PIXI.filters.ColorMatrixFilter()];
          this.filters[0].desaturate();
        }

        clearFilters() {
          return this.filters = [];
        }

        // * Общий метод (можно ли редактировать визуально)
        isCanBeEdited() {
          return false;
        }

        // * Общий метод (надо ли скрывать при игровом сообщнии)
        isHaveHideWithMessageFlag() {
          return false;
        }

        // * Общий метод (находится ли объект под мышкой)
        isUnderMouse() {
          var ref;
          return ((ref = this.zeroChild()) != null ? ref.isUnderMouse() : void 0) && this.isFullVisible();
        }

        // * Полностью ли виден объект? (включае всех его родителей)
        isFullVisible() {
          return this.visible === true && this.allParentsIsVisible();
        }

        // * Все ли родители объекта видимы
        allParentsIsVisible() {
          var e, p;
          if (!this.visible) {
            return false;
          }
          try {
            if (this.parent != null) {
              p = this.parent;
              while (p != null) {
                if (p.visible === true) {
                  p = p.parent;
                } else {
                  return false;
                }
              }
              return true;
            } else {
              return this.visible === true;
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            return true;
          }
        }

        // * Параметры первого элемента (если он есть)
        realWidth() {
          var child;
          child = this.zeroChild();
          if (child != null) {
            if (child instanceof KDCore.UI.Sprite_UIElement) {
              return child.realWidth();
            } else {
              return child.width;
            }
          }
          return 0;
        }

        realHeight() {
          var child;
          child = this.zeroChild();
          if (child != null) {
            if (child instanceof KDCore.UI.Sprite_UIElement) {
              return child.realHeight();
            } else {
              return child.height;
            }
          }
          return 0;
        }

        // * Метод восстановления значения на стандартные настройки
        reset(property) {
          var e;
          try {
            switch (property) {
              case "position":
                this._resetPosition();
                break;
              default:
                this[property] = this.params[property];
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }

      };

      // * Корневая директория для изображений
      Sprite_UIElement.RootImageFolder = "Alpha";

      return Sprite_UIElement;

    }).call(this);
    KDCore.UI.Sprite_UIElement = Sprite_UIElement;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIElement.prototype;
    _._init = function() {
      var e;
      this._prepare();
      try {
        return this._createContent();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        // * Если при создании произошла ошибка, отключаем элемент
        return this.isActive = function() {
          return false;
        };
      }
    };
    
    // * Подготовка элемента (проверка параметров)
    _._prepare = function() {
      //@params = @defaultParams() unless @params?
      this.params = Object.assign({}, this.defaultParams(), this.params);
      if (this.params.visible != null) {
        this.visible = this.params.visible;
      }
    };
    // * Наследники создают свои элементы в этом методе
    _._createContent = function() {}; // * EMPTY
    
    // * Сброс позиции
    _._resetPosition = function() {
      var e, x, y;
      if (this.params.position == null) {
        return;
      }
      try {
        ({x, y} = this.params.position);
        if (isFinite(x) && isFinite(y)) {
          x = Number(x);
          y = Number(y);
        } else {
          x = Number(eval(x));
          y = Number(eval(y));
        }
        this.move(x, y);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.move(0, 0);
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsListNHor;
  //TODO: NOT USED IN NUI 1.0
  //NUI 1.X !#!
  //rev 03.05.24

    //"type": "horList"
  Sprite_ItemsListNHor = class Sprite_ItemsListNHor extends KDCore.Sprite_ItemsListN {
    constructor() {
      super(...arguments);
    }

    //$[OVER]
    defaultSettings() {
      var settings;
      settings = super.defaultSettings();
      settings.width = 420;
      settings.height = 120;
      settings.maxCols = 4;
      return settings;
    }

    //$[OVER]
    setMaxCols(maxCols) {} // * AUTO

    setItems(items) {
      var e, l;
      try {
        if (items != null) {
          l = this.maxItems();
          if (l !== items.length) {
            this.settings.maxCols = items.length;
            this.clear();
            this._applySettings();
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return super.setItems(items);
    }

  };
  return KDCore.Sprite_ItemsListNHor = Sprite_ItemsListNHor;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Screen;
  //NUI 1.0
  //rev 04.05.24

    //"type": "screen"
  Sprite_Screen = class Sprite_Screen extends KDCore.Sprite_Group {
    constructor(settings) {
      super(settings);
      this._applyExtraSettings();
    }

    //TODO: В режиме linkToMap, должен иметь width и height карты (size * tileSize)
    realWidth() {
      return Graphics.width;
    }

    realHeight() {
      return Graphics.height;
    }

    defaultSettings() {
      var defaultSettings;
      defaultSettings = super.defaultSettings();
      return Object.assign(defaultSettings, {
        width: Graphics.width,
        height: Graphics.height,
        linkToMap: false //TODO: NOT USED IN NUI 1.0
      });
    }

    _applyExtraSettings() {
      var e;
      try {
        if (this.settings.linkToMap === true) {
          return this.anchorPoint = new KDCore.MapAnchorPoint(0, 0);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    update() {
      super.update();
      return this._refreshScreenPosition();
    }

    _refreshScreenPosition() {
      var e;
      try {
        if (this.anchorPoint == null) {
          return;
        }
        this.x = this.anchorPoint.screenX();
        return this.y = this.anchorPoint.screenY();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Screen = Sprite_Screen;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIButton;
    // * Кнопка на экране, можно нажимать
    Sprite_UIButton = class Sprite_UIButton extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          image: "Button_Inventory",
          isHaveDisabled: true,
          rootImageFolder: null, //?optional
          click: "console.log('click')" // * число или код
        };
      }

      // * Кнопка не поддерживает перерисовку
      draw() {} // * EMPTY

      disable() {
        var ref;
        return (ref = this.button) != null ? ref.disable() : void 0;
      }

      enable() {
        var ref;
        return (ref = this.button) != null ? ref.enable() : void 0;
      }

      setState(isEnabled) {
        if (isEnabled) {
          return this.enable();
        } else {
          return this.disable();
        }
      }

      
        // * Просто вызов метода
      call() {
        var ref;
        return (ref = this.button) != null ? ref.click() : void 0;
      }

      // * Вызов метода с симуляцией нажатия
      click() {
        var ref, ref1;
        if ((ref = this.button) != null) {
          ref.click();
        }
        return (ref1 = this.button) != null ? ref1.simulateClick() : void 0;
      }

    };
    KDCore.UI.Sprite_UIButton = Sprite_UIButton;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIButton.prototype;
    //$[OVER]
    _._createContent = function() {
      if (this.params.image.isEmpty()) {
        KDCore.warning('You try create Button without image');
        return;
      }
      this.button = new KDCore.ButtonM(this.params.image, this.params.isHaveDisabled, this.rootImageFolder());
      this.add(this.button);
      return this._registerClickMethod();
    };
    _._registerClickMethod = function() {
      var commonEventId, e, method, ref, script;
      if (!String.any(this.params.click)) {
        return;
      }
      method = null;
      try {
        // * Если число, то значит общее событие
        if (isFinite(this.params.click)) {
          commonEventId = parseInt(this.params.click);
          if (commonEventId > 0) {
            method = function() {
              return $gameTemp.reserveCommonEvent(commonEventId);
            };
          }
        } else {
          // * Иначе скрипт
          script = this.params.click;
          method = function() {
            return eval(script);
          };
        }
        return this.button.addClickHandler(method);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return (ref = this.button) != null ? ref.clearClickHandler() : void 0;
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    // * Рисует лицо персонажа (из папки Faces)
    var Sprite_UIFace;
    Sprite_UIFace = class Sprite_UIFace extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          faceName: "Actor1",
          faceIndex: 0,
          mirror: false,
          size: 144
        };
      }

      draw() {
        return this.drawFace(...arguments);
      }

      drawFace(faceName, faceIndex) {
        return this._drawFaceWhenReady(faceName, faceIndex);
      }

    };
    KDCore.UI.Sprite_UIFace = Sprite_UIFace;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIFace.prototype;
    //$[OVER]
    _._createContent = function() {
      return this._createFaceSprite();
    };
    _._createFaceSprite = function() {
      this._faceSpr = KDCore.Sprite.FromBitmap(this.params.size);
      if (this.params.mirror === true) {
        this._flipFaceSpr();
      }
      this.add(this._faceSpr);
      this._drawFaceWhenReady(this.params.faceName, this.params.faceIndex);
    };
    _._flipFaceSpr = function() {
      this._faceSpr.scale.x = -1;
      this._faceSpr.x = this.params.size;
    };
    _._drawFaceWhenReady = function(name, index = 0) {
      var ref;
      if ((ref = this._faceSpr) != null) {
        ref.clear();
      }
      if (!String.any(name)) {
        return;
      }
      if (index < 0) {
        return;
      }
      this._drawOnReady = {name, index};
      this._faceSourceBitmap = ImageManager.loadFace(name);
      this._faceSourceBitmap.addLoadListener(this._drawFace.bind(this));
      this._drawFace();
    };
    _._drawFace = function() {
      var fh, fw, size, sx, sy;
      if (this._faceSpr == null) {
        return;
      }
      this._faceSpr.clear();
      if (!String.any(this._drawOnReady.name)) {
        return;
      }
      if (KDCore.isMZ()) {
        fw = ImageManager.faceWidth;
        fh = ImageManager.faceHeight;
      } else {
        fw = Window_Base._faceWidth;
        fh = Window_Base._faceHeight;
      }
      size = this.params.size;
      sx = (this._drawOnReady.index % 4) * fw;
      sy = Math.floor(this._drawOnReady.index / 4) * fh;
      this._faceSpr.bitmap.blt(this._faceSourceBitmap, sx, sy, fw, fh, 0, 0, size, size);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIGauge;
    Sprite_UIGauge = class Sprite_UIGauge extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          fill: "",
          foreground: "",
          mask: "",
          backColor: "#000000".toCss(),
          backOpacity: 255,
          vertical: false,
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawGauge(...arguments);
      }

      drawGauge(percent = 1) {
        this._lastValue = percent;
        return this._drawGauge(percent);
      }

      isVertical() {
        return this.params.vertical === true;
      }

    };
    KDCore.UI.Sprite_UIGauge = Sprite_UIGauge;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIGauge.prototype;
    //$[OVER]
    _._createContent = function() {
      // * Загружается главное изображение, затем уже все остальные, т.к. нужны размеры
      return this._loadFillImage();
    };
    _._loadFillImage = function() {
      // * Главное изображение, поэтому если не указано, то ничего
      if (this.params.fill.isEmpty()) {
        KDCore.warning('You try create Gauge without fill image');
        return;
      }
      KDCore.Utils.loadImageAsync(this.rootImageFolder(), this.params.fill).then(this._createParts.bind(this));
    };
    // * Получаем изображение заполнения и создаём части (т.к. есть размеры)
    _._createParts = function(fillBitmap) {
      this.fillBitmap = fillBitmap;
      this._createBackground();
      this._createFillLayer();
      this._loadForeground();
      this._loadMask();
      return this._onReady();
    };
    _._createBackground = function() {
      this.background = KDCore.Sprite.FromBitmap(this.fillBitmap.width, this.fillBitmap.height);
      this.background.b().fillAll(this.params.backColor);
      this.background.opacity = this.params.backOpacity;
      return this.add(this.background);
    };
    _._createFillLayer = function() {
      this.fillLayer = KDCore.Sprite.FromBitmap(this.fillBitmap.width, this.fillBitmap.height);
      return this.add(this.fillLayer);
    };
    _._loadForeground = function() {
      var fore;
      if (String.isNullOrEmpty(this.params.foreground)) {
        return;
      }
      fore = KDCore.Sprite.FromImg(this.params.foreground, this.rootImageFolder());
      return this.add(fore);
    };
    _._loadMask = function() {
      var mask;
      if (String.isNullOrEmpty(this.params.mask)) {
        return;
      }
      mask = KDCore.Sprite.FromImg(this.params.mask, this.rootImageFolder());
      this.mask = mask;
      return this.add(mask);
    };
    // * Если что-то было до готовности, нарисовать
    _._onReady = function() {
      this.drawGauge(this._lastValue);
    };
    _._drawGauge = function(percent) {
      if (this.fillLayer == null) {
        return;
      }
      this.fillLayer.clear();
      if (this.isVertical()) {
        return this._drawVerGauge(percent);
      } else {
        return this._drawHorGauge(percent);
      }
    };
    _._drawHorGauge = function(percent) {
      var w;
      w = this.fillBitmap.width * percent;
      return this.fillLayer.b().blt(this.fillBitmap, 0, 0, w, this.fillLayer.height, 0, 0);
    };
    _._drawVerGauge = function(percent) {
      var h, hy;
      h = this.fillBitmap.height * percent;
      hy = this.fillBitmap.height - h;
      this.fillLayer.b().blt(this.fillBitmap, 0, 0, this.fillLayer.width, h, 0, hy);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIIcon;
    Sprite_UIIcon = class Sprite_UIIcon extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          index: 0,
          size: 32,
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawIcon(...arguments);
      }

      drawIcon(index = 0, noSmoth = false) {
        this._lastValue = index;
        return this._drawIcon(index, noSmoth);
      }

    };
    KDCore.UI.Sprite_UIIcon = Sprite_UIIcon;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIIcon.prototype;
    //$[OVER]
    _._createContent = function() {
      this._createIcon();
      return this._drawIcon(this.params.index);
    };
    _._createIcon = function() {
      this._icon = KDCore.Sprite.FromBitmap(this.params.size, this.params.size);
      this.add(this._icon);
      return this._onReady();
    };
    _._onReady = function() {
      return this.drawIcon(this._lastValue);
    };
    _._drawIcon = function(index, noSmoth = false) {
      this._icon.clear();
      if (KDCore.SDK.isString(index)) {
        this._drawImageIcon(index, noSmoth);
      } else {
        if (index <= 0) {
          return;
        }
        this._icon.drawIcon(0, 0, index, this.params.size, noSmoth);
      }
    };
    _._drawImageIcon = function(imageName, noSmoth = false) {
      return KDCore.Utils.loadImageAsync(this.rootImageFolder(), imageName).then((bitmap) => {
        return this._icon.drawIcon(0, 0, bitmap, this.params.size, noSmoth);
      });
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIImage;
    Sprite_UIImage = class Sprite_UIImage extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          image: "",
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawImage(...arguments);
      }

      drawImage(image) {
        return this._drawImage(image);
      }

    };
    KDCore.UI.Sprite_UIImage = Sprite_UIImage;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIImage.prototype;
    //$[OVER]
    _._createContent = function() {
      return this._drawImage(this.params.image);
    };
    _._drawImage = function(image) {
      this._clearImage();
      if (!String.isNullOrEmpty(image)) {
        this._image = KDCore.Sprite.FromImg(image, this.rootImageFolder());
        this.add(this._image);
      }
    };
    _._clearImage = function() {
      if (this._image == null) {
        return;
      }
      this._image.visible = false;
      this.removeChild(this._image);
      return this._image = null;
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIRect;
    Sprite_UIRect = class Sprite_UIRect extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            w: 60,
            h: 20
          },
          fillColor: "#FFFFFF".toCss(),
          fillOpacity: 255,
          borderColor: "#000000".toCss(),
          borderThickness: 1,
          borderOpacity: 255
        };
      }

      draw() {
        return this.fill(...arguments);
      }

      fill(color, opacity = 255) {
        return this._fill(color, opacity);
      }

      drawBorder(color, thickness = 1, opacity = 255) {
        return this._drawBorder(color, thickness, opacity);
      }

    };
    KDCore.UI.Sprite_UIRect = Sprite_UIRect;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIRect.prototype;
    //$[OVER]
    _._createContent = function() {
      if (String.any(this.params.fillColor)) {
        this._createFill();
        this.fill(this.params.fillColor, this.params.fillOpacity);
      }
      if (String.any(this.params.borderColor) && this.params.borderThickness > 0) {
        this._createBorder();
        return this.drawBorder(this.params.borderColor, this.params.borderThickness, this.params.borderOpacity);
      }
    };
    _._createFill = function() {
      this._fillSpr = KDCore.Sprite.FromBitmap(this.params.size.w, this.params.size.h);
      return this.addChild(this._fillSpr);
    };
    _._createBorder = function() {
      this._borderSprite = KDCore.Sprite.FromBitmap(this.params.size.w, this.params.size.h);
      return this.addChild(this._borderSprite);
    };
    _._fill = function(color, opacity) {
      if (this._fillSpr == null) {
        return;
      }
      this._fillSpr.fillAll(color);
      this._fillSpr.opacity = opacity;
    };
    _._drawBorder = function(color, thickness, opacity) {
      var b;
      if (this._borderSprite == null) {
        return;
      }
      this._borderSprite.clear();
      b = this._borderSprite.b();
      // * Top line
      b.fillRect(0, 0, b.width, thickness, color);
      // * Bottom line
      b.fillRect(0, b.height - thickness, b.width, thickness, color);
      // * Left line
      b.fillRect(0, 0, thickness, b.height, color);
      // * Right line
      b.fillRect(b.width - thickness, 0, thickness, b.height, color);
      return this._borderSprite.opacity = opacity;
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //NUI 1.0
    //rev 11.05.22

    //"type": "legacyText"
    var Sprite_UIText;
    Sprite_UIText = class Sprite_UIText extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
        if (String.any(this.params.text)) {
          this.drawText(this.params.text);
        }
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 60,
            height: 20
          },
          alignment: "center",
          font: {
            face: null,
            size: 18,
            italic: false
          },
          margins: {
            x: 0,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#ffffff",
          shadow: {
            color: "#000",
            opacity: 0,
            margins: {
              x: 1,
              y: 1
            }
          },
          text: ""
        };
      }

      // * For compatibility with old style configurations
      sizeWidth() {
        if (this.params.size.w != null) {
          return this.params.size.w;
        } else {
          if (this.params.size.width != null) {
            this.params.size.w = this.params.size.width;
            return this.params.size.width;
          }
        }
        return 0;
      }

      // * For compatibility with old style configurations
      sizeHeight() {
        if (this.params.size.h != null) {
          return this.params.size.h;
        } else {
          if (this.params.size.height != null) {
            this.params.size.h = this.params.size.height;
            return this.params.size.height;
          }
        }
        return 0;
      }

      realWidth() {
        return this.sizeWidth();
      }

      realHeight() {
        return this.sizeHeight();
      }

      dataBindings() {
        return Object.assign(super.dataBindings(), {
          text: function(v) {
            return this.drawText(v);
          },
          style: function(v) {
            return this.updateStyle(v);
          },
          width: function(v) {
            if (v != null) {
              return this.setSize(v, this.sizeHeight());
            }
          },
          height: function(v) {
            if (v != null) {
              return this.setSize(this.sizeWidth(), v);
            }
          },
          size: function(v) {
            if (v != null) {
              return this.setSize(v.width, v.height);
            }
          },
          textColor: function(v) {
            if (v != null) {
              return this.updateStyle({
                textColor: v
              });
            }
          },
          fontSize: function(v) {
            if (v != null) {
              return this.updateFontSize(v);
            }
          }
        });
      }

      setSize(w = 60, h = 20) {
        var e;
        try {
          w = this._getValueByStr(w, 'width', this);
          h = this._getValueByStr(h, 'height', this);
          return this.updateStyle({
            size: {
              w: w,
              h: h,
              width: w,
              height: h
            }
          });
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateStyle(newStyle) {
        var e;
        try {
          this.params = Object.assign({}, this.params, newStyle);
          this._destroyOldContent();
          this._createContent();
          // * Redraw Text
          return this.drawText(this._lastText || "");
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateFontSize(fontSize) {
        var e, font;
        try {
          font = Object.assign({}, this.params.font);
          if (typeof fontSize === "string") {
            fontSize = this._getValueByStr(fontSize, 'height', this);
          }
          font.size = fontSize;
          return this.updateStyle({font});
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      //?DYNAMIC
      // * Сперва рисуем по готовности, а как загрузился спрайт, меняем
      drawText(text) {
        var e;
        try {
          this.params.text = text;
          return this._drawTextWhenReady(text);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      // * Сборка текста с учётом формата
      // * Заменить вхождения %1, %2 на значения параметров
      drawTextWithFormat(/*format string, arguments parameters... */) {
        var text;
        text = this._convertFormatedString(...arguments);
        this.drawText(text);
      }

      // * Пишет текст с определённым цветом (один раз)
      drawTextColor(text, colorCss) {
        if (this._textSpr == null) {
          return;
        }
        this._textSpr.b().textColor = colorCss;
        this.drawText(text);
        this._textSpr.b().textColor = this.params.textColor;
      }

    };
    KDCore.UI.Sprite_UIText = Sprite_UIText;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIText.prototype;
    _._destroyOldContent = function() {
      var e, ref, ref1;
      try {
        if ((ref = this._shadowSpr) != null) {
          ref.removeFromParent();
        }
        return (ref1 = this._textSpr) != null ? ref1.removeFromParent() : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //$[OVER]
    _._createContent = function() {
      if (this.params.shadow != null) {
        this._createShadow();
      }
      return this._createTextSprite();
    };
    _._createTextSprite = function() {
      this._textSpr = KDCore.Sprite.FromParams(this.params);
      this._textSpr.onReady(this._onReady.bind(this));
      return this.add(this._textSpr);
    };
    // * Выполнить по готовности
    _._onReady = function() {
      // * Переключить метод, так как уже готов
      this.drawText = this._drawText;
      // * Написать то что нужно было до готовности (если есть)
      if (this._drawOnReady == null) {
        return;
      }
      this.drawText(this._drawOnReady);
      this._drawOnReady = null;
    };
    _._drawText = function(text) {
      this._lastText = text;
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      if (text != null) {
        this._textSpr.drawTextFull(text);
      }
      if (this._shadowSpr != null) {
        this._shadowSpr.clear();
        if (text != null) {
          this._shadowSpr.drawTextFull(text);
        }
      }
    };
    // * Написать текст когда будет готов
    _._drawTextWhenReady = function(text) {
      this._drawOnReady = text;
      return this._drawText(text);
    };
    
    // * Заменить вхождения %1, %2 на значения параметров
    _._convertFormatedString = function(/*text, args...*/) {
      var e, i, j, ref, text;
      try {
        text = arguments[0];
        for (i = j = 1, ref = arguments.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
          try {
            if (arguments[i] == null) {
              continue;
            }
            text = text.replace("%" + i, arguments[i]);
          } catch (error) {
            e = error;
            KDCore.warning(e);
            text = "[wrong format text input]";
          }
        }
        return text;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "[wrong format text input]";
      }
    };
    _._createShadow = function() {
      this._shadowSpr = KDCore.Sprite.FromParams(this.params);
      this._shadowSpr.bitmap.textColor = this.params.shadow.color;
      this._shadowSpr.opacity = this.params.shadow.opacity;
      this._shadowSpr.x += this.params.shadow.margins.x;
      this._shadowSpr.y += this.params.shadow.margins.y;
      return this.add(this._shadowSpr);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //NUI 1.0
    //rev 11.05.22
    var Sprite_UIText2;
    
      //"type": "text"
    Sprite_UIText2 = class Sprite_UIText2 extends KDCore.UI.Sprite_UIElement {
      constructor(params, userTextStyle) {
        super(params);
        this.userTextStyle = userTextStyle;
        this._applyParameters(params);
        this._createTextSprite();
        if (String.any(this.params.text)) {
          this.drawText(this.params.text);
        }
        return;
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 60,
            height: 20
          },
          alignment: "center",
          font: {
            face: null,
            size: 18,
            italic: false,
            bold: false,
            weight: 0 // * 0 - not used
          },
          margins: {
            x: 0,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#FFFFFF",
          shadow: {
            color: "#000",
            opacity: 0,
            margins: {
              x: 1,
              y: 1
            }
          },
          text: "",
          multiline: false,
          verticalCentered: true
        };
      }

      // * For compatibility with old style configurations
      sizeWidth() {
        if (this.params.size.w != null) {
          return this.params.size.w;
        } else {
          if (this.params.size.width != null) {
            this.params.size.w = this.params.size.width;
            return this.params.size.width;
          }
        }
        return 0;
      }

      // * For compatibility with old style configurations
      sizeHeight() {
        if (this.params.size.h != null) {
          return this.params.size.h;
        } else {
          if (this.params.size.height != null) {
            this.params.size.h = this.params.size.height;
            return this.params.size.height;
          }
        }
        return 0;
      }

      dataBindings() {
        return Object.assign(super.dataBindings(), {
          text: function(v) {
            return this.drawText(v);
          },
          style: function(v) {
            if (v != null) {
              return this.updateStyle(v);
            }
          },
          width: function(v) {
            if (v != null) {
              return this.setSize(v, this.sizeHeight());
            }
          },
          height: function(v) {
            if (v != null) {
              return this.setSize(this.sizeWidth(), v);
            }
          },
          size: function(v) {
            if (v != null) {
              return this.setSize(v.width, v.height);
            }
          },
          textColor: function(v) {
            if (v != null) {
              return this.updateStyle({
                textColor: v
              });
            }
          },
          fontSize: function(v) {
            if (v != null) {
              return this.updateFontSize(v);
            }
          }
        });
      }

      realWidth() {
        return this.sizeWidth();
      }

      realHeight() {
        return this.sizeHeight();
      }

      setSize(w = 60, h = 20) {
        var e;
        try {
          w = this._getValueByStr(w, 'width', this);
          h = this._getValueByStr(h, 'height', this);
          return this.updateStyle({
            size: {
              w: w,
              h: h
            }
          });
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      defaultStyle() {
        return {};
      }

      drawText(text) {
        if (text == null) {
          text = "";
        }
        this.params.text = text;
        this._drawText(text);
      }

      // * Сборка текста с учётом формата
      // * Заменить вхождения %1, %2 на значения параметров
      drawTextWithFormat(/*format string, arguments parameters... */) {
        var text;
        text = this._convertFormatedString(...arguments);
        this.drawText(text);
      }

      // * Пишет текст с определённым цветом (один раз)
      drawTextColor(text, colorCss = "#FFF") {
        if (this._textSpr == null) {
          return;
        }
        this.updateStyle({
          textColor: colorCss
        });
        this.drawText(text);
      }

      updateFontSize(fontSize) {
        var e, font;
        try {
          font = Object.assign({}, this.params.font);
          if (typeof fontSize === "string") {
            fontSize = this._getValueByStr(fontSize, 'height', this);
          }
          font.size = fontSize;
          return this.updateStyle({font});
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateStyle(newStyleInOldFormat = {}, newStyleInNewFormat = {}) {
        var e;
        try {
          this.textStyle = this._convertOldStyle(newStyleInOldFormat, newStyleInNewFormat);
          this._textSpr.style = this.textStyle;
          // * Redraw Text
          return this.drawText(this._textSpr.text);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      getMetrics() {
        return PIXI.TextMetrics.measureText(this._textSpr.text, this._textSpr.style);
      }

    };
    KDCore.UI.Sprite_UIText2 = Sprite_UIText2;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIText2.prototype;
    _._applyParameters = function(params) {
      var e;
      try {
        return this.textStyle = this._convertOldStyle(params, {});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._convertOldStyle = function(params = {}, style = {}) {
      var _textStyle, color, e, margins, opacity;
      try {
        this.params = Object.assign({}, this.params, params);
        _textStyle = Object.assign({}, this.defaultStyle(), this.userTextStyle, style);
        if (String.any(this.params.font.face)) {
          _textStyle.fontFamily = this.params.font.face;
        }
        _textStyle.fontSize = this.params.font.size;
        if (this.params.font.italic === true) {
          _textStyle.fontStyle = 'italic';
        }
        if (this.params.font.bold === true) {
          _textStyle.fontWeight = 'bold';
        }
        if ((this.params.font.weight != null) && this.params.font.weight > 0) {
          _textStyle.fontWeight = this.params.font.weight;
        }
        if (String.any(this.params.outline.color) && this.params.outline.width > 0) {
          _textStyle.stroke = this.params.outline.color;
          _textStyle.strokeThickness = this.params.outline.width;
        }
        _textStyle.fill = this.params.textColor;
        if ((this.params.shadow != null) && this.params.shadow.opacity > 0) {
          ({color, opacity, margins} = this.params.shadow);
          _textStyle.dropShadow = true;
          _textStyle.dropShadowAngle = margins.y;
          _textStyle.dropShadowColor = color;
          _textStyle.dropShadowDistance = margins.x;
          _textStyle.dropShadowAlpha = opacity / 255.0;
        }
        if (this.params.multiline === true) {
          _textStyle.align = this.params.alignment || 'left';
          _textStyle.wordWrap = true;
          if (this.params.font.size != null) {
            _textStyle.lineHeight = this.params.font.size + 2;
          }
          if (this.sizeWidth() > 0) {
            _textStyle.wordWrapWidth = this.sizeWidth();
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return _textStyle;
    };
    _._createTextSprite = function() {
      var style;
      style = new PIXI.TextStyle(this.textStyle);
      this._textSpr = new PIXI.Text('', style);
      this.add(this._textSpr);
      if (this._needToDrawText != null) {
        this.draw(this._needToDrawText);
        this._needToDrawText = null;
      }
    };
    _._drawText = function(text) {
      var e, h, height, maxLineWidth, textMetrics, w;
      if (this._textSpr == null) {
        this._needToDrawText = text;
        return;
      }
      this._textSpr.text = text;
      if (this.params.size.height != null) {
        this.params.size.h = this.params.size.height;
      }
      if (this.params.size.width != null) {
        this.params.size.w = this.params.size.width;
      }
      ({w, h} = this.params.size);
      try {
        if (typeof text !== "string") {
          text = String(text);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        text = "[wrong text input]";
      }
      textMetrics = PIXI.TextMetrics.measureText(text, this._textSpr.style);
      ({height, maxLineWidth} = textMetrics);
      if (this.params.verticalCentered === true) {
        this._textSpr.y = (h - height) / 2;
      } else {
        this._textSpr.y = 0;
      }
      if (this.params.alignment === 'center') {
        this._textSpr.x = (w - maxLineWidth) / 2;
      } else if (this.params.alignment === 'right') {
        this._textSpr.x = w - maxLineWidth;
      } else {
        this._textSpr.x = 0;
      }
      this._textSpr.x += this.params.margins.x;
      this._textSpr.y += this.params.margins.y;
    };
    // * Заменить вхождения %1, %2 на значения параметров
    _._convertFormatedString = function(/*text, args...*/) {
      var e, i, j, ref, text;
      try {
        text = arguments[0];
        for (i = j = 1, ref = arguments.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
          try {
            if (arguments[i] == null) {
              continue;
            }
            text = text.replace("%" + i, arguments[i]);
          } catch (error) {
            e = error;
            KDCore.warning(e);
            text = "[wrong format text input]";
          }
        }
        return text;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "[wrong format text input]";
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //TODO: NOT USED IN NUI 1.0
    //NUI 1.X !#!
    //rev 03.05.22

    //"type": "textExt"
    var Sprite_UITextExt;
    Sprite_UITextExt = class Sprite_UITextExt extends KDCore.UI.Sprite_UIText {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 200,
            height: 60
          },
          font: {
            face: null,
            size: 14,
            italic: false
          },
          margins: {
            x: 0,
            y: 0
          },
          // * новые параметры (KDCore 2.7)
          //?null могут быть
          singleLine: false,
          forceCentered: false
        };
      }

      //$[OVER]
      // * Данный метод не поддерживается, так как тут основа не Sprite, а Window
      drawTextColor() {
        return this.drawText(...arguments);
      }

    };
    KDCore.UI.Sprite_UITextExt = Sprite_UITextExt;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITextExt.prototype;
    //$[OVER]
    _._destroyOldContent = function() {
      var e;
      try {
        if (this._textSpr == null) {
          return;
        }
        return this.removeChild(this._textSpr);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //$[OVER]
    _._createTextSprite = function() {
      var rect;
      rect = new Rectangle(0, 0, this.sizeWidth(), this.sizeHeight());
      this._textSpr = new KDCore.Window_ExtTextLineBase(rect, this.params.font);
      this._textSpr.x = this.params.margins.x || 0;
      this._textSpr.y = this.params.margins.y || 0;
      this.add(this._textSpr);
      // * На следующий кадр, чтобы не было потери текста (опасно)
      setTimeout((() => {
        var e;
        try {
          return this._onReady();
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }), 10);
      this._onReady(); // * Сразу
    };
    
    //$[OVER]
    _._drawText = function(text) {
      this._lastText = text;
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.contents.clear();
      if (this.params.forceCentered === true) {
        this._textSpr.drawTextExInCenter(text, 0, 0, this._textSpr.width, this._textSpr.height);
      } else {
        if (this.params.singleLine === true) {
          this._textSpr.drawTextEx(text, 0, 0, this._textSpr.width);
        } else {
          // * По умолчанию
          this._textSpr.drawTextExWithWordWrap(text, 0, 0, this._textSpr.width);
        }
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UITextWithBack;
    Sprite_UITextWithBack = class Sprite_UITextWithBack extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          text: {
            visible: true,
            size: {
              w: 60,
              h: 20
            },
            alignment: "center",
            font: {
              face: null,
              size: 18,
              italic: false
            },
            margins: {
              x: 0,
              y: 0
            },
            outline: {
              color: null,
              width: 2
            },
            textColor: "#000000".toCss()
          },
          rect: {
            visible: true,
            size: {
              w: 60,
              h: 20
            },
            fillColor: "#FFFFFF".toCss(),
            fillOpacity: 255,
            borderColor: "#000000".toCss(),
            borderThickness: 1,
            borderOpacity: 255
          },
          textMargins: {
            x: 0,
            y: 0
          }
        };
      }

      draw() {
        return this.drawText(...arguments);
      }

      // * Aргументы смотри в Sprite_UIText
      drawText() {
        return this.text.draw(...arguments);
      }

      drawTextColor() {
        return this.text.drawTextColor(...arguments);
      }

      // * Аргументы смотри в Sprite_UIRect
      fill() {
        return this.rect.fill(...arguments);
      }

      drawBorder() {
        return this.rect.drawBorder(...arguments);
      }

      //$[OVER]
      isUnderMouse() {
        return this.rect.isUnderMouse();
      }

    };
    KDCore.UI.Sprite_UITextWithBack = Sprite_UITextWithBack;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITextWithBack.prototype;
    //$[OVER]
    _._createContent = function() {
      this._createRect();
      return this._createText();
    };
    _._createRect = function() {
      this.rect = new KDCore.UI.Sprite_UIRect(this.params.rect);
      return this.addChild(this.rect);
    };
    _._createText = function() {
      var x, y;
      this.text = new KDCore.UI.Sprite_UIText(this.params.text);
      ({x, y} = this.params.textMargins);
      this.text.move(x, y);
      return this.addChild(this.text);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIColorGauge;
    Sprite_UIColorGauge = class Sprite_UIColorGauge extends KDCore.UI.Sprite_UIGauge {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            w: 100,
            h: 40
          },
          fill: "#FFFFFF", // * В отличии от Gauge, тут цвет, а не картинка
          foreground: "", // картинка
          mask: "", // картинка
          backColor: "#000000".toCss(),
          backOpacity: 255,
          vertical: false,
          rootImageFolder: null //?optional
        };
      }

    };
    KDCore.UI.Sprite_UIColorGauge = Sprite_UIColorGauge;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIColorGauge.prototype;
    //$[OVER]
    // * Заместо изображения используем простой Bitmap с заливкой цвета
    _._loadFillImage = function() {
      var fillBitmap;
      fillBitmap = new Bitmap(this.params.size.w, this.params.size.h);
      fillBitmap.fillAll(this.params.fill);
      this._createParts(fillBitmap);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    // * Данный UI Элемент является только контейнером
    // * Он ничего не рисует, нужно добавлять в него
    // * контент методом addContent

    //rev 17.11.22
    var Sprite_UITooltip;
    Sprite_UITooltip = class Sprite_UITooltip extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
        this.opacity = 0;
      }

      isTooltipActive() {
        return (this._opThread != null) || (this._opChanger != null) || this.opacity > 0;
      }

      activateTooltip(x, y, parent) {
        if (this.isTooltipActive()) {
          return;
        }
        this.deactivateTooltip();
        this.move(x, y);
        this._opThread = new KDCore.TimedUpdate(this.params.delay, this.showTooltip.bind(this));
        if (!this.params.isGlobal && (parent != null)) {
          parent.addChild(this);
        } else {
          // * Always on Top on Scene  (if Global)
          SceneManager._scene.addChild(this);
        }
      }

      deactivateTooltip() {
        this._opThread = null;
        this._opChanger = null;
        return this.opacity = 0;
      }

      showTooltip() {
        this._opThread = null;
        this.appear(this.params.opacityChangeStep);
        if (this.params.cursorRelative === true) {
          return this.toCursor();
        }
      }

      update() {
        var ref;
        super.update();
        if ((ref = this._opThread) != null) {
          ref.update();
        }
        if (this.isTooltipActive() && this.params.cursorRelative === true) {
          return this.toCursor();
        }
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          delay: 30,
          opacityChangeStep: 35,
          margins: {
            x: 8,
            y: 8
          },
          isGlobal: true,
          cursorRelative: true
        };
      }

      toCursor() {
        var x, y;
        ({x, y} = this.params.margins);
        return this.move(TouchInput.x + x, TouchInput.y + y);
      }

      // * Основной метод, нужно добавить контент
      addContent(content) {
        return this.add(content);
      }

    };
    KDCore.UI.Sprite_UITooltip = Sprite_UITooltip;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITooltip.prototype;
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS__processEscapeCharacter, _;
  //@[DEFINES]
  _ = Window_Base.prototype;
  //@[ALIAS]
  ALIAS__processEscapeCharacter = _.processEscapeCharacter;
  _.processEscapeCharacter = function(code, textState) {
    switch (code) {
      case 'CHEX':
        this.pProcessColorChangeHex(this.pObtainEscapeParamHexColor(textState));
        break;
      case 'ISZ':
        this.pProcessDrawIconSized(this.pObtainEscapeParamIconArr(textState), textState);
        break;
      case 'PSZ':
        this.pProcessDrawPictureSized(this.pObtainEscapeParamImgArr(textState), textState, false);
        break;
      case 'PSB':
        this.pProcessDrawPictureSized(this.pObtainEscapeParamImgArr(textState), textState, true);
        break;
      default:
        ALIAS__processEscapeCharacter.call(this, code, textState);
    }
  };
  //?NEW
  _.pObtainEscapeParamHexColor = function(textState) {
    var arr, regExp, textPart;
    regExp = /^\[(#?([0-9a-fA-F]{2}){3}|([0-9a-fA-F]){3})\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      return arr[1];
    } else {
      return "";
    }
  };
  //?NEW
  _.pObtainEscapeParamIconArr = function(textState) {
    var arr, params, regExp, textPart;
    regExp = /^\[(\d+,\s*\d+,\s*-?\d+,\s*-?\d+)\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      if (arr[1] != null) {
        params = arr[1].split(",").map(function(i) {
          return parseInt(i.trim());
        });
        return params;
      }
    }
    return [];
  };
  //?NEW
  _.pObtainEscapeParamImgArr = function(textState) {
    var arr, params, regExp, textPart;
    regExp = /^\[(\w+,\s*\d+,\s*\d+,\s*-?\d+,\s*-?\d+)\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      if (arr[1] != null) {
        params = arr[1].split(",").map(function(i) {
          if (isFinite(i)) {
            return parseInt(i.trim());
          } else {
            return i;
          }
        });
        return params;
      }
    }
    return [];
  };
  //?NEW
  _.pProcessColorChangeHex = function(colorHex) {
    var e;
    try {
      this.changeTextColor(colorHex);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.resetTextColor();
    }
  };
  //?NEW
  //?params: [INDEX, SIZE, DX, DY]
  _.pProcessDrawIconSized = function(params, textState) {
    var dx, dy, e, iconIndex, size, staticMargin, x, y;
    try {
      if (params == null) {
        return;
      }
      if (params.isEmpty()) {
        return;
      }
      size = params[1];
      if (params[1] == null) {
        if (KDCore.isMZ()) {
          size = ImageManager.iconWidth;
        } else {
          size = Window_Base._iconWidth;
        }
      }
      if (params[2] == null) {
        params[2] = 0;
      }
      if (params[3] == null) {
        params[3] = 0;
      }
      iconIndex = params[0];
      dx = params[2];
      dy = params[3];
      staticMargin = 2;
      x = textState.x + staticMargin + dx;
      y = textState.y + staticMargin + dy;
      if (KDCore.isMZ()) {
        if (textState.drawing === true) {
          // * Только в режиме рисования
          this.contents.drawIcon(x, y, iconIndex, size);
        }
      } else {
        this.contents.drawIcon(x, y, iconIndex, size);
      }
      textState.x += size + (staticMargin * 2) + dx;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  //?NEW
  //?params: [NAME, W, H, DX, DY]
  _.pProcessDrawPictureSized = function(params, textState, isUnderText = false) {
    var drawBitmap, drawProcess, e, height, name, source, width, x, y;
    try {
      if (params == null) {
        return;
      }
      if (params.isEmpty()) {
        return;
      }
      name = params[0];
      if (!String.any(name)) {
        return;
      }
      width = params[1];
      height = params[2];
      if (params[3] == null) {
        params[3] = 0;
      }
      if (params[4] == null) {
        params[4] = 0;
      }
      x = textState.x + 2 + params[3];
      y = textState.y + 2 + params[4];
      drawBitmap = this.contents;
      source = this.pGetSourceImageForDrawPictureSized(name);
      if ((KDCore.isMZ() && textState.drawing === true) || KDCore.isMV()) {
        drawProcess = function() {
          var e;
          try {
            if (drawBitmap == null) {
              return;
            }
            return drawBitmap.drawOnMe(source, x, y, width, height);
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        source.addLoadListener(drawProcess);
      }
      if (isUnderText !== true) {
        // * Вариант, что текст не будет "перескакивать" за ширину картинки а пойдёт поверх (т.е. фоновая картинка)
        // * Если картине не preload, то может "вылезти" на текст потом, так как рисоваться будет позже
        textState.x += width + 4 + params[3];
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  // * Данный метод вынесен отдельно, чтобы можно было переопределять папки
  return _.pGetSourceImageForDrawPictureSized = function(name) {
    return ImageManager.loadPicture(name);
  };
});


// Generated by CoffeeScript 2.6.1



// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var FloatingWindow;
  
    // * Общий класс для всех окон на карте
  /*parameters
      {
          draggable: true,
          closeButton: true,
          moveToCenter: true,
          alwaysOnTop: true,
          header: true
      }
  */
  FloatingWindow = class FloatingWindow extends KDCore.Sprite {
    constructor(mainParent, windowW, windowH, parameters) {
      super();
      this.mainParent = mainParent;
      this.windowW = windowW;
      this.windowH = windowH;
      this.parameters = parameters;
      this._init();
      return;
    }

    static StaticSettings() {
      return {
        draggable: false,
        closeButton: false,
        moveToCenter: false,
        alwaysOnTop: false,
        header: false
      };
    }

    // * Статическое окно с дочерним
    static StaticWindow(parent, sub) {
      var p, w;
      p = KDCore.FloatingWindow.StaticSettings();
      w = new KDCore.FloatingWindow(parent, sub.width, sub.height, p);
      w.setSubWindow(sub);
      w.open();
      return w;
    }

    isActive() {
      return this.visible === true;
    }

    isReady() {
      return this._isReady === true;
    }

    isMouseIn() {
      return this.inPosition(TouchInput);
    }

    isOpen() {
      return this.isActive();
    }

    // * Дочернее окно (если есть)
    sub() {
      return this._subw;
    }

    setOnReadyHandler(_readyHandler) {
      this._readyHandler = _readyHandler;
      if ((this._readyHandler != null) && this._isReady === true) {
        return this._readyHandler();
      }
    }

    isDraggable() {
      return this._isDraggable === true && (this._headerSpr != null) && this._headerSpr.visible === true && this.isOpen();
    }

    setCloseHandler(_closeHandler) {
      this._closeHandler = _closeHandler;
    }

    callCloseHandler() {
      if (this._closeHandler != null) {
        return this._closeHandler();
      }
    }

    setDraggingHandler(_dragHandler) {
      this._dragHandler = _dragHandler;
    }

    setDragEndHandler(_dragEndHandler) {
      this._dragEndHandler = _dragEndHandler;
    }

    hideHeader() {} //TODO:

    hideCloseButton() {} //TODO:

    
      // * Сдвиг заголовка по X, чтобы рамку не задевал
    headerMarginX() {
      return 2;
    }

    // * Сдвиг заголовка по Y, чтобы рамку не задевал
    headerMarginY() {
      return 0;
    }

    // * Стандартная позиция кнопки "закрыть"
    closeButtonPosition() {
      return {
        x: this.width - 24,
        y: 4
      };
    }

    open() {
      if (this.isOpen()) {
        return;
      }
      this._open();
      this._afterOpen();
    }

    close() {
      if (!this.isOpen()) {
        return;
      }
      this._close();
      this._afterClose();
    }

    rootImageFolder() {
      return "Alpha/Windows";
    }

    update() {
      super.update();
      this._updateMouseCheckThread();
      this._updateDragging();
    }

    // * Добавить спрайт на специальный слой контента
    addContent(sprite) {
      return this._contentLayer.addChild(sprite);
    }

    // * Добавить дочернее окно
    setSubWindow(w) {
      this._subw = w;
      this.addContent(w);
    }

    destroy() {
      this._close();
      return Sprite.prototype.destroy.call(this);
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = FloatingWindow.prototype;
    _._init = function() {
      var ref;
      // * Окно всегда закрыто
      this.visible = false;
      // * Контент прогрузился?
      this._isReady = false;
      this._applyParameters();
      if (this._isAlwaysOnTop === false) {
        // * Если не всегда поверх окон, то добавляем сразу к родителю (один раз)
        if ((ref = this.mainParent) != null) {
          ref.addChild(this);
        }
      }
      this._initFloatingSystem();
      this._createLayers();
      this._loadWindowFrame();
    };
    // * Тут ничего не создавать, не двигать, так как
    // * конент создаётся Async, см. метод _createCustomElements
    _._applyParameters = function() {
      var p;
      this._applyDefaults();
      if (this.parameters == null) {
        return;
      }
      p = this.parameters;
      if (p.draggable != null) {
        this._isDraggable = p.draggable;
      }
      if (p.moveToCenter != null) {
        this._isMoveToCenter = p.moveToCenter;
      }
      if (p.header != null) {
        this._isHeaderVisible = p.header;
      }
      if (p.closeButton != null) {
        this._isHaveCloseButton = p.closeButton;
      }
      if (p.alwaysOnTop != null) {
        this._isAlwaysOnTop = p.alwaysOnTop;
      }
    };
    _._applyDefaults = function() {
      // * Окно можно перетаскивать мышкой (по умолчанию - да)
      this._isDraggable = true;
      this._isMoveToCenter = true;
      this._isHeaderVisible = true;
      this._isHaveCloseButton = true;
      this._isAlwaysOnTop = true;
    };
    _._initFloatingSystem = function() {
      if ($gameTemp._floatingWindows == null) {
        // * Создаём массив окон, он нужен для правильного
        // закрытия окон (по очереди) и перемещения drag and drop
        // с учётом верхнего окна
        $gameTemp._floatingWindows = [];
      }
      // * Вспомогательная переменная, чтобы не вызывать методы каждый кадр
      this._mouseIn = false;
      // * Тоже вспомогательная переменная
      this._dragging = false;
    };
    _._moveToStartPosition = function() {
      if (this._isMoveToCenter === true) {
        return this.moveToCenter(Graphics.width / 2, Graphics.height / 2);
      }
    };
    _._closeButtonClick = function() {
      // * При исчезании, кнопка не успевает себя "удалить"
      $gameTemp.kdButtonUnderMouse = null;
      this.callCloseHandler();
      return this.close();
    };
    (function() {      // * DRAGGING
      // -----------------------------------------------------------------------
      _._updateDragging = function() {
        if (!this.isDraggable()) {
          return;
        }
        // * Если мы уже двигаем окно, но мышка вышла за границы, то можно дальше двигать
        // * Только если мышка не в окне и не двигали ранее, то не проверяем
        if (this._mouseIn === false && this._dragging === false) {
          return;
        }
        // * Если существует объект который сейчас dragging
        if ($gameTemp.pkdDraggableInstance != null) {
          // * Если этот объект не этот объект, то выходим из метода
          if ($gameTemp.pkdDraggableInstance !== this) {
            return;
          }
        }
        if (TouchInput.isLongPressed()) {
          if (this._dragging === false) {
            this._onDragStart();
          } else {
            this._onDragging();
          }
        } else {
          this._stopDragging();
        }
      };
      _._onDragStart = function() {
        // * Проверка, в области Header или нет
        if (!this._isMouseInHeader()) {
          return;
        }
        // * Разница в координатах курсора и объекта, чтобы убрать эффект "прыжка"
        this.opacity = 200;
        this._deltaXY = this.getDeltaXY();
        this._dragging = true;
        // * Устанавливаем глобальную ссылку на объект перемещения
        $gameTemp.pkdDraggableInstance = this;
      };
      _.getDeltaXY = function() {
        var p;
        p = new KDCore.Point(this.x, this.y);
        return p.delta(TouchInput);
      };
      _._onDragging = function() {
        // * Защита от перетаскивания за края экрана
        if (!this._isNewMousePositionOnScreen()) {
          return;
        }
        this.move(TouchInput.x - this._deltaXY.x, TouchInput.y - this._deltaXY.y);
        if (this._dragHandler != null) {
          return this._dragHandler();
        }
      };
      _._stopDragging = function() {
        if (this._dragging === true) {
          this._dragging = false;
          this.opacity = 255;
          this._clearDraggableGlocalInstance();
          if (this._dragEndHandler != null) {
            this._dragEndHandler();
          }
        }
      };
      // * Освобождаем глобальную ссылку
      _._clearDraggableGlocalInstance = function() {
        if ($gameTemp.pkdDraggableInstance === this) {
          return $gameTemp.pkdDraggableInstance = null;
        }
      };
      _._isMouseInHeader = function() {
        if (this._headerSpr == null) {
          return false;
        }
        return this._headerSpr.isContainsPoint(TouchInput);
      };
      _._isNewMousePositionOnScreen = function() {
        return KDCore.Utils.isPointInScreen(TouchInput, 10);
      };
    })();
    (function() {      // -----------------------------------------------------------------------

      // * CREATE ELEMENTS
      // -----------------------------------------------------------------------
      
      // * Слои нужны, так как изображения загружаються асинхронно
      _._createLayers = function() {
        this._mainLayer = new Sprite();
        this._contentLayer = new Sprite();
        this._headerLayer = new Sprite();
        this._closeButtonLayer = new Sprite();
        this.addChild(this._mainLayer);
        this.addChild(this._contentLayer);
        this.addChild(this._headerLayer);
        this.addChild(this._closeButtonLayer);
      };
      _._loadWindowFrame = function() {
        return KDCore.Utils.loadImageAsync(this.rootImageFolder(), "windowFrame").then(this._createWindow.bind(this));
      };
      _._createWindow = function(frameImage) {
        this.bitmap = new Bitmap(this.windowW, this.windowH);
        this.wFrame = new KDCore.Sprite_TilingFrame(this.windowW, this.windowH, frameImage);
        this._mainLayer.addChild(this.wFrame);
        this._createParts();
      };
      _._createParts = function() {
        this._loadHeader();
        if (this._isHaveCloseButton === true) {
          this._createCloseButton();
        }
        this._moveToStartPosition();
        this._createCustomElements();
        // * Окно готово
        this._isReady = true;
        if (this._readyHandler != null) {
          this._readyHandler();
        }
      };
      _._loadHeader = function() {
        return KDCore.Utils.loadImageAsync(this.rootImageFolder(), "headerLine").then(this._createHeader.bind(this));
      };
      _._createHeader = function(headerLineImage) {
        var w;
        w = this.windowW - (this.headerMarginX() * 2);
        this._headerSpr = new KDCore.Sprite_TilingLine(w, headerLineImage.height, headerLineImage);
        this._headerSpr.x = this.headerMarginX();
        this._headerSpr.y = this.headerMarginY();
        this._headerLayer.addChild(this._headerSpr);
        if (this._isHeaderVisible === true) {
          // * Сдвигаем контент, чтобы было начало под заголовком
          this._contentLayer.y += headerLineImage.height + this.headerMarginY();
        } else {
          this._headerSpr.visible = false;
        }
      };
      _._createCloseButton = function() {
        this._closeButton = new KDCore.ButtonM("windowCloseButton", false, this.rootImageFolder());
        this._closeButtonLayer.addChild(this._closeButton);
        this._closeButton.move(this.closeButtonPosition());
        this._closeButton.addClickHandler(this._closeButtonClick.bind(this));
      };
      //%[FOR CHILDRENS]
      // * Наследники создают свои элементы в этом методе
      // * Есть специальный метод addContent()
      _._createCustomElements = function() {}; // * EMPTY
    })();
    (function() {      // -----------------------------------------------------------------------

      // * MOUSE
      // -----------------------------------------------------------------------
      
      // * Определение если мышка в области окна
      //TODO: Есть проблема при открытии окна сразу под курсором
      _._registerMouseInOut = function() {
        if (!this.isOpen()) {
          return;
        }
        if (this.isMouseIn()) {
          if (this._mouseIn === false) {
            this._mouseIn = true;
            this._onMouseIn();
          }
        } else {
          if (this._mouseIn === true) {
            this._mouseIn = false;
            this._onMouseOut();
          }
        }
      };
      // * Используется похожая система что и в KDCore.ButtonM
      _._onMouseIn = function() {
        return $gameTemp.floatingWindowUnderMouse = this;
      };
      _._onMouseOut = function() {
        if ($gameTemp.floatingWindowUnderMouse === this) {
          return $gameTemp.floatingWindowUnderMouse = null;
        }
      };
      // * Будем проверять мышка ли в окне только при открытом окне
      _._createMouseCheckThread = function() {
        this._mouseCheckThread = new KDCore.TimedUpdate(1, this._registerMouseInOut.bind(this));
        this._updateMouseCheckThread = () => {
          return this._mouseCheckThread.update();
        };
        return this._mouseCheckThread.call();
      };
      // * Когда окно закрывается, никаких проверок, обнуляем метод
      _._destroyMouseCheckThread = function() {
        this._mouseCheckThread = null;
        return this._updateMouseCheckThread = function() {};
      };
      //?DYNAMIC
      _._updateMouseCheckThread = function() {}; // * EMPTY
    })();
    (function() {      // -----------------------------------------------------------------------

      // * OPEN OR CLOSE
      // -----------------------------------------------------------------------
      _._open = function() {
        var ref, ref1;
        this.visible = true;
        if ((ref = $gameTemp._floatingWindows) != null) {
          ref.push(this);
        }
        if (this._isAlwaysOnTop === true) {
          // * Окно, которое открывается, всегда снова выше остальных (опция)
          if ((ref1 = this.mainParent) != null) {
            ref1.addChild(this);
          }
        }
        return this._createMouseCheckThread();
      };
      _._afterOpen = function() {}; // * EMPTY
      _._close = function() {
        this.visible = false;
        if (this._isAlwaysOnTop === true) {
          this.removeFromParent();
        }
        this._clearDraggableGlocalInstance();
        $gameTemp._floatingWindows.delete(this);
        this._onMouseOut();
        return this._destroyMouseCheckThread();
      };
      _._afterClose = function() {}; // * EMPTY
    })();
  })();
  (function() {    // ■ END PRIVATE.coffee
    //---------------------------------------------------------------------------

    // * Если окно под курсором, нельзя нажимать на карте для движения игрока
    // -----------------------------------------------------------------------
    (function() {      //╒═════════════════════════════════════════════════════════════════════════╛
      // ■ Scene_Map.coffee
      //╒═════════════════════════════════════════════════════════════════════════╛
      //---------------------------------------------------------------------------
      var ALIAS__isAnyButtonPressed, ALIAS__processMapTouch, _;
      
      //@[DEFINES]
      _ = Scene_Map.prototype;
      if (KDCore.isMZ()) {
        //@[ALIAS]
        ALIAS__isAnyButtonPressed = _.isAnyButtonPressed;
        _.isAnyButtonPressed = function() {
          if ($gameTemp.floatingWindowUnderMouse != null) {
            return true;
          } else {
            return ALIAS__isAnyButtonPressed.call(this);
          }
        };
      } else {
        //@[ALIAS]
        ALIAS__processMapTouch = _.processMapTouch;
        _.processMapTouch = function() {
          if ($gameTemp.floatingWindowUnderMouse != null) {
            return;
          }
          return ALIAS__processMapTouch.call(this);
        };
      }
    })();
  })();
  //@[EXTEND]
  // ■ END Scene_Map.coffee
  //---------------------------------------------------------------------------
  return KDCore.FloatingWindow = FloatingWindow;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var HUI;
  // * Html UI Manager
  // * Набор инструментов для работы с HTML элементами интерфейса
  HUI = function() {};
  (function() {
    var _;
    //@[DEFINES]
    _ = HUI;
    _.init = function() {
      // * Данный набор инструментов могут использовать многие плагины, поэтому проверка
      if (this.isInited()) {
        return;
      }
      this._createMainParentInHtml();
      this._extendGraphicsClass();
      this.refresh();
    };
    // * Был ли создан (инициализирован) основной элемент
    _.isInited = function() {
      return this.parent() != null;
    };
    // * Основной элемент родитель для всех элементов UI
    _.parent = function() {
      return this._parent;
    };
    _.refresh = function() {
      if (!this.isInited()) {
        return;
      }
      Graphics._centerElement(this._parent);
      this._parent.style.zIndex = 2;
      this._parent.style.width = Graphics._canvas.style.width;
      this._parent.style.height = Graphics._canvas.style.height;
    };
    _.initReactComponents = function(withBabel = true) {
      var e;
      try {
        if (withBabel) {
          this._loadBabel();
        }
        return this._loadReact();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadBabel = function() {
      var e;
      try {
        return this._loadScript('https://unpkg.com/babel-standalone@6/babel.min.js');
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadReact = function() {
      var e;
      try {
        this._loadScript('https://unpkg.com/react@18/umd/react.production.min.js');
        return this._loadScript('https://unpkg.com/react-dom@18/umd/react-dom.production.min.js');
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadScript = function(src, isReact = false) {
      var e, script;
      try {
        script = document.createElement("script");
        if (isReact === true) {
          script.type = "text/babel";
        } else {
          script.type = "text/javascript";
          script.crossorigin = true;
        }
        script.src = src;
        script.async = false;
        script.defer = true;
        script.onerror = function(e) {
          KDCore.warning('HUI: Failed to load script');
          return KDCore.warning(e);
        };
        document.body.appendChild(script);
        if (isReact === true) {
          return window.dispatchEvent(new Event('DOMContentLoaded'));
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.loadReactComponent = function(componentName, folder = 'data/uiComponents') {
      var e, src;
      try {
        src = folder + "/" + componentName + ".js";
        return this._loadScript(src, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addReactComponent = function(componentName, props, uniqueId = null) {
      var e, element, reactElement, root;
      try {
        if (window[componentName] == null) {
          KDCore.warning("Cant find " + componentName + ", make sure to load it first");
          return null;
        }
        if (uniqueId == null) {
          uniqueId = componentName;
        }
        // * Создаём отдельный DIV для каждого элемента (чтобы можно было удалять)
        element = this._getElementForReactComponent(uniqueId);
        root = ReactDOM.createRoot(element);
        reactElement = React.createElement(window[componentName], props);
        root.render(reactElement);
        return KDCore.HUI.getElement(uniqueId);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    // * Simple React Component (without JSX!)
    _.loadReactComponentFromFile = function(filename, props, uniqueId, handler, folder = "data/uiComponents") {
      var e, url, xhr;
      try {
        xhr = new XMLHttpRequest();
        url = folder + "/" + filename + ".js";
        xhr.open("GET", url);
        xhr.overrideMimeType("plain/text");
        xhr.onload = function() {
          var e, element;
          eval(xhr.responseText);
          element = KDCore.HUI.addReactComponent(filename, props, uniqueId);
          try {
            if (handler != null) {
              return handler(element, filename);
            }
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        return xhr.send();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getElementForReactComponent = function(componentId) {
      var e, element;
      try {
        this.removeElementById(componentId);
        element = this.addElement(componentId, '', null);
        return element;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    _.loadElementFromFile = function(filename, handler, folder = "data/uiComponents") {
      var e, url, xhr;
      try {
        xhr = new XMLHttpRequest();
        url = folder + "/" + filename + ".html";
        xhr.open("GET", url);
        xhr.overrideMimeType("plain/text");
        xhr.onload = function() {
          var e, element, htmlElementText;
          // * Хотел отдельные данные передавать и заменять в HTML текст
          // * Но если у нас есть React компоненты, то это не надо
          //htmlElementText = @convertDataKeys(xhr.responseText, dataKeys)
          htmlElementText = xhr.responseText;
          element = KDCore.HUI.addElement(filename, htmlElementText, null);
          try {
            if (handler != null) {
              return handler(element, filename);
            }
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        return xhr.send();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addCSS = function(name, folder = "css") {
      var head;
      if (!this.isInited()) {
        this.init();
      }
      head = document.getElementsByTagName("head")[0];
      if (head != null) {
        head.insertAdjacentHTML("beforeend", "<link rel=\"stylesheet\" href=\"$0/$1.css\" />".replace("$0", folder).replace("$1", name));
      }
    };
    _.addElement = function(id, html, classes = null) {
      var cls, element, i, len;
      if (!this.isInited()) {
        this.init();
      }
      element = document.createElement("div");
      element.id = id;
      element.innerHTML = html;
      if (classes != null) {
        for (i = 0, len = classes.length; i < len; i++) {
          cls = classes[i];
          element.classList.add(cls);
        }
      }
      this._parent.appendChild(element);
      return element;
    };
    _.appendElement = function(element) {
      var e;
      try {
        return this._parent.appendChild(element);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Может быть NULL
    _.getElement = function(id) {
      return document.getElementById(id);
    };
    _.removeElement = function(element) {
      if (element == null) {
        return;
      }
      if (KDCore.SDK.isString(element)) {
        this.removeElementById(element);
      } else {
        this.removeElementById(element.id);
      }
    };
    _.removeElementById = function(elementId) {
      var element;
      if (!this.isInited()) {
        return;
      }
      element = this.getElement(elementId);
      if (element != null) {
        this._parent.removeChild(element);
      }
    };
    // * PRIVATE ------------------------------------------------------------------
    _._createMainParentInHtml = function() {
      this._parent = document.createElement("div");
      this._parent.id = "KDCoreMain";
      document.body.appendChild(this._parent);
    };
    _._extendGraphicsClass = function() {
      var ALIAS___updateCanvas;
      //@[ALIAS]
      ALIAS___updateCanvas = Graphics._updateCanvas;
      Graphics._updateCanvas = function() {
        ALIAS___updateCanvas.call(this);
        return KDCore.HUI.refresh();
      };
    };
  })();
  //@[EXTEND]
  return KDCore.HUI = HUI;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS___onMouseUp, ALIAS___onRightButtonDown, ALIAS__clear, ALIAS__update, _;
  // * Right mouse pressed
  // * Определение когда правая (вторая) кнопка мыши зажата и удерживается

  //@[DEFINES]
  _ = TouchInput;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    this._kdMousePressed2 = false;
    this._kdPressedTime2 = 0;
  };
  //@[ALIAS]
  ALIAS___onRightButtonDown = _._onRightButtonDown;
  _._onRightButtonDown = function(event) {
    var check;
    ALIAS___onRightButtonDown.call(this, event);
    // * Это значит что ALIAS метод прошёл (верные X и Y в Canvas)
    if (KDCore.isMZ()) {
      check = this._newState.cancelled === true;
    } else {
      check = this._events.cancelled === true;
    }
    if (check === true) {
      this._kdMousePressed2 = true;
      this._kdPressedTime2 = 0;
    }
  };
  //@[ALIAS]
  ALIAS___onMouseUp = _._onMouseUp;
  _._onMouseUp = function(event) {
    ALIAS___onMouseUp.call(this, event);
    if (event.button === 2) {
      this._kdMousePressed2 = false;
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (this.kdIsPressed2()) {
      return this._kdPressedTime2++;
    }
  };
  //?[NEW]
  return _.kdIsPressed2 = function() {
    return this._kdMousePressed2 === true;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Методы из RPG Maker MZ которых нет в RPG Maker MV
  if (KDCore.isMZ()) {
    return;
  }
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Scene_Base.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Scene_Base.prototype;
    _.calcWindowHeight = function(numLines, selectable) {
      if (selectable === true) {
        return Window_Selectable.prototype.fittingHeight(numLines);
      } else {
        return Window_Base.prototype.fittingHeight(numLines);
      }
    };
  })();
  (function() {    // ■ END Scene_Base.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Selectable.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Window_Selectable.prototype;
    _.itemLineRect = function(index) {
      return this.itemRect(index);
    };
  })();
  (function() {    // ■ END Window_Selectable.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Base.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__initialize, ALIAS__processEscapeCharacter, _;
    //@[DEFINES]
    _ = Window_Base.prototype;
    // * Чтоб можно было Rectangle принимать в конструктор
    //@[ALIAS]
    ALIAS__initialize = _.initialize;
    _.initialize = function(x, y, w, h) {
      if (x instanceof PIXI.Rectangle || x instanceof Rectangle) {
        return ALIAS__initialize.call(this, x.x, x.y, x.width, x.height);
      } else {
        return ALIAS__initialize.call(this, ...arguments);
      }
    };
    
    // * В MZ используется FS для изменения размера шрифта в тексте
    //@[ALIAS]
    ALIAS__processEscapeCharacter = _.processEscapeCharacter;
    _.processEscapeCharacter = function(code, textState) {
      if (code === "FS") {
        this.contents.fontSize = this.obtainEscapeParam(textState);
      } else {
        ALIAS__processEscapeCharacter.call(this, code, textState);
      }
    };
  })();
  (function() {    // ■ END Window_Base.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Spriteset_Map.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Spriteset_Map.prototype;
    _.findTargetSprite = function(target) {
      return this._characterSprites.find(function(sprite) {
        return sprite.checkCharacter(target);
      });
    };
  })();
  return (function() {    // ■ END Spriteset_Map.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Sprite_Character.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Sprite_Character.prototype;
    _.checkCharacter = function(character) {
      return this._character === character;
    };
  })();
});

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var alias_SM_processMapTouch, alias_TIOMM;
  //?SMouse better alternative
  if (KDCore.isMZ()) {
    return;
  }
  // * Для ButtonM
  //@[ALIAS]
  alias_SM_processMapTouch = Scene_Map.prototype.processMapTouch;
  Scene_Map.prototype.processMapTouch = function() {
    if ($gameTemp.kdButtonUnderMouse != null) {
      if ($gameTemp.kdButtonUnderMouse.parent == null) {
        return $gameTemp.kdButtonUnderMouse = null;
      } else {

      }
    } else {
      return alias_SM_processMapTouch.call(this);
    }
  };
  //@[ALIAS]
  alias_TIOMM = TouchInput._onMouseMove;
  TouchInput._onMouseMove = function(event) {
    var x, y;
    alias_TIOMM.call(this, event);
    x = Graphics.pageToCanvasX(event.pageX);
    y = Graphics.pageToCanvasY(event.pageY);
    if (Graphics.isInsideCanvas(x, y)) {
      return this._onHover(x, y);
    }
  };
  
  //?NEW, from MZ
  return TouchInput._onHover = function(_x, _y) {
    this._x = _x;
    this._y = _y;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS__clear, ALIAS__update, _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Input;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    return this._virtualButton = null;
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (this._virtualButton == null) {
      return;
    }
    this._latestButton = this._virtualButton;
    this._pressedTime = 0;
    return this._virtualButton = null;
  };
  return _.virtualClick = function(buttonName) {
    return this._virtualButton = buttonName;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS___startLoading, _;
  // * В версии RPG Maker MZ 1.5.0 появился баг что картинки не успевают прогрузится
  // * Данный фикс, возвращает старое поведение
  if (!KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Bitmap.prototype;
  //@[ALIAS]
  ALIAS___startLoading = _._startLoading;
  return _._startLoading = function() {
    if (Utils.hasEncryptedImages()) {
      ALIAS___startLoading.call(this, ...arguments);
    } else {
      // * Это из RPG Maker MZ до версии 1.5
      this._image = new Image();
      this._image.onload = this._onLoad.bind(this);
      this._image.onerror = this._onError.bind(this);
      this._destroyCanvas();
      this._loadingState = "loading";
      this._image.src = this._url;
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Builder;
  Builder = {};
  (function() {    //NUI 1.0
    //rev 30.04.24
    var _;
    //@[DEFINES]
    _ = Builder;
    _.Factory = function(jsonCollection, owner, exRefresh = 0) {
      var e, item, items, j, key, len, value;
      try {
        if (jsonCollection == null) {
          return;
        }
        items = [];
        for (key in jsonCollection) {
          value = jsonCollection[key];
          item = KDCore.UI.Builder.Make(value, owner);
          if (item != null) {
            items.push(item); // * Skip not UI elements definitions
          }
        }
//owner[key] = item if owner?
        for (j = 0, len = items.length; j < len; j++) {
          item = items[j];
          item.refreshBindings(owner, true);
        }
        // * Обновить привязки через MS ещё раз
        if (exRefresh > 0) {
          setTimeout((function() {
            var e, k, len1, results;
            try {
              results = [];
              for (k = 0, len1 = items.length; k < len1; k++) {
                item = items[k];
                results.push(item.refreshBindings(owner, true));
              }
              return results;
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          }), exRefresh);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return items;
    };
    _.Make = function(jsonStructure, owner = null, parent = null) {
      var bindings, child, childrens, dataObject, e, item, j, len, parameters, shortcutData, subItem, type, value;
      try {
        if (jsonStructure == null) {
          return null;
        }
        if (jsonStructure.type == null) {
          return null;
        }
        if (jsonStructure.shortcut != null) {
          shortcutData = KDCore.UI.Builder.ConvertShortcut(jsonStructure.shortcut);
          ({type, parameters} = shortcutData);
        } else {
          ({type, parameters} = jsonStructure);
        }
        if (typeof parameters === "string") {
          parameters = KDCore.UI.Builder.ConvertShortcut(parameters);
        }
        if (jsonStructure.createIf != null) {
          value = this._convertBindingValue(owner, jsonStructure.createIf);
          if (value !== true) {
            return null;
          }
        }
        item = KDCore.UI.Builder.CreateItemByType(type, parameters);
        if (item == null) {
          return null;
        }
        ({dataObject, bindings, childrens} = jsonStructure);
        // * Parent нужен чтобы работали настройки положения (center, %) и т.д.
        if (parent != null) {
          parent.addChild(item);
        } else {
          // * Owner - это не только главный родитель, но и к кому мы
          // * прописываем все поля по ID
          if (owner != null) {
            owner.addChild(item);
          }
        }
        // * Сохраняем схему (но только этого элемента, без "детей")
        item.uiJsonScheme = Object.assign({}, jsonStructure, {
          childrens: []
        });
        // * Константы доступны не только у каждого элемента в схеме, но и у общего родителя
        if ((jsonStructure.constants != null) && (owner != null)) {
          if (owner.uiConstants == null) {
            owner.uiConstants = {};
          }
          owner.uiConstants = Object.assign(owner.uiConstants, jsonStructure.constants);
        }
        if (bindings != null) {
          if (dataObject == null) {
            dataObject = owner;
          }
          KDCore.UI.Builder.ApplyBindings(item, bindings, dataObject);
        }
        try {
          if (jsonStructure.effects != null) {
            KDCore.UI.Builder.ApplyEffects(item, jsonStructure.effects);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        try {
          if (jsonStructure.animations != null) {
            KDCore.UI.Builder.ApplyAnimations(item, jsonStructure.animations);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        if ((childrens != null) && childrens.length > 0) {
          for (j = 0, len = childrens.length; j < len; j++) {
            child = childrens[j];
            // * Дети всегда имеют родителя - этот элемент (а не owner)
            subItem = KDCore.UI.Builder.Make(child, owner, item);
          }
        }
        if (jsonStructure.id != null) {
          item.id = jsonStructure.id;
          if (owner != null) {
            owner[jsonStructure.id] = item;
          }
        }
        if (jsonStructure.parent != null) {
          parent = jsonStructure.parent;
          if ((owner != null) && (owner[parent] != null)) {
            owner[parent].addChild(item);
          }
        }
        // * Update bindings for recalculate Positions and Sizes
        if (bindings != null) {
          KDCore.UI.Builder.RefreshBindings(item, dataObject);
        }
        if (jsonStructure.position != null) {
          item.setPosition(jsonStructure.position);
        }
        return item;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    // * dataObject может быть Null, если нет binding c $
    _.ApplyBindings = function(uiElement, bindings, dataObject) {
      var dataBindings, e, field, value;
      try {
        if (uiElement == null) {
          return;
        }
        if (bindings == null) {
          return;
        }
        if (uiElement.dataBindings == null) {
          return;
        }
        dataBindings = uiElement.dataBindings();
        if (dataBindings == null) {
          return;
        }
        for (field in dataBindings) {
          if (bindings[field] != null) {
            value = this.ConvertBindingValue(dataObject, bindings[field], uiElement);
            dataBindings[field].call(uiElement, value);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.RefreshBindings = function(uiElement, dataObject) {
      var bindings, e;
      try {
        if (uiElement == null) {
          return;
        }
        if (uiElement.uiJsonScheme == null) {
          return;
        }
        ({bindings} = uiElement.uiJsonScheme);
        if (bindings == null) {
          return;
        }
        KDCore.UI.Builder.ApplyBindings(uiElement, bindings, dataObject);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.ApplyEffects = function(uiElement, effects) {
      var alpha, color, e, ef, efData, effectsArray, j, len, quality, thickness;
      try {
        if (uiElement == null) {
          return;
        }
        if (effects == null) {
          return;
        }
        //TODO: Преобразование цвета!
        effectsArray = [];
        for (j = 0, len = effects.length; j < len; j++) {
          ef = effects[j];
          if (ef == null) {
            continue;
          }
          efData = KDCore.UI.Builder.ConvertShortcut(ef);
          if ((efData.shadow != null) && KDCore.isMZ()) {
            effectsArray.push(new PIXI.filters.DropShadowFilter(efData));
          }
          if ((efData.outline != null) && KDCore.isMZ()) {
            ({thickness, color, quality} = efData);
            if (thickness == null) {
              thickness = 1;
            }
            if (color == null) {
              color = 0xffffff;
            }
            effectsArray.push(new PIXI.filters.OutlineFilter(thickness, color, quality));
          }
          if (efData.glow != null) {
            effectsArray.push(new PIXI.filters.GlowFilter(efData));
          }
          if (efData.tint != null) {
            ({color, alpha} = efData);
            if (alpha == null) {
              alpha = 0.5;
            }
            effectsArray.push(new PIXI.filters.ColorOverlayFilter(color, alpha));
          }
        }
        if (effectsArray.length > 0) {
          return uiElement.filters = effectsArray;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.ApplyAnimations = function(uiElement, animations) {
      var a, e, j, len;
      try {
        if (uiElement == null) {
          return;
        }
        if (animations == null) {
          return;
        }
        if (uiElement.addAnimationRule == null) {
          return;
        }
        if (animations.length === 0) {
          return;
        }
        for (j = 0, len = animations.length; j < len; j++) {
          a = animations[j];
          if (typeof a === 'string') {
            a = KDCore.UI.Builder.ConvertShortcut(a);
          }
          if (a != null) {
            uiElement.addAnimationRule(a);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.ConvertBindingValue = function(sourceObj, bindingValue, element = null) {
      var e, i, j, ref, text, value;
      try {
        if (bindingValue instanceof Array) {
          text = bindingValue[0];
          for (i = j = 1, ref = bindingValue.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
            if (bindingValue[i] == null) {
              continue;
            }
            value = this.ConvertBindingValue(sourceObj, bindingValue[i], element);
            if (value != null) {
              text = text.replace("%" + i, value);
            }
          }
          return text;
        } else {
          return this._convertBindingValue(sourceObj, bindingValue, element);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return bindingValue;
    };
    _.CreateItemByType = function(type, initialParameters = {}) {
      var e;
      try {
        // * SHOULD HAVE: dataBingins(size), realWidth, realHeight
        switch (type) {
          case 'button':
            return new KDCore.Sprite_SButton(initialParameters);
          case 'text':
            return new KDCore.UI.Sprite_UIText2(initialParameters);
          case 'plane':
            return new KDCore.Sprite_Plane(initialParameters);
          case 'rect':
            return new KDCore.Sprite_BaseRect(initialParameters);
          case 'image':
            return new KDCore.Sprite_Image(initialParameters);
          case 'legacyText':
            return new KDCore.UI.Sprite_UIText(initialParameters);
          case 'textExt':
            return new KDCore.UI.Sprite_UITextEx(initialParameters);
          case 'group':
            return new KDCore.Sprite_Group(initialParameters);
          case 'legacyButton':
            return new KDCore.Sprite_ImgButton(initialParameters);
          case 'circle':
            return new KDCore.Sprite_BaseCircle(initialParameters);
          case 'gauge':
            return new KDCore.Sprite_Gauge(initialParameters);
          case 'list':
            return new KDCore.Sprite_ItemsListN(initialParameters);
          case 'horList':
            return new KDCore.Sprite_ItemsListNHor(initialParameters);
          case 'screen':
            /*screenGroup = {
                "type": "group",
                "bindings": {
                    "width": "@Graphics.width",
                    "height": "@Graphics.height"
                }
            }
            return KDCore.UI.Builder.Make(screenGroup)*/
            return new KDCore.Sprite_Screen(initialParameters);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    _._convertValueDataFromShortcut = function(valueData) {
      var data, e, item, j, len, n, outerItems, p, v;
      try {
        if (valueData.contains("|")) {
          data = {};
          outerItems = valueData.split("|");
          for (j = 0, len = outerItems.length; j < len; j++) {
            item = outerItems[j];
            p = item.split("=");
            n = p.shift();
            v = p;
            if (v.length === 0) {
              v = true;
            } else {
              if (v.length === 1) {
                v = v[0];
                if (isFinite(v)) {
                  v = Number(v);
                }
              } else {
                v = KDCore.UI.Builder._convertValueDataFromShortcut(v.join("="));
              }
            }
            data[n] = v;
          }
          return data;
        }
        data = KDCore.UI.Builder.ConvertShortcut(valueData, ",", "=");
        return data;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.ConvertShortcut = function(shortcut, outerSep = ";", innerSep = ":") {
      var config, e, j, len, pair, value, valueData, valueName, values;
      try {
        config = {};
        values = shortcut.split(outerSep);
//console.log(values)
        for (j = 0, len = values.length; j < len; j++) {
          value = values[j];
          if (!String.any(value)) {
            continue;
          }
          pair = value.split(innerSep);
          valueName = pair[0];
          valueData = pair[1];
          if (String.any(valueData) && valueData.contains("=")) {
            valueData = KDCore.UI.Builder._convertValueDataFromShortcut(valueData);
          } else {
            if (valueData == null) {
              valueData = true;
            } else {
              if (isFinite(valueData)) {
                valueData = Number(valueData);
              }
            }
          }
          config[valueName] = valueData;
        }
        //console.log(valueName, valueData)
        return config;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._convertBindingValue = function(sourceObj, bindingValue, element = null) {
      var captured, dpValue, e, evalString, r, result, resultValue;
      try {
        if (typeof bindingValue === 'string') {
          // * Replace all HDP
          if (bindingValue.contains("hdp")) {
            r = new RegExp("(\\d+)hdp", "g");
            result = r.exec(bindingValue);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, true);
              bindingValue = bindingValue.replace(/(\d+)hdp/, resultValue);
              result = r.exec(bindingValue);
            }
          }
          // * Replace all DP
          if (bindingValue.contains("dp")) {
            r = new RegExp("(\\d+)dp", "g");
            result = r.exec(bindingValue);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, false);
              bindingValue = bindingValue.replace(/(\d+)dp/, resultValue);
              result = r.exec(bindingValue);
            }
          }
          // * FORCE EVAL
          if (bindingValue.contains("@") && bindingValue[0] === "@") {
            evalString = bindingValue.replace("@", "");
            return eval(evalString);
          }
          // * EXTRA $ calculations
          if (bindingValue.contains("~") && bindingValue[0] === "~") { // * POST EVAL
            if (bindingValue.contains("$")) {
              r = new RegExp("(\\$[\\w+.]*)", "g");
              result = r.exec(bindingValue);
              if (result != null) {
                //console.log(result)
                captured = result[1];
                if (String.any(captured)) {
                  resultValue = this._convertSingleBindingValue$(sourceObj, captured, element);
                  if (resultValue == null) {
                    return null;
                  }
                  if (typeof resultValue === 'function') {
                    return resultValue;
                  } else {
                    if (String.any(resultValue)) {
                      bindingValue = bindingValue.replace(captured, resultValue);
                      return this._convertBindingValue(sourceObj, bindingValue, element);
                    } else {
                      return null;
                    }
                  }
                }
              }
            } else {
              evalString = bindingValue.replace("~", "");
              return eval(evalString);
            }
          }
          
          // * Default old style simple $
          if (bindingValue.contains("$")) {
            return this._convertSingleBindingValue$(...arguments);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return bindingValue;
    };
    _._convertSingleBindingValue$ = function(sourceObj, bindingValue, element) {
      var e, field, parts, subData, subField;
      try {
        field = bindingValue.replace("$", "");
        if (field.contains(".")) { //$parent.width
          parts = field.split(".");
          // * Только одно вхождение
          field = parts[0];
          subField = parts[1];
          if (!String.any(field) && String.any(subField)) {
            if (element != null) {
              return this._convertSingleBindingValue$(element, "$" + subField, element);
            } else {
              return null;
            }
          }
          if (String.any(field) && !String.any(subField)) {
            return this._convertSingleBindingValue$(sourceObj, "$" + field, element);
          }
          if (sourceObj != null) {
            if (typeof sourceObj[field] === 'function') {
              subData = sourceObj[field]();
            } else {
              subData = sourceObj[field];
            }
            return this._convertSingleBindingValue$(subData, "$" + subField, element);
          } else {
            return null;
          }
        } else {
          if ((sourceObj != null) && (sourceObj[field] != null)) {
            if (typeof sourceObj[field] === 'function') {
              return sourceObj[field]();
            } else {
              return sourceObj[field];
            }
          } else {
            return null; // * We can't find value
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  //@[EXTEND]
  KDCore.UI = KDCore.UI || {};
  return KDCore.UI.Builder = Builder;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var alias_WBDTEX_KDCore29122021;
  // * <center>, для RPG Maker MZ и если нету Visu Message Core
  if (KDCore.isMZ()) {
    alias_WBDTEX_KDCore29122021 = Window_Base.prototype.drawTextEx;
    Window_Base.prototype.drawTextEx = function(text, x, y, width) {
      var e, newText;
      try {
        if (Imported.VisuMZ_1_MessageCore !== true) { // * В Visu уже есть <center>
          if (String.any(text) && text.contains("<center>")) {
            if (text[0] === "<" && text[1] === "c") { // * Должен быть в начале строки
              newText = text.replace("<center>", "");
              return this.drawTextExInCenter(newText, x, y, width);
            }
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return alias_WBDTEX_KDCore29122021.call(this, ...arguments);
    };
  }
  //?NEW
  Window_Base.prototype.drawTextExInCenter = function(text, x, y, width, height) {
    var e, newX, newY, textSize;
    try {
      if (KDCore.isMV()) { // * В MV нет поддержки данного метода
        this.drawTextEx(...arguments);
        return;
      }
      textSize = this.textSizeEx(text);
      newX = x + width / 2 - textSize.width / 2;
      if ((height != null) && height > 0) {
        newY = y + height / 2 - textSize.height / 2;
      } else {
        newY = y;
      }
      return this.drawTextEx(text, newX, newY, width);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this.drawTextEx(text, x, y, width);
    }
  };
  //?NEW
  Window_Base.prototype.drawTextExWithWordWrap = function(text, x, y, width, maxLines) {
    var maxWidth, wrappedText;
    this.drawTextEx("", 0, 0, 100);
    maxWidth = this.contentsWidth();
    wrappedText = Window_Message.prototype.pWordWrap.call(this, text, width || maxWidth, maxLines);
    return this.drawTextEx(wrappedText, x, y, width);
  };
  //?NEW
  return Window_Message.prototype.pWordWrap = function(text, maxWidth, maxLines) {
    var i, j, k, l, line, lines, newLines, ref, ref1, result, spaceLeft, spaceWidth, wordWidth, wordWidthWithSpace, words;
    lines = text.split('\n');
    maxWidth = maxWidth;
    spaceWidth = this.contents.measureTextWidth(' ');
    result = '';
    newLines = 1;
    for (i = k = 0, ref = lines.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      spaceLeft = maxWidth;
      line = lines[i];
      words = line.split(' ');
      for (j = l = 0, ref1 = words.length; (0 <= ref1 ? l < ref1 : l > ref1); j = 0 <= ref1 ? ++l : --l) {
        wordWidth = this.contents.measureTextWidth(words[j].replaceAll(/\\C\[\d+\]/g, ""));
        wordWidthWithSpace = wordWidth + spaceWidth;
        if (j === 0 || wordWidthWithSpace > spaceLeft) {
          if (j > 0) {
            if (maxLines === newLines) {
              return result;
            }
            result += '\n';
            newLines++;
          }
          result += words[j];
          spaceLeft = maxWidth - wordWidth;
          if (j === 0 && line.match(/\\n\w*\s*<\s*\\n\[\w*\s*\]\s*>*/gi)) {
            spaceLeft += 200;
          }
        } else {
          spaceLeft -= wordWidthWithSpace;
          result += ' ' + words[j];
        }
      }
      if (i < lines.length - 1) {
        result += '\n';
      }
    }
    return result;
  };
});


// Generated by CoffeeScript 2.6.1
// * Последний файл (после всех классов)
// * Загружает библиотеки
var i, len, lib, ref, text;

if (KDCore._requireLoadLibrary === true) {
  ref = KDCore[KDCore._loader];
  for (i = 0, len = ref.length; i < len; i++) {
    lib = ref[i];
    lib();
  }
  KDCore[KDCore._loader] = [];
  text = "%c  KDCore is loaded " + KDCore.Version + " + NUI " + KDCore.nuiVersion;
  console.log(text, 'background: #222; color: #82b2ff');
}

// ==========================================================================
// ==========================================================================

//   END OF PLUGINS CORE LIBRARY
//   (Next code is this plugin code)

// ==========================================================================
// ==========================================================================

//Plugin KDCore builded by PKD PluginBuilder 2.2.1 - 18.06.2024

//build: 11 
var KDNUI;
(function (KDNUI) {
    /**
     * The version of the KDNUI Library.
     * @type {string}
     */
    KDNUI.Version = "1.5";
    /**
     * Add NUI file to the list of files to be loaded.
     * @type {string} - The folder where the file is located.
     * @type {string} - The name of the file (without extension).
     */
    function RegisterNUIFile(folder, filnename) {
        let _name = "$" + folder + "_" + filnename;
        let src = folder + "/" + filnename + ".json";
        /* @ts-ignore */
        DataManager._databaseFiles.push({ name: _name, src: src });
    }
    KDNUI.RegisterNUIFile = RegisterNUIFile;
    /**
     * Creates a `KNSprite` instance from a given scheme and optionally attaches it to a parent or owner.
     *
     * @param scheme - The scheme to create the sprite from. It can be either a `NUIScheme` or a record of `NUIScheme`.
     * @param owner - (Optional) The owner object to bind the sprite to.
     * @param parent - (Optional) The parent `Sprite` to attach the created sprite to.
     * @returns The created `KNSprite` instance or `null` if creation fails.
     *
     * @remarks
     * - If the `scheme` contains a `type`, it uses `KNBuilder.Make` to create the sprite.
     * - If the `scheme` is a record of `NUIScheme`, it uses `KNBuilder.Factory` to create the sprite.
     * - If a `parent` is provided, the created sprite is added as a child to the parent.
     * - If no `parent` is provided but an `owner` with an `addChild` method is provided, the sprite is added as a child to the owner.
     * - The created sprite's bindings are refreshed with the owner.
     * - If an error occurs during creation, a warning is logged and a new `KNSprite` instance is returned.
     */
    function FromScheme(scheme, owner, parent) {
        try {
            let element;
            if (KDX.any(scheme) && KDX.any(scheme['type'])) {
                element = KNBuilder.Make(scheme, owner, parent);
            }
            else if (KDX.any(scheme)) {
                element = KNBuilder.Factory(scheme, owner, 100)[0];
            }
            if (KDX.any(element)) {
                if (KDX.any(parent)) {
                    parent.addChild(element);
                }
                else {
                    if (KDX.any(owner) && owner['addChild']) {
                        owner['addChild'](element);
                    }
                }
                element.refreshBindings(owner, true);
                return element;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return new KNSprite();
    }
    KDNUI.FromScheme = FromScheme;
})(KDNUI || (KDNUI = {}));
(function () {
    if (Utils.RPGMAKER_NAME.includes("MV"))
        return;
    // * В версии RPG Maker MZ 1.5.0 появился баг что картинки не успевают прогрузится
    // * Данный фикс, возвращает старое поведение
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Bitmap.ts
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    (() => {
        //@[DEFINES]
        const _ = Bitmap.prototype;
        if (Bitmap['_isExtenedByKDNUI'])
            return;
        Bitmap['_isExtenedByKDNUI'] = true;
        //@[ALIAS]
        /*@ts-ignore*/
        const ALIAS___startLoading = _._startLoading;
        _['_startLoading'] = function (...args) {
            /*@ts-ignore*/
            if (Utils.hasEncryptedImages()) {
                ALIAS___startLoading.call(this, ...args);
            }
            else {
                this._image = new Image();
                this._image.onload = this._onLoad.bind(this);
                this._image.onerror = this._onError.bind(this);
                this._destroyCanvas();
                this._loadingState = 'loading';
                this._image.src = this._url;
            }
        };
    })();
    // ■ END Bitmap.ts
    //---------------------------------------------------------------------------
})();
/**
* All available NUI elements types.
*/
var KNItemsTypes;
(function (KNItemsTypes) {
    KNItemsTypes["rect"] = "rect";
    KNItemsTypes["circle"] = "circle";
    KNItemsTypes["plane"] = "plane";
    KNItemsTypes["text"] = "text";
    KNItemsTypes["image"] = "image";
    KNItemsTypes["group"] = "group";
    KNItemsTypes["screen"] = "screen";
    KNItemsTypes["textPro"] = "textPro";
    KNItemsTypes["button"] = "button";
    KNItemsTypes["imageButton"] = "imageButton";
    KNItemsTypes["list"] = "list";
    KNItemsTypes["face"] = "face";
    KNItemsTypes["gauge"] = "gauge";
})(KNItemsTypes || (KNItemsTypes = {}));
var KNSpriteEffects;
(function (KNSpriteEffects) {
    KNSpriteEffects["Blur"] = "blur";
    KNSpriteEffects["Shadow"] = "shadow";
    KNSpriteEffects["Outline"] = "outline";
    KNSpriteEffects["Glow"] = "glow";
    KNSpriteEffects["Tint"] = "tint";
    KNSpriteEffects["Desaturate"] = "desaturate";
})(KNSpriteEffects || (KNSpriteEffects = {}));
var KBitmap;
(function (KBitmap) {
    let _loadedIconsCache = {};
    let _emptyBitmap = null;
    /**
     * Draws an icon onto the specified bitmap at the given coordinates.
     *
     * @param inputBitmap - The bitmap on which the icon will be drawn.
     * @param icon - The icon to draw, which can be either an icon index (number) or a Bitmap.
     * @param x - The x-coordinate where the icon will be drawn.
     * @param y - The y-coordinate where the icon will be drawn.
     * @param size - The size of the icon to draw. Defaults to 32.
     *
     * @throws Will log a warning to the console if an error occurs during the drawing process.
     */
    function DrawIcon(inputBitmap, icon, x, y, size = 32) {
        try {
            let bitmapToDraw = null;
            if (icon instanceof Bitmap) {
                bitmapToDraw = icon;
            }
            else {
                bitmapToDraw = GetIconBitmap(icon);
            }
            DrawInside(inputBitmap, bitmapToDraw, x, y, size, size);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KBitmap.DrawIcon = DrawIcon;
    /**
     * Draws a bitmap inside another bitmap at the specified coordinates.
     *
     * @param inputBitmap - The bitmap where the other bitmap will be drawn.
     * @param bitmapToDraw - The bitmap to draw inside the input bitmap.
     * @param x - The x-coordinate where the bitmap will be drawn.
     * @param y - The y-coordinate where the bitmap will be drawn.
     * @param sw - The width to scale the drawn bitmap to. Defaults to the width of the bitmap to draw.
     * @param sh - The height to scale the drawn bitmap to. Defaults to the height of the bitmap to draw.
     *
     * @throws Will log a warning to the console if an error occurs during the drawing process.
     */
    function DrawInside(inputBitmap, bitmapToDraw, x, y, sw = 0, sh = 0) {
        try {
            if (sw <= 0)
                sw = bitmapToDraw.width;
            if (sh <= 0)
                sh = bitmapToDraw.height;
            inputBitmap.blt(bitmapToDraw, 0, 0, bitmapToDraw.width, bitmapToDraw.height, x, y, sw, sh);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KBitmap.DrawInside = DrawInside;
    /**
     * Fills the input bitmap with the contents of another bitmap.
     *
     * @param inputBitmap - The bitmap to be filled.
     * @param bitmapToFill - The bitmap used to fill the input bitmap.
     */
    function FillWith(inputBitmap, bitmapToFill) {
        try {
            DrawInside(inputBitmap, bitmapToFill, 0, 0, inputBitmap.width, inputBitmap.height);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KBitmap.FillWith = FillWith;
    /**
     * Draws the specified text on the given bitmap at the specified position.
     *
     * @param inputBitmap - The bitmap on which the text will be drawn.
     * @param text - The text to be drawn on the bitmap.
     * @param position - The position where the text will be aligned. Can be 'center', 'left', or 'right'.
     *
     * @throws Will log a warning to the console if an error occurs during the drawing process.
     */
    function DrawTextFull(inputBitmap, text, position) {
        try {
            inputBitmap.drawText(text, 0, 0, inputBitmap.width, inputBitmap.height, position);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KBitmap.DrawTextFull = DrawTextFull;
    /**
     * Returns a singleton instance of an empty Bitmap.
     * If the instance does not exist, it creates a new Bitmap.
     *
     * @returns {Bitmap} A singleton instance of an empty Bitmap.
     */
    function GetEmptyBitmap() {
        if (!_emptyBitmap) {
            _emptyBitmap = new Bitmap();
        }
        return _emptyBitmap;
    }
    KBitmap.GetEmptyBitmap = GetEmptyBitmap;
    /**
     * Retrieves the bitmap for a specified icon index. If the icon is not already cached,
     * it loads the icon from the system icon set, caches it, and then returns the bitmap.
     * If an error occurs during this process, an empty bitmap is returned.
     *
     * @param {number} iconIndex - The index of the icon to retrieve.
     * @returns {Bitmap} The bitmap of the specified icon, or an empty bitmap if an error occurs.
     */
    function GetIconBitmap(iconIndex) {
        try {
            if (!_loadedIconsCache[iconIndex]) {
                let iconset = ImageManager.loadSystem("IconSet");
                let pw = 0;
                let ph = 0;
                if (KDX.isMV()) {
                    /* @ts-ignore */
                    pw = Window_Base._iconWidth;
                    /* @ts-ignore */
                    ph = Window_Base._iconHeight;
                }
                else {
                    pw = ImageManager.iconWidth;
                    ph = ImageManager.iconHeight;
                }
                let sx = iconIndex % 16 * pw;
                let sy = Math.floor(iconIndex / 16) * ph;
                let iconBitmap = new Bitmap(pw, ph);
                iconBitmap.blt(iconset, sx, sy, pw, ph, 0, 0);
                _loadedIconsCache[iconIndex] = iconBitmap;
            }
            return _loadedIconsCache[iconIndex];
        }
        catch (error) {
            console.warn(error);
            return GetEmptyBitmap();
        }
    }
})(KBitmap || (KBitmap = {}));
var KColor;
(function (KColor) {
    /**
     * Generates a random hexadecimal color code.
     *
     * @returns A string representing a random color code in the format "#RRGGBB".
     */
    function Random() {
        return `#${Math.floor(Math.random() * 16777215).toString(16)}`;
    }
    KColor.Random = Random;
    /**
     * Generates a lighter shade of the given hex color by a specified factor.
     *
     * @param {string} hex - The hex color code to lighten.
     * @param {number} [factor=0.2] - The factor by which to lighten the color. Default is 0.2.
     * @returns {string} The hex color code of the lighter shade.
     * @throws Will log a warning and return `#000000` if the input hex color is invalid.
     */
    function LighterColor(hex, factor = 0.2) {
        try {
            let [r, g, b] = HexToColor(hex);
            r = Math.min(255, r + 255 * factor);
            g = Math.min(255, g + 255 * factor);
            b = Math.min(255, b + 255 * factor);
            return HexFromColor(r, g, b);
        }
        catch (error) {
            console.warn(error);
            return `#000000`;
        }
    }
    KColor.LighterColor = LighterColor;
    /**
     * Darkens a given hex color by a specified factor.
     *
     * @param {string} hex - The hex color code to be darkened.
     * @param {number} [factor=0.2] - The factor by which to darken the color. Default is 0.2.
     * @returns {string} - The darkened hex color code.
     *
     * @throws Will log a warning and return `#000000` if the input hex color is invalid.
     */
    function DarkerColor(hex, factor = 0.2) {
        try {
            let [r, g, b] = HexToColor(hex);
            r = Math.max(0, r - 255 * factor);
            g = Math.max(0, g - 255 * factor);
            b = Math.max(0, b - 255 * factor);
            return HexFromColor(r, g, b);
        }
        catch (error) {
            console.warn(error);
            return `#000000`;
        }
    }
    KColor.DarkerColor = DarkerColor;
    /**
     * Converts RGB color values to a hexadecimal color string.
     *
     * @param r - The red component of the color, an integer between 0 and 255.
     * @param g - The green component of the color, an integer between 0 and 255.
     * @param b - The blue component of the color, an integer between 0 and 255.
     * @returns A string representing the hexadecimal color, prefixed with '#'.
     *          If an error occurs, returns "#000000".
     */
    function HexFromColor(r, g, b) {
        try {
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        catch (error) {
            console.warn(error);
            return "#000000";
        }
    }
    KColor.HexFromColor = HexFromColor;
    /**
     * Converts a short hexadecimal color code to a long hexadecimal color code.
     *
     * @param hex - The short hexadecimal color code (e.g., "#RGB").
     * @returns The long hexadecimal color code (e.g., "#RRGGBB"). If the input is already a long hexadecimal color code, it returns the input as is.
     *
     * @throws Will log a warning and return "#000000" if an error occurs during conversion.
     */
    function ToLongHex(hex) {
        try {
            if (hex.length == 4) {
                let r = hex[1];
                let g = hex[2];
                let b = hex[3];
                return `#${r}${r}${g}${g}${b}${b}`;
            }
            return hex;
        }
        catch (error) {
            console.warn(error);
            return "#000000";
        }
    }
    KColor.ToLongHex = ToLongHex;
    /**
     * Converts a hexadecimal color string to an RGB array.
     *
     * @param {string} hex - The hexadecimal color string (e.g., "#FFFFFF" or "FFFFFF").
     * @returns {number[]} An array containing the RGB values [r, g, b].
     *                      If the conversion fails, returns [0, 0, 0].
     * @throws Will log a warning to the console if the conversion fails.
     */
    function HexToColor(hex) {
        try {
            let _hex = ToLongHex(hex);
            let r = parseInt(_hex.substring(1, 3), 16);
            let g = parseInt(_hex.substring(3, 5), 16);
            let b = parseInt(_hex.substring(5, 7), 16);
            return [r, g, b];
        }
        catch (error) {
            console.warn(error);
            return [0, 0, 0];
        }
    }
    KColor.HexToColor = HexToColor;
    /**
     * Converts a hexadecimal color string to a color number.
     *
     * @param hex - The hexadecimal color string (e.g., "#RRGGBB" or "RRGGBB").
     * @returns The color number representation of the given hexadecimal color.
     */
    function HexToColorNumber(hex) {
        let [r, g, b] = HexToColor(hex);
        return r << 16 | g << 8 | b;
    }
    KColor.HexToColorNumber = HexToColorNumber;
    /**
     * Converts a hexadecimal color code to a CSS color string.
     *
     * @param {string} hex - The hexadecimal color code to convert.
     * @param {number} [alpha] - Optional alpha value for the color (0 to 1).
     * @returns {string} The CSS color string in `rgb` or `rgba` format.
     * @throws Will log a warning and return `rgb(0,0,0)` if the conversion fails.
     */
    function HexToCss(hex, alpha) {
        try {
            if (alpha) {
                return `rgba(${HexToColor(hex).join(",")},${alpha})`;
            }
            return `rgb(${HexToColor(hex).join(",")})`;
        }
        catch (error) {
            console.warn(error);
            return `rgb(0,0,0)`;
        }
    }
    KColor.HexToCss = HexToCss;
})(KColor || (KColor = {}));
var KNBuilder;
(function (KNBuilder) {
    function Factory(schemes, owner, extraRefreshAfterMs = 0) {
        let items = [];
        for (let key in schemes) {
            let item = Make(schemes[key], owner);
            if (KDX.any(item)) {
                items.push(item);
            }
        }
        // * Refresh all bindings
        for (let item of items) {
            item.refreshBindings(owner, true);
        }
        // * Обновить привязки через MS ещё раз
        if (extraRefreshAfterMs > 0) {
            setTimeout(() => {
                try {
                    for (let item of items) {
                        item === null || item === void 0 ? void 0 : item.refreshBindings(owner, true);
                    }
                }
                catch (error) {
                    console.warn(error);
                }
            }, extraRefreshAfterMs);
        }
        return items;
    }
    KNBuilder.Factory = Factory;
    function Make(scheme, owner, parent) {
        if (!scheme)
            return null;
        if (!scheme.type)
            return null;
        try {
            if (!isShouldCreate(scheme, owner))
                return null;
            let { type, parameters } = extractTypeAndParameters(scheme);
            //console.log(type);
            //console.log(parameters);
            let item = createItemByType(type, parameters);
            if (!item)
                return null;
            // * Parent нужен чтобы работали настройки положения (center, %) и т.д.
            if (KDX.any(parent)) {
                parent.addChild(item);
            }
            else {
                // * Owner - это не только главный родитель, но и к кому мы прописываем все поля по ID
                if (KDX.any(owner) && owner instanceof Sprite) {
                    owner.addChild(item);
                }
            }
            // * Сохраняем схему (но только этого элемента, без "детей")
            item.setJsonSchema(Object.assign({}, scheme, { children: [] }));
            // * Константы доступны не только у каждого элемента в схеме, но и у общего родителя
            if (KDX.any(scheme.constants)) {
                item.addUIConstants(scheme.constants);
                if (KDX.any(owner) && owner instanceof KNSprite) {
                    owner.addUIConstants(scheme.constants);
                }
            }
            // * Обновляем все связи (переменные) в элементе
            item.refreshBindings(owner, true);
            // * Применяем эффекты
            if (KDX.any(scheme.effects)) {
                try {
                    ApplyEffects(item, scheme.effects);
                }
                catch (error) {
                    console.warn(error);
                }
            }
            // * Если есть дети, то создаем их
            if (KDX.any(scheme.childrens)) {
                for (let childScheme of scheme.childrens) {
                    // * Дети всегда имеют родителя - этот элемент (а не owner)
                    Make(childScheme, owner, item);
                }
            }
            // * Если у элемента есть ID, то сохраняем его в общий объект
            if (KDX.any(scheme.id)) {
                item['id'] = scheme.id;
                if (KDX.any(owner)) {
                    owner[scheme.id] = item;
                }
            }
            // * Если у элемента есть родитель, то добавляем его в родительский элемент
            try {
                if (KDX.any(scheme.parent)) {
                    let parent = scheme.parent;
                    if (KDX.any(owner) && owner[parent] && owner[parent] instanceof Sprite) {
                        owner[parent].addChild(item);
                    }
                }
            }
            catch (error) {
                console.warn(error);
            }
            // * Обновляем все связи (переменные) в элементе ещё раз (после всех детей)
            item.refreshBindings(owner, true);
            // * Применяем анимации
            if (KDX.any(scheme.animations)) {
                try {
                    applyAnimations(item, scheme.animations);
                }
                catch (error) {
                    console.warn(error);
                }
            }
            return item;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    KNBuilder.Make = Make;
    function extractTypeAndParameters(scheme) {
        let type = scheme.type;
        let parameters = {};
        try {
            // * Shortcut type:X;parameters:Y
            if (type.includes("type:")) {
                //console.log("Convert shortcut");
                let shortcutData = NBindingsConverter.ConvertShortcut(scheme.type);
                //console.log(shortcutData);
                if (shortcutData) {
                    type = shortcutData.type;
                    parameters = shortcutData.parameters;
                }
            }
            else {
                parameters = scheme.parameters;
            }
            if (typeof parameters === "string" && KString.any(parameters)) {
                //console.log("Convert parameters");
                parameters = NBindingsConverter.ConvertShortcut(parameters);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return { type: type, parameters: parameters };
    }
    function isShouldCreate(scheme, owner) {
        if (!KDX.any(scheme.createIf))
            return true;
        if (typeof scheme.createIf === "boolean")
            return scheme.createIf;
        if (typeof scheme.createIf === "string" && KString.any(scheme.createIf)) {
            let value = NBindingsConverter.ConvertBindingValue(owner, scheme.createIf);
            if (!value) {
                return false;
            }
        }
        return true;
    }
    function createItemByType(type, parameters = {}) {
        switch (type) {
            case "rect": return new KNSprite_BaseRect(parameters);
            case "circle": return new KNSprite_BaseCircle(parameters);
            case "plane": return new KNSprite_Plane(parameters);
            case "text": return new KNSprite_Text(parameters);
            case "image": return new KNSprite_Image(parameters);
            case "group": return new KNSprite_Group(parameters);
            case "screen": return new KNSprite_Screen();
            case "textPro": return new KNSprite_TextPro(parameters);
            case "button": return new KNSprite_Button(parameters);
            case "imageButton": return new KNSprite_ImageButton(parameters);
            case "list": return new KNSprite_ItemsList(parameters);
            case "face": return new KNSprite_ActorFace(parameters);
            case "gauge": return new KNSprite_Gauge(parameters);
            default: {
                console.warn("Unknown NUI element type: " + type);
                return null;
            }
        }
    }
    function ApplyEffects(item, effects) {
        try {
            if (!KDX.any(item))
                return;
            if (!KDX.any(effects))
                return;
            for (let effect of effects) {
                if (KString.isString(effect)) {
                    try {
                        let effectData = NBindingsConverter.ConvertShortcut(effect);
                        if (effectData['color'] && KString.isString(effectData['color'])) {
                            effectData['color'] = KColor.HexToColorNumber(effectData['color']);
                        }
                        if (effectData['shadow']) {
                            item.addShadowEffect(effectData);
                            continue;
                        }
                        if (effectData['blur']) {
                            item.addBlurEffect(effectData);
                            continue;
                        }
                        if (effectData['outline']) {
                            item.addOutlineEffect(effectData);
                            continue;
                        }
                        if (effectData['glow']) {
                            item.addGlowEffect(effectData);
                            continue;
                        }
                        if (effectData['tint']) {
                            item.addTintEffect(effectData);
                        }
                        if (effectData['desaturate']) {
                            item.addDesaturateEffect();
                        }
                    }
                    catch (error) {
                        console.warn(error);
                    }
                }
                else {
                    try {
                        item.addEffect(effect);
                    }
                    catch (error) {
                        console.warn(error);
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    KNBuilder.ApplyEffects = ApplyEffects;
    function applyAnimations(item, animations) {
        try {
            if (KDX.any(animations)) {
                for (let animation of animations) {
                    item.addAnimationRule(animation);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
})(KNBuilder || (KNBuilder = {}));
class KSprite extends Sprite {
    constructor(bitmap) {
        super(bitmap);
        this._alphaCheckThreshold = 100;
    }
    static FromRect(width, height, color = "#FFFFFF") {
        let sprite = new KSprite(new Bitmap(width, height));
        sprite.fillAll(color);
        return sprite;
    }
    getGlobalPositionNew() {
        let bounds = this.getBounds();
        let p = { x: bounds.x, y: bounds.y };
        return p;
    }
    getLocalPosition() {
        let bounds = this.getLocalBounds();
        let p = { x: bounds.x, y: bounds.y };
        return p;
    }
    getGlobalRect() {
        let bounds = this.getBounds();
        return new Rectangle(bounds.x, bounds.y, bounds.width, bounds.height);
    }
    getLocalRect() {
        let localBounds = this.getLocalBounds();
        let globalBounds = this.getBounds();
        return new Rectangle(localBounds.x, localBounds.y, globalBounds.width, globalBounds.height);
    }
    toLocalPoint(point) {
        return this.worldTransform.applyInverse(point);
    }
    toGlobalPoint(point) {
        return this.worldTransform.apply(point);
    }
    isContainGlobalPoint(point) {
        let rect = this.getGlobalRect();
        return rect.contains(point.x, point.y);
    }
    isCursorInside() {
        return this.isContainGlobalPoint(TouchInput);
    }
    isNeedCheckAlphaPixels() {
        return false;
    }
    isHoveredByCursor() {
        if (!this.isNeedCheckAlphaPixels())
            return this.isCursorInside();
        if (!this.bitmap)
            return false;
        if (!this.bitmap.isReady())
            return false;
        try {
            let localPoint = this.toLocalPoint(new Point(TouchInput.x, TouchInput.y));
            let localBounds = this.getLocalBounds();
            let x = Math.floor(localPoint.x - localBounds.x);
            let y = Math.floor(localPoint.y - localBounds.y);
            if (x < 0 || y < 0)
                return false;
            if (x >= this.bitmap.width || y >= this.bitmap.height)
                return false;
            let alpha = Number(this.bitmap.getAlphaPixel(x, y));
            return alpha > this._alphaCheckThreshold;
        }
        catch (error) {
            console.warn(error);
            return false;
        }
    }
    removeFromParent() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
    }
    isVisible() {
        return this.worldVisible == true;
    }
    fillAll(color = "#FFFFFF") {
        if (this.bitmap) {
            this.bitmap.fillAll(color);
        }
    }
    setCommonAnchor(x, y) {
        try {
            if (y === undefined)
                y = x;
            this.anchor.set(x, y);
            // * Set the anchor for each children
            for (let child of this.children) {
                if (!child)
                    continue;
                if (child['setCommonAnchor']) {
                    child['setCommonAnchor'](x, y);
                }
                else {
                    if (!child['anchor'])
                        continue;
                    /*@ts-ignore*/
                    child.anchor.set(x, y);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    onBitmapLoaded(callback) {
        if (this.bitmap && this.bitmap.isReady()) {
            callback();
        }
        else {
            this.bitmap.addLoadListener(() => {
                callback();
            });
        }
    }
}
var KDNUI;
(function (KDNUI) {
    let EasingFunc;
    (function (EasingFunc) {
        EasingFunc["Linear"] = "linear";
        EasingFunc["EaseInQuad"] = "easeInQuad";
        EasingFunc["EaseOutQuad"] = "easeOutQuad";
        EasingFunc["EaseInOutQuad"] = "easeInOutQuad";
        EasingFunc["EaseInCubic"] = "easeInCubic";
        EasingFunc["EaseOutCubic"] = "easeOutCubic";
        EasingFunc["EaseInOutCubic"] = "easeInOutCubic";
    })(EasingFunc = KDNUI.EasingFunc || (KDNUI.EasingFunc = {}));
    class EasingFuncs {
        /**
         * Linear easing function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static linear(t, b, c, d) {
            return c * t / d + b;
        }
        /**
         * Ease in quadratic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeInQuad(t, b, c, d) {
            t /= d;
            return c * t * t + b;
        }
        /**
         * Ease out quadratic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeOutQuad(t, b, c, d) {
            t /= d;
            return -c * t * (t - 2) + b;
        }
        /**
         * Ease in and out quadratic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeInOutQuad(t, b, c, d) {
            t /= d / 2;
            if (t < 1)
                return c / 2 * t * t + b;
            t--;
            return -c / 2 * (t * (t - 2) - 1) + b;
        }
        /**
         * Ease in cubic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeInCubic(t, b, c, d) {
            t /= d;
            return c * t * t * t + b;
        }
        /**
         * Ease out cubic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeOutCubic(t, b, c, d) {
            t = t / d - 1;
            return c * (t * t * t + 1) + b;
        }
        /**
         * Ease in and out cubic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeInOutCubic(t, b, c, d) {
            t /= d / 2;
            if (t < 1)
                return c / 2 * t * t * t + b;
            t -= 2;
            return c / 2 * (t * t * t + 2) + b;
        }
    }
    KDNUI.EasingFuncs = EasingFuncs;
})(KDNUI || (KDNUI = {}));
var NUtils;
(function (NUtils) {
    function GetSpriteRealSize(forField, sprite) {
        try {
            if (!sprite) {
                return 0;
            }
            if (forField == "width" || forField == "x") {
                if (sprite["realWidth"])
                    return sprite["realWidth"]();
                else
                    return sprite.width;
            }
            if (forField == "height" || forField == "y") {
                if (sprite["realHeight"])
                    return sprite["realHeight"]();
                else
                    return sprite.height;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    NUtils.GetSpriteRealSize = GetSpriteRealSize;
    function ConvertDimension(value) {
        try {
            if (typeof value == "string") {
                value = NBindingsConverter.ConvertAllDimensionValues(value);
                if (KString.any(value))
                    return Number(value);
            }
            else {
                return value;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    NUtils.ConvertDimension = ConvertDimension;
})(NUtils || (NUtils = {}));
var KDNUI;
(function (KDNUI) {
    class AnimationKeyFrame {
        /**
         * Creates an instance of AnimationKeyFrame.
         * @param startValue The starting value of the animation.
         * @param endValue The ending value of the animation.
         * @param duration The duration of the animation in seconds.
         * @param func The easing function name.
         */
        constructor(startValue, endValue, duration = 1, func = 'linear') {
            this.startValue = startValue;
            this.endValue = endValue;
            this._t = 0;
            this._d = duration * 60; // Convert to Frames
            this._c = this.endValue - this.startValue; // Change
            this.func = func || 'linear';
        }
        /**
         * Resets the animation timer.
         */
        reset() {
            this._t = 0;
        }
        /**
         * Updates the animation timer.
         */
        update() {
            if (this._t < this._d) {
                this._t += 1;
            }
        }
        /**
         * Checks if the animation has ended.
         * @returns True if the animation has ended, otherwise false.
         */
        isEnd() {
            return this._t >= this._d || this._d <= 0;
        }
        /**
         * Gets the current value of the animation.
         * @returns The current value of the animation.
         */
        getValue() {
            if (this._d <= 0) {
                return this.endValue;
            }
            else {
                return this.easingFunc()(this._t, this.startValue, this._c, this._d);
            }
        }
        /**
         * Gets the easing function based on the function name.
         * @returns {KDNUI.IEasingFunction} The easing function.
         */
        easingFunc() {
            if (this.func && KDNUI.EasingFuncs[this.func]) {
                return KDNUI.EasingFuncs[this.func];
            }
            else {
                console.warn(`Easing func ${this.func} not found!`);
                return this.linear;
            }
        }
        /**
         * Default linear easing function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        linear(t, b, c, d) {
            return c * t / d + b;
        }
    }
    KDNUI.AnimationKeyFrame = AnimationKeyFrame;
})(KDNUI || (KDNUI = {}));
var KDNUI;
(function (KDNUI) {
    class AnimationKeyLine {
        /**
         * Creates an instance of AnimationKeyLine.
         * @param keyFramesList The list of keyframes.
         * @param totalDuration The total duration of the animation.
         * @param func The easing function name.
         */
        constructor(keyFramesList, totalDuration = 1, func = 'linear') {
            this.totalDuration = totalDuration;
            this.keyFrames = this._parseKeyFrames(keyFramesList, func);
            this.repeatsLeftBase = 0;
            this.repeatsLeft = 0;
            this.keyIndex = 0;
            this._relativeValue = 0;
            this._isStarted = false;
        }
        /**
         * Sets the relative value.
         * @param _relativeValue The relative value.
         */
        setRelativeValue(_relativeValue) {
            this._relativeValue = _relativeValue;
        }
        /**
         * Sets the number of repeats.
         * @param repeatsLeftBase The number of repeats.
         */
        setRepeatsCount(repeatsLeftBase) {
            this.repeatsLeftBase = repeatsLeftBase;
            this.repeatsLeft = repeatsLeftBase;
        }
        /**
         * Sets the animation to loop indefinitely.
         */
        setLoop() {
            this.setRepeatsCount(-1);
        }
        /**
         * Starts the animation with an optional delay.
         * @param startDelay The delay before starting the animation.
         */
        start(startDelay = 0) {
            if (startDelay === 0) {
                this._isStarted = true;
            }
            else {
                this._startTimer = startDelay * 60;
            }
        }
        /**
         * Pauses the animation.
         */
        pause() {
            this._isStarted = false;
            this._startTimer = null;
        }
        /**
         * Checks if the animation has started.
         * @returns True if the animation has started, otherwise false.
         */
        isStarted() {
            return this._isStarted === true;
        }
        /**
         * Completes the animation.
         */
        complete() {
            this.keyIndex = this.keyFrames.length;
            this.repeatsLeft = 0;
        }
        /**
         * Resets the animation.
         */
        reset() {
            this.repeatsLeft = this.repeatsLeftBase;
            this._resetKeyframes();
        }
        /**
         * Updates the animation.
         */
        update() {
            if (this._startTimer != null) {
                this._updateStartTimer();
            }
            if (!this.isStarted())
                return;
            if (this.isEnd()) {
                if (this.repeatsLeft === 0) {
                    return; // No repeats at all
                }
                else if (this.repeatsLeft < 0) { // Infinite Loop
                    this._resetKeyframes();
                }
                else {
                    this.repeatsLeft -= 1;
                    this._resetKeyframes();
                }
            }
            this.keyFrames[this.keyIndex].update();
            if (this.keyFrames[this.keyIndex].isEnd()) {
                this.keyIndex++;
            }
        }
        /**
         * Checks if the animation has ended.
         * @returns True if the animation has ended, otherwise false.
         */
        isEnd() {
            return this.keyIndex > this.keyFrames.length - 1;
        }
        /**
         * Gets the current value of the animation.
         * @returns The current value of the animation.
         */
        getValue() {
            let value;
            if (this.isEnd()) {
                value = this.keyFrames[this.keyFrames.length - 1].getValue();
            }
            else {
                value = this.keyFrames[this.keyIndex].getValue();
            }
            return value + this._relativeValue;
        }
        /**
         * Parses the keyframes.
         * @param keyframes The keyframes to parse.
         * @param func The easing function name.
         * @returns The parsed keyframes.
         */
        _parseKeyFrames(keyframes, func) {
            const keyframesOutput = [];
            const endValues = [];
            const keys = [];
            let index = 0;
            try {
                for (const key in keyframes) {
                    if (keyframes.hasOwnProperty(key)) {
                        let startValue;
                        if (endValues.length > 0) {
                            startValue = endValues[index - 1];
                        }
                        else {
                            startValue = 0;
                        }
                        const value = NUtils.ConvertDimension(keyframes[key]);
                        const endValue = value;
                        let duration;
                        if (key === "0") {
                            duration = 0;
                        }
                        else {
                            const prevKey = keys[index - 1];
                            duration = this._calculateDuration(prevKey, key);
                        }
                        const kf = new KDNUI.AnimationKeyFrame(startValue, endValue, duration, func);
                        keys[index] = key;
                        endValues[index] = value;
                        keyframesOutput.push(kf);
                        index++;
                    }
                }
            }
            catch (e) {
                console.warn(e);
            }
            return keyframesOutput;
        }
        /**
         * Calculates the duration between two keyframes.
         * @param rateA The start rate.
         * @param rateB The end rate.
         * @returns The calculated duration.
         */
        _calculateDuration(rateA, rateB) {
            try {
                const rateANum = Number(rateA) / 100.0;
                const rateBNum = Number(rateB) / 100.0;
                const timeA = this.totalDuration * rateANum;
                const timeB = this.totalDuration * rateBNum;
                const d = timeB - timeA;
                return d;
            }
            catch (e) {
                console.warn(e);
                return 0;
            }
        }
        /**
         * Resets the keyframes.
         */
        _resetKeyframes() {
            try {
                this.keyIndex = 0;
                for (const f of this.keyFrames) {
                    f.reset();
                }
            }
            catch (e) {
                console.warn(e);
            }
        }
        /**
         * Updates the start timer.
         */
        _updateStartTimer() {
            try {
                if (this._startTimer == null)
                    return;
                this._startTimer -= 1;
                if (this._startTimer <= 0) {
                    this._isStarted = true;
                    this._startTimer = null;
                }
            }
            catch (e) {
                console.warn(e);
            }
        }
    }
    KDNUI.AnimationKeyLine = AnimationKeyLine;
})(KDNUI || (KDNUI = {}));
var KDNUI;
(function (KDNUI) {
    class AnimationRule {
        /**
         * Creates an instance of AnimationRule.
         * @param animationConfig The animation configuration.
         * @param obj The object to apply the animation to.
         */
        constructor(animationConfig, obj) {
            if (typeof animationConfig === "string") {
                animationConfig = NBindingsConverter.ConvertShortcut(animationConfig);
            }
            this.animationConfig = Object.assign(AnimationRule.DefaultConfig(), animationConfig);
            const { condition } = this.animationConfig;
            if (KString.any(condition)) {
                if (eval(condition) === false) {
                    return;
                }
            }
            const { keyframes, duration, func, repeats, delay } = this.animationConfig;
            this.prepareKeyFrames(keyframes, obj);
            this.keyLine = new KDNUI.AnimationKeyLine(keyframes, duration, func);
            this.keyLine.setRepeatsCount(repeats !== null && repeats !== void 0 ? repeats : 0);
            if (obj && this.animationConfig.field === "_scaleFactor") {
                this.prepareObject(obj);
            }
            if (this.animationConfig.relative === true && obj) {
                this.keyLine.setRelativeValue(obj[this.animationConfig.field]);
            }
            this.keyLine.start(delay);
            if (obj && delay <= 0) {
                this.applyAnimation(obj);
            }
        }
        // * DefaultSettings in JSON format (for easy copy-paste)
        /**
         * Gets the default configuration for the animation.
         * @returns The default configuration.
         */
        static DefaultConfig() {
            return {
                "field": "opacity",
                "duration": 1,
                "func": "linear",
                "delay": 0,
                "repeats": 0,
                "relative": false,
                "keyframes": {
                    "0": 0,
                    "100": 255
                },
                "condition": null
            };
        }
        /**
         * Prepares the keyframes for the animation.
         * @param keyframes The keyframes to prepare.
         * @param obj The object to apply the animation to.
         */
        prepareKeyFrames(keyframes, obj) {
            for (const key in keyframes) {
                if (keyframes.hasOwnProperty(key)) {
                    if (keyframes[key] === "@") {
                        if (obj && obj[this.animationConfig.field] != null) {
                            keyframes[key] = obj[this.animationConfig.field];
                        }
                        else {
                            keyframes[key] = 0;
                        }
                    }
                }
            }
        }
        /**
         * Sets the end callback for the animation.
         * @param onEndCallback The callback to call when the animation ends.
         */
        setEndCallback(onEndCallback) {
            this.onEndCallback = onEndCallback;
        }
        /**
         * Checks if there is an end callback.
         * @returns True if there is an end callback, otherwise false.
         */
        isHaveEndCallback() {
            try {
                // Callback works only for single-shot animations
                if (this.animationConfig.repeats !== 0) {
                    return false;
                }
                return this.onEndCallback != null;
            }
            catch (e) {
                console.warn(e);
                return false;
            }
        }
        /**
         * Updates the animation.
         */
        update() {
            var _a;
            if (!this.keyLine)
                return;
            this.keyLine.update();
            if (this.isHaveEndCallback() && this.keyLine.isEnd()) {
                try {
                    (_a = this.onEndCallback) === null || _a === void 0 ? void 0 : _a.call(this);
                }
                catch (e) {
                    console.warn(e);
                }
                this.onEndCallback = null;
            }
        }
        /**
         * Applies the animation to the object.
         * @param obj The object to apply the animation to.
         */
        applyAnimation(obj) {
            try {
                if (!obj || !this.keyLine)
                    return;
                obj[this.animationConfig.field] = this.keyLine.getValue();
            }
            catch (e) {
                console.warn(e);
            }
        }
        /**
         * Prepares the object for the animation.
         * @param obj The object to prepare.
         */
        prepareObject(obj) {
            try {
                if (obj && obj.onBeforeChangeScaleFactor) {
                    obj.onBeforeChangeScaleFactor();
                }
            }
            catch (e) {
                console.warn(e);
            }
        }
    }
    KDNUI.AnimationRule = AnimationRule;
})(KDNUI || (KDNUI = {}));
class KFilteredSprite extends KSprite {
    constructor() {
        super();
        this._activeFilters = {};
    }
    addEffect(effectSettings) {
        try {
            switch (effectSettings.type) {
                case KNSpriteEffects.Blur:
                    this.addBlurEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Shadow:
                    this.addShadowEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Outline:
                    this.addOutlineEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Glow:
                    this.addGlowEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Tint:
                    this.addTintEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Desaturate:
                    this.addDesaturateEffect();
                    break;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    addBlurEffect(settings = {}) {
        try {
            if (!PIXI.filters['BlurFilter']) {
                console.warn("The blur effect is not available in the current version of PIXI.js.");
                return;
            }
            let strength = settings.strength || 8;
            let quality = settings.quality || 4;
            let filterObject = new PIXI.filters.BlurFilter(strength, quality);
            this._addFilter(KNSpriteEffects.Blur, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * MZ only
    addShadowEffect(settings = {}) {
        try {
            if (!PIXI.filters['DropShadowFilter']) {
                console.warn("The shadow effect is not available in the current version of PIXI.js.");
                return;
            }
            if (KDX.isMV()) {
                console.warn("The shadow effect is not available in MV.");
                return;
            }
            let rotation = settings.rotation || 45;
            let color = settings.color || 0x000000;
            let alpha = settings.alpha || 0.5;
            let distance = settings.distance || 5;
            let shadowOnly = settings.shadowOnly || false;
            let blur = settings.blur || 2;
            let quality = settings.quality || 3;
            /*@ts-ignore*/
            let filterObject = new PIXI.filters.DropShadowFilter({
                rotation,
                color,
                alpha,
                distance,
                shadowOnly,
                blur,
                quality
            });
            this._addFilter(KNSpriteEffects.Shadow, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * MZ only
    addOutlineEffect(settings = {}) {
        try {
            if (!PIXI.filters['OutlineFilter']) {
                console.warn("The outline effect is not available in the current version of PIXI.js.");
                return;
            }
            if (KDX.isMV()) {
                console.warn("The outline effect is not available in MV.");
                return;
            }
            let thickness = settings.thickness || 1;
            let color = settings.color || 0xffffff;
            let quality = settings.quality || 0.1;
            let knockout = settings.knockout || false;
            /*@ts-ignore*/
            let filterObject = new PIXI.filters.OutlineFilter(thickness, color, quality, true, knockout);
            this._addFilter(KNSpriteEffects.Outline, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    addGlowEffect(settings = {}) {
        try {
            if (!PIXI.filters['GlowFilter']) {
                console.warn("The glow effect is not available in the current version of PIXI.js.");
                return;
            }
            let color = settings.color || 0xffffff;
            let distance = settings.distance || 10;
            let outerStrength = settings.outerStrength || 4;
            let innerStrength = settings.innerStrength || 0;
            let quality = settings.quality || 0.1;
            let knockout = settings.knockout || false;
            /*@ts-ignore*/
            let filterObject = new PIXI.filters.GlowFilter({ distance, outerStrength, innerStrength, color, quality, knockout });
            this._addFilter(KNSpriteEffects.Glow, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    addTintEffect(settings = {}) {
        try {
            if (!PIXI.filters['ColorOverlayFilter']) {
                console.warn("The tint effect is not available in the current version of PIXI.js.");
                return;
            }
            let color = settings.color || 0xffffff;
            let alpha = settings.alpha || 0.5;
            /*@ts-ignore*/
            let filterObject = new PIXI.filters.ColorOverlayFilter(color, alpha);
            this._addFilter(KNSpriteEffects.Tint, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    addDesaturateEffect() {
        try {
            if (!PIXI.filters['ColorMatrixFilter']) {
                console.warn("The desaturate effect is not available in the current version of PIXI.js.");
                return;
            }
            let filterObject = new PIXI.filters.ColorMatrixFilter();
            filterObject.desaturate();
            this._addFilter(KNSpriteEffects.Desaturate, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    removeEffect(effectType) {
        try {
            this._removeFilter(effectType);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _removeFilter(filter) {
        try {
            let filterObj = this._activeFilters[filter];
            if (filterObj) {
                if (KDX.isMV()) {
                    /*@ts-ignore*/
                    this._filters = this._filters.filter(f => f !== filterObj);
                }
                else {
                    this.filters = this.filters.filter(f => f !== filterObj);
                }
            }
            delete this._activeFilters[filter];
        }
        catch (error) {
            console.warn(error);
        }
    }
    _addFilter(filter, filterObject) {
        try {
            if (this._activeFilters[filter]) {
                this._removeFilter(filter);
            }
            if (KDX.isMV()) {
                /*@ts-ignore*/
                if (!this._filters) {
                    this._filters = [];
                }
            }
            else {
                if (!this.filters) {
                    this.filters = [];
                }
            }
            if (KDX.isMV()) {
                /*@ts-ignore*/
                this._filters.push(filterObject);
            }
            else {
                this.filters.push(filterObject);
            }
            this._activeFilters[filter] = filterObject;
        }
        catch (error) {
            console.warn(error);
        }
    }
}
let globalHandledSprite = null;
class KHandledSprite extends KFilteredSprite {
    static GlobalHandledSprite() {
        return globalHandledSprite;
    }
    static DeactivateGlobalHandledSprite(reference = null) {
        if (globalHandledSprite && globalHandledSprite != reference) {
            globalHandledSprite._deactivateHandler();
        }
    }
    constructor() {
        super();
        this._handledIndex = 0;
        this._handleManagerActive = false;
        this._handlerActive = false;
    }
    get handledIndex() {
        return this._handledIndex;
    }
    set handledIndex(value) {
        this._handledIndex = value;
    }
    addChild(child) {
        super.addChild(child);
        if (child instanceof KHandledSprite) {
            if (child.isSupportKeyboardHandle()) {
                child.handledIndex = this._pGetAllHandlers().length - 1;
            }
        }
        return child;
    }
    destroy(options) {
        this._deactivateHandler();
        super.destroy(options);
    }
    update() {
        super.update();
        if (this.isHandlerActive()) {
            this._handleKeyboardInputs();
        }
    }
    // * This should be TRUE if element can be selected (activated) or navigated by keyboard
    isSupportKeyboardHandle() {
        return false;
    }
    isVerticalKeyboardNavigation() {
        return true;
    }
    isFreeKeyboardNavigation() {
        return false;
    }
    isHandlerActive() {
        return this._handleManagerActive || this._handlerActive;
    }
    isAnyHandlerSelected() {
        return globalHandledSprite != null;
    }
    activateHandlerManagment() {
        if (this.isFreeKeyboardNavigation()) {
            this._handleUpAction = this._freeSelectionUpHandler.bind(this);
            this._handleDownAction = this._freeSelectionDownHandler.bind(this);
            this._handleLeftAction = this._freeSelectionLeftHandler.bind(this);
            this._handleRightAction = this._freeSelectionRightHandler.bind(this);
        }
        else {
            this._handleUpAction = this._selectPreviousHandlerItem.bind(this);
            this._handleDownAction = this._selectNextHandlerItem.bind(this);
        }
        this._handleManagerActive = true;
    }
    deactivateHandlerManagment() {
        this._handleManagerActive = false;
        if (globalHandledSprite == this) {
            this._deactivateHandler();
        }
        this._handleUpAction = null;
        this._handleDownAction = null;
        this._handleLeftAction = null;
        this._handleRightAction = null;
    }
    _handleKeyboardInputs() {
        try {
            if (Input.isTriggered('left')) {
                this._handleKeyLeft();
            }
            else if (Input.isTriggered('right')) {
                this._handleKeyRight();
            }
            else if (Input.isTriggered('up')) {
                this._handleKeyUp();
            }
            else if (Input.isTriggered('down')) {
                this._handleKeyDown();
            }
            else if (Input.isTriggered('ok')) {
                this._handleKeyOk();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyLeft(ignoreNavigation = false) {
        try {
            if (this.isVerticalKeyboardNavigation() || ignoreNavigation) {
                if (this._handleLeftAction) {
                    this._handleLeftAction();
                    this._onActionHandled();
                }
            }
            else {
                this._handleKeyUp(true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyRight(ignoreNavigation = false) {
        try {
            if (this.isVerticalKeyboardNavigation() || ignoreNavigation) {
                if (this._handleRightAction) {
                    this._handleRightAction();
                    this._onActionHandled();
                }
            }
            else {
                this._handleKeyDown(true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyUp(ignoreNavigation = false) {
        try {
            if (this.isVerticalKeyboardNavigation() || ignoreNavigation) {
                if (this._handleUpAction) {
                    this._handleUpAction();
                    this._onActionHandled();
                }
            }
            else {
                this._handleKeyLeft(true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyDown(ignoreNavigation = false) {
        try {
            if (this.isVerticalKeyboardNavigation() || ignoreNavigation) {
                if (this._handleDownAction) {
                    this._handleDownAction();
                    this._onActionHandled();
                }
            }
            else {
                this._handleKeyRight(true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyOk() {
        try {
            if (this._handleOkAction) {
                this._handleOkAction();
                this._onActionHandled();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _onActionHandled() {
        Input.clear();
    }
    _selectPreviousHandlerItem() {
        if (!this.isAnyHandlerSelected()) {
            this._trySelectHandler(0);
        }
        else {
            this._trySelectHandler(this._selectedHandlerIndex() - 1);
        }
    }
    _selectedHandlerIndex() {
        return globalHandledSprite.handledIndex;
    }
    _trySelectHandler(index) {
        let handlers = this._pGetAllHandlers();
        let handler = handlers.find(h => h.handledIndex == index);
        if (handler) {
            handler._activateHandler();
        }
        this._onActionHandled();
    }
    _pGetAllHandlers() {
        let handlers = [];
        for (let child of this.children) {
            if (child instanceof KHandledSprite) {
                if (child.isSupportKeyboardHandle()) {
                    handlers.push(child);
                }
            }
        }
        return handlers;
    }
    _selectNextHandlerItem() {
        if (!this.isAnyHandlerSelected()) {
            this._trySelectHandler(0);
        }
        else {
            this._trySelectHandler(this._selectedHandlerIndex() + 1);
        }
    }
    _activateHandler() {
        if (globalHandledSprite && globalHandledSprite != this) {
            globalHandledSprite._deactivateHandler();
        }
        globalHandledSprite = this;
        this._handlerActive = true;
        this._activateHandlerVisually();
    }
    _activateHandlerVisually() {
        this.addGlowEffect({ distance: 15, outerStrength: 4 });
    }
    _deactivateHandler() {
        if (globalHandledSprite == this) {
            globalHandledSprite = null;
        }
        this._handlerActive = false;
        this._deactivateHandlerVisually();
    }
    _deactivateHandlerVisually() {
        this.removeEffect(KNSpriteEffects.Glow);
    }
    _getClosestItemToYx(x, y, fromItems) {
        let items = [];
        if (y >= 0) {
            items = fromItems.filter(i => i.y > y);
        }
        else {
            items = fromItems.filter(i => i.y < Math.abs(y));
        }
        if (items.length == 0) {
            return null;
        }
        let itemsInRow = items.filter(i => i.x == x);
        if (itemsInRow.length > 0) {
            itemsInRow.sort((a, b) => a.y - b.y);
            return itemsInRow[0];
        }
        else {
            let distances = [];
            let rY = Math.abs(y);
            let index = 0;
            for (let item of items) {
                distances.push([index, Math.abs(item.x - x) + Math.abs(item.y - rY)]);
                index++;
            }
            distances.sort((a, b) => a[1] - b[1]);
            return items[distances[0][0]];
        }
    }
    _getClosestItemToXy(x, y, fromItems) {
        let items = [];
        if (x >= 0) {
            items = fromItems.filter(i => i.x > x);
        }
        else {
            items = fromItems.filter(i => i.x < Math.abs(x));
        }
        if (items.length == 0) {
            return null;
        }
        let itemsInRow = items.filter(i => i.y == y);
        if (itemsInRow.length > 0) {
            itemsInRow.sort((a, b) => a.x - b.x);
            return itemsInRow[0];
        }
        else {
            let distances = [];
            let rX = Math.abs(x);
            let index = 0;
            for (let item of items) {
                distances.push([index, Math.abs(item.x - rX) + Math.abs(item.y - y)]);
                index++;
            }
            distances.sort((a, b) => a[1] - b[1]);
            return items[distances[0][0]];
        }
    }
    _freeSelectionUpHandler() {
        try {
            let allItems = this._pGetAllHandlers();
            if (allItems.length == 0) {
                return;
            }
            if (this.isAnyHandlerSelected()) {
                let item = this._getClosestItemToYx(globalHandledSprite.x, -globalHandledSprite.y, allItems);
                if (item) {
                    item._activateHandler();
                }
            }
            else {
                allItems[0]._activateHandler();
            }
        }
        catch (error) {
            console.warn(error);
        }
        this._onActionHandled();
    }
    _freeSelectionDownHandler() {
        try {
            let allItems = this._pGetAllHandlers();
            if (allItems.length == 0) {
                return;
            }
            if (this.isAnyHandlerSelected()) {
                let item = this._getClosestItemToYx(globalHandledSprite.x, globalHandledSprite.y, allItems);
                if (item) {
                    item._activateHandler();
                }
            }
            else {
                allItems[0]._activateHandler();
            }
        }
        catch (error) {
            console.warn(error);
        }
        this._onActionHandled();
    }
    _freeSelectionLeftHandler() {
        try {
            let allItems = this._pGetAllHandlers();
            if (allItems.length == 0) {
                return;
            }
            if (this.isAnyHandlerSelected()) {
                let item = this._getClosestItemToXy(-globalHandledSprite.x, globalHandledSprite.y, allItems);
                if (item) {
                    item._activateHandler();
                }
            }
            else {
                allItems[0]._activateHandler();
            }
        }
        catch (error) {
            console.warn(error);
        }
        this._onActionHandled();
    }
    _freeSelectionRightHandler() {
        try {
            let allItems = this._pGetAllHandlers();
            if (allItems.length == 0) {
                return;
            }
            if (this.isAnyHandlerSelected()) {
                let item = this._getClosestItemToXy(globalHandledSprite.x, globalHandledSprite.y, allItems);
                if (item) {
                    item._activateHandler();
                }
            }
            else {
                allItems[0]._activateHandler();
            }
        }
        catch (error) {
            console.warn(error);
        }
        this._onActionHandled();
    }
}
var NBindingsConverter;
(function (NBindingsConverter) {
    function ConvertBindingValue(sourceElement, bindingValue, element = null) {
        try {
            // * ["%1 %2", value1, value2]
            if (Array.isArray(bindingValue)) {
                let bindingValuesArray = bindingValue;
                let sourceText = bindingValuesArray[0];
                if (!KString.any(sourceText))
                    return "";
                for (let i = 1; i < bindingValuesArray.length; i++) {
                    if (KString.any(bindingValuesArray[i])) {
                        try {
                            let value = _convertSingleBindingValue(sourceElement, bindingValuesArray[i], element);
                            if (KString.any(value)) {
                                sourceText = sourceText.replace(`%${i}`, value);
                            }
                        }
                        catch (error) {
                            console.warn(error);
                        }
                    }
                }
                return sourceText;
            }
            else {
                return _convertSingleBindingValue(sourceElement, bindingValue, element);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return bindingValue.toString();
    }
    NBindingsConverter.ConvertBindingValue = ConvertBindingValue;
    function _convertSingleBindingValue(sourceElement, bindingValue, element = null) {
        try {
            if (typeof bindingValue != "string") {
                return bindingValue;
            }
            // * CONVERT THERNARY OPERATORS
            // * example: "value ? true : false"
            let regex = new RegExp("(.+?)\\?(.+?):(.+)", "g");
            let result = regex.exec(bindingValue);
            if (result) {
                let condition = result[1].trim();
                let trueValue = result[2].trim();
                let falseValue = result[3].trim();
                let value = _convertSingleBindingValue(sourceElement, condition, element);
                if (value) {
                    return _convertSingleBindingValue(sourceElement, trueValue, element);
                }
                else {
                    return _convertSingleBindingValue(sourceElement, falseValue, element);
                }
            }
            // * CONVERT DIMENSION VALUES (HDP and DP)
            bindingValue = ConvertAllDimensionValues(bindingValue);
            // * FORCE EVAL
            if (bindingValue[0] == '@') {
                let evalString = bindingValue.replace("@", "");
                return eval(evalString);
            }
            // * EXTRA $ calculations (POST EVAL)
            if (bindingValue[0] == '~') {
                if (bindingValue.includes("$")) {
                    let regex = new RegExp("(\\$[\\w+.]*)", "g");
                    let result = regex.exec(bindingValue);
                    if (result) {
                        let captured = result[1];
                        if (KDX.any(captured)) {
                            let resultValue = _convertSingleBindingValue$(sourceElement, captured, element);
                            if (!KDX.any(resultValue)) {
                                return null;
                            }
                            if (typeof resultValue == "function") {
                                return resultValue;
                            }
                            else {
                                if (KDX.any(resultValue)) {
                                    bindingValue = bindingValue.replace(captured, resultValue);
                                    return ConvertBindingValue(sourceElement, bindingValue, element);
                                }
                                else {
                                    return null;
                                }
                            }
                        }
                    }
                }
                else {
                    let evalString = bindingValue.replace("~", "");
                    return eval(evalString);
                }
            }
            // * DEFAULT OLD STYLE SIMPLE $
            if (bindingValue.includes('$')) {
                return _convertSingleBindingValue$(sourceElement, bindingValue, element);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return bindingValue;
    }
    function ConvertAllDimensionValues(value) {
        if (value.includes('hdp')) {
            let regex = new RegExp("(\\d+)hdp", "g");
            let result = regex.exec(value);
            while (result) {
                let dpValue = parseInt(result[1]);
                let converted = ConvertDimenstionToPixels(dpValue, true);
                value = value.replace(result[0], converted.toString());
                result = regex.exec(value);
            }
        }
        if (value.includes('dp')) {
            let regex = new RegExp("(\\d+)dp", "g");
            let result = regex.exec(value);
            while (result) {
                let dpValue = parseInt(result[1]);
                let converted = ConvertDimenstionToPixels(dpValue, false);
                value = value.replace(result[0], converted.toString());
                result = regex.exec(value);
            }
        }
        return value;
    }
    NBindingsConverter.ConvertAllDimensionValues = ConvertAllDimensionValues;
    function _convertSingleBindingValue$(sourceElement, bindingValue, element) {
        try {
            let field = bindingValue.replace("$", "");
            if (field.includes(".")) { // * example: $parent.width
                let parts = field.split(".");
                // * Только одно вхождение (одна точка)
                field = parts[0];
                let subField = parts[1];
                if (!KString.any(field) && KString.any(subField)) {
                    if (element) {
                        return _convertSingleBindingValue$(element, "$" + subField, element);
                    }
                    else {
                        return null;
                    }
                }
                if (KString.any(field) && !KString.any(subField)) {
                    return _convertSingleBindingValue$(sourceElement, "$" + field, element);
                }
                if (sourceElement) {
                    let subData = _getSourceElementFieldValue(sourceElement, field);
                    return _convertSingleBindingValue$(subData, "$" + subField, element);
                }
                else {
                    return null;
                }
            }
            else {
                return _getSourceElementFieldValue(sourceElement, field);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    function _getSourceElementFieldValue(sourceElement, field) {
        try {
            if (sourceElement && sourceElement[field]) {
                if (typeof sourceElement[field] == "function") {
                    return sourceElement[field]();
                }
                else {
                    return sourceElement[field];
                }
            }
            else {
                return null; // * We can't find value
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    function ConvertDimenstionToPixels(value = 0, isHalf = false) {
        try {
            if (Graphics.width == 816 && Graphics.height == 624) {
                return value;
            }
            let modX = Graphics.width / 816;
            let modY = Graphics.height / 624;
            let mod = (modX + modY) / 2;
            if (mod == 0)
                return 0;
            if (isHalf) {
                if (mod < 1) {
                    let d = 1 - mod;
                    mod += d / 2;
                }
                else if (mod > 1) {
                    let d = mod - 1;
                    mod = 1 + (d / 2);
                }
            }
            return Math.round(value * mod);
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    NBindingsConverter.ConvertDimenstionToPixels = ConvertDimenstionToPixels;
    function ConvertPercentageValues(value, forField, spriteParent) {
        try {
            if (value.includes("%")) {
                let regex = new RegExp("(\\d+)%", "g");
                let result = regex.exec(value);
                while (result) {
                    let percentageValue = parseInt(result[1]);
                    let resultValue = 0;
                    if (spriteParent) {
                        let parentRefSize = NUtils.GetSpriteRealSize(forField, spriteParent);
                        resultValue = parentRefSize * (percentageValue / 100.0);
                    }
                    value = value.replace(result[0], resultValue.toString());
                    result = regex.exec(value);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return value;
    }
    NBindingsConverter.ConvertPercentageValues = ConvertPercentageValues;
    /**
     * Converts a shortcut string to a configuration object.
     * @param shortcut The shortcut string to convert.
     * @param outerSep The outer separator (default is ";").
     * @param innerSep The inner separator (default is ":").
     * @returns The configuration object.
     */
    function ConvertShortcut(shortcut, outerSep = ";", innerSep = ":") {
        try {
            const config = {};
            const values = shortcut.split(outerSep);
            for (const value of values) {
                if (!String(value).trim())
                    continue;
                const pair = value.split(innerSep);
                const valueName = pair[0];
                let valueData = pair[1];
                if (valueData && valueData.includes("=")) {
                    valueData = _convertValueDataFromShortcut(valueData);
                }
                else {
                    if (valueData == null) {
                        valueData = true;
                    }
                    else {
                        if (isFinite(valueData))
                            valueData = Number(valueData);
                    }
                }
                config[valueName] = valueData;
            }
            return config;
        }
        catch (e) {
            console.warn(e);
            return {};
        }
    }
    NBindingsConverter.ConvertShortcut = ConvertShortcut;
    /**
     * Converts a value data string from a shortcut format to an object.
     * @param valueData The value data string to convert.
     * @returns The converted object.
     */
    function _convertValueDataFromShortcut(valueData) {
        try {
            if (valueData.includes("|")) {
                const data = {};
                const outerItems = valueData.split("|");
                for (const item of outerItems) {
                    const p = item.split("=");
                    const n = p.shift();
                    let v = p;
                    if (v.length === 0) {
                        v = true;
                    }
                    else {
                        if (v.length === 1) {
                            v = v[0];
                            if (isFinite(v))
                                v = Number(v);
                        }
                        else {
                            v = _convertValueDataFromShortcut(v.join("="));
                        }
                    }
                    if (n)
                        data[n] = v;
                }
                return data;
            }
            const data = ConvertShortcut(valueData, ",", "=");
            return data;
        }
        catch (e) {
            console.warn(e);
            return {};
        }
    }
})(NBindingsConverter || (NBindingsConverter = {}));
let globalUnderMouseSprite = null;
function IsAnyKNButtonUnderMouse() {
    if (!globalUnderMouseSprite) {
        return false;
    }
    if (globalUnderMouseSprite) {
        if (!globalUnderMouseSprite.parent) {
            globalUnderMouseSprite = null;
            return false;
        }
        if (!globalUnderMouseSprite.worldVisible) {
            return false;
        }
    }
    return true;
}
class KClickableSprite extends KHandledSprite {
    constructor() {
        super(...arguments);
        this._isHovered = false;
        this._isPressed = false;
        this._isDisabled = false;
    }
    static GlobalUnderMouseSprite() {
        return globalUnderMouseSprite;
    }
    static DeactivateGlobalUnderMouseSprite(reference = null) {
        if (globalUnderMouseSprite && globalUnderMouseSprite != reference) {
            globalUnderMouseSprite._clearClickState();
        }
        else {
            globalUnderMouseSprite = null;
        }
    }
    _activateHandler() {
        KClickableSprite.DeactivateGlobalUnderMouseSprite(this);
        super._activateHandler();
    }
    isCanHandleTouch() {
        return false;
    }
    isClickEnabled() {
        return this.worldVisible;
    }
    isDisabled() {
        return this._isDisabled;
    }
    isPressed() {
        return this._isPressed;
    }
    isHovered() {
        return this._isHovered;
    }
    isFocused() {
        return this.isHandlerActive();
    }
    update() {
        super.update();
        if (this.isCanHandleTouch()) {
            this._updateTouch();
        }
    }
    onMouseEnter() {
        this._activateHandler();
        //console.log("Mouse enter");
    }
    onMouseExit() {
        this._deactivateHandler();
        //console.log("Mouse exit");
    }
    onClick() {
        this._handleKeyOk();
        //console.log("Click");
    }
    onPress() {
        //console.log("Press");
    }
    onReleased() {
        //console.log("Released");
    }
    setClickHandler(handler) {
        this._handleOkAction = handler;
    }
    _handleKeyOk() {
        if (this.isDisabled()) {
            return;
        }
        if (this.isClickEnabled()) {
            super._handleKeyOk();
        }
    }
    _updateTouch() {
        if (this.isClickEnabled()) {
            if (this.isHoveredByCursor()) {
                /*@ts-ignore*/
                if (!this.isHovered() && !TouchInput.isPressed()) {
                    this._isHovered = true;
                    if (!this.isDisabled()) {
                        this.onMouseEnter();
                    }
                    globalUnderMouseSprite = this;
                    KHandledSprite.DeactivateGlobalHandledSprite(this);
                }
            }
            else {
                if (this.isHovered()) {
                    this._clearClickState();
                    if (!this.isDisabled()) {
                        this.onMouseExit();
                    }
                }
            }
            if (TouchInput.isPressed() && this.isHovered() && !this.isDisabled()) {
                if (!this.isPressed()) {
                    this._isPressed = true;
                    this.onPress();
                }
            }
            if (TouchInput.isReleased() && this.isPressed() && !this.isDisabled()) {
                this._isPressed = false;
                this.onReleased();
                if (this.isHovered()) {
                    this.onClick();
                }
            }
        }
        else {
            this._clearClickState();
        }
    }
    _clearClickState() {
        this._isHovered = false;
        this._isPressed = false;
        if (globalUnderMouseSprite == this) {
            globalUnderMouseSprite = null;
        }
    }
    destroy(options) {
        this._clearClickState();
        super.destroy(options);
    }
}
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Scene_Map.prototype;
    //@[ALIAS]
    const ALIAS__isAnyButtonPressed = _.isAnyButtonPressed;
    _.isAnyButtonPressed = function () {
        if (IsAnyKNButtonUnderMouse()) {
            return true;
        }
        return ALIAS__isAnyButtonPressed.call(this);
    };
    //@[ALIAS]
    const ALIAS__start = _.start;
    _.start = function () {
        globalUnderMouseSprite = null;
        ALIAS__start.call(this);
    };
    if (Utils.RPGMAKER_NAME.includes("MV")) {
        //@[ALIAS]
        const ALIAS__processMapTouch = _.processMapTouch;
        _.processMapTouch = function () {
            if (IsAnyKNButtonUnderMouse()) {
                return;
            }
            ALIAS__processMapTouch.call(this);
        };
    }
})();
// ■ END Scene_Map.ts
//---------------------------------------------------------------------------
class KNSprite extends KClickableSprite {
    constructor() {
        super();
        this._scaleFactor = null;
        this._isNotHaveBounds = false;
        this._requiredFuncs = null;
        this._loadListeners = null;
        this._animationRules = null;
        this._uiJsonSchema = null;
        this._dataBindingsCache = null;
        this._uiConstants = null;
    }
    isNotHaveBounds() {
        return this._isNotHaveBounds == true;
    }
    isLoaded() {
        return true;
    }
    isShouldAlwaysKeepCentered() {
        return this._anchoredCenterX != null;
    }
    realWidth() {
        try {
            if (this.isNotHaveBounds()) {
                return 0;
            }
            if (this.width == 0) {
                let child = this.children[0];
                if (child) {
                    if (child["realWidth"])
                        return child["realWidth"]();
                    else
                        return child.width;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return this.width;
    }
    realHeight() {
        try {
            if (this.isNotHaveBounds()) {
                return 0;
            }
            if (this.height == 0) {
                let child = this.children[0];
                if (child) {
                    if (child["realHeight"])
                        return child["realHeight"]();
                    else
                        return child.height;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return this.height;
    }
    setJsonSchema(schema) {
        this._uiJsonSchema = schema;
    }
    getJsonSchema() {
        return this._uiJsonSchema;
    }
    addUIConstants(constants) {
        if (!this._uiConstants) {
            this._uiConstants = {};
        }
        this._uiConstants = Object.assign(this._uiConstants, constants);
    }
    uiConstant(key, defaultValue = undefined) {
        if (!this._uiConstants) {
            this._uiConstants = {};
        }
        if (KDX.any(this._uiConstants[key])) {
            return this._uiConstants[key];
        }
        else {
            return defaultValue;
        }
    }
    dataBindings() {
        if (!this._dataBindingsCache) {
            this._dataBindingsCache = {
                x: (v) => this.setPosition(v, this.y),
                y: (v) => this.setPosition(this.x, v),
                position: (v) => this.setPosition(v.x, v.y),
                visible: (v) => { this.visible = v; },
                opacity: (v) => { if (KDX.any(v)) {
                    this.opacity = v;
                } },
                scale: (v) => { if (KDX.any(v)) {
                    this.scale.set(v);
                } },
                rotation: (v) => { if (KDX.any(v)) {
                    this.rotation = v;
                } },
                physicalBounds: (v) => { this._isNotHaveBounds = !v; },
                anchor: (v) => { if (KDX.any(v)) {
                    this.setCommonAnchor(v);
                } },
                animation: (v) => { if (v) {
                    this.addAnimationRule(v);
                } },
                centeredScale: (v) => { if (KDX.any(v)) {
                    this.setCenteredScale(v);
                } }
            };
        }
        return this._dataBindingsCache;
    }
    refreshBindings(dataObject = null, resursive = true) {
        let _isUseDataObjectForChildrens = true;
        if (!dataObject) {
            dataObject = this;
            _isUseDataObjectForChildrens = false;
        }
        if (this._uiJsonSchema) {
            let { bindings } = this._uiJsonSchema;
            if (bindings) {
                for (let key in this.dataBindings()) {
                    if (!KDX.any(bindings[key])) {
                        continue;
                    }
                    try {
                        let value = NBindingsConverter.ConvertBindingValue(dataObject, bindings[key], this);
                        this.callBinding(key, value);
                    }
                    catch (error) {
                        console.warn(error);
                    }
                }
            }
        }
        if (resursive) {
            for (let child of this.children) {
                if (!child)
                    continue;
                try {
                    if (child['refreshBindings']) {
                        if (_isUseDataObjectForChildrens) {
                            child['refreshBindings'](dataObject, resursive);
                        }
                        else {
                            child['refreshBindings'](null, resursive);
                        }
                    }
                }
                catch (error) {
                    console.warn(error);
                }
            }
        }
    }
    callBinding(key, value) {
        try {
            let bindings = this.dataBindings();
            if (bindings[key]) {
                bindings[key](value);
            }
            else {
                console.warn("Binding not found", key);
            }
        }
        catch (error) {
            console.warn("Binding call error", error);
        }
    }
    addAnimationRule(rule) {
        try {
            if (!this._animationRules) {
                this._animationRules = [];
            }
            let animationRule = new KDNUI.AnimationRule(rule, this);
            this._animationRules.push(animationRule);
            return animationRule;
        }
        catch (error) {
            console.warn(error);
            return null;
        }
    }
    setAnimationRule(rule) {
        try {
            this._animationRules = []; // * Clear all rules
            if (rule) {
                return this.addAnimationRule(rule);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    addLoadListener(func) {
        try {
            if (this.isLoaded()) {
                func();
            }
            else {
                this._addLoadListener(func);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    setCenteredScale(value) {
        if (!this.isLoaded()) {
            this.requireFunc("setCenteredScale", arguments);
            return;
        }
        this._refreshAnchoredCenter();
        this._scaleFactor = value;
    }
    // * For Animation Rule (callback)
    onBeforeChangeScaleFactor() {
        try {
            if (this.isShouldAlwaysKeepCentered()) {
                this._refreshAnchoredCenter();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * Examples: setPosition(10, 10), setPosition("center") - for both x and y
    setPosition(x, y, bindedObject) {
        try {
            if (!this.isLoaded()) {
                this.requireFunc("setPosition", arguments);
                return;
            }
            if (typeof x == "string") {
                if (y == null || y == undefined) { // * If single string argument X, then Y = X
                    y = x;
                }
                x = this.convertStringSizeValue(x, "x", bindedObject);
            }
            if (y == null || y == undefined) {
                y = this.y;
            }
            if (typeof y == "string") {
                y = this.convertStringSizeValue(y, "y", bindedObject);
            }
            if (!isNaN(x) && !isNaN(y)) {
                this.move(x, y);
            }
            else {
                console.warn("Invalid position values X, Y ", x, y);
            }
        }
        catch (error) {
            console.warn(error);
            this.move(0, 0);
        }
    }
    update() {
        super.update();
        this._updateAnimationRules();
        if (this._scaleFactor != null) {
            this._updateScaleFactor(); // * For Centered Scale
        }
    }
    convertStringSizeValue(value, forField, owner) {
        try {
            if (typeof value == "number") {
                return value;
            }
            /* @ts-ignore */
            if (isFinite(value)) {
                return Number(value);
            }
            if (typeof value != "string") {
                return 0;
            }
            if (value[0] == '$' || value[0] == '@') {
                let v = NBindingsConverter.ConvertBindingValue(owner, value, this);
                return this.convertStringSizeValue(v, forField, owner);
            }
            if (value.includes("prevX")) {
                value = value.replace("prevX", this.getPreviousChildData("x"));
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("prevY")) {
                value = value.replace("prevY", this.getPreviousChildData("y"));
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("prevHeight")) {
                value = value.replace("prevHeight", this.getPreviousChildData("height"));
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("prevWidth")) {
                value = value.replace("prevWidth", this.getPreviousChildData("width"));
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("prevEndX")) {
                value = value.replace("prevEndX", "prevX + prevWidth");
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("prevEndY")) {
                value = value.replace("prevEndY", "prevY + prevHeight");
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("end")) {
                value = value.replace("end", "100%");
            }
            if (value.includes("begin")) {
                if (forField == "y") {
                    value = value.replace("begin", "-height");
                }
                else {
                    value = value.replace("begin", "-width");
                }
            }
            if (value.includes("right")) {
                value = value.replace("right", "100% - width");
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("left")) {
                value = value.replace("left", "0");
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("top")) {
                value = value.replace("top", "0");
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("bottom")) {
                value = value.replace("bottom", "100% - height");
                return this.convertStringSizeValue(value, forField, owner);
            }
            // * Replace all %
            if (value.includes("%")) {
                if (this.parent) {
                    value = NBindingsConverter.ConvertPercentageValues(value, forField, this.parent);
                }
                else {
                    value = NBindingsConverter.ConvertPercentageValues(value, forField, this);
                }
            }
            // * Replace HDP and DP
            value = NBindingsConverter.ConvertAllDimensionValues(value);
            if (value.includes('center')) {
                let v = this.convertStringSizeValue('50%', forField, owner);
                let exValue = NUtils.GetSpriteRealSize(forField, this);
                exValue = v - (exValue / 2);
                value = value.replace('center', exValue.toString());
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes('height')) {
                let exValue = NUtils.GetSpriteRealSize('height', this);
                value = value.replace('height', exValue.toString());
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes('width')) {
                let exValue = NUtils.GetSpriteRealSize('width', this);
                value = value.replace('width', exValue.toString());
                return this.convertStringSizeValue(value, forField, owner);
            }
            let v = eval(value);
            return this.convertStringSizeValue(v, forField, owner);
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    getPreviousChildData(forField) {
        try {
            if (!this.parent)
                return 0;
            if (this.parent.children.length <= 1)
                return 0;
            let myIndex = this.parent.children.indexOf(this);
            let prevChild = this.parent.children[myIndex - 1];
            if (!prevChild)
                return 0;
            if (forField == "x") {
                return prevChild.x;
            }
            if (forField == "y") {
                return prevChild.y;
            }
            return NUtils.GetSpriteRealSize(forField, prevChild);
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    requireFunc(funcName, args) {
        try {
            if (!this._requiredFuncs) {
                this._requiredFuncs = [];
            }
            this._requiredFuncs.push([funcName, args]);
        }
        catch (error) {
            console.warn(error);
        }
    }
    executeRequiredFuncs() {
        var _a;
        try {
            if (!this._requiredFuncs) {
                return;
            }
            for (let i = 0; i < this._requiredFuncs.length; i++) {
                let funcName = this._requiredFuncs[i][0];
                let args = this._requiredFuncs[i][1];
                try {
                    (_a = this[funcName]) === null || _a === void 0 ? void 0 : _a.apply(this, args);
                }
                catch (error) {
                    console.warn(error);
                }
            }
            this._requiredFuncs = null;
        }
        catch (error) {
            console.warn(error);
        }
    }
    executeLoadListeners() {
        try {
            if (!this._loadListeners) {
                return;
            }
            for (let i = 0; i < this._loadListeners.length; i++) {
                try {
                    this._loadListeners[i]();
                }
                catch (error) {
                    console.warn(error);
                }
            }
            this._loadListeners = null;
        }
        catch (error) {
            console.warn(error);
        }
    }
    _addLoadListener(func) {
        try {
            if (!this._loadListeners) {
                this._loadListeners = [];
            }
            this._loadListeners.push(func);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateAnimationRules() {
        try {
            if (!this._animationRules) {
                return;
            }
            for (let i = 0; i < this._animationRules.length; i++) {
                this._animationRules[i].update();
                this._animationRules[i].applyAnimation(this);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshAnchoredCenter() {
        try {
            if (this._lastCenterBaseX != this.x || this._lastCenterBaseY != this.y) {
                this._lastCenterBaseX = this.x;
                this._lastCenterBaseY = this.y;
            }
            this._anchoredCenterX = this._lastCenterBaseX + (this.realWidth() / 2);
            this._anchoredCenterY = this._lastCenterBaseY + (this.realHeight() / 2);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshRelativeToCenterPosition() {
        try {
            if (this._anchoredCenterX != null) {
                this.x = this._anchoredCenterX - (this.realWidth() * this.scale.x / 2);
                this.y = this._anchoredCenterY - (this.realHeight() * this.scale.y / 2);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateScaleFactor() {
        try {
            if (this.scale.x != this._scaleFactor || this.scale.y != this._scaleFactor) {
                this.scale.set(this._scaleFactor);
                if (this.isShouldAlwaysKeepCentered()) {
                    this._refreshRelativeToCenterPosition();
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
}
// * NUI 1.2
// * rev 10.09.24
// * "type": "face"
class KNSprite_ActorFace extends KNSprite {
    /**
     * Creates an instance of Sprite_ActorFace.
     * @param settings The settings for the sprite.
     */
    constructor(settings) {
        super();
        this.settings = Object.assign({}, KNSprite_ActorFace.DefaultSettings(), settings);
        this._create();
        this.draw(this.settings.faceName, this.settings.faceIndex);
        this.flipX(this.settings.mirror);
    }
    /**
     * Checks if the sprite is loaded.
     * @returns True if the sprite is loaded, otherwise false.
     */
    isLoaded() {
        return true;
    }
    /**
     * Gets the default settings for the sprite.
     * @returns The default settings.
     */
    static DefaultSettings() {
        return {
            "faceName": "",
            "faceIndex": 0,
            "size": 144,
            "mirror": false
        };
    }
    /**
     * Gets the real width of the sprite.
     * @returns The real width.
     */
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.size;
    }
    /**
     * Gets the real height of the sprite.
     * @returns The real height.
     */
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.size;
    }
    /**
     * Gets the data bindings for the sprite.
     * @returns The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            // * For compatibility with old format
            size: (v) => this.setSize(v),
            faceSize: (v) => this.setSize(v),
            faceName: (v) => this.draw(v, this.settings.faceIndex),
            faceIndex: (v) => this.draw(this.settings.faceName, v),
            mirror: (v) => this.flipX(v)
        });
    }
    /**
     * Sets the size of the sprite.
     * @param size The size to set.
     */
    setSize(size = 144) {
        try {
            size = this.convertStringSizeValue(size, 'width', this);
            if (size != null)
                this.settings.size = size;
            this._onResize();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the face image.
     * @param faceName The name of the face image.
     * @param faceIndex The index of the face image.
     */
    draw(faceName = "", faceIndex = 0) {
        try {
            this.settings.faceName = faceName;
            this.settings.faceIndex = faceIndex;
            if (faceName === "") {
                this.image.bitmap.clear();
                return;
            }
            this._drawFaceImage(faceName);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Flips the sprite horizontally.
     * @param isMirror Whether to flip the sprite.
     */
    flipX(isMirror) {
        try {
            if (isMirror) {
                this.image.scale.x = -1;
                this.image.x = this.settings.size;
            }
            else {
                this.image.scale.x = 1;
                this.image.x = 0;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the sprite.
     */
    _create() {
        try {
            this.image = new KSprite(new Bitmap(1, 1));
            this.addChild(this.image);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the face image.
     * @param faceName The name of the face image.
     */
    _drawFaceImage(faceName) {
        try {
            this._srcBitmap = ImageManager.loadFace(faceName);
            this._srcBitmap.addLoadListener(this._onBitmapLoaded.bind(this));
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Called when the bitmap is loaded.
     */
    _onBitmapLoaded() {
        try {
            this._onResize();
            this.executeRequiredFuncs();
            this.executeLoadListeners();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Resizes the sprite.
     */
    _onResize() {
        try {
            this.image.bitmap = new Bitmap(this.realWidth(), this.realHeight());
            if (!this._srcBitmap)
                return;
            const b = this._srcBitmap;
            let fw, fh;
            if (KDX.isMZ()) {
                fw = ImageManager.faceWidth;
                fh = ImageManager.faceHeight;
            }
            else {
                /* @ts-ignore */
                fw = Window_Base._faceWidth;
                /* @ts-ignore */
                fh = Window_Base._faceHeight;
            }
            const size = this.settings.size;
            const sx = (this.settings.faceIndex % 4) * fw;
            const sy = Math.floor(this.settings.faceIndex / 4) * fh;
            this.image.bitmap.blt(b, sx, sy, fw, fh, 0, 0, size, size);
            this.setFrame(0, 0, size, size);
            this.flipX(this.settings.mirror);
        }
        catch (e) {
            console.warn(e);
        }
    }
}
// * NUI 1.0
// * rev 10.09.24
// * "type": "circle"
class KNSprite_BaseCircle extends KNSprite {
    constructor(settings) {
        super();
        this._settings = Object.assign({}, KNSprite_BaseCircle.DefaultSettings(), settings);
        this._create();
        this._applySettings();
    }
    // * DefaultSettings in JSON format (for easy copy-paste)
    /**
     * Returns the default settings for the base circle sprite.
     * @returns {BaseCircleSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "width": 100,
            "height": 100,
            "fillColor": "#FFFFFF",
            "fillAlpha": 1,
            "strokeWidth": 4,
            "strokeColor": "#000000",
            "strokeAlpha": 1
        };
    }
    /**
     * Gets the current settings of the base circle sprite.
     * @returns {BaseCircleSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Applies the current settings to the sprite.
     */
    refresh() {
        try {
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, stroke, and fill.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.settings.height); },
            height: (v) => { if (v)
                this.setSize(this.settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            stroke: (v) => { if (v)
                this.setStroke(v.color, v.width, v.alpha); },
            fill: (v) => { if (v)
                this.setFill(v.color, v.alpha); }
        });
    }
    /**
     * Sets the size of the base circle sprite.
     * @param {number | string} [width=100] - The width of the sprite.
     * @param {number | string} [height=100] - The height of the sprite.
     */
    setSize(width = 100, height = 100) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this.refresh();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Sets the stroke properties of the base circle sprite.
     * @param {string} [color="#FFFFFF"] - The stroke color.
     * @param {number} [width=0] - The stroke width.
     * @param {number} [alpha=1] - The stroke alpha.
     */
    setStroke(color = "#FFFFFF", width = 0, alpha = 1) {
        this._settings.strokeColor = color;
        this._settings.strokeWidth = width;
        this._settings.strokeAlpha = alpha;
        this.refresh();
    }
    /**
     * Sets the fill properties of the base circle sprite.
     * @param {string} [color="#FFFFFF"] - The fill color.
     * @param {number} [alpha=1] - The fill alpha.
     */
    setFill(color = "#FFFFFF", alpha = 1) {
        this._settings.fillColor = color;
        this._settings.fillAlpha = alpha;
        this.refresh();
    }
    /**
     * Creates the graphics object and adds it as a child.
     * @private
     */
    _create() {
        this._graphics = new PIXI.Graphics();
        this.addChild(this._graphics);
    }
    /**
     * Applies the current settings to the base circle sprite.
     * @private
     */
    _applySettings() {
        if (!this._settings)
            return;
        if (!this._graphics)
            return;
        this._graphics.clear();
        try {
            this._drawBaseCircle();
        }
        catch (error) {
            console.warn(error);
        }
        this._applySize();
    }
    /**
     * Draws the base circle with the current settings.
     * @private
     */
    _drawBaseCircle() {
        // * Fill circle
        this._graphics.beginFill(KColor.HexToColorNumber(this._settings.fillColor), this._settings.fillAlpha);
        this._graphics.drawEllipse(0, 0, this._settings.width / 2, this._settings.height / 2);
        this._graphics.endFill();
        if (this._settings.strokeWidth > 0) {
            // * Stroke circle
            this._graphics.lineStyle(this._settings.strokeWidth, KColor.HexToColorNumber(this._settings.strokeColor), this._settings.strokeAlpha);
            this._graphics.drawEllipse(0, 0, this._settings.width / 2, this._settings.height / 2);
        }
    }
    /**
     * Applies the size settings to the base circle sprite and its graphics object.
     * @private
     */
    _applySize() {
        this.width = this._settings.width;
        this.height = this._settings.height;
        // * Круг (элипс) рисуется от центра, что не удобно  при расчёте координат, поэтому сдвигаем в левый вверхний угол
        this._graphics.position.set(this._settings.width / 2, this._settings.height / 2);
    }
}
// * NUI 1.0
// * rev 09.09.24
// * "type": "rect"
class KNSprite_BaseRect extends KNSprite {
    constructor(settings) {
        super();
        this._settings = Object.assign({}, KNSprite_BaseRect.DefaultSettings(), settings);
        this._create();
        this._applySettings();
    }
    // * DefaultSettings in JSON format (for easy copy-paste)
    /**
     * Returns the default settings for the base rectangle sprite.
     * @returns {BaseRectSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "width": 100,
            "height": 100,
            "corners": 0,
            "fillGradient": null,
            "gradientStart": { "x": 0, "y": 0 },
            "gradientEnd": { "x": 0, "y": 100 },
            "fillColor": "#FFFFFF",
            "fillAlpha": 1,
            "strokeWidth": 4,
            "strokeColor": "#000000",
            "strokeAlpha": 1
        };
    }
    /**
     * Returns the default gradient settings.
     * @returns {Record<string, string>} The default gradient settings.
     */
    static DefaultGradientSettings() {
        return {
            "0": "#9ff",
            "1": "#033"
        };
    }
    /**
     * Returns the default corner settings.
     * @returns {RectCorners} The default corner settings.
     */
    static DefaultCornerSettings() {
        return {
            "topLeft": 0,
            "topRight": 0,
            "bottomRight": 0,
            "bottomLeft": 0
        };
    }
    /**
     * Gets the current settings of the base rectangle sprite.
     * @returns {BaseRectSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Checks if the sprite has a gradient fill.
     * @returns {boolean} True if the sprite has a gradient fill, otherwise false.
     */
    isHaveGradient() {
        return this._settings.fillGradient != null;
    }
    /**
     * Applies the current settings to the sprite.
     */
    refresh() {
        try {
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, stroke, fill, gradient start, and gradient end.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.settings.height); },
            height: (v) => { if (v)
                this.setSize(this.settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            stroke: (v) => { if (v)
                this.setStroke(v.color, v.width, v.alpha); },
            fill: (v) => { if (v)
                this.setFill(v.color, v.alpha); },
            gradientStart: (v) => { if (v)
                this.setGradientStartEnd(v, this.settings.gradientEnd); },
            gradientEnd: (v) => { if (v)
                this.setGradientStartEnd(this.settings.gradientStart, v); }
        });
    }
    /**
     * Sets the size of the base rectangle sprite.
     * @param {number | string} [width=100] - The width of the sprite.
     * @param {number | string} [height=100] - The height of the sprite.
     */
    setSize(width = 100, height = 100) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this.refresh();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Sets the stroke properties of the base rectangle sprite.
     * @param {string} [color="#FFFFFF"] - The stroke color.
     * @param {number} [width=0] - The stroke width.
     * @param {number} [alpha=1] - The stroke alpha.
     */
    setStroke(color = "#FFFFFF", width = 0, alpha = 1) {
        this._settings.strokeColor = color;
        this._settings.strokeWidth = width;
        this._settings.strokeAlpha = alpha;
        this.refresh();
    }
    /**
     * Sets the fill properties of the base rectangle sprite.
     * @param {string} [color="#FFFFFF"] - The fill color.
     * @param {number} [alpha=1] - The fill alpha.
     */
    setFill(color = "#FFFFFF", alpha = 1) {
        this._settings.fillColor = color;
        this._settings.fillAlpha = alpha;
        this._settings.fillGradient = null;
        this.refresh();
    }
    /**
     * Sets the gradient start and end points for the base rectangle sprite.
     * @param {{ x: number, y: number }} start - The start point of the gradient.
     * @param {{ x: number, y: number }} end - The end point of the gradient.
     */
    setGradientStartEnd(start, end) {
        try {
            if (start) {
                start.x = this.convertStringSizeValue(start.x, 'width', this);
                start.y = this.convertStringSizeValue(start.y, 'height', this);
            }
            if (end) {
                end.x = this.convertStringSizeValue(end.x, 'width', this);
                end.y = this.convertStringSizeValue(end.y, 'height', this);
            }
            this._settings.gradientStart = start;
            this._settings.gradientEnd = end;
            this.refresh();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Creates the graphics object and adds it as a child.
     * @private
     */
    _create() {
        this._graphics = new PIXI.Graphics();
        this.addChild(this._graphics);
    }
    /**
     * Applies the current settings to the base rectangle sprite.
     * @private
     */
    _applySettings() {
        if (!this._settings)
            return;
        if (!this._graphics)
            return;
        this._graphics.clear();
        try {
            this._applyGradient();
            this._drawCornerRect();
        }
        catch (error) {
            console.warn(error);
        }
        this._applySize();
    }
    /**
     * Applies the gradient fill to the base rectangle sprite.
     * @private
     */
    _applyGradient() {
        try {
            if (!this.isHaveGradient())
                return;
            if (KDX.isMV())
                return;
            let gradientFillSettings = Object.assign({}, KNSprite_BaseRect.DefaultGradientSettings(), this._settings.fillGradient);
            let canvas = document.createElement("canvas");
            let ctx = canvas.getContext("2d");
            let gradient = ctx.createLinearGradient(this._settings.gradientStart.x, this._settings.gradientStart.y, this._settings.gradientEnd.x, this._settings.gradientEnd.y);
            for (let key in gradientFillSettings) {
                let color = this._convertGradientStopColor(gradientFillSettings[key]);
                gradient.addColorStop(Number(key), color);
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, this._settings.width, this._settings.height);
            let texture = PIXI.Texture.from(canvas);
            this._graphics.beginTextureFill({ texture: texture });
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Converts a gradient stop color to a CSS color string.
     * @param {string} color - The color to convert.
     * @returns {string} The converted color.
     * @private
     */
    _convertGradientStopColor(color) {
        if (!KString.any(color))
            return "#000000";
        try {
            if (color.includes("%")) {
                let [hex, opacity] = color.split("%");
                return KColor.HexToCss(hex, parseFloat(opacity));
            }
            else {
                return color;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return "#000000";
    }
    /**
     * Draws the rectangle with rounded corners.
     * @private
     */
    _drawCornerRect() {
        try {
            if (typeof this._settings.corners == "number") {
                this._drawRoundRect(this._settings.corners);
            }
            else {
                let corners = Object.assign({}, KNSprite_BaseRect.DefaultCornerSettings(), this.settings.corners);
                this._drawAllCornersRect(corners);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws a rounded rectangle.
     * @param {number} radius - The radius of the corners.
     * @private
     */
    _drawRoundRect(radius) {
        if (!this.isHaveGradient()) {
            this._graphics.beginFill(KColor.HexToColorNumber(this._settings.fillColor), this._settings.fillAlpha);
        }
        this._graphics.drawRoundedRect(0, 0, this._settings.width, this._settings.height, radius);
        if (this._settings.strokeWidth > 0) {
            let strokeWidth = this._settings.strokeWidth;
            // * Draw Stroke Around the Rect
            this._graphics.lineStyle(this._settings.strokeWidth, KColor.HexToColorNumber(this._settings.strokeColor), this._settings.strokeAlpha);
            this._graphics.drawRoundedRect(-strokeWidth / 2, -strokeWidth / 2, this._settings.width + strokeWidth / 2, this._settings.height + strokeWidth / 2, radius);
        }
        if (!this.isHaveGradient()) {
            this._graphics.endFill();
        }
    }
    /**
     * Draws a rectangle with different corner radii.
     * @param {RectCorners} corners - The radii of the corners.
     * @private
     */
    _drawAllCornersRect(corners) {
        if (!this.isHaveGradient()) {
            this._graphics.beginFill(KColor.HexToColorNumber(this._settings.fillColor), this._settings.fillAlpha);
        }
        this._drawRoundedRectComplex(0, 0, this._settings.width, this._settings.height, corners.topLeft, corners.topRight, corners.bottomRight, corners.bottomLeft);
        if (this._settings.strokeWidth > 0) {
            let strokeWidth = this._settings.strokeWidth;
            // * Draw Stroke Around the Rect
            this._graphics.lineStyle(this._settings.strokeWidth, KColor.HexToColorNumber(this._settings.strokeColor), this._settings.strokeAlpha);
            this._drawRoundedRectComplex(-strokeWidth / 2, -strokeWidth / 2, this._settings.width + strokeWidth / 2, this._settings.height + strokeWidth / 2, corners.topLeft, corners.topRight, corners.bottomRight, corners.bottomLeft);
            // this._graphics.closePath();
        }
        if (!this.isHaveGradient()) {
            this._graphics.endFill();
        }
    }
    /**
     * Draws a complex rounded rectangle with different corner radii.
     * @param {number} x - The x-coordinate of the rectangle.
     * @param {number} y - The y-coordinate of the rectangle.
     * @param {number} width - The width of the rectangle.
     * @param {number} height - The height of the rectangle.
     * @param {number} radiusTL - The radius of the top-left corner.
     * @param {number} radiusTR - The radius of the top-right corner.
     * @param {number} radiusBR - The radius of the bottom-right corner.
     * @param {number} radiusBL - The radius of the bottom-left corner.
     * @private
     */
    _drawRoundedRectComplex(x, y, width, height, radiusTL, radiusTR, radiusBR, radiusBL) {
        this._graphics.moveTo(x + radiusTL, y);
        this._graphics.lineTo(x + width - radiusTR, y);
        if (radiusTR > 0)
            this._graphics.quadraticCurveTo(x + width, y, x + width, y + radiusTR);
        this._graphics.lineTo(x + width, y + height - radiusBR);
        if (radiusBR > 0)
            this._graphics.quadraticCurveTo(x + width, y + height, x + width - radiusBR, y + height);
        this._graphics.lineTo(x + radiusBL, y + height);
        if (radiusBL > 0)
            this._graphics.quadraticCurveTo(x, y + height, x, y + height - radiusBL);
        this._graphics.lineTo(x, y + radiusTL);
        if (radiusTL > 0)
            this._graphics.quadraticCurveTo(x, y, x + radiusTL, y);
    }
    /**
     * Applies the size settings to the base rectangle sprite and its graphics object.
     * @private
     */
    _applySize() {
        this.width = this._settings.width;
        this.height = this._settings.height;
    }
}
class KNSprite_Button extends KNSprite {
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._isForcePressed = false;
        this._settings = Object.assign(KNSprite_Button.DefaultSettings(), _settings);
        this._create();
        this._applySettings();
    }
    static DefaultSettings() {
        return {
            "imageName": "",
            "folderName": "pictures",
            "imageMargins": 20,
            "width": 160,
            "height": 60,
            "clickSe": "Cursor1",
            "desaturateWhenDisabled": false,
            "tint": "",
            "tintAlpha": 0.5,
            "overTint": "#FFFFDD",
            "overTintAlpha": 0.5,
            "activeTint": "#AAAAAA",
            "activeTintAlpha": 0.5,
            "disabledTint": "#AAAAAA",
            "disabledTintAlpha": 0.5,
            "keyboardKey": "",
            "keyboardHandled": true,
            "enabled": true,
        };
    }
    isCanHandleTouch() {
        return true;
    }
    isSupportKeyboardHandle() {
        return this._settings.keyboardHandled == true;
    }
    isClickEnabled() {
        return super.isClickEnabled() && this.opacity != 0;
    }
    onPress() {
        super.onPress();
        this._refreshTint();
    }
    onReleased() {
        super.onReleased();
        this._refreshTint();
    }
    onMouseEnter() {
        super.onMouseEnter();
        this._refreshTint();
    }
    onMouseExit() {
        super.onMouseExit();
        this._refreshTint();
    }
    onClick() {
        try {
            if (this.isDisabled())
                return;
            if (this.isClickEnabled()) {
                KAudio.PlaySE(this._settings.clickSe);
            }
            super.onClick();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Gets the current settings of the Button.
     * @returns {ButtonSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Returns an object with data bindings for width, height, and size.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.settings.height); },
            height: (v) => { if (v)
                this.setSize(this.settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            style: (v) => { if (KDX.any(v))
                this.setStyle(v); },
            enable: (v) => { if (KDX.any(v))
                this.setEnabledState(v); },
            handler: (v) => { this.addClickHandler(v); }
        });
    }
    setStyle(style) {
        this._settings = Object.assign(this._settings, style);
        this._applySettings();
    }
    /**
     * Sets the size of the sprite button.
     *
     * @param {number | string} [width=160] - The width of the button. Can be a number or a string.
     * @param {number | string} [height=60] - The height of the button. Can be a number or a string.
     *
     * @throws {Error} Will throw an error if the width or height cannot be converted.
     */
    setSize(width = 160, height = 60) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this._settings.width;
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this._settings.height;
    }
    update() {
        super.update();
        if (this.isClickEnabled()) {
            this._updateButtonKeyboardHandling();
        }
    }
    isEnabled() {
        return !this.isDisabled();
    }
    setEnabledState(enabled) {
        try {
            this._settings.enabled = enabled;
            if (enabled) {
                this._enable();
            }
            else {
                this._disable();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    addClickHandler(handler) {
        this._handleOkAction = handler;
    }
    // * Only visual
    simulateClickEffect() {
        this._isForcePressed = true;
        setTimeout(() => {
            try {
                this._isForcePressed = false;
                this._refreshTint();
            }
            catch (error) {
                console.warn(error);
            }
        }, 100);
        this._refreshTint();
    }
    enable() {
        this.setEnabledState(true);
    }
    disable() {
        this.setEnabledState(false);
    }
    _create() {
        this._buttonPlane = new KNSprite_Plane({
            "width": this._settings.width,
            "height": this._settings.height,
            "margins": this._settings.imageMargins,
            "imageName": this._settings.imageName,
            "folderName": this._settings.folderName,
        });
        this.addChild(this._buttonPlane);
    }
    _applySettings() {
        try {
            this._onResize();
            this._refreshTint();
            this._refreshState();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _onResize() {
        try {
            this.width = this._settings.width;
            this.height = this._settings.height;
            this._buttonPlane.setSize(this._settings.width, this._settings.height);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshTint() {
        try {
            if (this.isPressed() || this._isForcePressed) {
                this._applyTint(this._settings.activeTint, this._settings.activeTintAlpha);
            }
            else if (this.isHovered()) {
                this._applyTint(this._settings.overTint, this._settings.overTintAlpha);
            }
            else {
                this._applyTint(this._settings.tint, this._settings.tintAlpha);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _applyTint(color, alpha = 0.5) {
        try {
            if (!KString.any(color)) {
                this.removeEffect(KNSpriteEffects.Tint);
                return;
            }
            else {
                let tintColor = KColor.HexToColorNumber(color);
                this.addTintEffect({
                    "color": tintColor,
                    "alpha": alpha
                });
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshState() {
        try {
            this.setEnabledState(this._settings.enabled);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _enable() {
        this._isDisabled = false;
        try {
            if (this._settings.desaturateWhenDisabled) {
                this.removeEffect(KNSpriteEffects.Desaturate);
            }
            this._refreshTint();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _disable() {
        try {
            this._isDisabled = true;
            if (this._settings.desaturateWhenDisabled) {
                this.addDesaturateEffect();
            }
            else if (KString.any(this._settings.disabledTint)) {
                this._applyTint(this._settings.disabledTint, this._settings.disabledTintAlpha);
            }
            else {
                this._applyTint(this._settings.tint, this._settings.tintAlpha);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateButtonKeyboardHandling() {
        if (KString.any(this._settings.keyboardKey)) {
            if (Input.isTriggered(this._settings.keyboardKey)) {
                try {
                    Input.clear();
                    this.onClick();
                }
                catch (error) {
                    console.warn(error);
                }
            }
        }
    }
    _activateHandlerVisually() {
        try {
            if (this.isDisabled()) {
                super._activateHandlerVisually();
                return;
            }
            this._applyTint(this._settings.overTint, this._settings.overTintAlpha);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deactivateHandlerVisually() {
        try {
            if (this.isDisabled()) {
                super._deactivateHandlerVisually();
                return;
            }
            this._refreshTint();
        }
        catch (error) {
            console.warn(error);
        }
    }
}
// * NUI 1.1
// * rev 11.09.24
// * "type": "gauge"
class KNSprite_Gauge extends KNSprite {
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._settings = Object.assign({}, KNSprite_Gauge.DefaultSettings(), _settings);
        this._loaded = false;
        this._lastValue = 1;
        this._create();
        this._applySettings();
    }
    /**
     * Returns the default settings for the gauge sprite.
     * @returns {GaugeSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "fillMode": "color",
            "fillColor": "#ffffff",
            "fillOpacity": 255,
            "imageName": "",
            "folderName": "pictures",
            "margins": 2,
            "width": "auto",
            "height": "auto",
            "mask": "",
            "backColor": "#000000",
            "backImage": "",
            "backOpacity": 255,
            "vertical": false
        };
    }
    /**
     * Checks if the gauge sprite is loaded.
     * @returns {boolean} True if loaded, otherwise false.
     */
    isLoaded() {
        try {
            return this._loaded === true;
        }
        catch (e) {
            console.warn(e);
        }
        return false;
    }
    /**
     * Gets the real width of the gauge sprite.
     * @returns {number} The real width.
     */
    realWidth() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this._settings.width !== "auto") {
                return this._settings.width;
            }
            else if (this._gaugeSpr) {
                return this._gaugeSpr.realWidth();
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this.width;
    }
    /**
     * Gets the real height of the gauge sprite.
     * @returns {number} The real height.
     */
    realHeight() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this._settings.height !== "auto") {
                return this._settings.height;
            }
            else if (this._gaugeSpr) {
                return this._gaugeSpr.realHeight();
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this.height;
    }
    /**
     * Returns an object with data bindings for width, height, size, rate, fillImage, fillColor, and fillOpacity.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this._settings.height); },
            height: (v) => { if (v)
                this.setSize(this._settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            rate: (v) => { if (v)
                this.draw(v); },
            fillImage: (v) => { if (v)
                this.setFillImage(v); },
            fillColor: (v) => { if (v)
                this.setFillColor(v); },
            fillOpacity: (v) => { if (v)
                this.setFillOpacity(v); }
        });
    }
    /**
     * Draws the gauge with the specified percentage.
     * @param {number} [percent=1] - The percentage to draw.
     */
    draw(percent = 1) {
        try {
            if (!this.isLoaded()) {
                this.requireFunc('draw', arguments);
                return;
            }
            this._lastValue = percent;
            this._drawGauge(percent);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the fill opacity of the gauge.
     * @param {number} opacity - The fill opacity.
     */
    setFillOpacity(opacity) {
        try {
            this._settings.fillOpacity = opacity;
            if (this._fillLayer) {
                this._fillLayer.opacity = opacity;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the fill color of the gauge.
     * @param {string} color - The fill color.
     */
    setFillColor(color) {
        try {
            this._settings.fillColor = color;
            if (this._fillColorBitmap) {
                this._createColorGaugeFillColorBitmap();
                this._drawGauge(this._lastValue);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the fill image of the gauge.
     * @param {string} imageName - The name of the fill image.
     */
    setFillImage(imageName) {
        try {
            this._settings.imageName = imageName;
            this._applySettings();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the size of the gauge sprite.
     * @param {number | string} [width="auto"] - The width of the sprite.
     * @param {number | string} [height="auto"] - The height of the sprite.
     */
    setSize(width = "auto", height = "auto") {
        try {
            if (width !== "auto") {
                width = this.convertStringSizeValue(width, 'width', this);
            }
            if (height !== "auto") {
                height = this.convertStringSizeValue(height, 'height', this);
            }
            if (width)
                this._settings.width = width;
            if (height)
                this._settings.height = height;
            this._applySettings();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the base layer sprite.
     * @private
     */
    _create() {
        this._gaugeBaseLayer = new KSprite();
        this.addChild(this._gaugeBaseLayer);
    }
    /**
     * Applies the current settings to the gauge sprite.
     * @private
     */
    _applySettings() {
        try {
            this._loaded = false;
            this._destroyExistGauge();
            this._createGaugeFromSettings();
            this.draw(this._lastValue);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Destroys the existing gauge sprite.
     * @private
     */
    _destroyExistGauge() {
        try {
            if (!this._gaugeSpr)
                return;
            this._gaugeSpr.removeFromParent();
            this._gaugeSpr = null;
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the gauge sprite based on the current settings.
     * @private
     */
    _createGaugeFromSettings() {
        try {
            this._gaugeSpr = new KNSprite();
            this._gaugeBaseLayer.addChild(this._gaugeSpr);
            switch (this._settings.fillMode) {
                case "image":
                    this._createImageGauge();
                    break;
                case "plane":
                    this._createPlaneGauge();
                    break;
                case "color":
                    this._createColorGauge();
                    break;
                default:
                    console.warn("Unknown Gauge fillMode: " + this._settings.fillMode);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the image gauge.
     * @private
     */
    _createImageGauge() {
        try {
            this._gaugeSourceImage = new KNSprite_Image({
                imageName: this._settings.imageName,
                folderName: this._settings.folderName,
                width: this._settings.width,
                height: this._settings.height
            });
            this._gaugeSourceImage.addLoadListener(this._onGaugeFillImageLoaded.bind(this));
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Handles the event when the gauge fill image is loaded.
     * @private
     */
    _onGaugeFillImageLoaded() {
        try {
            let width = this._gaugeSourceImage.realWidth();
            let height = this._gaugeSourceImage.realHeight();
            this._addBackground(width, height);
            this._fillLayer = new KSprite(new Bitmap(width, height));
            this._fillLayer.opacity = this._settings.fillOpacity;
            this._gaugeSpr.addChild(this._fillLayer);
            this._addMask();
            this._onGaugeLoadedAndReady();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Handles the event when the gauge is loaded and ready.
     * @private
     */
    _onGaugeLoadedAndReady() {
        try {
            this._loaded = true;
            this.width = this.realWidth();
            this.height = this.realHeight();
            this.executeRequiredFuncs();
            this.executeLoadListeners();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the plane gauge.
     * @private
     */
    _createPlaneGauge() {
        try {
            // * Нельзя создать Plane Gauge с auto размером, поэтому задаём стандартные значения
            if (this._settings.width === "auto")
                this._settings.width = 80;
            if (this._settings.height === "auto")
                this._settings.height = 20;
            this._addBackground(this._settings.width, this._settings.height);
            this._fillLayer = new KNSprite_Plane({
                imageName: this._settings.imageName,
                folderName: this._settings.folderName,
                width: this._settings.width,
                height: this._settings.height,
                margins: this._settings.margins
            });
            this._fillLayer.opacity = this._settings.fillOpacity;
            this._gaugeSpr.addChild(this._fillLayer);
            this._addMask();
            this._onGaugeLoadedAndReady();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the color gauge.
     * @private
     */
    _createColorGauge() {
        try {
            // * Нельзя создать цветную Gauge с auto размером, поэтому задаём стандартные значения
            if (this._settings.width === "auto")
                this._settings.width = 80;
            if (this._settings.height === "auto")
                this._settings.height = 20;
            this._addBackground(this._settings.width, this._settings.height);
            this._fillLayer = new KSprite(new Bitmap(this._settings.width, this._settings.height));
            this._fillLayer.opacity = this._settings.fillOpacity;
            this._createColorGaugeFillColorBitmap();
            this._gaugeSpr.addChild(this._fillLayer);
            this._addMask();
            this._onGaugeLoadedAndReady();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the fill color bitmap for the color gauge.
     * @private
     */
    _createColorGaugeFillColorBitmap() {
        try {
            this._fillColorBitmap = new Bitmap(this._settings.width, this._settings.height);
            this._fillColorBitmap.fillAll(this._settings.fillColor);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Adds the background to the gauge sprite.
     * @param {number} width - The width of the background.
     * @param {number} height - The height of the background.
     * @private
     */
    _addBackground(width, height) {
        try {
            if (!this._gaugeSpr)
                return;
            let background = null;
            if (KString.any(this._settings.backImage)) {
                background = this._createGaugeBackgroundImage();
            }
            else if (KString.any(this._settings.backColor)) {
                background = this._createGaugeBackgroundColor(width, height, this._settings.backColor);
            }
            if (background) {
                if (this._settings.backOpacity) {
                    background.opacity = this._settings.backOpacity;
                }
                this._gaugeSpr.addChild(background);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Adds the mask to the gauge sprite.
     * @private
     */
    _addMask() {
        try {
            if (!this._gaugeSpr)
                return;
            if (!KString.any(this._settings.mask))
                return;
            const gaugeMask = new KNSprite_Image({
                imageName: this._settings.mask,
                folderName: this._settings.folderName,
                width: this._settings.width,
                height: this._settings.height
            });
            this._gaugeSpr.mask = gaugeMask.image;
            this._gaugeSpr.addChild(gaugeMask);
        }
        catch (e) {
            console.warn(e);
            this._gaugeSpr.mask = null;
        }
    }
    /**
     * Creates the background color for the gauge sprite.
     * @param {number} width - The width of the background.
     * @param {number} height - The height of the background.
     * @param {string} color - The color of the background.
     * @returns {KSprite} The background sprite.
     * @private
     */
    _createGaugeBackgroundColor(width, height, color) {
        try {
            const background = new KSprite(new Bitmap(width, height));
            background.fillAll(color);
            return background;
        }
        catch (e) {
            console.warn(e);
            return new KSprite();
        }
    }
    /**
     * Creates the background image for the gauge sprite.
     * @returns {KNSprite_Image} The background image sprite.
     * @private
     */
    _createGaugeBackgroundImage() {
        try {
            return new KNSprite_Image({
                imageName: this._settings.backImage,
                folderName: this._settings.folderName,
                width: this._settings.width,
                height: this._settings.height
            });
        }
        catch (e) {
            console.warn(e);
            return new KNSprite();
        }
    }
    /**
     * Draws the gauge with the specified percentage.
     * @param {number} percent - The percentage to draw.
     * @private
     */
    _drawGauge(percent) {
        try {
            if (!this._fillLayer)
                return;
            if (this._settings.vertical == true) {
                this._drawVertical(percent);
            }
            else {
                this._drawHorizontal(percent);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the horizontal gauge based on the fill mode and percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawHorizontal(percent) {
        try {
            switch (this._settings.fillMode) {
                case "image":
                    this._drawImageGauge(percent);
                    break;
                case "plane":
                    this._drawPlaneGauge(percent);
                    break;
                case "color":
                    this._drawColorGauge(percent);
                    break;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the image gauge with the specified percentage.
     * @param {number} percent - The percentage to draw.
     * @private
     */
    _drawImageGauge(percent) {
        try {
            this._fillLayer.bitmap.clear();
            const fillBitmap = this._gaugeSourceImage.image.bitmap;
            this._drawGaugeBitmapBased(percent, fillBitmap);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the gauge based on the specified bitmap and percentage.
     * @param {number} percent - The percentage to draw.
     * @param {Bitmap} fillBitmap - The bitmap to use for drawing.
     * @private
     */
    _drawGaugeBitmapBased(percent, fillBitmap) {
        try {
            const w = this.realWidth() * percent;
            const h = this.realHeight();
            this._fillLayer.bitmap.blt(fillBitmap, 0, 0, w, h, 0, 0);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the horizontal color gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawColorGauge(percent) {
        try {
            this._fillLayer.bitmap.clear();
            const fillBitmap = this._fillColorBitmap;
            this._drawGaugeBitmapBased(percent, fillBitmap);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the horizontal plane gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawPlaneGauge(percent) {
        try {
            const w = this.realWidth() * percent;
            const h = this.realHeight();
            if (this._fillLayer['setSize'])
                this._fillLayer['setSize'](w, h);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical gauge based on the fill mode and percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawVertical(percent) {
        try {
            switch (this._settings.fillMode) {
                case "image":
                    this._drawImageGaugeVertical(percent);
                    break;
                case "plane":
                    this._drawPlaneGaugeVertical(percent);
                    break;
                case "color":
                    this._drawColorGaugeVertical(percent);
                    break;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical image gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawImageGaugeVertical(percent) {
        try {
            this._fillLayer.bitmap.clear();
            const fillBitmap = this._gaugeSourceImage.image.bitmap;
            this._drawGaugeBitmapBasedVertical(percent, fillBitmap);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical gauge based on the bitmap and percentage.
     * @param {number} percent - The percentage to fill the gauge.
     * @param {Bitmap} fillBitmap - The bitmap to use for the gauge.
     */
    _drawGaugeBitmapBasedVertical(percent, fillBitmap) {
        try {
            const w = this.realWidth();
            const h = this.realHeight() * percent;
            this._fillLayer.bitmap.blt(fillBitmap, 0, 0, w, h, 0, 0);
            this._fillLayer.y = this.realHeight() - h;
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical color gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawColorGaugeVertical(percent) {
        try {
            this._fillLayer.bitmap.clear();
            const fillBitmap = this._fillColorBitmap;
            this._drawGaugeBitmapBasedVertical(percent, fillBitmap);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical plane gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawPlaneGaugeVertical(percent) {
        try {
            const w = this.realWidth();
            const h = this.realHeight() * percent;
            if (this._fillLayer['setSize'])
                this._fillLayer['setSize'](w, h);
            this._fillLayer.y = this.realHeight() - h;
        }
        catch (e) {
            console.warn(e);
        }
    }
}
//NUI 1.0
//rev 11.09.24
//"type": "group"
class KNSprite_Group extends KNSprite {
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._isNeedWaitLoadingChild = false;
        this._settings = Object.assign({}, KNSprite_Group.DefaultSettings(), _settings);
        if (this._settings.horizontalNavigation === true) {
            this.isVerticalKeyboardNavigation = () => false;
        }
        if (this._settings.freeNavigation === true) {
            this.isFreeKeyboardNavigation = () => true;
        }
        this._applySettings();
        this._onResize();
    }
    /**
     * Gets the current settings of the image sprite.
     * @returns {GroupSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Returns the default settings for the sprite group.
     * @returns {GroupSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "keyboardHandling": false,
            "horizontalNavigation": false,
            "freeNavigation": false,
            "width": "auto",
            "height": "auto"
        };
    }
    /**
     * Returns an object with data bindings for width, height, and size.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this._settings.height); },
            height: (v) => { if (v)
                this.setSize(this._settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); }
        });
    }
    /**
     * Updates the sprite group.
     */
    update() {
        super.update();
        try {
            if (this._isNeedWaitLoadingChild === true) {
                this.refreshBindings(this._dataObjectRef, true);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Refreshes the bindings for the sprite group.
     * @param {object} dataObject - The data object to bind.
     * @param {boolean} recursive - Whether to refresh bindings recursively.
     */
    refreshBindings(dataObject, recursive) {
        super.refreshBindings(dataObject, recursive);
        for (const c of this.children) {
            if (c instanceof KNSprite) {
                if (!c.isLoaded()) {
                    this._startWaitLoading(dataObject);
                    return;
                }
            }
        }
        this._isNeedWaitLoadingChild = false;
    }
    /**
     * Starts waiting for a child to load.
     * @param {object} dataObjectRef - The data object reference.
     */
    _startWaitLoading(dataObjectRef) {
        try {
            this._dataObjectRef = dataObjectRef;
            this._isNeedWaitLoadingChild = true;
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the size of the sprite group.
     * @param {number | string} [width="auto"] - The width of the sprite group.
     * @param {number | string} [height="auto"] - The height of the sprite group.
     */
    setSize(width = 'auto', height = 'auto') {
        try {
            if (width !== "auto") {
                width = this.convertStringSizeValue(width, 'width', this);
            }
            if (height !== "auto") {
                height = this.convertStringSizeValue(height, 'height', this);
            }
            if (width != null)
                this._settings.width = width;
            if (height != null)
                this._settings.height = height;
            this._onResize();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Gets the real width of the sprite group.
     * @returns {number} The real width.
     */
    realWidth() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this._settings.width === "auto") {
                return this._calculateMax("x", "width");
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this._settings.width;
    }
    /**
     * Gets the real height of the sprite group.
     * @returns {number} The real height.
     */
    realHeight() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this._settings.height === "auto") {
                return this._calculateMax("y", "height");
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this._settings.height;
    }
    /**
     * Calculates the maximum size of the sprite group.
     * @param {'x' | 'y'} axis - The axis to calculate.
     * @param {string} b - The size property to calculate.
     * @returns {number} The maximum size.
     */
    _calculateMax(axis, b) {
        let value = 0;
        try {
            for (const child of this.children) {
                const size = child[axis] + NUtils.GetSpriteRealSize(b, child);
                if (size > value)
                    value = size;
            }
            if (value < 0)
                value = 0;
        }
        catch (e) {
            console.warn(e);
            return 0;
        }
        return value;
    }
    /**
     * Applies the current settings to the sprite group.
     * @private
     */
    _applySettings() {
        try {
            if (this._settings.keyboardHandling === true) {
                this.activateHandlerManagment();
            }
            else {
                this.deactivateHandlerManagment();
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Resizes the sprite group based on its real width and height.
     * @private
     */
    _onResize() {
        try {
            this.width = this.realWidth();
            this.height = this.realHeight();
        }
        catch (e) {
            console.warn(e);
        }
    }
}
// * NUI 1.0
// * rev 07.10.24
// * "type": "image"
/**
 * Represents an image sprite used in the NUI system.
 * @class
 * @extends KNSprite
 */
class KNSprite_Image extends KNSprite {
    /**
     * Constructs a new instance of the NUI_Sprite_Image class.
     * @param _settings - The optional settings for the image sprite.
     */
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._isLoaded = false;
        this._settings = Object.assign({}, KNSprite_Image.DefaultSettings(), _settings);
        this._create();
        this._onResize();
        this.draw(this._settings.imageName);
    }
    // * DefaultSettings in JSON format (for easy copy-paste)
    /**
     * Returns the default settings for the image sprite.
     * @returns {ImageSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "width": "auto",
            "height": "auto",
            "imageName": "",
            "folderName": "pictures",
            "keepAspect": false,
            "useAspectSize": false
        };
    }
    /**
     * Gets the current settings of the image sprite.
     * @returns {ImageSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Gets the image sprite.
     * @returns {KSprite} The image sprite.
     */
    get image() {
        return this._image;
    }
    /**
     * Checks if the image sprite is loaded.
     * @returns {boolean} True if loaded, otherwise false.
     */
    isLoaded() {
        try {
            /*if(this.settings.width != 'auto' && this.settings.height != 'auto') {
                return true;
            }*/
            return this._isLoaded == true;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    /**
     * Gets the real width of the image sprite.
     * @returns {number} The real width.
     */
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        if (this.settings.useAspectSize == true && this._aspectWidth) {
            return this._aspectWidth;
        }
        if (this.settings.width == 'auto') {
            if (this._srcBitmap) {
                return this._srcBitmap.width;
            }
            else {
                if (this._image.bitmap && this._image.bitmap.isReady()) {
                    return this._image.bitmap.width;
                }
            }
        }
        else {
            return this.settings.width;
        }
        return this.width;
    }
    /**
     * Gets the real height of the image sprite.
     * @returns {number} The real height.
     */
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        if (this.settings.useAspectSize == true && this._aspectHeight) {
            return this._aspectHeight;
        }
        if (this.settings.height == 'auto') {
            if (this._srcBitmap) {
                return this._srcBitmap.height;
            }
            else {
                if (this._image.bitmap && this._image.bitmap.isReady()) {
                    return this._image.bitmap.height;
                }
            }
        }
        else {
            return this.settings.height;
        }
        return this.height;
    }
    /**
     * Sets the image for the sprite.
     * @param {string} imageName - The name of the image.
     * @param {string} [folderName] - The name of the folder containing the image.
     */
    setImage(imageName, folderName) {
        if (KString.any(folderName)) {
            this._settings.folderName = folderName;
        }
        this.draw(imageName);
    }
    isHoveredByCursor() {
        if (this.image) {
            return this.image.isHoveredByCursor();
        }
        else {
            return super.isHoveredByCursor();
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, image, and icon.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.settings.height); },
            height: (v) => { if (v)
                this.setSize(this.settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            image: (v) => { this.draw(v); },
            icon: (v) => { this.drawIcon(v); }
        });
    }
    /**
     * Sets the size of the image sprite.
     * @param {number | string} [width='auto'] - The width of the sprite.
     * @param {number | string} [height='auto'] - The height of the sprite.
     */
    setSize(width = 'auto', height = 'auto') {
        try {
            if (width != 'auto')
                width = this.convertStringSizeValue(width, 'width', this);
            if (height != 'auto')
                height = this.convertStringSizeValue(height, 'height', this);
            if (width != null)
                this._settings.width = width;
            if (height != null)
                this._settings.height = height;
            this._onResize();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws an icon on the sprite.
     * @param {number} iconIndex - The index of the icon.
     */
    drawIcon(iconIndex) {
        try {
            if (typeof (iconIndex) == 'number') {
                this.draw(iconIndex);
            }
            else {
                this.draw("");
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws an image or icon on the sprite.
     * @param {string | number} [imageName=""] - The name of the image or the index of the icon.
     */
    draw(imageName = "") {
        if (typeof (imageName) == 'string' && KString.any(imageName)) {
            this._drawImage(imageName);
            return;
        }
        if (typeof (imageName) == 'number' && imageName >= 0) {
            this._drawIcon(imageName);
            return;
        }
        this._srcBitmap = null;
        this._onResize();
    }
    /**
     * Draws an icon on the sprite.
     * @param {number} iconIndex - The index of the icon.
     * @private
     */
    _drawIcon(iconIndex) {
        try {
            let size = this.settings.width == 'auto' ? 32 : this.settings.width;
            this.settings.height = size;
            this._srcBitmap = new Bitmap(size, size);
            KBitmap.DrawIcon(this._srcBitmap, iconIndex, 0, 0, size);
            this._isLoaded = true;
            this._onResize();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws an image on the sprite.
     * @param {string} imageName - The name of the image.
     * @private
     */
    _drawImage(imageName) {
        this._isLoaded = false;
        this._srcBitmap = ImageManager.loadBitmap('img/' + this.settings.folderName + '/', imageName, 0, false);
        this._srcBitmap.addLoadListener(() => {
            this._isLoaded = true;
            this._onResize();
            this.executeRequiredFuncs();
            this.executeLoadListeners();
        });
    }
    /**
     * Creates the image sprite and adds it as a child.
     * @private
     */
    _create() {
        this._image = new KSprite(new Bitmap(1, 1));
        this._image.isNeedCheckAlphaPixels = () => true;
        this.addChild(this._image);
    }
    /**
     * Resizes the image sprite.
     * @private
     */
    _onResize() {
        try {
            this._aspectWidth = null;
            this._aspectHeight = null;
            this._image.bitmap = new Bitmap(this.realWidth(), this.realHeight());
            if (!this._srcBitmap)
                return;
            let fw = this.realWidth();
            let fh = this.realHeight();
            if (this.settings.keepAspect) {
                let aspect = this._calculateAspect(this._image.bitmap.width, this._image.bitmap.height, this._srcBitmap.width, this._srcBitmap.height);
                fw = aspect.width;
                fh = aspect.height;
                if (fh < this._image.bitmap.height) {
                    this._aspectHeight = fh;
                }
                else {
                    this._aspectHeight = this._image.bitmap.height;
                }
                if (fw < this._image.bitmap.width) {
                    this._aspectWidth = fw;
                }
                else {
                    this._aspectWidth = this._image.bitmap.width;
                }
            }
            this._image.bitmap.blt(this._srcBitmap, 0, 0, this._srcBitmap.width, this._srcBitmap.height, 0, 0, fw, fh);
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Calculates the aspect ratio for resizing.
     * @param {number} containerWidth - The width of the container.
     * @param {number} containerHeight - The height of the container.
     * @param {number} width - The width of the image.
     * @param {number} height - The height of the image.
     * @returns {{ width: number, height: number }} The calculated width and height.
     * @private
     */
    _calculateAspect(containerWidth, containerHeight, width, height) {
        let aspect = width / height;
        let containerAspectRatio = containerWidth / containerHeight;
        if (aspect > containerAspectRatio) {
            width = containerWidth;
            height = width / aspect;
        }
        else {
            height = containerHeight;
            width = height * aspect;
        }
        return { width, height };
    }
}
class KNSprite_ImageButton extends KNSprite {
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._isSimulation = false;
        this._settings = Object.assign(KNSprite_ImageButton.DefaultSettings(), _settings);
        this._create();
        this._applySettings();
    }
    static DefaultSettings() {
        return {
            "folderName": "pictures",
            "imageName": "",
            "hoverImageName": "",
            "pressedImageName": "",
            "disabledImageName": "",
            "isCheckAlpha": false,
            "width": 160,
            "height": 60,
            "clickSe": "Cursor1",
            "desaturateWhenDisabled": false,
            "tint": "",
            "tintAlpha": 0.5,
            "overTint": "",
            "overTintAlpha": 0.5,
            "activeTint": "",
            "activeTintAlpha": 0.5,
            "disabledTint": "",
            "disabledTintAlpha": 0.5,
            "keyboardKey": "",
            "keyboardHandled": true,
            "enabled": true,
        };
    }
    isCanHandleTouch() {
        return true;
    }
    isSupportKeyboardHandle() {
        return this._settings.keyboardHandled == true;
    }
    isClickEnabled() {
        return super.isClickEnabled() && this.opacity != 0;
    }
    onPress() {
        super.onPress();
        this._refreshVisualState();
    }
    onReleased() {
        super.onReleased();
        this._refreshVisualState();
    }
    onMouseEnter() {
        super.onMouseEnter();
        this._refreshVisualState();
    }
    onMouseExit() {
        super.onMouseExit();
        this._refreshVisualState();
    }
    isHoveredByCursor() {
        if (this._buttonImage && this._buttonImage.visible && this._buttonImage.isHoveredByCursor()) {
            return true;
        }
        if (this._hoveredImage && this._hoveredImage.visible && this._hoveredImage.isHoveredByCursor()) {
            return true;
        }
        if (this._pressedImage && this._pressedImage.visible && this._pressedImage.isHoveredByCursor()) {
            return true;
        }
        if (this._disabledImage && this._disabledImage.visible && this._disabledImage.isHoveredByCursor()) {
            return true;
        }
        return false;
    }
    onClick() {
        try {
            if (this.isDisabled())
                return;
            if (this.isClickEnabled()) {
                KAudio.PlaySE(this._settings.clickSe);
            }
            super.onClick();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Gets the current settings of the Button.
     * @returns {ImageButtonSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Returns an object with data bindings for width, height, and size.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.settings.height); },
            height: (v) => { if (v)
                this.setSize(this.settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            style: (v) => { if (KDX.any(v))
                this.setStyle(v); },
            enable: (v) => { if (KDX.any(v))
                this.setEnabledState(v); },
            handler: (v) => { this.addClickHandler(v); },
            image: (v) => { if (KDX.any(v))
                this.setImage(v); },
            // * Не используются, т.к. этих кнопок может не быть созданно, будет путанница
            //hoveredImage: (v: string) => {  if(KDX.any(v)) this.setHoveredImage(v) },
            //pressedImage: (v: string) => {  if(KDX.any(v)) this.setPressedImage(v) },
            //disabledImage: (v: string) => {  if(KDX.any(v)) this.setDisabledImage(v) }
        });
    }
    setStyle(style) {
        this._settings = Object.assign(this._settings, style);
        this._applySettings();
    }
    setImage(imageName) {
        var _a;
        try {
            this._settings.imageName = imageName;
            (_a = this._buttonImage) === null || _a === void 0 ? void 0 : _a.setImage(imageName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setHoveredImage(imageName) {
        var _a;
        try {
            this._settings.hoverImageName = imageName;
            (_a = this._hoveredImage) === null || _a === void 0 ? void 0 : _a.setImage(imageName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setPressedImage(imageName) {
        var _a;
        try {
            this._settings.pressedImageName = imageName;
            (_a = this._pressedImage) === null || _a === void 0 ? void 0 : _a.setImage(imageName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setDisabledImage(imageName) {
        var _a;
        try {
            this._settings.disabledImageName = imageName;
            (_a = this._disabledImage) === null || _a === void 0 ? void 0 : _a.setImage(imageName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Sets the size of the sprite button.
     *
     * @param {number | string} [width=160] - The width of the button. Can be a number or a string.
     * @param {number | string} [height=60] - The height of the button. Can be a number or a string.
     *
     * @throws {Error} Will throw an error if the width or height cannot be converted.
     */
    setSize(width = 160, height = 60) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this._settings.width;
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this._settings.height;
    }
    update() {
        super.update();
        if (this.isClickEnabled()) {
            this._updateButtonKeyboardHandling();
        }
    }
    isEnabled() {
        return !this.isDisabled();
    }
    setEnabledState(enabled) {
        try {
            this._settings.enabled = enabled;
            if (enabled) {
                this._enable();
            }
            else {
                this._disable();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    addClickHandler(handler) {
        this._handleOkAction = handler;
    }
    // * Only visual
    simulateClickEffect() {
        this._isSimulation = true;
        setTimeout(() => {
            try {
                this._isSimulation = false;
                this._refreshVisualState();
            }
            catch (error) {
                console.warn(error);
            }
        }, 100);
        this._refreshVisualState();
    }
    enable() {
        this.setEnabledState(true);
    }
    disable() {
        this.setEnabledState(false);
    }
    _create() {
        if (this._settings.isPlane) {
            this._buttonImage = new KNSprite_Plane({
                "folderName": this._settings.folderName,
                "imageName": this._settings.imageName,
                "width": this._settings.width,
                "height": this._settings.height,
                "margins": this._settings.margins,
            });
        }
        else {
            this._buttonImage = new KNSprite_Image({
                "folderName": this._settings.folderName,
                "imageName": this._settings.imageName,
                "width": this._settings.width,
                "height": this._settings.height,
            });
        }
        this.addChild(this._buttonImage);
        if (KString.any(this._settings.hoverImageName)) {
            if (this._settings.isPlane) {
                this._hoveredImage = new KNSprite_Plane({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.hoverImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                    "margins": this._settings.margins,
                });
            }
            else {
                this._hoveredImage = new KNSprite_Image({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.hoverImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                });
            }
            this.addChild(this._hoveredImage);
        }
        if (KString.any(this._settings.pressedImageName)) {
            if (this._settings.isPlane) {
                this._pressedImage = new KNSprite_Plane({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.pressedImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                    "margins": this._settings.margins,
                });
            }
            else {
                this._pressedImage = new KNSprite_Image({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.pressedImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                });
            }
            this.addChild(this._pressedImage);
        }
        if (KString.any(this._settings.disabledImageName)) {
            if (this._settings.isPlane) {
                this._disabledImage = new KNSprite_Plane({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.disabledImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                    "margins": this._settings.margins,
                });
            }
            else {
                this._disabledImage = new KNSprite_Image({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.disabledImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                });
            }
            this.addChild(this._disabledImage);
        }
        if (this._settings.isCheckAlpha == true) {
            this._buttonImage.isNeedCheckAlphaPixels = () => true;
            if (this._hoveredImage)
                this._hoveredImage.isNeedCheckAlphaPixels = () => true;
            if (this._pressedImage)
                this._pressedImage.isNeedCheckAlphaPixels = () => true;
            if (this._disabledImage)
                this._disabledImage.isNeedCheckAlphaPixels = () => true;
        }
    }
    _applySettings() {
        try {
            this._onResize();
            this._refreshVisualState();
            this._refreshState();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _onResize() {
        try {
            this.width = this._settings.width;
            this.height = this._settings.height;
            if (this._buttonImage) {
                this._buttonImage.setSize(this._settings.width, this._settings.height);
            }
            if (this._hoveredImage) {
                this._hoveredImage.setSize(this._settings.width, this._settings.height);
            }
            if (this._pressedImage) {
                this._pressedImage.setSize(this._settings.width, this._settings.height);
            }
            if (this._disabledImage) {
                this._disabledImage.setSize(this._settings.width, this._settings.height);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshVisualState() {
        try {
            this._refreshImage();
            this._refreshTint();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshImage() {
        if (this._isSimulation == true) {
            if (this._pressedImage) {
                this._showPressedImage();
            }
            else {
                this._showHoveredImage();
            }
            return;
        }
        if (this.isPressed()) {
            this._showPressedImage();
        }
        else if (this.isHovered()) {
            this._showHoveredImage();
        }
        else {
            this._hideAllButtonImages();
            this._buttonImage.visible = true;
        }
    }
    _hideAllButtonImages() {
        if (this._buttonImage) {
            this._buttonImage.visible = false;
        }
        if (this._hoveredImage) {
            this._hoveredImage.visible = false;
        }
        if (this._pressedImage) {
            this._pressedImage.visible = false;
        }
        if (this._disabledImage) {
            this._disabledImage.visible = false;
        }
    }
    _showHoveredImage() {
        this._hideAllButtonImages();
        if (this._hoveredImage) {
            this._hoveredImage.visible = true;
        }
        else {
            this._buttonImage.visible = true;
        }
    }
    _showPressedImage() {
        this._hideAllButtonImages();
        if (this._pressedImage) {
            this._pressedImage.visible = true;
        }
        else {
            this._buttonImage.visible = true;
        }
    }
    _showDisabledImage() {
        this._hideAllButtonImages();
        if (this._disabledImage) {
            this._disabledImage.visible = true;
        }
        else {
            this._buttonImage.visible = true;
        }
    }
    _refreshTint() {
        if (this.isPressed() || this._isSimulation) {
            this._applyTint(this._settings.activeTint, this._settings.activeTintAlpha);
        }
        else if (this.isHovered()) {
            this._applyTint(this._settings.overTint, this._settings.overTintAlpha);
        }
        else {
            this._applyTint(this._settings.tint, this._settings.tintAlpha);
        }
    }
    _applyTint(color, alpha = 0.5) {
        try {
            if (!KString.any(color)) {
                this.removeEffect(KNSpriteEffects.Tint);
                return;
            }
            else {
                let tintColor = KColor.HexToColorNumber(color);
                this.addTintEffect({
                    "color": tintColor,
                    "alpha": alpha
                });
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshState() {
        try {
            this.setEnabledState(this._settings.enabled);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _enable() {
        this._isDisabled = false;
        try {
            if (this._settings.desaturateWhenDisabled) {
                this.removeEffect(KNSpriteEffects.Desaturate);
            }
            this._refreshVisualState();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _disable() {
        try {
            this._isDisabled = true;
            this._showDisabledImage();
            if (this._settings.desaturateWhenDisabled) {
                this.addDesaturateEffect();
            }
            else if (KString.any(this._settings.disabledTint)) {
                this._applyTint(this._settings.disabledTint, this._settings.disabledTintAlpha);
            }
            else {
                this._applyTint(this._settings.tint, this._settings.tintAlpha);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateButtonKeyboardHandling() {
        if (KString.any(this._settings.keyboardKey)) {
            if (Input.isTriggered(this._settings.keyboardKey)) {
                try {
                    Input.clear();
                    this.onClick();
                }
                catch (error) {
                    console.warn(error);
                }
            }
        }
    }
    _activateHandlerVisually() {
        try {
            if (this.isDisabled()) {
                super._activateHandlerVisually();
                return;
            }
            this._applyTint(this._settings.overTint, this._settings.overTintAlpha);
            this._showHoveredImage();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deactivateHandlerVisually() {
        try {
            if (this.isDisabled()) {
                super._deactivateHandlerVisually();
                return;
            }
            this._refreshVisualState();
        }
        catch (error) {
            console.warn(error);
        }
    }
}
//NUI 1.0
//rev 10.10.24
//type: "list"
class KNSprite_ItemsList extends KNSprite {
    constructor(settings = {}) {
        super();
        this._settings = Object.assign(KSelectableItemsList.DefaultSettings(), settings);
        this._applySettings();
    }
    get settings() {
        return this._settings;
    }
    get list() {
        return this._list;
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.width;
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.height;
    }
    /**
     * Returns an object with data bindings for width, height, size, text, and style settings.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.realHeight()); },
            height: (v) => { if (v)
                this.setSize(this.realWidth(), v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            maxCols: (v) => { if (v)
                this.setMaxCols(v); }
        });
    }
    setSize(width, height) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            this.settings.width = _width;
            this.settings.height = _height;
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    setMaxCols(value) {
        try {
            this.settings.maxCols = value;
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _applySettings() {
        let storedListData = this._destroyList();
        /*@ts-ignore*/
        this._list = new KSelectableItemsList(0, 0, this.settings);
        /*@ts-ignore*/
        this.addChild(this._list);
        this._restoreData(storedListData);
    }
    _destroyList() {
        if (!this.list)
            return null;
        let storedData = {
            listItems: this.list.getAllItems(),
            activeState: this.list.isOpenAndActive(),
            selectedIdx: this.list.index(),
            /*@ts-ignore*/
            handlers: this.list._handlers
        };
        /*@ts-ignore*/
        this.removeChild(this.list);
        this._list = null;
        return storedData;
    }
    _restoreData(data) {
        if (!data)
            return;
        if (!this.list)
            return;
        this._list.setItems(data.listItems);
        if (data.activeState) {
            this._list.activate(data.selectedIdx);
        }
        for (let key in data.handlers) {
            this._list.setHandler(key, data.handlers[key]);
        }
    }
}
//Класс который позволяет сделать список (на основе Window_Selectable), но из Sprite элементов, а не Draw на Bitmap
class KSelectableItemsList extends Window_Selectable {
    constructor(x = 0, y = 0, settings = {}) {
        let _settings = Object.assign(KSelectableItemsList.DefaultSettings(), settings);
        if (KDX.isMV()) {
            /*@ts-ignore*/
            super(x, y, _settings.width, _settings.height);
        }
        else {
            super(new Rectangle(x, y, _settings.width, _settings.height));
        }
        this._settings = _settings;
        this._itemsSet = [];
        this._lastSelectedIndexForCallback = -1;
        this._prevSelectedIndex = -1;
        this._createItemsContainer();
        this._createWindowContentMask();
        this.setBackgroundType(this._settings.backgroundType);
    }
    get settings() {
        return this._settings;
    }
    get padding() {
        if (this.settings) {
            return this.settings.itemsPadding;
        }
        else {
            return 12;
        }
    }
    get width() {
        if (this.settings) {
            return this.settings.width;
        }
        else {
            return 240;
        }
    }
    get height() {
        if (this.settings) {
            return this.settings.height;
        }
        else {
            return 420;
        }
    }
    static DefaultSettings() {
        return {
            "width": 240,
            "height": 420,
            "maxCols": 1,
            "isHaveSelectionEffect": false,
            "selectionEffects": ["glow;distance:12;outerStrength:3"],
            "scaleItemsWidth": false,
            "scaleItemsHeight": false,
            "isDrawDefaultItemBack": false,
            "defaultItemHeight": 0,
            "backgroundType": 2,
            "itemsPadding": 12,
            "isHaveInOutAnimation": false,
            "isHorizontal": false,
            "inAnimation": "field:x;duration:0.15;keyframes:0=0,100=4",
            "outAnimation": "field:x;duration:0.15;keyframes:0=4,100=0",
            "isPlayOkSound": true,
            "isPlayCursorSound": true
        };
    }
    isHoveredByCursor() {
        return this.getAllItems().some((item) => item.isHoveredByCursor());
    }
    setSelectionHandler(callback) {
        this.setHandler('onSelectionChanged', callback);
    }
    setOkHandler(callback) {
        this.setHandler('ok', callback);
    }
    setCancelHandler(callback) {
        this.setHandler('cancel', callback);
    }
    getAllItems() {
        return this._itemsSet || [];
    }
    maxCols() {
        if (!this.settings)
            return 1;
        if (this.settings.isHorizontal) {
            return this.maxItems();
        }
        return this.settings.maxCols;
    }
    maxItems() {
        return this.getAllItems().length;
    }
    clear() {
        this.setItems([]);
    }
    selectedItem() {
        return this._itemsSet[this.index()];
    }
    itemAt(index) {
        return this._itemsSet[index];
    }
    lineHeight() {
        try {
            if (!this.settings)
                return 36; // * For super class
            if (this.settings.defaultItemHeight && this.settings.defaultItemHeight > 0) {
                return this.settings.defaultItemHeight;
            }
            if (this.maxItems() > 0) {
                return this.itemAt(0).realHeight();
            }
        }
        catch (error) {
            console.warn(error);
        }
        return 36;
    }
    activate(index) {
        try {
            if (index !== undefined) {
                this.refresh();
                this.safeSelect(index);
            }
        }
        catch (error) {
            console.warn(error);
        }
        super.activate();
    }
    select(index) {
        super.select(index);
        if (this._lastSelectedIndexForCallback !== index) {
            try {
                this.callHandler('onSelectionChanged');
            }
            catch (error) {
                console.warn(error);
            }
            this._lastSelectedIndexForCallback = index;
        }
    }
    safeSelect(index) {
        try {
            if (this.maxItems() > index) {
                this.select(index);
            }
            else {
                if (this.maxItems() > 0) {
                    this.select(0);
                }
                else {
                    this.select(-1);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    setItems(items) {
        try {
            this._prevSelectedIndex = -1;
            this._itemsSet = items;
            this._itemsContainer.removeChildren();
            this.setTopRow(0);
            this.refresh();
            items.forEach((item, index) => this._addNewItemToList(item, index));
        }
        catch (error) {
            console.warn(error);
            this.setItems([]);
        }
    }
    isCursorVisible() {
        if (KDX.isMV()) {
            return super.isCursorVisible();
        }
        else {
            /*@ts-ignore*/
            return this.cursorVisible;
        }
    }
    playOkSound() {
        if (this.settings.isPlayOkSound == true) {
            super.playOkSound();
        }
    }
    playCursorSound() {
        if (this.settings.isPlayCursorSound == true) {
            super.playCursorSound();
        }
    }
    clearActivatedStateForItems() {
        try {
            this.getAllItems().forEach((item) => item === null || item === void 0 ? void 0 : item.setActivatedInListState(false));
        }
        catch (error) {
            console.warn(error);
        }
    }
    setActiveStateForItem(item, value) {
        try {
            this.clearActivatedStateForItems();
            item === null || item === void 0 ? void 0 : item.setActivatedInListState(value);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setActiveStateForCurrentItem(value = true) {
        this.setActiveStateForItem(this.selectedItem(), value);
    }
    setActiveStateForItemAt(index, value = true) {
        this.setActiveStateForItem(this.itemAt(index), value);
    }
    processTouch() {
        if (KDX.isMV()) {
            if (this.isOpenAndActive()) {
                if (!TouchInput.isPressed() && this.isTouchedInsideFrame()) {
                    this.onTouch(false);
                }
            }
            super.processTouch();
        }
        else {
            super.processTouch();
        }
    }
    update() {
        super.update();
        /*@ts-ignore*/
        this._itemsContainer.y = -this._scrollY;
        this._updateItemsSelectionState();
    }
    _createItemsContainer() {
        this._windowItemsContentLayer = new KSprite();
        this._windowItemsContentLayer.move(this.padding, this.padding);
        this.addChild(this._windowItemsContentLayer);
        this._itemsContainer = new KSprite();
        this._windowItemsContentLayer.addChild(this._itemsContainer);
        try {
            if (this['_downArrowSprite']) {
                this.addChild(this['_downArrowSprite']);
            }
            if (this['_upArrowSprite']) {
                this.addChild(this['_upArrowSprite']);
            }
            if (!this.settings.isDrawDefaultItemBack) {
                if (this['_contentsBackSprite']) {
                    this['_contentsBackSprite'].visible = false;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _createWindowContentMask() {
        try {
            let maskBitmap = new Bitmap(this.width - this.padding * 2, this.height - this.padding * 2);
            maskBitmap.fillAll('#ffffff');
            let maskSprite = new KSprite(maskBitmap);
            /*@ts-ignore*/
            this._windowItemsContentLayer.mask = maskSprite;
            this._windowItemsContentLayer.addChild(maskSprite);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateItemsSelectionState() {
        try {
            if (!this.isOpenAndActive() || this.index() < 0 || !this.isCursorVisible) {
                this._disableSelectionForAll();
                return;
            }
            this._selectItemAtIndex(this.index());
        }
        catch (error) {
            console.warn(error);
        }
    }
    _disableSelectionForAll() {
        try {
            if (this._prevSelectedIndex == -2) {
                return;
            }
            this._prevSelectedIndex = -2;
            this.getAllItems().forEach((item) => this._deselectItem(item));
        }
        catch (error) {
            console.warn(error);
        }
    }
    _selectItemAtIndex(index) {
        try {
            if (this._prevSelectedIndex == index) {
                return;
            }
            let item = this.itemAt(index);
            if (item) {
                this._selectItem(item);
                this._prevSelectedIndex = index;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _selectItem(item) {
        if (!item)
            return;
        try {
            if (this._prevSelectedIndex >= 0) {
                this._deselectItem(this.itemAt(this._prevSelectedIndex));
            }
            item.activateInList();
            this._playItemInAnimation(item);
            this._selectItemVisually(item);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deselectItem(item) {
        if (!item)
            return;
        try {
            item.deactivateInList();
            this._playItemOutAnimation(item);
            this._deselectItemVisually(item);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _selectItemVisually(item) {
        try {
            if (!this.settings.isHaveSelectionEffect)
                return;
            if (!this.settings.selectionEffects)
                return;
            if (this.settings.selectionEffects.length == 0)
                return;
            KNBuilder.ApplyEffects(item, this.settings.selectionEffects);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _playItemInAnimation(item) {
        try {
            if (!this.settings.isHaveInOutAnimation)
                return;
            if (KString.any(this.settings.inAnimation)) {
                this._playItemAnimation(item, this.settings.inAnimation);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _playItemOutAnimation(item) {
        try {
            if (!this.settings.isHaveInOutAnimation)
                return;
            if (KString.any(this.settings.outAnimation)) {
                this._playItemAnimation(item, this.settings.outAnimation);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _playItemAnimation(item, animation) {
        try {
            let child = item.children[0];
            if (!child)
                return;
            if (!child.setAnimationRule)
                return;
            child.setAnimationRule(animation);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deselectItemVisually(item) {
        try {
            if (!this.settings.isHaveSelectionEffect)
                return;
            item.filters = [];
        }
        catch (error) {
            console.warn(error);
        }
    }
    _addNewItemToList(item, index) {
        if (!item)
            return;
        try {
            let rect = this.itemRect(index);
            item.move(rect.x, rect.y);
            if (this.settings.scaleItemsHeight) {
                item.scale.y = rect.height / item.realHeight();
            }
            if (this.settings.scaleItemsWidth) {
                item.scale.x = rect.width / item.realWidth();
            }
            this._itemsContainer.addChild(item);
        }
        catch (error) {
            console.warn(error);
        }
    }
    //$[OVER]
    // * We don't need Default Cursor of Window_Selectable
    _updateCursor() {
        if (KDX.isMZ()) {
            /*@ts-ignore*/
            this._cursorSprite.visible = false;
        }
        else {
            /*@ts-ignore*/
            this.setCursorRect(0, 0, 0, 0);
        }
    }
}
// * NUI 1.0
// * rev 15.02.25
// * "type": "plane"
/**
 * Represents a NineSlicePlane sprite used in NUI system.
 */
class KNSprite_Plane extends KNSprite {
    /**
     * Constructs a new instance of the KNSprite_Plane class.
     * @param _settings - The settings for the plane sprite.
     */
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._settings = Object.assign({}, KNSprite_Plane.DefaultSettings(), _settings);
        this._create();
        this._applySettings();
    }
    // * DefaultSettings in JSON format (for easy copy-paste)
    /**
     * Returns the default settings for the plane sprite.
     * @returns {PlaneSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "width": 100,
            "height": 100,
            "margins": 20,
            "imageName": "",
            "folderName": "pictures"
        };
    }
    /**
     * Gets the current settings of the plane sprite.
     * @returns {PlaneSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Gets the real width of the sprite.
     * @returns {number} The real width.
     */
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.width;
    }
    /**
     * Gets the real height of the sprite.
     * @returns {number} The real height.
     */
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.height;
    }
    /**
     * Applies the current settings to the sprite.
     */
    refresh() {
        try {
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Returns an object with data bindings for width, height, and size.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.settings.height); },
            height: (v) => { if (v)
                this.setSize(this.settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            image: (v) => { this.setImage(v); }
        });
    }
    /**
     * Sets the size of the sprite.
     * @param {number | string} [width=100] - The width of the sprite.
     * @param {number | string} [height=100] - The height of the sprite.
     */
    setSize(width = 100, height = 100) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this.refresh();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Sets the image for the sprite.
     * @param {string} imageName - The name of the image.
     * @param {string} [folderName] - The name of the folder containing the image.
     */
    setImage(imageName, folderName) {
        if (KString.any(folderName)) {
            this._settings.folderName = folderName;
        }
        this._settings.imageName = imageName;
        this.refresh();
    }
    /**
     * Creates the plane container and adds it as a child.
     * @private
     */
    _create() {
        this._planeContainer = new KSprite();
        this.addChild(this._planeContainer);
    }
    /**
     * Applies the current settings to the plane sprite.
     * @private
     */
    _applySettings() {
        if (!this._settings)
            return;
        try {
            if (this._plane) {
                this._planeContainer.removeChild(this._plane);
                this._plane.destroy();
            }
            let margins = this._getMargins();
            let textureSource = ImageManager.loadBitmap('img/' + this._settings.folderName + "/", this._settings.imageName, 0, false);
            textureSource.addLoadListener(() => {
                let texture = new PIXI.Texture(textureSource.baseTexture);
                if (KDX.isMV()) {
                    /*@ts-ignore*/
                    this._plane = new PIXI.mesh.NineSlicePlane(texture, margins.left, margins.top, margins.right, margins.bottom);
                }
                else {
                    this._plane = new PIXI.NineSlicePlane(texture, margins.left, margins.top, margins.right, margins.bottom);
                }
                this._planeContainer.addChild(this._plane);
                this._applySize();
            });
        }
        catch (error) {
            console.warn(error);
        }
        this._applySize();
    }
    /**
     * Returns the margins for the plane sprite.
     * @returns {PlaneMargins} The margins.
     * @private
     */
    _getMargins() {
        let margins = this._settings.margins;
        if (typeof margins === "number") {
            return {
                left: margins,
                top: margins,
                right: margins,
                bottom: margins
            };
        }
        else {
            return margins;
        }
    }
    /**
     * Applies the size settings to the plane sprite and its container.
     * @private
     */
    _applySize() {
        this.width = this._settings.width;
        this.height = this._settings.height;
        if (!this._plane)
            return;
        this._plane.width = this._settings.width;
        this._plane.height = this._settings.height;
    }
}
//NUI 1.0
//rev 11.09.24
//"type": "screen"
class KNSprite_Screen extends KNSprite_Group {
    constructor() {
        super({
            width: Graphics.width,
            height: Graphics.height
        });
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return Graphics.width;
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return Graphics.height;
    }
}
//NUI 1.0
//rev 07.12.24
//"type": "text"
class KNSprite_Text extends KNSprite {
    /**
         * Creates an instance of Sprite_UIText2.
         * @param _settings The parameters for the sprite.
         * @param _userTextStyle The user-defined text style.
         */
    constructor(settings = {}, _userTextStyle = {}) {
        super();
        this._userTextStyle = _userTextStyle;
        this._settings = KNSprite_Text.DefaultSettings();
        this._applySettings(settings);
        this._createTextSprite();
        if (KString.any(settings.text)) {
            this.drawText(settings.text);
        }
    }
    /**
     * Checks if the image sprite is loaded.
     * @returns {boolean} True if loaded, otherwise false.
     */
    isLoaded() {
        try {
            /*if(this.settings.width != 'auto' && this.settings.height != 'auto') {
                return true;
            }*/
            return !!this._textSpr;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    /**
     * Gets the current settings of the image sprite.
     * @returns {TextSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    get textColor() {
        return this._settings.textColor;
    }
    set textColor(value) {
        this.setTextColor(value);
    }
    static DefaultSettings() {
        return {
            "size": { "width": 60, "height": 20 },
            "alignment": "center",
            "font": {
                "face": null,
                "size": 18,
                "italic": false,
                "bold": false,
                "weight": 0
            },
            "margins": { "x": 0, "y": 0 },
            "outline": { "color": null, "width": 2 },
            "textColor": "#FFFFFF",
            "shadow": {
                "color": "#000",
                "opacity": 0,
                "margins": { "x": 1, "y": 1 }
            },
            "text": "",
            "multiline": false,
            "verticalCentered": true,
            "actualWidth": false,
            "actualHeight": false,
            "isLoadFontFromFile": false
        };
    }
    /**
     * Returns an object with data bindings for width, height, size, text, and style settings.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.realHeight()); },
            height: (v) => { if (v)
                this.setSize(this.realWidth(), v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            text: (v) => { this.drawText(v); },
            style: (v) => { if (v)
                this.setStyle(v, {}); },
            textColor: (v) => { if (v)
                this.setTextColor(v); },
            fontSize: (v) => { if (KDX.any(v))
                this.setFontSize(v); }
        });
    }
    setSize(width, height) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            this.setStyle({ size: { width: _width, height: _height } }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    setStyle(newStyleInOldFormat, newStyleInPixiFormat) {
        try {
            this._textStyle = this._convertToPixiStyle(newStyleInOldFormat, newStyleInPixiFormat);
            this._textSpr.style = this._textStyle;
            this.drawText(this._textSpr.text);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setFontSize(size) {
        try {
            let font = Object.assign({}, this._settings.font);
            if (typeof size == "string") {
                size = this.convertStringSizeValue(size, 'height', this);
            }
            font.size = size;
            this.setStyle({ font }, {});
            this.drawText(this._settings.text);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setTextColor(color) {
        try {
            this._settings.textColor = color;
            this.setStyle({ textColor: color }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    getMetrics() {
        return PIXI.TextMetrics.measureText(this._textSpr.text, this._textSpr.style);
    }
    drawText(text) {
        try {
            if (!KString.any(text)) {
                text = "";
            }
            this._settings.text = text;
            this._drawText(text);
        }
        catch (error) {
            console.warn(error);
        }
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        if (this._textSpr && this._settings.actualWidth == true) {
            return this.getMetrics().width;
        }
        if (this._settings.size.width > 0) {
            return this._settings.size.width;
        }
        return super.realWidth();
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        if (this._textSpr && this._settings.actualHeight == true) {
            return this.getMetrics().height;
        }
        if (this._settings.size.height > 0) {
            return this._settings.size.height;
        }
        return super.realHeight();
    }
    /**
         * Applies the parameters to the sprite.
         * @param settings The parameters to apply.
         */
    _applySettings(settings) {
        try {
            this._textStyle = this._convertToPixiStyle(settings, {});
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
         * Converts the old style parameters to the new (PIXI) style.
         * @param settings The old style parameters.
         * @param style The new style parameters.
         * @returns The converted text style.
         */
    _convertToPixiStyle(settings = {}, style) {
        try {
            this._settings = Object.assign(this._settings, settings);
            let _textStyle = (Object.assign({}, this._userTextStyle, style));
            if (KString.any(this._settings.font.face)) {
                this._loadFont();
                _textStyle.fontFamily = this._settings.font.face;
            }
            _textStyle.fontSize = this._settings.font.size;
            if (this._settings.font.italic === true) {
                _textStyle.fontStyle = 'italic';
            }
            if (this._settings.font.bold === true) {
                _textStyle.fontWeight = 'bold';
            }
            if (this._settings.font.weight && this._settings.font.weight > 0) {
                _textStyle.fontWeight = this._settings.font.weight.toString();
            }
            if (KString.any(this._settings.outline.color) && this._settings.outline.width > 0) {
                _textStyle.stroke = this._settings.outline.color;
                _textStyle.strokeThickness = this._settings.outline.width;
            }
            _textStyle.fill = this._settings.textColor;
            if (this._settings.shadow && this._settings.shadow.opacity > 0) {
                const { color, opacity, margins } = this._settings.shadow;
                _textStyle.dropShadow = true;
                _textStyle.dropShadowAngle = margins.y;
                _textStyle.dropShadowColor = color;
                _textStyle.dropShadowDistance = margins.x;
                _textStyle.dropShadowAlpha = opacity / 255.0;
            }
            if (this._settings.multiline === true) {
                _textStyle.align = this._settings.alignment || 'left';
                _textStyle.wordWrap = true;
                if (this._settings.font.size) {
                    _textStyle.lineHeight = this._settings.font.size + 2;
                }
                if (this.realWidth() > 0) {
                    _textStyle.wordWrapWidth = this.realWidth();
                }
            }
            return _textStyle;
        }
        catch (e) {
            console.warn(e);
            return new PIXI.TextStyle();
        }
    }
    _loadFont() {
        try {
            if (this._settings.isLoadFontFromFile != true)
                return;
            if (!KString.any(this._settings.font.face))
                return;
            //@ts-ignore
            if (KNSprite_Text._loadedFonts.includes(this._settings.font.face))
                return;
            if (KDX.isMV()) {
                let url = "fonts/" + Utils.encodeURI(this._settings.font.face) + ".ttf";
                var style = document.createElement('style');
                var head = document.getElementsByTagName('head');
                var rule = '@font-face { font-family: "' + this._settings.font.face + '"; src: url("' + url + '"); }';
                style.type = 'text/css';
                head.item(0).appendChild(style);
                style.sheet.insertRule(rule, 0);
            }
            else {
                //@ts-ignore
                FontManager.load(this._settings.font.face, this._settings.font.face + ".ttf");
            }
            KNSprite_Text._loadedFonts.push(this._settings.font.face);
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Creates the text sprite.
     */
    _createTextSprite() {
        try {
            const style = new PIXI.TextStyle(this._textStyle);
            this._textSpr = new PIXI.Text('', style);
            this.addChild(this._textSpr);
            this.executeRequiredFuncs();
            this.executeLoadListeners();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the text.
     * @param text The text to draw.
     */
    _drawText(text) {
        try {
            if (!this.isLoaded()) {
                this.requireFunc("_drawText", text);
                return;
            }
            if (typeof text !== "string") {
                text = String(text);
            }
            try {
                text = TextProParser.ConvertControlCharacters(text);
            }
            catch (error) {
                console.warn(error);
            }
            this._textSpr.text = text;
            const { width: w, height: h } = this._settings.size;
            // * Fix for a bug with 0 font size
            if (this._textSpr.style.fontSize == 0) {
                this._textSpr.style.fontSize = 18;
            }
            let textMetrics;
            try {
                textMetrics = PIXI.TextMetrics.measureText(text, this._textSpr.style);
            }
            catch (error) {
                console.warn(error);
                return;
            }
            const { height, maxLineWidth } = textMetrics;
            if (this._settings.verticalCentered === true) {
                this._textSpr.y = (h - height) / 2;
            }
            else {
                this._textSpr.y = 0;
            }
            if (this._settings.alignment === 'center') {
                this._textSpr.x = (w - maxLineWidth) / 2;
            }
            else if (this._settings.alignment === 'right') {
                this._textSpr.x = (w - maxLineWidth);
            }
            else {
                this._textSpr.x = 0;
            }
            this._textSpr.x += this._settings.margins.x;
            this._textSpr.y += this._settings.margins.y;
        }
        catch (e) {
            console.warn(e);
        }
    }
}
KNSprite_Text._loadedFonts = [];
//NUI 1.3
//rev 07.10.24
//"type": "textPro"
class KNSprite_TextPro extends KNSprite {
    /**
         * Creates an instance of Sprite_UIText2.
         * @param _settings The parameters for the sprite.
         * @param _userTextStyle The user-defined text style.
         */
    constructor(settings = {}, _userTextStyle = {}) {
        super();
        this._userTextStyle = _userTextStyle;
        this._settings = Object.assign(KNSprite_TextPro.DefaultSettings(), settings);
        this._textsContainer = new KNSprite_Group();
        this._textLines = [];
        this.addChild(this._textsContainer);
        if (KString.any(settings.text)) {
            this.drawText(settings.text);
        }
    }
    /**
     * Gets the current settings of the image sprite.
     * @returns {TextProSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    static DefaultSettings() {
        return {
            "size": { "width": 60, "height": 20 },
            "alignment": "center",
            "font": {
                "face": null,
                "size": 18,
                "italic": false,
                "bold": false,
                "weight": 0
            },
            "margins": { "x": 0, "y": 0 },
            "outline": { "color": null, "width": 2 },
            "textColor": "#FFFFFF",
            "shadow": {
                "color": "#000",
                "opacity": 0,
                "margins": { "x": 1, "y": 1 }
            },
            "text": "",
            "multiline": false,
            "verticalCentered": true,
            "verticalAlignment": "top",
            "verticalSpacing": 4,
            "actualWidth": false,
            "actualHeight": false,
            "trimWidth": false,
            "trimHeight": false,
            "iconPadding": {
                "left": 2,
                "right": 2,
                "top": 0,
                "bottom": 0
            },
            "iconSize": 1,
            "isStaticIconSize": false,
            "isLoadFontFromFile": false
        };
    }
    realWidth() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this.settings.actualWidth == true) {
                return this._textsContainer.realWidth();
            }
            return this.settings.size.width;
        }
        catch (error) {
            console.warn(error);
            return 0;
        }
    }
    realHeight() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this.settings.actualHeight == true) {
                return this._textsContainer.realHeight();
            }
            return this.settings.size.height;
        }
        catch (error) {
            console.warn(error);
            return 0;
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, text, and style settings.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.realHeight()); },
            height: (v) => { if (v)
                this.setSize(this.realWidth(), v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            text: (v) => { this.drawText(v); },
            style: (v) => { if (v)
                this.setStyle(v, {}); },
            textColor: (v) => { if (v)
                this.setTextColor(v); },
            fontSize: (v) => { if (KDX.any(v))
                this.setFontSize(v); },
            iconSize: (v) => { if (KDX.any(v))
                this.setIconSize(v); },
            verticalSpacing: (v) => { if (KDX.any(v))
                this.setVerticalSpacing(v); }
        });
    }
    setSize(width, height) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            this.setStyle({ size: { width: _width, height: _height } }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    setTextColor(color) {
        try {
            this.setStyle({ textColor: color }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    setIconSize(size) {
        if (typeof size == "string") {
            size = this.convertStringSizeValue(size, 'height', this);
        }
        this.setStyle({ iconSize: size }, {});
    }
    setVerticalSpacing(spacing) {
        if (typeof spacing == "string") {
            spacing = this.convertStringSizeValue(spacing, 'height', this);
        }
        this.setStyle({ verticalSpacing: spacing }, {});
    }
    setFontSize(size) {
        try {
            let font = Object.assign({}, this._settings.font);
            if (typeof size == "string") {
                size = this.convertStringSizeValue(size, 'height', this);
            }
            font.size = size;
            this.setStyle({ font }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    setStyle(style, userStyle) {
        try {
            this._settings = Object.assign(this._settings, style);
            this._userTextStyle = Object.assign(this._userTextStyle, userStyle);
            this.drawText(this.settings.text);
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws the specified text on the sprite.
     *
     * @param text - The text to be drawn. If the text is not provided or is invalid, an empty string will be used.
     * @throws Will log a warning to the console if an error occurs during the drawing process.
     */
    drawText(text) {
        try {
            if (!KString.any(text)) {
                text = "";
            }
            this._settings.text = text;
            this._createTextSprites();
            this._applyAlignment();
            this._applyMargins();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _createTextSprites() {
        try {
            this._clearTextSprites();
            let textConfigs = TextProParser.ParseText(this.settings);
            let elements = TextProElementsBuilder.Build(textConfigs, this.settings, this._userTextStyle);
            if (this.settings.multiline == true || this.settings.trimWidth == true) {
                let lines = this._separateTextToLines(elements);
                for (let line of lines) {
                    this._textLines.push(line);
                    this._textsContainer.addChild(line);
                    this._refreshTextElementsVerticalPosition(line);
                    this._applyLineAligmnent(line);
                }
            }
            else {
                this._textLines.push(elements);
                this._textsContainer.addChild(elements);
                this._refreshTextElementsVerticalPosition(elements);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _clearTextSprites() {
        try {
            this._textsContainer.move(0, 0);
            this._textsContainer.removeChildren();
            this._textLines = [];
        }
        catch (error) {
            console.warn(error);
        }
    }
    _separateTextToLines(allTextElements) {
        const lines = [];
        try {
            const maxLineWidth = this.settings.size.width;
            const maxHeight = this.settings.size.height;
            let currentWidth = 0;
            const currentHeight = () => {
                return lines.reduce((sum, line) => sum + line.realHeight(), 0);
            };
            const elements = [];
            for (const child of allTextElements.children) {
                elements.push(child);
            }
            let line = new KNSprite_Group({});
            lines.push(line);
            for (const el of elements) {
                currentWidth += el.realWidth();
                if (currentWidth > maxLineWidth) {
                    currentWidth = 0;
                    if (this.settings.multiline === false)
                        break;
                    const newHeight = currentHeight() + el.realHeight();
                    if (newHeight > maxHeight) {
                        if (this.settings.trimHeight === true)
                            break;
                    }
                    line = new KNSprite_Group({});
                    line.addChild(el);
                    el.setPosition(0, this._textElementVerticalPosition());
                    lines.push(line);
                    line.y += line.realHeight() + this.settings.verticalSpacing;
                }
                else {
                    line.addChild(el);
                    el.setPosition("prevEndX", this._textElementVerticalPosition());
                }
            }
        }
        catch (e) {
            console.warn(e);
        }
        return lines;
    }
    _refreshTextElementsVerticalPosition(elements) {
        try {
            for (let child of elements.children) {
                child.setPosition(child.x, this._textElementVerticalPosition());
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Gets the vertical position for the text element.
     * @returns The vertical position for the text element.
     * @private
     */
    _textElementVerticalPosition() {
        try {
            if (this.settings.verticalCentered) {
                return "center";
            }
        }
        catch (e) {
            console.warn(e);
        }
        return 0;
    }
    _applyLineAligmnent(line) {
        try {
            line.setPosition(this.settings.alignment, line.y);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _applyAlignment() {
        try {
            this._textsContainer.setPosition(this.settings.alignment, this.settings.verticalAlignment);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _applyMargins() {
        try {
            this._textsContainer.x += this.settings.margins.x;
            this._textsContainer.y += this.settings.margins.y;
        }
        catch (error) {
            console.warn(error);
        }
    }
}
class TextProElementsBuilder {
    /**
     * Creates an instance of TextProElementsBuilder.
     * @param configs The configuration for the text elements.
     * @param settings The settings for the TextPro sprite.
     * @param userTextStyle The user-defined text style.
     */
    constructor(configs, settings, userTextStyle) {
        this.configs = configs;
        this.settings = settings;
        this.userTextStyle = userTextStyle;
        this._elements = new KNSprite_Group();
        this._buildElements();
    }
    /**
     * Gets the elements created by the builder.
     * @returns The elements created by the builder.
     */
    getElements() {
        return this._elements;
    }
    /**
     * Builds the elements based on the provided configurations.
     * @param configs The configuration for the text elements.
     * @param settings The settings for the TextPro sprite.
     * @param userTextStyle The user-defined text style.
     * @returns The elements created by the builder.
     */
    static Build(configs, settings, userTextStyle) {
        const builder = new TextProElementsBuilder(configs, settings, userTextStyle);
        return builder.getElements();
    }
    /**
     * Builds the elements based on the configurations.
     * @private
     */
    _buildElements() {
        try {
            for (const config of this.configs) {
                if (config.iconIndex !== undefined && config.iconIndex >= 0) {
                    this._createIconElement(config, this._elements);
                }
                else {
                    this._createTextElement(config, this._elements);
                }
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates an icon element based on the configuration.
     * @param config The configuration for the icon element.
     * @param line The line to add the icon element to.
     * @private
     */
    _createIconElement(config, line) {
        try {
            let iconSize;
            if (this.settings.isStaticIconSize) {
                iconSize = this.settings.iconSize;
            }
            else {
                if (config.fontSize && config.fontSize > 0) {
                    iconSize = config.fontSize * this.settings.iconSize;
                }
                else {
                    iconSize = this.settings.font.size * this.settings.iconSize;
                }
            }
            const icon = new KNSprite_Image({
                imageName: config.iconIndex,
                width: iconSize,
                height: iconSize
            });
            const paddingGroup = new KNSprite_Group({
                width: iconSize + this.settings.iconPadding.left + this.settings.iconPadding.right,
                height: iconSize + this.settings.iconPadding.top + this.settings.iconPadding.bottom
            });
            paddingGroup.addChild(icon);
            icon.setPosition("center", "center");
            line.addChild(paddingGroup);
            paddingGroup.setPosition("prevEndX", this._textElementVerticalPosition());
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates a text element based on the configuration.
     * @param config The configuration for the text element.
     * @param line The line to add the text element to.
     * @private
     */
    _createTextElement(config, line) {
        try {
            const textSettings = Object.assign({}, this.settings);
            textSettings.text = config.text;
            if (config.fontSize && config.fontSize > 0) {
                textSettings.font.size = config.fontSize;
            }
            if (config.color && KString.any(config.color)) {
                textSettings.textColor = config.color;
            }
            textSettings.alignment = "left";
            textSettings.multiline = false;
            textSettings.verticalCentered = false;
            textSettings.actualWidth = true;
            textSettings.actualHeight = true;
            textSettings.margins = { x: 0, y: 0 };
            const text = new KNSprite_Text(textSettings, this.userTextStyle);
            line.addChild(text);
            text.setPosition("prevEndX", this._textElementVerticalPosition());
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Gets the vertical position for the text element.
     * @returns The vertical position for the text element.
     * @private
     */
    _textElementVerticalPosition() {
        try {
            if (this.settings.verticalCentered) {
                return "center";
            }
        }
        catch (e) {
            console.warn(e);
        }
        return 0;
    }
}
let _pkdTempWindowBaseForConvertEscapeCharacters = null;
class TextProParser {
    /**
     * Converts control characters in the input text.
     * @param inputText The input text to convert.
     * @returns The converted text.
     */
    static ConvertControlCharacters(inputText) {
        try {
            if (KString.any(inputText)) {
                if (!_pkdTempWindowBaseForConvertEscapeCharacters) {
                    if (KDX.isMV()) {
                        //@ts-ignore
                        _pkdTempWindowBaseForConvertEscapeCharacters = new Window_Base(0, 0, 0, 0);
                    }
                    else {
                        _pkdTempWindowBaseForConvertEscapeCharacters = new Window_Base(new Rectangle(0, 0, 0, 0));
                    }
                }
                return _pkdTempWindowBaseForConvertEscapeCharacters.convertEscapeCharacters(inputText);
            }
            else {
                return "";
            }
        }
        catch (e) {
            console.warn(e);
            return "";
        }
    }
    /**
     * Creates an instance of TextProParser.
     * @param settings The settings for the TextPro sprite.
     */
    constructor(settings) {
        this._textsConfigs = [];
        this.settings = settings;
        if (KDX.isMV()) {
            if (!window["__kdSharedTextProTextColorSourceWindow"]) {
                /*@ts-ignore*/
                window["__kdSharedTextProTextColorSourceWindow"] = new Window_Base(0, 0, 0, 0);
            }
        }
        this._parseAllText();
    }
    /**
     * Parses the text based on the provided settings.
     * @param settings The settings for the TextPro sprite.
     * @returns The parsed text configurations.
     */
    static ParseText(settings) {
        const parser = new TextProParser(settings);
        return parser.getConfigs();
    }
    /**
     * Checks if the character is a control separator.
     * @param char The character to check.
     * @returns True if the character is a control separator, otherwise false.
     */
    static isControlSeparator(char) {
        return '\x1b' === char;
    }
    /**
     * Gets the parsed text configurations.
     * @returns The parsed text configurations.
     */
    getConfigs() {
        return this._textsConfigs;
    }
    /**
     * Parses all the text based on the settings.
     * @private
     */
    _parseAllText() {
        try {
            const preparedText = TextProParser.ConvertControlCharacters(this.settings.text);
            const textState = this._makeInitialTextState(preparedText);
            this._processAllText(textState);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the initial text state.
     * @param text The text to create the state for.
     * @returns The initial text state.
     * @private
     */
    _makeInitialTextState(text) {
        return {
            text: text,
            buffer: "",
            index: 0,
            color: "", // * "" default
            fontSize: -1, // * -1 default
            iconIndex: -1, // * -1 none
        };
    }
    /**
     * Processes all the text based on the text state.
     * @param textState The text state to process.
     * @private
     */
    _processAllText(textState) {
        try {
            while (textState.index < textState.text.length) {
                this._processCharacter(textState);
            }
            this._saveTextConfig(textState);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Processes a single character in the text state.
     * @param textState The text state to process.
     * @private
     */
    _processCharacter(textState) {
        try {
            const c = textState.text[textState.index++];
            if (c.charCodeAt(0) < 0x20) {
                this._saveTextConfig(textState);
                this._processControlCharacter(textState, c);
            }
            else {
                textState.buffer += c;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Saves the current text configuration.
     * @param textState The text state to save.
     * @private
     */
    _saveTextConfig(textState) {
        try {
            if (textState.buffer.length > 0 || textState.iconIndex > 0) {
                this._textsConfigs.push({
                    text: textState.buffer,
                    color: textState.color,
                    fontSize: textState.fontSize,
                    iconIndex: textState.iconIndex
                });
                textState.buffer = "";
                textState.iconIndex = -1;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Processes a control character in the text state.
     * @param textState The text state to process.
     * @param c The control character to process.
     * @private
     */
    _processControlCharacter(textState, c) {
        try {
            if (TextProParser.isControlSeparator(c)) {
                const code = this._obtainEscapeCode(textState);
                this._processEscapeCharacter(code, textState);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Obtains the escape code from the text state.
     * @param textState The text state to obtain the escape code from.
     * @returns The escape code.
     * @private
     */
    _obtainEscapeCode(textState) {
        try {
            const regExp = /^[$.|^!><{}\\]|^[A-Z]+/i;
            const arr = regExp.exec(textState.text.slice(textState.index));
            if (arr) {
                textState.index += arr[0].length;
                return arr[0].toUpperCase();
            }
            else {
                return "";
            }
        }
        catch (e) {
            console.warn(e);
            return "";
        }
    }
    /**
     * Processes an escape character in the text state.
     * @param code The escape code to process.
     * @param textState The text state to process.
     * @private
     */
    _processEscapeCharacter(code, textState) {
        try {
            let currentFontSize = textState.fontSize;
            switch (code) {
                case "C":
                    const colorIndex = this._obtainEscapeParam(textState);
                    if (colorIndex > 0) {
                        if (KDX.isMV()) {
                            textState.color = window["__kdSharedTextProTextColorSourceWindow"].textColor(colorIndex);
                        }
                        else {
                            textState.color = ColorManager.textColor(colorIndex);
                        }
                    }
                    else {
                        textState.color = "";
                    }
                    break;
                case "I":
                    const iconIndex = this._obtainEscapeParam(textState);
                    if (iconIndex > 0) {
                        textState.iconIndex = iconIndex;
                        // * Icon is a separate sprite, so save the current text as separate
                        this._saveTextConfig(textState);
                    }
                    else {
                        textState.iconIndex = -1;
                    }
                    break;
                case "FS":
                    const fontSize = this._obtainEscapeParam(textState);
                    textState.fontSize = fontSize;
                    break;
                case "{": // * Make font bigger by 1
                    currentFontSize = textState.fontSize;
                    if (currentFontSize === -1) {
                        currentFontSize = this.settings.font.size;
                    }
                    textState.fontSize = currentFontSize + 1;
                    break;
                case "}":
                    currentFontSize = textState.fontSize;
                    if (currentFontSize === -1) {
                        currentFontSize = this.settings.font.size;
                    }
                    textState.fontSize = currentFontSize - 1;
                    break;
                default:
                    console.warn("KNSprite_TextPro: Unknown escape code: " + code);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Obtains the escape parameter from the text state.
     * @param textState The text state to obtain the escape parameter from.
     * @returns The escape parameter.
     * @private
     */
    _obtainEscapeParam(textState) {
        try {
            const regExp = /^\[\d+\]/;
            const arr = regExp.exec(textState.text.slice(textState.index));
            if (arr) {
                textState.index += arr[0].length;
                return parseInt(arr[0].slice(1));
            }
            else {
                return 0;
            }
        }
        catch (e) {
            console.warn(e);
            return 0;
        }
    }
}


//build: 6 
var KDX;
(function (KDX) {
    /**
     * The version of the KDX Library.
     * @type {string}
     */
    KDX.Version = "0.1";
    /**
     * Checks if the RPG Maker version is MV.
     * @returns {boolean} True if the RPG Maker version is MV, otherwise false.
     */
    /* @ts-ignore */
    KDX.isMV = () => Utils.RPGMAKER_NAME.includes("MV");
    /**
     * Checks if the RPG Maker version is MZ.
     * @returns {boolean} True if the RPG Maker version is MZ, otherwise false.
     */
    KDX.isMZ = () => !KDX.isMV();
    /**
     * Checks if a value is not null and not undefined
     *
     * @param {any} value - The value to check.
     * @returns {boolean} True if the value is not null and not undefined
     */
    KDX.any = (value) => (value === null || value === undefined) ? false : true;
})(KDX || (KDX = {}));
var KArray;
(function (KArray) {
    /**
     * Deletes all occurrences of a specified item from an array.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array from which to delete items.
     * @param {T} item - The item to delete from the array.
     * @returns {T[]} A new array with all occurrences of the specified item removed.
     */
    function deleteAll(array, item) {
        return array.filter((i) => i !== item);
    }
    KArray.deleteAll = deleteAll;
    /**
     * Returns a random item from an array.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array from which to select a random item.
     * @returns {T} A random item from the array.
     */
    function randomItem(array) {
        return array[Math.floor(Math.random() * array.length)];
    }
    KArray.randomItem = randomItem;
    /**
     * Shuffles the elements of an array in place.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array to shuffle.
     * @returns {T[]} The shuffled array.
     */
    function shuffle(array) {
        let currentIndex = array.length;
        let randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }
    KArray.shuffle = shuffle;
    /**
     * Finds an item in an array by a specified key and value.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array to search.
     * @param {string} key - The key to match.
     * @param {any} value - The value to match.
     * @returns {T | null} The found item, or null if no item matches.
     */
    function getByKey(array, key, value) {
        try {
            return array.find((i) => i[key] === value);
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    KArray.getByKey = getByKey;
    /**
     * Finds an item in an array by its 'id' property.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array to search.
     * @param {any} value - The value of the 'id' property to match.
     * @returns {T | null} The found item, or null if no item matches.
     */
    function getById(array, value) {
        return getByKey(array, "id", value);
    }
    KArray.getById = getById;
})(KArray || (KArray = {}));
var KNumber;
(function (KNumber) {
    /**
    * Clamps a number within a specified range.
    *
    * @param {number} value - The value to clamp.
    * @param {number} min - The minimum value.
    * @param {number} max - The maximum value.
    * @returns {number} The clamped value.
    */
    KNumber.clamp = (value, min, max) => {
        return Math.min(Math.max(value, min), max);
    };
    /**
     * Generates a random number between the specified minimum and maximum values (inclusive).
     *
     * @param {number} min - The minimum value of the range.
     * @param {number} max - The maximum value of the range.
     * @returns {number} A random number between the minimum and maximum values.
     */
    KNumber.random = (min, max) => {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    /**
     * Checks if the given number is greater than zero.
     *
     * @param {number} number - The number to be checked.
     * @returns {boolean} `true` if the number is greater than zero, `false` otherwise.
     */
    KNumber.any = (number) => {
        if (number === null || number === undefined) {
            return false;
        }
        return number > 0;
    };
})(KNumber || (KNumber = {}));
var KString;
(function (KString) {
    /**
         * Generates a random string of the specified length.
         * @param {number} length - The length of the generated string.
         * @returns {string} The generated string.
         */
    KString.randomString = (length) => {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    };
    /**
     * Replaces all occurrences of a substring in a string with a specified replacement.
     *
     * @param {string} source - The source string.
     * @param {string} search - The substring to search for.
     * @param {string} replacement - The replacement string.
     * @returns {string} The modified string with all occurrences of the substring replaced.
     */
    KString.replaceAll = (source, search, replacement) => {
        return source.split(search).join(replacement);
    };
    /**
     * Checks if a string is not null, not undefined, and has a length greater than 0 (after trimming).
     *
     * @param {string} str - The string to check.
     * @returns {boolean} True if the string is not null, not undefined, and has a length greater than 0 (after trimming), otherwise false.
     */
    KString.any = (str) => {
        if (str === null || str === undefined) {
            return false;
        }
        // * For compatibility with old verions of KDCore library
        if (typeof str === "boolean") {
            return str == true;
        }
        try {
            if (typeof str == "string") {
                return str.length > 0 || str.trim().length > 0;
            }
            else {
                return true;
            }
        }
        catch (error) {
            console.warn(error);
            return false;
        }
    };
    /**
     * Checks if the provided value is of type string.
     *
     * @param value - The value to check.
     * @returns `true` if the value is a string, otherwise `false`.
     */
    KString.isString = (value) => {
        return typeof value === "string";
    };
})(KString || (KString = {}));
(function () {
    // * RPG Maker MV only
    // * В версии RPG Maker MV не отслеживаются координаты курсора, если мы просто двигаем мышкой
    // * Данный код исправляет эту проблему, чтобы можно было отслеживать координаты курсора, даже если мышь не нажата
    if (!Utils.RPGMAKER_NAME.includes("MV"))
        return;
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ TouchInput.ts
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    (() => {
        //@[DEFINES]
        const _ = TouchInput;
        //@[ALIAS]
        /*@ts-ignore*/
        const ALIAS___onMouseMove = _._onMouseMove;
        _['_onMouseMove'] = function (event) {
            ALIAS___onMouseMove.call(this, event);
            let x = Graphics.pageToCanvasX(event.pageX);
            let y = Graphics.pageToCanvasY(event.pageY);
            if (Graphics.isInsideCanvas(x, y)) {
                this['_x'] = x;
                this['_y'] = y;
            }
        };
    })();
    // ■ END TouchInput.ts
    //---------------------------------------------------------------------------
})();
var KAudio;
(function (KAudio) {
    /**
     * Plays a sound effect (SE) with the specified parameters.
     *
     * @param name - The name of the sound effect file to play.
     * @param pitch - The pitch of the sound effect. Defaults to 100.
     * @param volume - The volume of the sound effect. Defaults to 100.
     *
     * @remarks
     * If the provided name is empty or invalid, the function will not attempt to play the sound effect.
     */
    function PlaySE(name, pitch = 100, volume = 100) {
        if (!KString.any(name))
            return;
        let audioData = {
            name: name,
            pitch: pitch,
            volume: volume,
            pan: 0,
            pos: 0
        };
        AudioManager.playStaticSe(audioData);
    }
    KAudio.PlaySE = PlaySE;
})(KAudio || (KAudio = {}));
var KGameEvents;
(function (KGameEvents) {
    // * Return whole line that contains the commentCode
    /**
     * Retrieves a specific comment line from a game event based on the provided comment code.
     *
     * @param commentCode - The code to search for within the comment lines.
     * @param event - The game event from which to retrieve the comment line.
     * @returns The comment line containing the specified code, or `null` if not found.
     *
     * @remarks
     * This function searches through the event's page list to find a comment line that includes the specified comment code.
     * It looks for comment codes 108 and 408, which are typically used for comments in RPG Maker events.
     * If the event or its page list is not available, or if no matching comment line is found, the function returns `null`.
     *
     * @throws Will log a warning to the console if an error occurs during the search process.
     */
    function GetCommentLine(commentCode, event) {
        try {
            if (!event)
                return null;
            let page = event.page();
            if (!page)
                return null;
            let list = page.list;
            if (!list)
                return null;
            for (let i = 0; i < list.length; i++) {
                if (!list[i])
                    continue;
                if (list[i].code === 108 || list[i].code === 408) {
                    let line = list[i].parameters[0];
                    if (line && line.includes(commentCode)) {
                        return line;
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    KGameEvents.GetCommentLine = GetCommentLine;
    /**
     *
     * @param commentCode - The code to search for within the comment lines.
     * @param event - The game event from which to retrieve the comment lines.
     * @returns An array of comment lines containing the specified code, or an empty array if not found.
     */
    function GetCommentLines(commentCode, event) {
        let lines = [];
        try {
            if (!event)
                return lines;
            let page = event.page();
            if (!page)
                return lines;
            let list = page.list;
            if (!list)
                return lines;
            for (let i = 0; i < list.length; i++) {
                if (!list[i])
                    continue;
                if (list[i].code === 108 || list[i].code === 408) {
                    let line = list[i].parameters[0];
                    if (line && line.includes(commentCode)) {
                        lines.push(line);
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return lines;
    }
    KGameEvents.GetCommentLines = GetCommentLines;
    // * For commentCode:value
    /**
     * Retrieves the value associated with a specific comment code from a game event.
     * Pattern commentCode:value
     *
     * @param commentCode - The code of the comment to search for.
     * @param event - The game event object to search within.
     * @returns The value associated with the comment code, or null if not found.
     */
    function GetCommentCodeValue(commentCode, event) {
        try {
            let line = GetCommentLine(commentCode, event);
            if (!line)
                return null;
            let value = line.split(":")[1].trim();
            return value;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    KGameEvents.GetCommentCodeValue = GetCommentCodeValue;
})(KGameEvents || (KGameEvents = {}));
var KGameItems;
(function (KGameItems) {
    /**
     * Checks if the given object has a meta property with the specified symbol.
     *
     * @param symbol - The symbol to check for in the meta property.
     * @param obj - The object to check for the meta property.
     * @returns `true` if the object has a meta property with the specified symbol, otherwise `false`.
     * @throws Will log a warning to the console if an error occurs during the check.
     */
    function IsHaveMeta(symbol, obj) {
        try {
            return obj && obj.meta && obj.meta.hasOwnProperty(symbol);
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    KGameItems.IsHaveMeta = IsHaveMeta;
    /**
     * Retrieves the metadata associated with a given symbol from an object.
     *
     * @param symbol - The key for the metadata to retrieve.
     * @param obj - The object containing the metadata.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns The metadata value. If the symbol is not present or an error occurs, returns the default value.
     */
    function GetMeta(symbol, obj, defaultValue = null) {
        try {
            if (!IsHaveMeta(symbol, obj))
                return defaultValue;
            return obj.meta[symbol];
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetMeta = GetMeta;
    /**
     * Retrieves the metadata associated with a given symbol from an object and converts it to an array of strings.
     * Example:
     * <meta:a,b,c> -> ["a", "b", "c"]
     * <meta:a> -> ["a"]
     * @param symbol - The key for the metadata to retrieve.
     * @param obj - The object to check for the meta property.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns An array of metadata values associated with the symbol. If the symbol is not present or an error occurs, returns the default value.
     */
    function GetMetaValues(symbol, obj, defaultValue = []) {
        try {
            let values = GetMeta(symbol, obj, null);
            if (KString.any(values)) {
                if (values.includes(',')) {
                    // Split values by comma and trim each value
                    let resultValues = values.split(',').map((value) => value.trim());
                    // Filter out empty values
                    resultValues = resultValues.filter((value) => value !== '');
                    return resultValues;
                }
                else {
                    return [values];
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetMetaValues = GetMetaValues;
    /**
     * Retrieves the metadata associated with a given symbol from an object and converts it to an array of numbers.
     * Example:
     * <meta:1,2,3> -> [1, 2, 3]
     * <meta:1> -> [1]
     * @param symbol - The key for the metadata to retrieve.
     * @param obj - The object to check for the meta property.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns An array of metadata values associated with the symbol. If the symbol is not present or an error occurs, returns the default value.
     * */
    function GetMetaValuesAsNumbers(symbol, obj, defaultValue = []) {
        try {
            let values = GetMetaValues(symbol, obj, []);
            let resultValues = values.map((value) => Number(value.trim()));
            // Filter out NaN values
            resultValues = resultValues.filter((value) => !isNaN(value));
            return resultValues;
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetMetaValuesAsNumbers = GetMetaValuesAsNumbers;
    /**
    * Retrieves the metadata associated with a given symbol from an object when object have many same meta values.
    * Example:
    * <symbol:value1>
    * <symbol:value2>
    * ...
    * Return [value1, value2, ...]
    * @param symbol - The symbol to check for in the meta property.
     * @param obj - The object containing the metadata.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns  An array of metadata values associated with the symbol. If the symbol is not present or an error occurs, returns an empty array.
     */
    function GetSameMetaValues(symbol, obj, defaultValue = []) {
        try {
            if (!IsHaveMeta(symbol, obj))
                return defaultValue;
            let lines = obj.note.split(/[\r\n]+/).filter(line => line.includes(symbol));
            // Remove symbol from lines
            // Remove < and > from lines
            lines = lines.map(line => line.replace(/<|>/g, '').replace(symbol + ":", '').trim());
            return lines;
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetSameMetaValues = GetSameMetaValues;
    /**
     * Retrieves the metadata associated with the given symbol from the specified object
     * and converts it to a number.
     *
     * @param symbol - The key for the metadata to retrieve.
     * @param obj - The object from which to retrieve the metadata.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns The metadata value as a number. If the symbol is not present or an error occurs, returns the default value.
     */
    function GetMetaAsNumber(symbol, obj, defaultValue = 0) {
        try {
            return Number(GetMeta(symbol, obj, defaultValue));
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetMetaAsNumber = GetMetaAsNumber;
})(KGameItems || (KGameItems = {}));
var KInput;
(function (KInput) {
    /**
     * Simulates a virtual click on the specified button.
     *
     * @param buttonName - The name of the button to simulate a click on.
     *
     * This function checks if the environment is MV (RPG Maker MV) and if the `Input.virtualClick` method is not already extended.
     * If both conditions are met, it extends the MV Input system to support virtual clicks.
     *
     * @remarks
     * The function uses a TypeScript ignore comment to bypass type checking for the `Input.virtualClick` method.
     */
    function VirtualClick(buttonName) {
        try {
            if (KDX.isMV() && !KDX.any(Input['virtualClick'])) {
                _extendMvInput();
            }
            /* @ts-ignore */
            Input.virtualClick(buttonName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KInput.VirtualClick = VirtualClick;
    function IsCancel() {
        return Input.isTriggered('cancel') || TouchInput.isCancelled();
    }
    KInput.IsCancel = IsCancel;
    function _extendMvInput() {
        //╒═════════════════════════════════════════════════════════════════════════╛
        // ■ Input.ts
        //╒═════════════════════════════════════════════════════════════════════════╛
        //---------------------------------------------------------------------------
        (() => {
            //@[DEFINES]
            const _ = Input;
            _['virtualClick'] = function (buttonName) {
                this._virtualButton = buttonName;
            };
            //@[ALIAS]
            const ALIAS__clear = _.clear;
            _.clear = function () {
                ALIAS__clear.call(this);
                this._virtualButton = null;
            };
            //@[ALIAS]
            const ALIAS__update = _.update;
            _.update = function () {
                ALIAS__update.call(this);
                try {
                    if (KString.any(this._virtualButton)) {
                        this._latestButton = this._virtualButton;
                        this._pressedTime = 0;
                        this._virtualButton = null;
                    }
                }
                catch (error) {
                    console.warn(error);
                }
            };
        })();
        // ■ END Input.ts
        //---------------------------------------------------------------------------
    }
    function _extend() {
        // * If Input is extended by KDCore or KDX
        if (KDX.any(Input['KeyMapperPKD']))
            return;
        try {
            let KeyMapperPKD = {};
            //Numbers
            for (let i = 48; i <= 57; i++) {
                KeyMapperPKD[i] = String.fromCharCode(i);
            }
            //Letters Upper
            for (let i = 65; i <= 90; i++) {
                KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
            }
            //Letters Lower
            for (let i = 97; i <= 122; i++) {
                KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
            }
            Input['KeyMapperPKD'] = KeyMapperPKD;
        }
        catch (error) {
            console.warn(error);
        }
    }
    function _onKeyDown(event) {
        try {
            _extend();
            /* @ts-ignore */
            let symbol = Input.KeyMapperPKD[event.keyCode];
            if (symbol) {
                /* @ts-ignore */
                Input._currentState[symbol] = true;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    KInput._onKeyDown = _onKeyDown;
    function _onKeyUp(event) {
        try {
            _extend();
            /* @ts-ignore */
            let symbol = Input.KeyMapperPKD[event.keyCode];
            if (symbol) {
                /* @ts-ignore */
                Input._currentState[symbol] = false;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    KInput._onKeyUp = _onKeyUp;
})(KInput || (KInput = {}));
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Input.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Input;
    //@[ALIAS]
    /* @ts-ignore */
    const ALIAS___onKeyDown = _._onKeyDown;
    /* @ts-ignore */
    _._onKeyDown = function (event) {
        let t = this;
        ALIAS___onKeyDown.call(this, event);
        try {
            if (Input.keyMapper[event.keyCode]) {
                return;
            }
            KInput._onKeyDown(event);
        }
        catch (error) {
            console.warn(error);
        }
    };
    //@[ALIAS]
    /* @ts-ignore */
    const ALIAS___onKeyUp = _._onKeyUp;
    /* @ts-ignore */
    _._onKeyUp = function (event) {
        let t = this;
        ALIAS___onKeyUp.call(this, event);
        try {
            if (Input.keyMapper[event.keyCode]) {
                return;
            }
            KInput._onKeyUp(event);
        }
        catch (error) {
            console.warn(error);
        }
    };
})();
// ■ END Input.ts
//---------------------------------------------------------------------------
var KPoint;
(function (KPoint) {
    /**
     * Clones a given Point object.
     *
     * @param {IPoint} p - The Point object to be cloned.
     * @returns {IPoint} A new Point object with the same x and y coordinates as the input.
     */
    function Clone(p) {
        return new PIXI.Point(p.x, p.y);
    }
    KPoint.Clone = Clone;
    /**
     * Checks if two Point objects have the same coordinates.
     *
     * @param {IPoint} p1 - The first Point object.
     * @param {IPoint} p2 - The second Point object.
     * @returns {boolean} True if both points have the same coordinates, false otherwise.
     */
    function IsSame(p1, p2) {
        return p1.x == p2.x && p1.y == p2.y;
    }
    KPoint.IsSame = IsSame;
    /**
     * Converts a Point object to a string representation.
     *
     * @param {IPoint} p - The Point object to be converted.
     * @returns {string} A string representation of the Point object.
     */
    function ToPrint(p) {
        return `(${p.x}, ${p.y})`;
    }
    KPoint.ToPrint = ToPrint;
    /**
     * Converts a Point object from screen coordinates to map coordinates.
     *
     * @param {IPoint} p - The Point object in screen coordinates.
     * @returns {IPoint} A new Point object in map coordinates.
     */
    function ConvertFromScreenToMap(p) {
        return new PIXI.Point($gameMap.canvasToMapX(p.x), $gameMap.canvasToMapY(p.y));
    }
    KPoint.ConvertFromScreenToMap = ConvertFromScreenToMap;
    /**
     * Converts a Point object from map coordinates to screen coordinates.
     *
     * @param {IPoint} p - The Point object in map coordinates.
     * @returns {IPoint} A new Point object in screen coordinates.
     */
    function ConvertFromMapToScreen(p) {
        let x = $gameMap.adjustX(p.x);
        let tw = $gameMap.tileWidth();
        x = Math.round(x * tw + tw / 2);
        let y = $gameMap.adjustY(p.y);
        let th = $gameMap.tileHeight();
        y = Math.round(y * th + th);
        return new PIXI.Point(x, y);
    }
    KPoint.ConvertFromMapToScreen = ConvertFromMapToScreen;
    /**
     * Rounds the coordinates of a Point object to the nearest integer.
     *
     * @param {IPoint} p - The Point object to be rounded.
     * @returns {IPoint} A new Point object with rounded coordinates.
     */
    function Round(p) {
        return new PIXI.Point(Math.round(p.x), Math.round(p.y));
    }
    KPoint.Round = Round;
    /**
     * Calculates the distance between two Point objects.
     *
     * @param {IPoint} p1 - The first Point object.
     * @param {IPoint} p2 - The second Point object.
     * @returns {number} The distance between the two points.
     */
    function Distance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }
    KPoint.Distance = Distance;
    /**
     * Checks if a Point object is inside a given rectangle.
     *
     * @param {IPoint} p - The Point object to check.
     * @param {PIXI.Rectangle} rect - The rectangle to check against.
     * @returns {boolean} True if the point is inside the rectangle, false otherwise.
     */
    function IsInsideRect(p, rect) {
        return rect.contains(p.x, p.y);
    }
    KPoint.IsInsideRect = IsInsideRect;
    /**
     * Checks if a Point object is inside a given circle.
     *
     * @param {IPoint} p - The Point object to check.
     * @param {IPoint} center - The center of the circle.
     * @param {number} radius - The radius of the circle.
     * @returns {boolean} True if the point is inside the circle, false otherwise.
     */
    function IsInsideCircle(p, center, radius) {
        return Distance(p, center) <= radius;
    }
    KPoint.IsInsideCircle = IsInsideCircle;
})(KPoint || (KPoint = {}));
var KUtils;
(function (KUtils) {
    /**
     * Calls a specified callback function after a given delay.
     *
     * @param callback - The function to be called after the delay.
     * @param delay - The delay in milliseconds before the callback is executed.
     * @returns The ID of the timeout, which can be used to cancel the timeout with clearTimeout.
     *
     * @throws Will log a warning to the console if the callback throws an error.
     */
    function CallWithDelay(callback, delay) {
        if (!callback)
            return;
        return setTimeout(() => {
            try {
                callback();
            }
            catch (error) {
                console.warn(error);
            }
        }, delay);
    }
    KUtils.CallWithDelay = CallWithDelay;
    function IsMapScene() {
        return SceneManager._scene instanceof Scene_Map;
    }
    KUtils.IsMapScene = IsMapScene;
    function IsBattleScene() {
        return SceneManager._scene instanceof Scene_Battle;
    }
    KUtils.IsBattleScene = IsBattleScene;
    function StartCEIfValid(commonEventId) {
        try {
            if (commonEventId > 0 && $dataCommonEvents[commonEventId]) {
                $gameTemp.reserveCommonEvent(commonEventId);
                return true;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    KUtils.StartCEIfValid = StartCEIfValid;
    function IsValidSelfSwitch(selfSwitch) {
        try {
            return ['A', 'B', 'C', 'D'].indexOf(selfSwitch) !== -1;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    KUtils.IsValidSelfSwitch = IsValidSelfSwitch;
    function IsChanceIsPassed(chance) {
        try {
            if (chance > 1) {
                chance = chance / 100.0;
            }
            if (chance < 0) {
                chance = 0;
            }
            if (chance > 1) {
                chance = 1;
            }
            return Math.random() < chance;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    KUtils.IsChanceIsPassed = IsChanceIsPassed;
})(KUtils || (KUtils = {}));
var KDX;
(function (KDX) {
    /**
 * A class that can smoothly change a parameter.
 * Works in a chainable method style.
 *
 * Example:
 * ```typescript
 * const changer = new Changer(someSprite);
 * changer.change('opacity').from(255)
 *        .to(0).step(5).speed(1).delay(30).repeat(4).reverse()
 *        .start().done(() => console.log('done'));
 * changer.update();
 * ```
 */
    class Changer {
        constructor(obj) {
            this.obj = obj;
            this._field = null;
            this._speed = 1;
            this._step = 1;
            this._from = 0;
            this._to = 0;
            this._thread = null;
            this._orienation = true;
            this._delay = 0;
            this._changer = null;
            this._isRepeat = false;
            this._onDoneMethod = null;
            this._isPrepared = false;
            this._isBeenStarted = false;
            this._repeatCount = null;
            this._isReverse = false;
            this._delayThread = null;
        }
        static Opacity(sprite, from, to, step, onDone = null, delay = 0) {
            const changer = new Changer(sprite);
            changer.change('opacity').from(from).to(to).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        static MoveX(obj, from, to, step, onDone = null, delay = 0) {
            const changer = new Changer(obj);
            changer.change('x').from(from).to(to).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        static MoveY(obj, from, to, step, onDone = null, delay = 0) {
            const changer = new Changer(obj);
            changer.change('y').from(from).to(to).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        static Appear(sprite, step, onDone = null, delay = 0) {
            const changer = new Changer(sprite);
            changer.change('opacity').from(sprite.opacity).to(255).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        static Disappear(sprite, step, onDone = null, delay = 0) {
            const changer = new Changer(sprite);
            changer.change('opacity').from(sprite.opacity).to(0).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        /**
         * Starts the changer.
         */
        start() {
            if (!this._field || this._from === this._to)
                return this;
            if (this._delay > 0) {
                this._delayThread = new KDX.TimedUpdate(this._delay, this._startThread.bind(this));
                this._delayThread.once();
            }
            else {
                this._startThread();
            }
            return this;
        }
        /**
         * Checks if the changer has started.
         */
        isStarted() {
            return !!this._thread || !!this._delayThread;
        }
        /**
         * Sets the starting value.
         */
        from(value) {
            this._from = value;
            return this;
        }
        /**
         * Sets the target value.
         */
        to(value) {
            this._to = value;
            return this;
        }
        /**
         * Sets the step value for each update.
         */
        step(value) {
            this._step = value;
            return this;
        }
        /**
         * Sets the speed (frames per update).
         */
        speed(value) {
            this._speed = value;
            return this;
        }
        /**
         * Sets the field to be changed.
         */
        change(field) {
            this._field = field;
            return this;
        }
        /**
         * Repeats the changer. If no count is specified or <= 0, it repeats indefinitely.
         */
        repeat(count = 0) {
            this._repeatCount = count <= 0 ? null : count;
            this._isRepeat = true;
            this._changer = null;
            return this;
        }
        /**
         * Reverses the `from` and `to` values after each repeat (works only with repeat >= 2).
         */
        reverse() {
            this._isReverse = true;
            return this;
        }
        /**
         * Checks if the changer has completed.
         */
        isDone() {
            if (!this._isPrepared)
                return false;
            if (!this._orienation) {
                return this.value() <= this._to;
            }
            else {
                return this.value() >= this._to;
            }
        }
        /**
         * Gets the current value of the field being changed.
         */
        value() {
            return this.obj[this._field];
        }
        /**
         * Stops the changer.
         */
        stop() {
            this._thread = null;
            this._delayThread = null;
            if (!this._changer)
                this._callDoneMethod();
        }
        /**
         * Sets a delay before starting the changer.
         */
        delay(value) {
            this._delay = value;
            return this;
        }
        /**
         * Chains another changer to execute after this one.
         * Not compatible with repeat.
         */
        then(changer) {
            this._isRepeat = false;
            this._changer = changer;
            return this;
        }
        /**
         * Sets a method to be executed when the changer is done.
         */
        done(method) {
            this._onDoneMethod = method;
            return this;
        }
        /**
         * Manually performs a single step of the changer.
         */
        makeStep() {
            if (!this.isStarted())
                this._prepare();
            this._makeStep();
            return this;
        }
        /**
         * Updates the changer. Should be called every frame.
         */
        update() {
            var _a;
            if (this.isStarted()) {
                if (this._delay > 0)
                    (_a = this._delayThread) === null || _a === void 0 ? void 0 : _a.update();
                if (this._thread)
                    this._updateMainThread();
            }
            else if (this._isBeenStarted) {
                if (this._changer)
                    this._updateChainedChanger();
            }
        }
        // Private methods
        _prepare() {
            if (!this._field)
                return;
            this._orienation = this._from < this._to;
            if (!this._orienation)
                this._step *= -1;
            this.obj[this._field] = this._from;
            this._isPrepared = true;
        }
        _makeStep() {
            if (this.isDone())
                return;
            let value = this.value();
            value += this._step;
            this.obj[this._field] = value;
        }
        _startThread() {
            this._prepare();
            if (this.isDone())
                return;
            this._thread = new KDX.TimedUpdate(this._speed, this._makeStep.bind(this));
            this._isBeenStarted = true;
        }
        _updateChainedChanger() {
            if (this._changer.isStarted()) {
                this._changer.update();
                if (this._changer.isDone()) {
                    this._callDoneMethod();
                    this._changer.stop();
                    this._changer = null;
                }
            }
            else {
                this._changer.start();
            }
        }
        _restart() {
            if (!this._isCanRepeatMore())
                return;
            if (!this._repeatCount)
                this._callDoneMethod();
            if (this._isReverse)
                this._swapFromTo();
            this._prepare();
            this.start();
        }
        _swapFromTo() {
            const temp = this._from;
            this._from = this._to;
            this._to = temp;
            this._step *= -1;
        }
        _callDoneMethod() {
            if (this._onDoneMethod)
                this._onDoneMethod();
        }
        _isCanRepeatMore() {
            if (!this._repeatCount)
                return true;
            this._repeatCount--;
            if (this._repeatCount <= 0) {
                this.stop();
                return false;
            }
            return true;
        }
        _updateMainThread() {
            this._thread.update();
            if (this.isDone()) {
                if (this._isRepeat) {
                    this._restart();
                }
                else {
                    if (this._changer)
                        this._updateChainedChanger();
                    this.stop();
                }
            }
        }
    }
    KDX.Changer = Changer;
})(KDX || (KDX = {}));
var KDX;
(function (KDX) {
    class ParamLoader {
        /**
         * Creates an instance of ParamLoader.
         * @param _pluginName The name of the plugin.
         */
        constructor(_pluginName) {
            this._pluginName = _pluginName;
            this._paramsRaw = this.getPluginParametersByRoot(this._pluginName);
            this._params = KDX.ParamParser.ParseParameters(this._paramsRaw, this._pluginName);
        }
        /**
         * Gets the plugin parameters by the root name.
         * @param rootName The root name of the plugin.
         * @returns The plugin parameters if found, otherwise calls PluginManager.parameters.
         */
        getPluginParametersByRoot(rootName) {
            /* @ts-ignore */
            let allParametersRaw = PluginManager._parameters;
            for (const property in allParametersRaw) {
                if (allParametersRaw.hasOwnProperty(property)) {
                    const pluginParameters = allParametersRaw[property];
                    if (pluginParameters.hasOwnProperty(rootName)) {
                        return pluginParameters;
                    }
                }
            }
            return PluginManager.parameters(rootName);
        }
        /**
         * Checks if the parameters are loaded.
         * @returns True if the parameters are loaded, otherwise false.
         */
        isLoaded() {
            return !!this._paramsRaw && this._paramsRaw.hasOwnProperty(this._pluginName);
        }
        /**
         * Checks if a parameter exists.
         * @param paramName The name of the parameter.
         * @returns True if the parameter exists, otherwise false.
         */
        isHasParameter(paramName) {
            return this._params.hasOwnProperty(paramName);
        }
        /**
         * Gets the value of a parameter.
         * @param paramName The name of the parameter.
         * @param def The default value if the parameter is not found.
         * @returns The value of the parameter or the default value.
         */
        getParam(paramName, def) {
            if (this.isHasParameter(paramName)) {
                const value = this._params[paramName];
                if (value != null)
                    return value;
            }
            return def;
        }
    }
    KDX.ParamLoader = ParamLoader;
})(KDX || (KDX = {}));
var KDX;
(function (KDX) {
    let ParamParser;
    (function (ParamParser) {
        let _ppNameToParseNext = "";
        let _pluginName = "";
        /**
         * Parses the parameters from the plugin.
         * @param paramSet The raw parameter set.
         * @returns The parsed parameters.
         */
        function ParseParameters(paramSet, _pluginNameForInfo) {
            _pluginName = _pluginNameForInfo;
            const params = {};
            for (const key in paramSet) {
                if (paramSet.hasOwnProperty(key)) {
                    _ppNameToParseNext = key;
                    const clearKey = parseKey(key);
                    const typeKey = parseKeyType(key);
                    params[clearKey] = parseParamItem(typeKey, paramSet[key]);
                }
            }
            return params;
        }
        ParamParser.ParseParameters = ParseParameters;
        /**
         * Parses the key to remove the type.
         * @param keyRaw The raw key.
         * @returns The parsed key.
         */
        function parseKey(keyRaw) {
            return keyRaw.split(":")[0];
        }
        /**
         * Parses the key to get the type.
         * @param keyRaw The raw key.
         * @returns The type of the key.
         */
        function parseKeyType(keyRaw) {
            return keyRaw.split(":")[1];
        }
        /**
         * Writes a detailed error message to the console.
         */
        function writeDetailedError() {
            try {
                if (!KString.any(_ppNameToParseNext))
                    return;
                console.warn(`Please, check Plugin Parameter ${_ppNameToParseNext} in plugin ${_pluginName}`);
            }
            catch (e) {
                console.warn(e);
            }
        }
        /**
         * Parses a parameter item based on its type.
         * @param type The type of the parameter.
         * @param item The parameter item.
         * @returns The parsed parameter item.
         */
        function parseParamItem(type, item) {
            if (!type)
                return item;
            try {
                switch (type) {
                    case "int":
                    case "i":
                        return Number(item);
                    case "intA":
                        return parseArray(item, "int");
                    case "bool":
                    case "b":
                    case "e":
                        return eval(item);
                    case "struct":
                    case "s":
                        return parseStruct(item);
                    case "structA":
                        return parseStructArray(item);
                    case "str":
                        return item;
                    case "strA":
                        return parseArray(item, "str");
                    case "note":
                        return parseNote(item);
                    case "json":
                    case "j":
                        return parseJson(item);
                    case "jA":
                        return parseArray(item, "json");
                    default:
                        return item;
                }
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return item;
            }
        }
        /**
         * Parses an array of items.
         * @param items The items to parse.
         * @param type The type of the items.
         * @returns The parsed array.
         */
        function parseArray(items, type) {
            try {
                const elements = [];
                const parsed = JsonEx.parse(items);
                for (const p of parsed) {
                    try {
                        elements.push(parseParamItem(type, p));
                    }
                    catch (e) {
                        console.warn(e);
                    }
                }
                return elements;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return [];
            }
        }
        /**
         * Parses a struct item.
         * @param item The item to parse.
         * @returns The parsed struct.
         */
        function parseStruct(item) {
            try {
                if (!item || !KString.any(item))
                    return null;
                const parsed = JsonEx.parse(item);
                return parsed ? ParseParameters(parsed, _pluginName) : null;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return null;
            }
        }
        /**
         * Parses an array of struct items.
         * @param items The items to parse.
         * @returns The parsed array of structs.
         */
        function parseStructArray(items) {
            try {
                const elements = [];
                const parsed = JsonEx.parse(items);
                for (const p of parsed) {
                    try {
                        elements.push(parseStruct(p));
                    }
                    catch (e) {
                        console.warn(e);
                        writeDetailedError();
                    }
                }
                return elements;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return [];
            }
        }
        /**
         * Parses a note item.
         * @param item The item to parse.
         * @returns The parsed note.
         */
        function parseNote(item) {
            try {
                const parsed = JsonEx.parse(item);
                return parsed ? parsed : item;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return item;
            }
        }
        /**
         * Parses a JSON item.
         * @param item The item to parse.
         * @returns The parsed JSON.
         */
        function parseJson(item) {
            try {
                const json = {};
                const parsed = JsonEx.parse(item);
                const elements = parsed.split('\n');
                for (const element of elements) {
                    const cx = `{${element}}`;
                    try {
                        const item = JsonEx.parse(cx);
                        for (const key in item) {
                            if (item.hasOwnProperty(key)) {
                                json[key] = item[key];
                            }
                        }
                    }
                    catch (e) {
                        console.warn(`Parameter ${element} has syntax errors, ignored`);
                    }
                }
                return json;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return null; // To return default value
            }
        }
    })(ParamParser = KDX.ParamParser || (KDX.ParamParser = {}));
})(KDX || (KDX = {}));
var KDX;
(function (KDX) {
    class TimedUpdate {
        /**
         * Creates an instance of TimedUpdate.
         * @param interval The interval in frames.
         * @param method The method to call on update.
         */
        constructor(interval, method) {
            this.interval = interval;
            this.method = method;
            this._timer = 0;
            this._once = false;
        }
        /**
         * Sets the number of repeats and the callback after completion.
         * @param repeatsLeft The number of repeats left.
         * @param afterCallback The callback to call after completion.
         */
        setAfter(repeatsLeft, afterCallback) {
            this._repeatsLeft = repeatsLeft;
            this._afterCallback = afterCallback;
        }
        /**
         * Updates the timer and calls the method if the interval is reached.
         */
        update() {
            if (this.interval == null)
                return;
            if (this._timer++ >= this.interval) {
                this.call();
                this._timer = 0;
                if (this._repeatsLeft != null) {
                    this._repeatsLeft -= 1;
                    if (this._repeatsLeft <= 0) {
                        if (this._afterCallback)
                            this._afterCallback();
                    }
                }
                if (this._once)
                    this.stop();
            }
        }
        /**
         * Sets the update to be called only once.
         */
        once() {
            this._once = true;
        }
        /**
         * Sets the method to call on update.
         * @param method The method to call on update.
         */
        onUpdate(method) {
            this.method = method;
        }
        /**
         * Stops the update.
         */
        stop() {
            this.interval = null;
        }
        /**
         * Checks if the update is still active.
         * @returns True if the update is active, otherwise false.
         */
        isAlive() {
            return this.interval != null;
        }
        /**
         * Randomizes the interval within a given range.
         * @param min The minimum value to add to the interval.
         * @param max The maximum value to add to the interval.
         */
        applyTimeRange(min, max) {
            if (!this.isAlive())
                return;
            const value = KNumber.random(min, max);
            this.interval += value;
        }
        /**
         * Calls the method.
         */
        call() {
            try {
                if (this.method)
                    this.method();
            }
            catch (e) {
                console.warn(e);
            }
        }
    }
    KDX.TimedUpdate = TimedUpdate;
})(KDX || (KDX = {}));


/**
 *    ____       _   _     _____ _           _ _                _         
 *   |  _ \ __ _| |_| |__ |  ___(_)_ __   __| (_)_ __   __ _   (_)___     
 *   | |_) / _` | __| '_ \| |_  | | '_ \ / _` | | '_ \ / _` |  | / __|    
 *   |  __/ (_| | |_| | | |  _| | | | | | (_| | | | | | (_| |_ | \__ \    
 *   |_|   \__,_|\__|_| |_|_|   |_|_| |_|\__,_|_|_| |_|\__, (_)/ |___/    
 *                                                     |___/ |__/         
 *   https://github.com/qiao/PathFinding.js
 */

!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.PF=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports = _dereq_('./lib/heap');

},{"./lib/heap":2}],2:[function(_dereq_,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
    module.exports = Heap;
  } else {
    window.Heap = Heap;
  }

}).call(this);

},{}],3:[function(_dereq_,module,exports){
var DiagonalMovement = {
    Always: 1,
    Never: 2,
    IfAtMostOneObstacle: 3,
    OnlyWhenNoObstacles: 4
};

module.exports = DiagonalMovement;
},{}],4:[function(_dereq_,module,exports){
var Node = _dereq_('./Node');
var DiagonalMovement = _dereq_('./DiagonalMovement');

/**
 * The Grid class, which serves as the encapsulation of the layout of the nodes.
 * @constructor
 * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix
 * @param {number} height Number of rows of the grid.
 * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix
 *     representing the walkable status of the nodes(0 or false for walkable).
 *     If the matrix is not supplied, all the nodes will be walkable.  */
function Grid(width_or_matrix, height, matrix) {
    var width;

    if (typeof width_or_matrix !== 'object') {
        width = width_or_matrix;
    } else {
        height = width_or_matrix.length;
        width = width_or_matrix[0].length;
        matrix = width_or_matrix;
    }

    /**
     * The number of columns of the grid.
     * @type number
     */
    this.width = width;
    /**
     * The number of rows of the grid.
     * @type number
     */
    this.height = height;

    /**
     * A 2D array of nodes.
     */
    this.nodes = this._buildNodes(width, height, matrix);
}

/**
 * Build and return the nodes.
 * @private
 * @param {number} width
 * @param {number} height
 * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing
 *     the walkable status of the nodes.
 * @see Grid
 */
Grid.prototype._buildNodes = function(width, height, matrix) {
    var i, j,
        nodes = new Array(height);

    for (i = 0; i < height; ++i) {
        nodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            nodes[i][j] = new Node(j, i);
        }
    }


    if (matrix === undefined) {
        return nodes;
    }

    if (matrix.length !== height || matrix[0].length !== width) {
        throw new Error('Matrix size does not fit');
    }

    for (i = 0; i < height; ++i) {
        for (j = 0; j < width; ++j) {
            if (matrix[i][j]) {
                // 0, false, null will be walkable
                // while others will be un-walkable
                nodes[i][j].walkable = false;
            }
        }
    }

    return nodes;
};


Grid.prototype.getNodeAt = function(x, y) {
    return this.nodes[y][x];
};


/**
 * Determine whether the node at the given position is walkable.
 * (Also returns false if the position is outside the grid.)
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @return {boolean} - The walkability of the node.
 */
Grid.prototype.isWalkableAt = function(x, y) {
    return this.isInside(x, y) && this.nodes[y][x].walkable;
};


/**
 * Determine whether the position is inside the grid.
 * XXX: `grid.isInside(x, y)` is wierd to read.
 * It should be `(x, y) is inside grid`, but I failed to find a better
 * name for this method.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
Grid.prototype.isInside = function(x, y) {
    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
};


/**
 * Set whether the node on the given position is walkable.
 * NOTE: throws exception if the coordinate is not inside the grid.
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @param {boolean} walkable - Whether the position is walkable.
 */
Grid.prototype.setWalkableAt = function(x, y, walkable) {
    this.nodes[y][x].walkable = walkable;
};


/**
 * Get the neighbors of the given node.
 *
 *     offsets      diagonalOffsets:
 *  +---+---+---+    +---+---+---+
 *  |   | 0 |   |    | 0 |   | 1 |
 *  +---+---+---+    +---+---+---+
 *  | 3 |   | 1 |    |   |   |   |
 *  +---+---+---+    +---+---+---+
 *  |   | 2 |   |    | 3 |   | 2 |
 *  +---+---+---+    +---+---+---+
 *
 *  When allowDiagonal is true, if offsets[i] is valid, then
 *  diagonalOffsets[i] and
 *  diagonalOffsets[(i + 1) % 4] is valid.
 * @param {Node} node
 * @param {DiagonalMovement} diagonalMovement
 */
Grid.prototype.getNeighbors = function(node, diagonalMovement) {
    var x = node.x,
        y = node.y,
        neighbors = [],
        s0 = false, d0 = false,
        s1 = false, d1 = false,
        s2 = false, d2 = false,
        s3 = false, d3 = false,
        nodes = this.nodes;

    // ↑
    if (this.isWalkableAt(x, y - 1)) {
        neighbors.push(nodes[y - 1][x]);
        s0 = true;
    }
    // →
    if (this.isWalkableAt(x + 1, y)) {
        neighbors.push(nodes[y][x + 1]);
        s1 = true;
    }
    // ↓
    if (this.isWalkableAt(x, y + 1)) {
        neighbors.push(nodes[y + 1][x]);
        s2 = true;
    }
    // ←
    if (this.isWalkableAt(x - 1, y)) {
        neighbors.push(nodes[y][x - 1]);
        s3 = true;
    }

    if (diagonalMovement === DiagonalMovement.Never) {
        return neighbors;
    }

    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        d0 = s3 && s0;
        d1 = s0 && s1;
        d2 = s1 && s2;
        d3 = s2 && s3;
    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {
        d0 = s3 || s0;
        d1 = s0 || s1;
        d2 = s1 || s2;
        d3 = s2 || s3;
    } else if (diagonalMovement === DiagonalMovement.Always) {
        d0 = true;
        d1 = true;
        d2 = true;
        d3 = true;
    } else {
        throw new Error('Incorrect value of diagonalMovement');
    }

    // ↖
    if (d0 && this.isWalkableAt(x - 1, y - 1)) {
        neighbors.push(nodes[y - 1][x - 1]);
    }
    // ↗
    if (d1 && this.isWalkableAt(x + 1, y - 1)) {
        neighbors.push(nodes[y - 1][x + 1]);
    }
    // ↘
    if (d2 && this.isWalkableAt(x + 1, y + 1)) {
        neighbors.push(nodes[y + 1][x + 1]);
    }
    // ↙
    if (d3 && this.isWalkableAt(x - 1, y + 1)) {
        neighbors.push(nodes[y + 1][x - 1]);
    }

    return neighbors;
};


/**
 * Get a clone of this grid.
 * @return {Grid} Cloned grid.
 */
Grid.prototype.clone = function() {
    var i, j,

        width = this.width,
        height = this.height,
        thisNodes = this.nodes,

        newGrid = new Grid(width, height),
        newNodes = new Array(height);

    for (i = 0; i < height; ++i) {
        newNodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
        }
    }

    newGrid.nodes = newNodes;

    return newGrid;
};

module.exports = Grid;

},{"./DiagonalMovement":3,"./Node":6}],5:[function(_dereq_,module,exports){
/**
 * @namespace PF.Heuristic
 * @description A collection of heuristic functions.
 */
module.exports = {

  /**
   * Manhattan distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} dx + dy
   */
  manhattan: function(dx, dy) {
      return dx + dy;
  },

  /**
   * Euclidean distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy)
   */
  euclidean: function(dx, dy) {
      return Math.sqrt(dx * dx + dy * dy);
  },

  /**
   * Octile distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy) for grids
   */
  octile: function(dx, dy) {
      var F = Math.SQRT2 - 1;
      return (dx < dy) ? F * dx + dy : F * dy + dx;
  },

  /**
   * Chebyshev distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} max(dx, dy)
   */
  chebyshev: function(dx, dy) {
      return Math.max(dx, dy);
  }

};

},{}],6:[function(_dereq_,module,exports){
/**
 * A node in grid. 
 * This class holds some basic information about a node and custom 
 * attributes may be added, depending on the algorithms' needs.
 * @constructor
 * @param {number} x - The x coordinate of the node on the grid.
 * @param {number} y - The y coordinate of the node on the grid.
 * @param {boolean} [walkable] - Whether this node is walkable.
 */
function Node(x, y, walkable) {
    /**
     * The x coordinate of the node on the grid.
     * @type number
     */
    this.x = x;
    /**
     * The y coordinate of the node on the grid.
     * @type number
     */
    this.y = y;
    /**
     * Whether this node can be walked through.
     * @type boolean
     */
    this.walkable = (walkable === undefined ? true : walkable);
}

module.exports = Node;

},{}],7:[function(_dereq_,module,exports){
/**
 * Backtrace according to the parent records and return the path.
 * (including both start and end nodes)
 * @param {Node} node End node
 * @return {Array<Array<number>>} the path
 */
function backtrace(node) {
    var path = [[node.x, node.y]];
    while (node.parent) {
        node = node.parent;
        path.push([node.x, node.y]);
    }
    return path.reverse();
}
exports.backtrace = backtrace;

/**
 * Backtrace from start and end node, and return the path.
 * (including both start and end nodes)
 * @param {Node}
 * @param {Node}
 */
function biBacktrace(nodeA, nodeB) {
    var pathA = backtrace(nodeA),
        pathB = backtrace(nodeB);
    return pathA.concat(pathB.reverse());
}
exports.biBacktrace = biBacktrace;

/**
 * Compute the length of the path.
 * @param {Array<Array<number>>} path The path
 * @return {number} The length of the path
 */
function pathLength(path) {
    var i, sum = 0, a, b, dx, dy;
    for (i = 1; i < path.length; ++i) {
        a = path[i - 1];
        b = path[i];
        dx = a[0] - b[0];
        dy = a[1] - b[1];
        sum += Math.sqrt(dx * dx + dy * dy);
    }
    return sum;
}
exports.pathLength = pathLength;


/**
 * Given the start and end coordinates, return all the coordinates lying
 * on the line formed by these coordinates, based on Bresenham's algorithm.
 * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
 * @param {number} x0 Start x coordinate
 * @param {number} y0 Start y coordinate
 * @param {number} x1 End x coordinate
 * @param {number} y1 End y coordinate
 * @return {Array<Array<number>>} The coordinates on the line
 */
function interpolate(x0, y0, x1, y1) {
    var abs = Math.abs,
        line = [],
        sx, sy, dx, dy, err, e2;

    dx = abs(x1 - x0);
    dy = abs(y1 - y0);

    sx = (x0 < x1) ? 1 : -1;
    sy = (y0 < y1) ? 1 : -1;

    err = dx - dy;

    while (true) {
        line.push([x0, y0]);

        if (x0 === x1 && y0 === y1) {
            break;
        }
        
        e2 = 2 * err;
        if (e2 > -dy) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }

    return line;
}
exports.interpolate = interpolate;


/**
 * Given a compressed path, return a new path that has all the segments
 * in it interpolated.
 * @param {Array<Array<number>>} path The path
 * @return {Array<Array<number>>} expanded path
 */
function expandPath(path) {
    var expanded = [],
        len = path.length,
        coord0, coord1,
        interpolated,
        interpolatedLen,
        i, j;

    if (len < 2) {
        return expanded;
    }

    for (i = 0; i < len - 1; ++i) {
        coord0 = path[i];
        coord1 = path[i + 1];

        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
        interpolatedLen = interpolated.length;
        for (j = 0; j < interpolatedLen - 1; ++j) {
            expanded.push(interpolated[j]);
        }
    }
    expanded.push(path[len - 1]);

    return expanded;
}
exports.expandPath = expandPath;


/**
 * Smoothen the give path.
 * The original path will not be modified; a new path will be returned.
 * @param {PF.Grid} grid
 * @param {Array<Array<number>>} path The path
 */
function smoothenPath(grid, path) {
    var len = path.length,
        x0 = path[0][0],        // path start x
        y0 = path[0][1],        // path start y
        x1 = path[len - 1][0],  // path end x
        y1 = path[len - 1][1],  // path end y
        sx, sy,                 // current start coordinate
        ex, ey,                 // current end coordinate
        newPath,
        i, j, coord, line, testCoord, blocked;

    sx = x0;
    sy = y0;
    newPath = [[sx, sy]];

    for (i = 2; i < len; ++i) {
        coord = path[i];
        ex = coord[0];
        ey = coord[1];
        line = interpolate(sx, sy, ex, ey);

        blocked = false;
        for (j = 1; j < line.length; ++j) {
            testCoord = line[j];

            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                blocked = true;
                break;
            }
        }
        if (blocked) {
            lastValidCoord = path[i - 1];
            newPath.push(lastValidCoord);
            sx = lastValidCoord[0];
            sy = lastValidCoord[1];
        }
    }
    newPath.push([x1, y1]);

    return newPath;
}
exports.smoothenPath = smoothenPath;


/**
 * Compress a path, remove redundant nodes without altering the shape
 * The original path is not modified
 * @param {Array<Array<number>>} path The path
 * @return {Array<Array<number>>} The compressed path
 */
function compressPath(path) {

    // nothing to compress
    if(path.length < 3) {
        return path;
    }

    var compressed = [],
        sx = path[0][0], // start x
        sy = path[0][1], // start y
        px = path[1][0], // second point x
        py = path[1][1], // second point y
        dx = px - sx, // direction between the two points
        dy = py - sy, // direction between the two points
        lx, ly,
        ldx, ldy,
        sq, i;

    // normalize the direction
    sq = Math.sqrt(dx*dx + dy*dy);
    dx /= sq;
    dy /= sq;

    // start the new path
    compressed.push([sx,sy]);

    for(i = 2; i < path.length; i++) {

        // store the last point
        lx = px;
        ly = py;

        // store the last direction
        ldx = dx;
        ldy = dy;

        // next point
        px = path[i][0];
        py = path[i][1];

        // next direction
        dx = px - lx;
        dy = py - ly;

        // normalize
        sq = Math.sqrt(dx*dx + dy*dy);
        dx /= sq;
        dy /= sq;

        // if the direction has changed, store the point
        if ( dx !== ldx || dy !== ldy ) {
            compressed.push([lx,ly]);
        }
    }

    // store the last point
    compressed.push([px,py]);

    return compressed;
}
exports.compressPath = compressPath;

},{}],8:[function(_dereq_,module,exports){
module.exports = {
    'Heap'                      : _dereq_('heap'),
    'Node'                      : _dereq_('./core/Node'),
    'Grid'                      : _dereq_('./core/Grid'),
    'Util'                      : _dereq_('./core/Util'),
    'DiagonalMovement'          : _dereq_('./core/DiagonalMovement'),
    'Heuristic'                 : _dereq_('./core/Heuristic'),
    'AStarFinder'               : _dereq_('./finders/AStarFinder'),
    'BestFirstFinder'           : _dereq_('./finders/BestFirstFinder'),
    'BreadthFirstFinder'        : _dereq_('./finders/BreadthFirstFinder'),
    'DijkstraFinder'            : _dereq_('./finders/DijkstraFinder'),
    'BiAStarFinder'             : _dereq_('./finders/BiAStarFinder'),
    'BiBestFirstFinder'         : _dereq_('./finders/BiBestFirstFinder'),
    'BiBreadthFirstFinder'      : _dereq_('./finders/BiBreadthFirstFinder'),
    'BiDijkstraFinder'          : _dereq_('./finders/BiDijkstraFinder'),
    'IDAStarFinder'             : _dereq_('./finders/IDAStarFinder'),
    'JumpPointFinder'           : _dereq_('./finders/JumpPointFinder'),
};

},{"./core/DiagonalMovement":3,"./core/Grid":4,"./core/Heuristic":5,"./core/Node":6,"./core/Util":7,"./finders/AStarFinder":9,"./finders/BestFirstFinder":10,"./finders/BiAStarFinder":11,"./finders/BiBestFirstFinder":12,"./finders/BiBreadthFirstFinder":13,"./finders/BiDijkstraFinder":14,"./finders/BreadthFirstFinder":15,"./finders/DijkstraFinder":16,"./finders/IDAStarFinder":17,"./finders/JumpPointFinder":22,"heap":1}],9:[function(_dereq_,module,exports){
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * A* path-finder. Based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching 
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 */
function AStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    //admissible. It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng;

    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;

        // if reached the end position, construct the path and return it
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    openList.push(neighbor);
                    neighbor.opened = true;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    openList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};

module.exports = AStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}],10:[function(_dereq_,module,exports){
var AStarFinder = _dereq_('./AStarFinder');

/**
 * Best-First-Search path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function BestFirstFinder(opt) {
    AStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}

BestFirstFinder.prototype = new AStarFinder();
BestFirstFinder.prototype.constructor = BestFirstFinder;

module.exports = BestFirstFinder;

},{"./AStarFinder":9}],11:[function(_dereq_,module,exports){
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * A* path-finder.
 * based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 */
function BiAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var cmp = function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        },
        startOpenList = new Heap(cmp),
        endOpenList = new Heap(cmp),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng,
        BY_START = 1, BY_END = 2;

    // set the `g` and `f` value of the start node to be 0
    // and push it into the start open list
    startNode.g = 0;
    startNode.f = 0;
    startOpenList.push(startNode);
    startNode.opened = BY_START;

    // set the `g` and `f` value of the end node to be 0
    // and push it into the open open list
    endNode.g = 0;
    endNode.f = 0;
    endOpenList.push(endNode);
    endNode.opened = BY_END;

    // while both the open lists are not empty
    while (!startOpenList.empty() && !endOpenList.empty()) {

        // pop the position of start node which has the minimum `f` value.
        node = startOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_END) {
                return Util.biBacktrace(node, neighbor);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h ||
                    weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    startOpenList.push(neighbor);
                    neighbor.opened = BY_START;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    startOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor


        // pop the position of end node which has the minimum `f` value.
        node = endOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_START) {
                return Util.biBacktrace(neighbor, node);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h ||
                    weight * heuristic(abs(x - startX), abs(y - startY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    endOpenList.push(neighbor);
                    neighbor.opened = BY_END;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    endOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};

module.exports = BiAStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}],12:[function(_dereq_,module,exports){
var BiAStarFinder = _dereq_('./BiAStarFinder');

/**
 * Bi-direcitional Best-First-Search path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function BiBestFirstFinder(opt) {
    BiAStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}

BiBestFirstFinder.prototype = new BiAStarFinder();
BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;

module.exports = BiBestFirstFinder;

},{"./BiAStarFinder":11}],13:[function(_dereq_,module,exports){
var Util = _dereq_('../core/Util');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Bi-directional Breadth-First-Search path finder.
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BiBreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}


/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        startOpenList = [], endOpenList = [],
        neighbors, neighbor, node,
        diagonalMovement = this.diagonalMovement,
        BY_START = 0, BY_END = 1,
        i, l;

    // push the start and end nodes into the queues
    startOpenList.push(startNode);
    startNode.opened = true;
    startNode.by = BY_START;

    endOpenList.push(endNode);
    endNode.opened = true;
    endNode.by = BY_END;

    // while both the queues are not empty
    while (startOpenList.length && endOpenList.length) {

        // expand start open list

        node = startOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                // if this node has been inspected by the reversed search,
                // then a path is found.
                if (neighbor.by === BY_END) {
                    return Util.biBacktrace(node, neighbor);
                }
                continue;
            }
            startOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_START;
        }

        // expand end open list

        node = endOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                if (neighbor.by === BY_START) {
                    return Util.biBacktrace(neighbor, node);
                }
                continue;
            }
            endOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_END;
        }
    }

    // fail to find the path
    return [];
};

module.exports = BiBreadthFirstFinder;

},{"../core/DiagonalMovement":3,"../core/Util":7}],14:[function(_dereq_,module,exports){
var BiAStarFinder = _dereq_('./BiAStarFinder');

/**
 * Bi-directional Dijkstra path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BiDijkstraFinder(opt) {
    BiAStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}

BiDijkstraFinder.prototype = new BiAStarFinder();
BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;

module.exports = BiDijkstraFinder;

},{"./BiAStarFinder":11}],15:[function(_dereq_,module,exports){
var Util = _dereq_('../core/Util');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Breadth-First-Search path finder.
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = [],
        diagonalMovement = this.diagonalMovement,
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        neighbors, neighbor, node, i, l;

    // push the start pos into the queue
    openList.push(startNode);
    startNode.opened = true;

    // while the queue is not empty
    while (openList.length) {
        // take the front node from the queue
        node = openList.shift();
        node.closed = true;

        // reached the end position
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            // skip this neighbor if it has been inspected before
            if (neighbor.closed || neighbor.opened) {
                continue;
            }

            openList.push(neighbor);
            neighbor.opened = true;
            neighbor.parent = node;
        }
    }
    
    // fail to find the path
    return [];
};

module.exports = BreadthFirstFinder;

},{"../core/DiagonalMovement":3,"../core/Util":7}],16:[function(_dereq_,module,exports){
var AStarFinder = _dereq_('./AStarFinder');

/**
 * Dijkstra path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function DijkstraFinder(opt) {
    AStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}

DijkstraFinder.prototype = new AStarFinder();
DijkstraFinder.prototype.constructor = DijkstraFinder;

module.exports = DijkstraFinder;

},{"./AStarFinder":9}],17:[function(_dereq_,module,exports){
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var Node       = _dereq_('../core/Node');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Iterative Deeping A Star (IDA*) path-finder.
 *
 * Recursion based on:
 *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html
 *
 * Path retracing based on:
 *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh
 *  "A Parallel Implementation of Iterative-Deeping-A*", January 1987.
 *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf
 *
 * @author Gerard Meier (www.gerardmeier.com)
 *
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 * @param {boolean} opt.trackRecursion Whether to track recursion for
 *     statistical purposes.
 * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.
 */
function IDAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.trackRecursion = opt.trackRecursion || false;
    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    // admissible, it should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path. When an empty array is returned, either
 * no path is possible, or the maximum execution time is reached.
 *
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
IDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    // Used for statistics:
    var nodesVisited = 0;

    // Execution time limitation:
    var startTime = new Date().getTime();

    // Heuristic helper:
    var h = function(a, b) {
        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
    }.bind(this);

    // Step cost from a to b:
    var cost = function(a, b) {
        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
    };

    /**
     * IDA* search implementation.
     *
     * @param {Node} The node currently expanding from.
     * @param {number} Cost to reach the given node.
     * @param {number} Maximum search depth (cut-off value).
     * @param {Array<Array<number>>} The found route.
     * @param {number} Recursion depth.
     *
     * @return {Object} either a number with the new optimal cut-off depth,
     * or a valid node instance, in which case a path was found.
     */
    var search = function(node, g, cutoff, route, depth) {
        nodesVisited++;

        // Enforce timelimit:
        if (this.timeLimit > 0 &&
            new Date().getTime() - startTime > this.timeLimit * 1000) {
            // Enforced as "path-not-found".
            return Infinity;
        }

        var f = g + h(node, end) * this.weight;

        // We've searched too deep for this iteration.
        if (f > cutoff) {
            return f;
        }

        if (node == end) {
            route[depth] = [node.x, node.y];
            return node;
        }

        var min, t, k, neighbour;

        var neighbours = grid.getNeighbors(node, this.diagonalMovement);

        // Sort the neighbours, gives nicer paths. But, this deviates
        // from the original algorithm - so I left it out.
        //neighbours.sort(function(a, b){
        //    return h(a, end) - h(b, end);
        //});

        
        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment
        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment
            if (this.trackRecursion) {
                // Retain a copy for visualisation. Due to recursion, this
                // node may be part of other paths too.
                neighbour.retainCount = neighbour.retainCount + 1 || 1;

                if(neighbour.tested !== true) {
                    neighbour.tested = true;
                }
            }

            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);

            if (t instanceof Node) {
                route[depth] = [node.x, node.y];

                // For a typical A* linked list, this would work:
                // neighbour.parent = node;
                return t;
            }

            // Decrement count, then determine whether it's actually closed.
            if (this.trackRecursion && (--neighbour.retainCount) === 0) {
                neighbour.tested = false;
            }

            if (t < min) {
                min = t;
            }
        }

        return min;

    }.bind(this);

    // Node instance lookups:
    var start = grid.getNodeAt(startX, startY);
    var end   = grid.getNodeAt(endX, endY);

    // Initial search depth, given the typical heuristic contraints,
    // there should be no cheaper route possible.
    var cutOff = h(start, end);

    var j, route, t;

    // With an overflow protection.
    for (j = 0; true; ++j) {

        route = [];

        // Search till cut-off depth:
        t = search(start, 0, cutOff, route, 0);

        // Route not possible, or not found in time limit.
        if (t === Infinity) {
            return [];
        }

        // If t is a node, it's also the end node. Route is now
        // populated with a valid path to the end node.
        if (t instanceof Node) {
            return route;
        }

        // Try again, this time with a deeper cut-off. The t score
        // is the closest we got to the end node.
        cutOff = t;
    }

    // This _should_ never to be reached.
    return [];
};

module.exports = IDAStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Node":6,"../core/Util":7}],18:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which always moves
 * diagonally irrespective of the number of obstacles.
 */
function JPFAlwaysMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();
JPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    return this._jump(x + dx, y + dy, x, y);
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x + dx, y + dy)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
                if (!grid.isWalkableAt(x + 1, y)) {
                    neighbors.push([x + 1, y + dy]);
                }
                if (!grid.isWalkableAt(x - 1, y)) {
                    neighbors.push([x - 1, y + dy]);
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
                if (!grid.isWalkableAt(x, y + 1)) {
                    neighbors.push([x + dx, y + 1]);
                }
                if (!grid.isWalkableAt(x, y - 1)) {
                    neighbors.push([x + dx, y - 1]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFAlwaysMoveDiagonally;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],19:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there is at most one obstacle.
 */
function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();
JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                    if (!grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                    if (!grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (!grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFMoveDiagonallyIfAtMostOneObstacle;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],20:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there are no obstacles.
 */
function JPFMoveDiagonallyIfNoObstacles(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();
JPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            // return [x, y];
        // }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if (dx !== 0) {
            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                return [x, y];
            }
        }
        else if (dy !== 0) {
            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                return [x, y];
            }
            // When moving vertically, must check for horizontal jump points
            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                // return [x, y];
            // }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
        }
        // search horizontally/vertically
        else {
            var isNextWalkable;
            if (dx !== 0) {
                isNextWalkable = grid.isWalkableAt(x + dx, y);
                var isTopWalkable = grid.isWalkableAt(x, y + 1);
                var isBottomWalkable = grid.isWalkableAt(x, y - 1);

                if (isNextWalkable) {
                    neighbors.push([x + dx, y]);
                    if (isTopWalkable) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (isBottomWalkable) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
                if (isTopWalkable) {
                    neighbors.push([x, y + 1]);
                }
                if (isBottomWalkable) {
                    neighbors.push([x, y - 1]);
                }
            }
            else if (dy !== 0) {
                isNextWalkable = grid.isWalkableAt(x, y + dy);
                var isRightWalkable = grid.isWalkableAt(x + 1, y);
                var isLeftWalkable = grid.isWalkableAt(x - 1, y);

                if (isNextWalkable) {
                    neighbors.push([x, y + dy]);
                    if (isRightWalkable) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (isLeftWalkable) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
                if (isRightWalkable) {
                    neighbors.push([x + 1, y]);
                }
                if (isLeftWalkable) {
                    neighbors.push([x - 1, y]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFMoveDiagonallyIfNoObstacles;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],21:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm allowing only horizontal
 * or vertical movements.
 */
function JPFNeverMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();
JPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    if (dx !== 0) {
        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
            return [x, y];
        }
    }
    else if (dy !== 0) {
        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
            return [x, y];
        }
        //When moving vertically, must check for horizontal jump points
        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
            return [x, y];
        }
    }
    else {
        throw new Error("Only horizontal and vertical movements are allowed");
    }

    return this._jump(x + dx, y + dy, x, y);
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        if (dx !== 0) {
            if (grid.isWalkableAt(x, y - 1)) {
                neighbors.push([x, y - 1]);
            }
            if (grid.isWalkableAt(x, y + 1)) {
                neighbors.push([x, y + 1]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
        }
        else if (dy !== 0) {
            if (grid.isWalkableAt(x - 1, y)) {
                neighbors.push([x - 1, y]);
            }
            if (grid.isWalkableAt(x + 1, y)) {
                neighbors.push([x + 1, y]);
            }
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFNeverMoveDiagonally;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],22:[function(_dereq_,module,exports){
/**
 * @author aniero / https://github.com/aniero
 */
var DiagonalMovement = _dereq_('../core/DiagonalMovement');
var JPFNeverMoveDiagonally = _dereq_('./JPFNeverMoveDiagonally');
var JPFAlwaysMoveDiagonally = _dereq_('./JPFAlwaysMoveDiagonally');
var JPFMoveDiagonallyIfNoObstacles = _dereq_('./JPFMoveDiagonallyIfNoObstacles');
var JPFMoveDiagonallyIfAtMostOneObstacle = _dereq_('./JPFMoveDiagonallyIfAtMostOneObstacle');

/**
 * Path finder using the Jump Point Search algorithm
 * @param {Object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal
 *      movement will be allowed.
 */
function JumpPointFinder(opt) {
    opt = opt || {};
    if (opt.diagonalMovement === DiagonalMovement.Never) {
        return new JPFNeverMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.Always) {
        return new JPFAlwaysMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        return new JPFMoveDiagonallyIfNoObstacles(opt);
    } else {
        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
    }
}

module.exports = JumpPointFinder;

},{"../core/DiagonalMovement":3,"./JPFAlwaysMoveDiagonally":18,"./JPFMoveDiagonallyIfAtMostOneObstacle":19,"./JPFMoveDiagonallyIfNoObstacles":20,"./JPFNeverMoveDiagonally":21}],23:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Base class for the Jump Point Search algorithm
 * @param {object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function JumpPointFinderBase(opt) {
    opt = opt || {};
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.trackJumpRecursion = opt.trackJumpRecursion || false;
}

/**
 * Find and return the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
JumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = this.openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = this.startNode = grid.getNodeAt(startX, startY),
        endNode = this.endNode = grid.getNodeAt(endX, endY), node;

    this.grid = grid;


    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;

        if (node === endNode) {
            return Util.expandPath(Util.backtrace(endNode));
        }

        this._identifySuccessors(node);
    }

    // fail to find the path
    return [];
};

/**
 * Identify successors for the given node. Runs a jump point search in the
 * direction of each available neighbor, adding any points found to the open
 * list.
 * @protected
 */
JumpPointFinderBase.prototype._identifySuccessors = function(node) {
    var grid = this.grid,
        heuristic = this.heuristic,
        openList = this.openList,
        endX = this.endNode.x,
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this._findNeighbors(node);
    for(i = 0, l = neighbors.length; i < l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

            jx = jumpPoint[0];
            jy = jumpPoint[1];
            jumpNode = grid.getNodeAt(jx, jy);

            if (jumpNode.closed) {
                continue;
            }

            // include distance, as parent may not be immediately adjacent:
            d = Heuristic.octile(abs(jx - x), abs(jy - y));
            ng = node.g + d; // next `g` value

            if (!jumpNode.opened || ng < jumpNode.g) {
                jumpNode.g = ng;
                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                jumpNode.f = jumpNode.g + jumpNode.h;
                jumpNode.parent = node;

                if (!jumpNode.opened) {
                    openList.push(jumpNode);
                    jumpNode.opened = true;
                } else {
                    openList.updateItem(jumpNode);
                }
            }
        }
    }
};

module.exports = JumpPointFinderBase;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}]},{},[8])
(8)
});

// Version 0.9.0 - Copyright 2012 - 2021 -  Jim Riecken <jimr@jimr.ca>
//
// Released under the MIT License - https://github.com/jriecken/sat-js
//
// A simple library for determining intersections of circles and
// polygons using the Separating Axis Theorem.
/** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */

/*global define: false, module: false*/
/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true,
  eqeqeq:true, bitwise:true, strict:true, undef:true,
  curly:true, browser:true */

// Create a UMD wrapper for SAT. Works in:
//
//  - Plain browser via global SAT variable
//  - AMD loader (like require.js)
//  - Node.js
//
// The quoted properties all over the place are used so that the Closure Compiler
// does not mangle the exposed API in advanced mode.
/**
 * @param {*} root - The global scope
 * @param {Function} factory - Factory that creates SAT module
 */
(function (root, factory) {
  "use strict";
  if (typeof define === 'function' && define['amd']) {
    define(factory);
  } else if (typeof exports === 'object') {
    module['exports'] = factory();
  } else {
    root['SAT'] = factory();
  }
}(this, function () {
  "use strict";

  var SAT = {};

  //
  // ## Vector
  //
  // Represents a vector in two dimensions with `x` and `y` properties.


  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If
  // a coordinate is not specified, it will be set to `0`
  /**
   * @param {?number=} x The x position.
   * @param {?number=} y The y position.
   * @constructor
   */
  function Vector(x, y) {
    this['x'] = x || 0;
    this['y'] = y || 0;
  }
  SAT['Vector'] = Vector;
  // Alias `Vector` as `V`
  SAT['V'] = Vector;


  // Copy the values of another Vector into this one.
  /**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['copy'] = Vector.prototype.copy = function (other) {
    this['x'] = other['x'];
    this['y'] = other['y'];
    return this;
  };

  // Create a new vector with the same coordinates as this on.
  /**
   * @return {Vector} The new cloned vector
   */
  Vector.prototype['clone'] = Vector.prototype.clone = function () {
    return new Vector(this['x'], this['y']);
  };

  // Change this vector to be perpendicular to what it was before. (Effectively
  // roatates it 90 degrees in a clockwise direction)
  /**
   * @return {Vector} This for chaining.
   */
  Vector.prototype['perp'] = Vector.prototype.perp = function () {
    var x = this['x'];
    this['x'] = this['y'];
    this['y'] = -x;
    return this;
  };

  // Rotate this vector (counter-clockwise) by the specified angle (in radians).
  /**
   * @param {number} angle The angle to rotate (in radians)
   * @return {Vector} This for chaining.
   */
  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {
    var x = this['x'];
    var y = this['y'];
    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);
    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);
    return this;
  };

  // Reverse this vector.
  /**
   * @return {Vector} This for chaining.
   */
  Vector.prototype['reverse'] = Vector.prototype.reverse = function () {
    this['x'] = -this['x'];
    this['y'] = -this['y'];
    return this;
  };


  // Normalize this vector.  (make it have length of `1`)
  /**
   * @return {Vector} This for chaining.
   */
  Vector.prototype['normalize'] = Vector.prototype.normalize = function () {
    var d = this.len();
    if (d > 0) {
      this['x'] = this['x'] / d;
      this['y'] = this['y'] / d;
    }
    return this;
  };

  // Add another vector to this one.
  /**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['add'] = Vector.prototype.add = function (other) {
    this['x'] += other['x'];
    this['y'] += other['y'];
    return this;
  };

  // Subtract another vector from this one.
  /**
   * @param {Vector} other The other Vector.
   * @return {Vector} This for chaiing.
   */
  Vector.prototype['sub'] = Vector.prototype.sub = function (other) {
    this['x'] -= other['x'];
    this['y'] -= other['y'];
    return this;
  };

  // Scale this vector. An independent scaling factor can be provided
  // for each axis, or a single scaling factor that will scale both `x` and `y`.
  /**
   * @param {number} x The scaling factor in the x direction.
   * @param {?number=} y The scaling factor in the y direction.  If this
   *   is not specified, the x scaling factor will be used.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['scale'] = Vector.prototype.scale = function (x, y) {
    this['x'] *= x;
    this['y'] *= typeof y != 'undefined' ? y : x;
    return this;
  };

  // Project this vector on to another vector.
  /**
   * @param {Vector} other The vector to project onto.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['project'] = Vector.prototype.project = function (other) {
    var amt = this.dot(other) / other.len2();
    this['x'] = amt * other['x'];
    this['y'] = amt * other['y'];
    return this;
  };

  // Project this vector onto a vector of unit length. This is slightly more efficient
  // than `project` when dealing with unit vectors.
  /**
   * @param {Vector} other The unit vector to project onto.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['projectN'] = Vector.prototype.projectN = function (other) {
    var amt = this.dot(other);
    this['x'] = amt * other['x'];
    this['y'] = amt * other['y'];
    return this;
  };

  // Reflect this vector on an arbitrary axis.
  /**
   * @param {Vector} axis The vector representing the axis.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['reflect'] = Vector.prototype.reflect = function (axis) {
    var x = this['x'];
    var y = this['y'];
    this.project(axis).scale(2);
    this['x'] -= x;
    this['y'] -= y;
    return this;
  };

  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is
  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.
  /**
   * @param {Vector} axis The unit vector representing the axis.
   * @return {Vector} This for chaining.
   */
  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function (axis) {
    var x = this['x'];
    var y = this['y'];
    this.projectN(axis).scale(2);
    this['x'] -= x;
    this['y'] -= y;
    return this;
  };

  // Get the dot product of this vector and another.
  /**
   * @param {Vector}  other The vector to dot this one against.
   * @return {number} The dot product.
   */
  Vector.prototype['dot'] = Vector.prototype.dot = function (other) {
    return this['x'] * other['x'] + this['y'] * other['y'];
  };

  // Get the squared length of this vector.
  /**
   * @return {number} The length^2 of this vector.
   */
  Vector.prototype['len2'] = Vector.prototype.len2 = function () {
    return this.dot(this);
  };

  // Get the length of this vector.
  /**
   * @return {number} The length of this vector.
   */
  Vector.prototype['len'] = Vector.prototype.len = function () {
    return Math.sqrt(this.len2());
  };

  // ## Circle
  //
  // Represents a circle with a position and a radius.

  // Create a new circle, optionally passing in a position and/or radius. If no position
  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will
  // have a radius of `0`.
  /**
   * @param {Vector=} pos A vector representing the position of the center of the circle
   * @param {?number=} r The radius of the circle
   * @constructor
   */
  function Circle(pos, r) {
    this['pos'] = pos || new Vector();
    this['r'] = r || 0;
    this['offset'] = new Vector();
  }
  SAT['Circle'] = Circle;

  // Compute the axis-aligned bounding box (AABB) of this Circle.
  //
  // Note: Returns a _new_ `Box` each time you call this.
  /**
   * @return {Polygon} The AABB
   */
  Circle.prototype['getAABBAsBox'] = Circle.prototype.getAABBAsBox = function () {
    var r = this['r'];
    var corner = this['pos'].clone().add(this['offset']).sub(new Vector(r, r));
    return new Box(corner, r * 2, r * 2);
  };

  // Compute the axis-aligned bounding box (AABB) of this Circle.
  //
  // Note: Returns a _new_ `Polygon` each time you call this.
  /**
   * @return {Polygon} The AABB
   */
  Circle.prototype['getAABB'] = Circle.prototype.getAABB = function () {
    return this.getAABBAsBox().toPolygon();
  };

  // Set the current offset to apply to the radius.
  /**
   * @param {Vector} offset The new offset vector.
   * @return {Circle} This for chaining.
   */
  Circle.prototype['setOffset'] = Circle.prototype.setOffset = function (offset) {
    this['offset'] = offset;
    return this;
  };

  // ## Polygon
  //
  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)
  //
  // Note: Do _not_ manually change the `points`, `angle`, or `offset` properties. Use the
  // provided setters. Otherwise the calculated properties will not be updated correctly.
  //
  // `pos` can be changed directly.

  // Create a new polygon, passing in a position vector, and an array of points (represented
  // by vectors relative to the position vector). If no position is passed in, the position
  // of the polygon will be `(0,0)`.
  /**
   * @param {Vector=} pos A vector representing the origin of the polygon. (all other
   *   points are relative to this one)
   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,
   *   in counter-clockwise order.
   * @constructor
   */
  function Polygon(pos, points) {
    this['pos'] = pos || new Vector();
    this['angle'] = 0;
    this['offset'] = new Vector();
    this.setPoints(points || []);
  }
  SAT['Polygon'] = Polygon;

  // Set the points of the polygon. Any consecutive duplicate points will be combined.
  //
  // Note: The points are counter-clockwise *with respect to the coordinate system*.
  // If you directly draw the points on a screen that has the origin at the top-left corner
  // it will _appear_ visually that the points are being specified clockwise. This is just
  // because of the inversion of the Y-axis when being displayed.
  /**
   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,
   *   in counter-clockwise order.
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function (points) {
    // Only re-allocate if this is a new polygon or the number of points has changed.
    var lengthChanged = !this['points'] || this['points'].length !== points.length;
    if (lengthChanged) {
      var i;
      var calcPoints = this['calcPoints'] = [];
      var edges = this['edges'] = [];
      var normals = this['normals'] = [];
      // Allocate the vector arrays for the calculated properties
      for (i = 0; i < points.length; i++) {
        // Remove consecutive duplicate points
        var p1 = points[i];
        var p2 = i < points.length - 1 ? points[i + 1] : points[0];
        if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {
          points.splice(i, 1);
          i -= 1;
          continue;
        }
        calcPoints.push(new Vector());
        edges.push(new Vector());
        normals.push(new Vector());
      }
    }
    this['points'] = points;
    this._recalc();
    return this;
  };

  // Set the current rotation angle of the polygon.
  /**
   * @param {number} angle The current rotation angle (in radians).
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function (angle) {
    this['angle'] = angle;
    this._recalc();
    return this;
  };

  // Set the current offset to apply to the `points` before applying the `angle` rotation.
  /**
   * @param {Vector} offset The new offset vector.
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function (offset) {
    this['offset'] = offset;
    this._recalc();
    return this;
  };

  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).
  //
  // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation).
  /**
   * @param {number} angle The angle to rotate (in radians)
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function (angle) {
    var points = this['points'];
    var len = points.length;
    for (var i = 0; i < len; i++) {
      points[i].rotate(angle);
    }
    this._recalc();
    return this;
  };

  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate
  // system* (i.e. `pos`).
  //
  // This is most useful to change the "center point" of a polygon. If you just want to move the whole polygon, change
  // the coordinates of `pos`.
  //
  // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)
  /**
   * @param {number} x The horizontal amount to translate.
   * @param {number} y The vertical amount to translate.
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {
    var points = this['points'];
    var len = points.length;
    for (var i = 0; i < len; i++) {
      points[i]['x'] += x;
      points[i]['y'] += y;
    }
    this._recalc();
    return this;
  };


  // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the
  // edges and normals of the collision polygon.
  /**
   * @return {Polygon} This for chaining.
   */
  Polygon.prototype._recalc = function () {
    // Calculated points - this is what is used for underlying collisions and takes into account
    // the angle/offset set on the polygon.
    var calcPoints = this['calcPoints'];
    // The edges here are the direction of the `n`th edge of the polygon, relative to
    // the `n`th point. If you want to draw a given edge from the edge value, you must
    // first translate to the position of the starting point.
    var edges = this['edges'];
    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative
    // to the position of the `n`th point. If you want to draw an edge normal, you must first
    // translate to the position of the starting point.
    var normals = this['normals'];
    // Copy the original points array and apply the offset/angle
    var points = this['points'];
    var offset = this['offset'];
    var angle = this['angle'];
    var len = points.length;
    var i;
    for (i = 0; i < len; i++) {
      var calcPoint = calcPoints[i].copy(points[i]);
      calcPoint['x'] += offset['x'];
      calcPoint['y'] += offset['y'];
      if (angle !== 0) {
        calcPoint.rotate(angle);
      }
    }
    // Calculate the edges/normals
    for (i = 0; i < len; i++) {
      var p1 = calcPoints[i];
      var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];
      var e = edges[i].copy(p2).sub(p1);
      normals[i].copy(e).perp().normalize();
    }
    return this;
  };


  // Compute the axis-aligned bounding box. Any current state
  // (translations/rotations) will be applied before constructing the AABB.
  //
  // Note: Returns a _new_ `Box` each time you call this.
  /**
   * @return {Polygon} The AABB
   */
  Polygon.prototype['getAABBAsBox'] = Polygon.prototype.getAABBAsBox = function () {
    var points = this['calcPoints'];
    var len = points.length;
    var xMin = points[0]['x'];
    var yMin = points[0]['y'];
    var xMax = points[0]['x'];
    var yMax = points[0]['y'];
    for (var i = 1; i < len; i++) {
      var point = points[i];
      if (point['x'] < xMin) {
        xMin = point['x'];
      }
      else if (point['x'] > xMax) {
        xMax = point['x'];
      }
      if (point['y'] < yMin) {
        yMin = point['y'];
      }
      else if (point['y'] > yMax) {
        yMax = point['y'];
      }
    }
    return new Box(this['pos'].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);
  };


  // Compute the axis-aligned bounding box. Any current state
  // (translations/rotations) will be applied before constructing the AABB.
  //
  // Note: Returns a _new_ `Polygon` each time you call this.
  /**
   * @return {Polygon} The AABB
   */
  Polygon.prototype['getAABB'] = Polygon.prototype.getAABB = function () {
    return this.getAABBAsBox().toPolygon();
  };

  // Compute the centroid (geometric center) of the polygon. Any current state
  // (translations/rotations) will be applied before computing the centroid.
  //
  // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_a_polygon
  //
  // Note: Returns a _new_ `Vector` each time you call this.
  /**
   * @return {Vector} A Vector that contains the coordinates of the Centroid.
   */
  Polygon.prototype['getCentroid'] = Polygon.prototype.getCentroid = function () {
    var points = this['calcPoints'];
    var len = points.length;
    var cx = 0;
    var cy = 0;
    var ar = 0;
    for (var i = 0; i < len; i++) {
      var p1 = points[i];
      var p2 = i === len - 1 ? points[0] : points[i + 1]; // Loop around if last point
      var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];
      cx += (p1['x'] + p2['x']) * a;
      cy += (p1['y'] + p2['y']) * a;
      ar += a;
    }
    ar = ar * 3; // we want 1 / 6 the area and we currently have 2*area
    cx = cx / ar;
    cy = cy / ar;
    return new Vector(cx, cy);
  };


  // ## Box
  //
  // Represents an axis-aligned box, with a width and height.


  // Create a new box, with the specified position, width, and height. If no position
  // is given, the position will be `(0,0)`. If no width or height are given, they will
  // be set to `0`.
  /**
   * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).
   * @param {?number=} w The width of the box.
   * @param {?number=} h The height of the box.
   * @constructor
   */
  function Box(pos, w, h) {
    this['pos'] = pos || new Vector();
    this['w'] = w || 0;
    this['h'] = h || 0;
  }
  SAT['Box'] = Box;

  // Returns a polygon whose edges are the same as this box.
  /**
   * @return {Polygon} A new Polygon that represents this box.
   */
  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function () {
    var pos = this['pos'];
    var w = this['w'];
    var h = this['h'];
    return new Polygon(new Vector(pos['x'], pos['y']), [
      new Vector(), new Vector(w, 0),
      new Vector(w, h), new Vector(0, h)
    ]);
  };

  // ## Response
  //
  // An object representing the result of an intersection. Contains:
  //  - The two objects participating in the intersection
  //  - The vector representing the minimum change necessary to extract the first object
  //    from the second one (as well as a unit vector in that direction and the magnitude
  //    of the overlap)
  //  - Whether the first object is entirely inside the second, and vice versa.
  /**
   * @constructor
   */
  function Response() {
    this['a'] = null;
    this['b'] = null;
    this['overlapN'] = new Vector();
    this['overlapV'] = new Vector();
    this.clear();
  }
  SAT['Response'] = Response;

  // Set some values of the response back to their defaults.  Call this between tests if
  // you are going to reuse a single Response object for multiple intersection tests (recommented
  // as it will avoid allcating extra memory)
  /**
   * @return {Response} This for chaining
   */
  Response.prototype['clear'] = Response.prototype.clear = function () {
    this['aInB'] = true;
    this['bInA'] = true;
    this['overlap'] = Number.MAX_VALUE;
    return this;
  };

  // ## Object Pools

  // A pool of `Vector` objects that are used in calculations to avoid
  // allocating memory.
  /**
   * @type {Array<Vector>}
   */
  var T_VECTORS = [];
  for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }

  // A pool of arrays of numbers used in calculations to avoid allocating
  // memory.
  /**
   * @type {Array<Array<number>>}
   */
  var T_ARRAYS = [];
  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }

  // Temporary response used for polygon hit detection.
  /**
   * @type {Response}
   */
  var T_RESPONSE = new Response();

  // Tiny "point" polygon used for polygon hit detection.
  /**
   * @type {Polygon}
   */
  var TEST_POINT = new Box(new Vector(), 0.000001, 0.000001).toPolygon();

  // ## Helper Functions

  // Flattens the specified array of points onto a unit vector axis,
  // resulting in a one dimensional range of the minimum and
  // maximum value on that axis.
  /**
   * @param {Array<Vector>} points The points to flatten.
   * @param {Vector} normal The unit vector axis to flatten on.
   * @param {Array<number>} result An array.  After calling this function,
   *   result[0] will be the minimum value,
   *   result[1] will be the maximum value.
   */
  function flattenPointsOn(points, normal, result) {
    var min = Number.MAX_VALUE;
    var max = -Number.MAX_VALUE;
    var len = points.length;
    for (var i = 0; i < len; i++) {
      // The magnitude of the projection of the point onto the normal
      var dot = points[i].dot(normal);
      if (dot < min) { min = dot; }
      if (dot > max) { max = dot; }
    }
    result[0] = min; result[1] = max;
  }

  // Check whether two convex polygons are separated by the specified
  // axis (must be a unit vector).
  /**
   * @param {Vector} aPos The position of the first polygon.
   * @param {Vector} bPos The position of the second polygon.
   * @param {Array<Vector>} aPoints The points in the first polygon.
   * @param {Array<Vector>} bPoints The points in the second polygon.
   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons
   *   will be projected onto this axis.
   * @param {Response=} response A Response object (optional) which will be populated
   *   if the axis is not a separating axis.
   * @return {boolean} true if it is a separating axis, false otherwise.  If false,
   *   and a response is passed in, information about how much overlap and
   *   the direction of the overlap will be populated.
   */
  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
    var rangeA = T_ARRAYS.pop();
    var rangeB = T_ARRAYS.pop();
    // The magnitude of the offset between the two polygons
    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
    var projectedOffset = offsetV.dot(axis);
    // Project the polygons onto the axis.
    flattenPointsOn(aPoints, axis, rangeA);
    flattenPointsOn(bPoints, axis, rangeB);
    // Move B's range to its position relative to A.
    rangeB[0] += projectedOffset;
    rangeB[1] += projectedOffset;
    // Check if there is a gap. If there is, this is a separating axis and we can stop
    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
      T_VECTORS.push(offsetV);
      T_ARRAYS.push(rangeA);
      T_ARRAYS.push(rangeB);
      return true;
    }
    // This is not a separating axis. If we're calculating a response, calculate the overlap.
    if (response) {
      var overlap = 0;
      // A starts further left than B
      if (rangeA[0] < rangeB[0]) {
        response['aInB'] = false;
        // A ends before B does. We have to pull A out of B
        if (rangeA[1] < rangeB[1]) {
          overlap = rangeA[1] - rangeB[0];
          response['bInA'] = false;
          // B is fully inside A.  Pick the shortest way out.
        } else {
          var option1 = rangeA[1] - rangeB[0];
          var option2 = rangeB[1] - rangeA[0];
          overlap = option1 < option2 ? option1 : -option2;
        }
        // B starts further left than A
      } else {
        response['bInA'] = false;
        // B ends before A ends. We have to push A out of B
        if (rangeA[1] > rangeB[1]) {
          overlap = rangeA[0] - rangeB[1];
          response['aInB'] = false;
          // A is fully inside B.  Pick the shortest way out.
        } else {
          var option1 = rangeA[1] - rangeB[0];
          var option2 = rangeB[1] - rangeA[0];
          overlap = option1 < option2 ? option1 : -option2;
        }
      }
      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.
      var absOverlap = Math.abs(overlap);
      if (absOverlap < response['overlap']) {
        response['overlap'] = absOverlap;
        response['overlapN'].copy(axis);
        if (overlap < 0) {
          response['overlapN'].reverse();
        }
      }
    }
    T_VECTORS.push(offsetV);
    T_ARRAYS.push(rangeA);
    T_ARRAYS.push(rangeB);
    return false;
  }
  SAT['isSeparatingAxis'] = isSeparatingAxis;

  // Calculates which Voronoi region a point is on a line segment.
  // It is assumed that both the line and the point are relative to `(0,0)`
  //
  //            |       (0)      |
  //     (-1)  [S]--------------[E]  (1)
  //            |       (0)      |
  /**
   * @param {Vector} line The line segment.
   * @param {Vector} point The point.
   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,
   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,
   *          RIGHT_VORONOI_REGION (1) if it is the right region.
   */
  function voronoiRegion(line, point) {
    var len2 = line.len2();
    var dp = point.dot(line);
    // If the point is beyond the start of the line, it is in the
    // left voronoi region.
    if (dp < 0) { return LEFT_VORONOI_REGION; }
    // If the point is beyond the end of the line, it is in the
    // right voronoi region.
    else if (dp > len2) { return RIGHT_VORONOI_REGION; }
    // Otherwise, it's in the middle one.
    else { return MIDDLE_VORONOI_REGION; }
  }
  // Constants for Voronoi regions
  /**
   * @const
   */
  var LEFT_VORONOI_REGION = -1;
  /**
   * @const
   */
  var MIDDLE_VORONOI_REGION = 0;
  /**
   * @const
   */
  var RIGHT_VORONOI_REGION = 1;

  // ## Collision Tests

  // Check if a point is inside a circle.
  /**
   * @param {Vector} p The point to test.
   * @param {Circle} c The circle to test.
   * @return {boolean} true if the point is inside the circle, false if it is not.
   */
  function pointInCircle(p, c) {
    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);
    var radiusSq = c['r'] * c['r'];
    var distanceSq = differenceV.len2();
    T_VECTORS.push(differenceV);
    // If the distance between is smaller than the radius then the point is inside the circle.
    return distanceSq <= radiusSq;
  }
  SAT['pointInCircle'] = pointInCircle;

  // Check if a point is inside a convex polygon.
  /**
   * @param {Vector} p The point to test.
   * @param {Polygon} poly The polygon to test.
   * @return {boolean} true if the point is inside the polygon, false if it is not.
   */
  function pointInPolygon(p, poly) {
    TEST_POINT['pos'].copy(p);
    T_RESPONSE.clear();
    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);
    if (result) {
      result = T_RESPONSE['aInB'];
    }
    return result;
  }
  SAT['pointInPolygon'] = pointInPolygon;

  // Check if two circles collide.
  /**
   * @param {Circle} a The first circle.
   * @param {Circle} b The second circle.
   * @param {Response=} response Response object (optional) that will be populated if
   *   the circles intersect.
   * @return {boolean} true if the circles intersect, false if they don't.
   */
  function testCircleCircle(a, b, response) {
    // Check if the distance between the centers of the two
    // circles is greater than their combined radius.
    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);
    var totalRadius = a['r'] + b['r'];
    var totalRadiusSq = totalRadius * totalRadius;
    var distanceSq = differenceV.len2();
    // If the distance is bigger than the combined radius, they don't intersect.
    if (distanceSq > totalRadiusSq) {
      T_VECTORS.push(differenceV);
      return false;
    }
    // They intersect.  If we're calculating a response, calculate the overlap.
    if (response) {
      var dist = Math.sqrt(distanceSq);
      response['a'] = a;
      response['b'] = b;
      response['overlap'] = totalRadius - dist;
      response['overlapN'].copy(differenceV.normalize());
      response['overlapV'].copy(differenceV).scale(response['overlap']);
      response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];
      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];
    }
    T_VECTORS.push(differenceV);
    return true;
  }
  SAT['testCircleCircle'] = testCircleCircle;

  // Check if a polygon and a circle collide.
  /**
   * @param {Polygon} polygon The polygon.
   * @param {Circle} circle The circle.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */
  function testPolygonCircle(polygon, circle, response) {
    // Get the position of the circle relative to the polygon.
    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);
    var radius = circle['r'];
    var radius2 = radius * radius;
    var points = polygon['calcPoints'];
    var len = points.length;
    var edge = T_VECTORS.pop();
    var point = T_VECTORS.pop();

    // For each edge in the polygon:
    for (var i = 0; i < len; i++) {
      var next = i === len - 1 ? 0 : i + 1;
      var prev = i === 0 ? len - 1 : i - 1;
      var overlap = 0;
      var overlapN = null;

      // Get the edge.
      edge.copy(polygon['edges'][i]);
      // Calculate the center of the circle relative to the starting point of the edge.
      point.copy(circlePos).sub(points[i]);

      // If the distance between the center of the circle and the point
      // is bigger than the radius, the polygon is definitely not fully in
      // the circle.
      if (response && point.len2() > radius2) {
        response['aInB'] = false;
      }

      // Calculate which Voronoi region the center of the circle is in.
      var region = voronoiRegion(edge, point);
      // If it's the left region:
      if (region === LEFT_VORONOI_REGION) {
        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.
        edge.copy(polygon['edges'][prev]);
        // Calculate the center of the circle relative the starting point of the previous edge
        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
        region = voronoiRegion(edge, point2);
        if (region === RIGHT_VORONOI_REGION) {
          // It's in the region we want.  Check if the circle intersects the point.
          var dist = point.len();
          if (dist > radius) {
            // No intersection
            T_VECTORS.push(circlePos);
            T_VECTORS.push(edge);
            T_VECTORS.push(point);
            T_VECTORS.push(point2);
            return false;
          } else if (response) {
            // It intersects, calculate the overlap.
            response['bInA'] = false;
            overlapN = point.normalize();
            overlap = radius - dist;
          }
        }
        T_VECTORS.push(point2);
        // If it's the right region:
      } else if (region === RIGHT_VORONOI_REGION) {
        // We need to make sure we're in the left region on the next edge
        edge.copy(polygon['edges'][next]);
        // Calculate the center of the circle relative to the starting point of the next edge.
        point.copy(circlePos).sub(points[next]);
        region = voronoiRegion(edge, point);
        if (region === LEFT_VORONOI_REGION) {
          // It's in the region we want.  Check if the circle intersects the point.
          var dist = point.len();
          if (dist > radius) {
            // No intersection
            T_VECTORS.push(circlePos);
            T_VECTORS.push(edge);
            T_VECTORS.push(point);
            return false;
          } else if (response) {
            // It intersects, calculate the overlap.
            response['bInA'] = false;
            overlapN = point.normalize();
            overlap = radius - dist;
          }
        }
        // Otherwise, it's the middle region:
      } else {
        // Need to check if the circle is intersecting the edge,
        // Change the edge into its "edge normal".
        var normal = edge.perp().normalize();
        // Find the perpendicular distance between the center of the
        // circle and the edge.
        var dist = point.dot(normal);
        var distAbs = Math.abs(dist);
        // If the circle is on the outside of the edge, there is no intersection.
        if (dist > 0 && distAbs > radius) {
          // No intersection
          T_VECTORS.push(circlePos);
          T_VECTORS.push(normal);
          T_VECTORS.push(point);
          return false;
        } else if (response) {
          // It intersects, calculate the overlap.
          overlapN = normal;
          overlap = radius - dist;
          // If the center of the circle is on the outside of the edge, or part of the
          // circle is on the outside, the circle is not fully inside the polygon.
          if (dist >= 0 || overlap < 2 * radius) {
            response['bInA'] = false;
          }
        }
      }

      // If this is the smallest overlap we've seen, keep it.
      // (overlapN may be null if the circle was in the wrong Voronoi region).
      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {
        response['overlap'] = overlap;
        response['overlapN'].copy(overlapN);
      }
    }

    // Calculate the final overlap vector - based on the smallest overlap.
    if (response) {
      response['a'] = polygon;
      response['b'] = circle;
      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);
    }
    T_VECTORS.push(circlePos);
    T_VECTORS.push(edge);
    T_VECTORS.push(point);
    return true;
  }
  SAT['testPolygonCircle'] = testPolygonCircle;

  // Check if a circle and a polygon collide.
  //
  // **NOTE:** This is slightly less efficient than polygonCircle as it just
  // runs polygonCircle and reverses everything at the end.
  /**
   * @param {Circle} circle The circle.
   * @param {Polygon} polygon The polygon.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */
  function testCirclePolygon(circle, polygon, response) {
    // Test the polygon against the circle.
    var result = testPolygonCircle(polygon, circle, response);
    if (result && response) {
      // Swap A and B in the response.
      var a = response['a'];
      var aInB = response['aInB'];
      response['overlapN'].reverse();
      response['overlapV'].reverse();
      response['a'] = response['b'];
      response['b'] = a;
      response['aInB'] = response['bInA'];
      response['bInA'] = aInB;
    }
    return result;
  }
  SAT['testCirclePolygon'] = testCirclePolygon;

  // Checks whether polygons collide.
  /**
   * @param {Polygon} a The first polygon.
   * @param {Polygon} b The second polygon.
   * @param {Response=} response Response object (optional) that will be populated if
   *   they interset.
   * @return {boolean} true if they intersect, false if they don't.
   */
  function testPolygonPolygon(a, b, response) {
    var aPoints = a['calcPoints'];
    var aLen = aPoints.length;
    var bPoints = b['calcPoints'];
    var bLen = bPoints.length;
    // If any of the edge normals of A is a separating axis, no intersection.
    for (var i = 0; i < aLen; i++) {
      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {
        return false;
      }
    }
    // If any of the edge normals of B is a separating axis, no intersection.
    for (var i = 0; i < bLen; i++) {
      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {
        return false;
      }
    }
    // Since none of the edge normals of A or B are a separating axis, there is an intersection
    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the
    // final overlap vector.
    if (response) {
      response['a'] = a;
      response['b'] = b;
      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);
    }
    return true;
  }
  SAT['testPolygonPolygon'] = testPolygonPolygon;

  return SAT;
}));


// * SAT Library colliders save/load support

//@[ALIAS]
var _alias_JsonEx__decode = JsonEx._decode;
JsonEx._decode = function (value) {
    try {
        const type = Object.prototype.toString.call(value);
        if (type === "[object Object]" || type === "[object Array]") {
            if (value["@"]) {
                let className = value["@"];
                if(['Vector', 'Circle', 'Polygon'].contains(className)) {
                    const constructor = window.SAT[value["@"]];
                    Object.setPrototypeOf(value, constructor.prototype);

                    for (const key of Object.keys(value)) {
                        value[key] = this._decode(value[key]);
                    }

                    return value;
                }
            }
        }
    } catch (error) {
        KDCore.warning(error);
    }
    return _alias_JsonEx__decode.call(this, ...arguments);
};

/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/pixi-filters@5.3.0/dist/browser/pixi-filters.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * pixi-filters - v5.3.0
 * Compiled Thu, 15 Feb 2024 16:39:05 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(e,t,r,n){"use strict";class i extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n"),this.gamma=1,this.saturation=1,this.contrast=1,this.brightness=1,this.red=1,this.green=1,this.blue=1,this.alpha=1,Object.assign(this,e)}apply(e,t,r,n){this.uniforms.gamma=Math.max(this.gamma,1e-4),this.uniforms.saturation=this.saturation,this.uniforms.contrast=this.contrast,this.uniforms.brightness=this.brightness,this.uniforms.red=this.red,this.uniforms.green=this.green,this.uniforms.blue=this.blue,this.uniforms.alpha=this.alpha,e.applyFilter(this,t,r,n)}}class o extends t.Filter{constructor(e=4,r=3,n=!1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",n?"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n":"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}"),this._kernels=[],this._blur=4,this._quality=3,this.uniforms.uOffset=new Float32Array(2),this._pixelSize=new t.Point,this.pixelSize=1,this._clamp=n,Array.isArray(e)?this.kernels=e:(this._blur=e,this.quality=r)}apply(e,t,r,n){const i=this._pixelSize.x/t._frame.width,o=this._pixelSize.y/t._frame.height;let s;if(1===this._quality||0===this._blur)s=this._kernels[0]+.5,this.uniforms.uOffset[0]=s*i,this.uniforms.uOffset[1]=s*o,e.applyFilter(this,t,r,n);else{const a=e.getFilterTexture();let l,u=t,c=a;const f=this._quality-1;for(let t=0;t<f;t++)s=this._kernels[t]+.5,this.uniforms.uOffset[0]=s*i,this.uniforms.uOffset[1]=s*o,e.applyFilter(this,u,c,1),l=u,u=c,c=l;s=this._kernels[f]+.5,this.uniforms.uOffset[0]=s*i,this.uniforms.uOffset[1]=s*o,e.applyFilter(this,u,r,n),e.returnFilterTexture(a)}}_updatePadding(){this.padding=Math.ceil(this._kernels.reduce(((e,t)=>e+t+.5),0))}_generateKernels(){const e=this._blur,t=this._quality,r=[e];if(e>0){let n=e;const i=e/t;for(let e=1;e<t;e++)n-=i,r.push(n)}this._kernels=r,this._updatePadding()}get kernels(){return this._kernels}set kernels(e){Array.isArray(e)&&e.length>0?(this._kernels=e,this._quality=e.length,this._blur=Math.max(...e)):(this._kernels=[0],this._quality=1)}get clamp(){return this._clamp}set pixelSize(e){"number"==typeof e?(this._pixelSize.x=e,this._pixelSize.y=e):Array.isArray(e)?(this._pixelSize.x=e[0],this._pixelSize.y=e[1]):e instanceof t.Point?(this._pixelSize.x=e.x,this._pixelSize.y=e.y):(this._pixelSize.x=1,this._pixelSize.y=1)}get pixelSize(){return this._pixelSize}get quality(){return this._quality}set quality(e){this._quality=Math.max(1,Math.round(e)),this._generateKernels()}get blur(){return this._blur}set blur(e){this._blur=e,this._generateKernels()}}var s="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";class a extends t.Filter{constructor(e=.5){super(s,"\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n"),this.threshold=e}get threshold(){return this.uniforms.threshold}set threshold(e){this.uniforms.threshold=e}}const l=class extends t.Filter{constructor(e){super(s,"uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n"),this.bloomScale=1,this.brightness=1,this._resolution=t.settings.FILTER_RESOLUTION,"number"==typeof e&&(e={threshold:e});const r=Object.assign(l.defaults,e);this.bloomScale=r.bloomScale,this.brightness=r.brightness;const{kernels:n,blur:i,quality:u,pixelSize:c,resolution:f}=r;this._extractFilter=new a(r.threshold),this._extractFilter.resolution=f,this._blurFilter=n?new o(n):new o(i,u),this.pixelSize=c,this.resolution=f}apply(e,t,r,n,i){const o=e.getFilterTexture();this._extractFilter.apply(e,t,o,1,i);const s=e.getFilterTexture();this._blurFilter.apply(e,o,s,1),this.uniforms.bloomScale=this.bloomScale,this.uniforms.brightness=this.brightness,this.uniforms.bloomTexture=s,e.applyFilter(this,t,r,n),e.returnFilterTexture(s),e.returnFilterTexture(o)}get resolution(){return this._resolution}set resolution(e){this._resolution=e,this._extractFilter&&(this._extractFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)}get threshold(){return this._extractFilter.threshold}set threshold(e){this._extractFilter.threshold=e}get kernels(){return this._blurFilter.kernels}set kernels(e){this._blurFilter.kernels=e}get blur(){return this._blurFilter.blur}set blur(e){this._blurFilter.blur=e}get quality(){return this._blurFilter.quality}set quality(e){this._blurFilter.quality=e}get pixelSize(){return this._blurFilter.pixelSize}set pixelSize(e){this._blurFilter.pixelSize=e}};let u=l;u.defaults={threshold:.5,bloomScale:1,brightness:1,kernels:null,blur:8,quality:4,pixelSize:1,resolution:t.settings.FILTER_RESOLUTION};class c extends t.Filter{constructor(e=8){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor(coord / size) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod(coord, size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, 4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the grid position\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    // sample the color at grid position\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // brightness of the color as it's perceived by the human eye\n    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n\n    // determine the character to use\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}\n"),this.size=e}get size(){return this.uniforms.pixelSize}set size(e){this.uniforms.pixelSize=e}}class f extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n"),this._thickness=2,this._angle=0,this.uniforms.lightColor=new Float32Array(3),this.uniforms.shadowColor=new Float32Array(3),Object.assign(this,{rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7},e),this.padding=1}_updateTransform(){this.uniforms.transformX=this._thickness*Math.cos(this._angle),this.uniforms.transformY=this._thickness*Math.sin(this._angle)}get rotation(){return this._angle/t.DEG_TO_RAD}set rotation(e){this._angle=e*t.DEG_TO_RAD,this._updateTransform()}get thickness(){return this._thickness}set thickness(e){this._thickness=e,this._updateTransform()}get lightColor(){return t.utils.rgb2hex(this.uniforms.lightColor)}set lightColor(e){t.utils.hex2rgb(e,this.uniforms.lightColor)}get lightAlpha(){return this.uniforms.lightAlpha}set lightAlpha(e){this.uniforms.lightAlpha=e}get shadowColor(){return t.utils.rgb2hex(this.uniforms.shadowColor)}set shadowColor(e){t.utils.hex2rgb(e,this.uniforms.shadowColor)}get shadowAlpha(){return this.uniforms.shadowAlpha}set shadowAlpha(e){this.uniforms.shadowAlpha=e}}class d extends t.Filter{constructor(e=2,i=4,o=t.settings.FILTER_RESOLUTION,s=5){let a,l;super(),"number"==typeof e?(a=e,l=e):e instanceof t.Point?(a=e.x,l=e.y):Array.isArray(e)&&(a=e[0],l=e[1]),this.blurXFilter=new n.BlurFilterPass(!0,a,i,o,s),this.blurYFilter=new n.BlurFilterPass(!1,l,i,o,s),this.blurYFilter.blendMode=t.BLEND_MODES.SCREEN,this.defaultFilter=new r.AlphaFilter}apply(e,t,r,n){const i=e.getFilterTexture();this.defaultFilter.apply(e,t,r,n),this.blurXFilter.apply(e,t,i,1),this.blurYFilter.apply(e,i,r,0),e.returnFilterTexture(i)}get blur(){return this.blurXFilter.blur}set blur(e){this.blurXFilter.blur=this.blurYFilter.blur=e}get blurX(){return this.blurXFilter.blur}set blurX(e){this.blurXFilter.blur=e}get blurY(){return this.blurYFilter.blur}set blurY(e){this.blurYFilter.blur=e}}const h=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n"),this.uniforms.dimensions=new Float32Array(2),Object.assign(this,h.defaults,e)}apply(e,t,r,n){const{width:i,height:o}=t.filterFrame;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=o,e.applyFilter(this,t,r,n)}get radius(){return this.uniforms.radius}set radius(e){this.uniforms.radius=e}get strength(){return this.uniforms.strength}set strength(e){this.uniforms.strength=e}get center(){return this.uniforms.center}set center(e){this.uniforms.center=e}};let m=h;m.defaults={center:[.5,.5],radius:100,strength:1};var g,v;(v=v||{}).stringify=(g={"visit_linear-gradient":function(e){return g.visit_gradient(e)},"visit_repeating-linear-gradient":function(e){return g.visit_gradient(e)},"visit_radial-gradient":function(e){return g.visit_gradient(e)},"visit_repeating-radial-gradient":function(e){return g.visit_gradient(e)},visit_gradient:function(e){var t=g.visit(e.orientation);return t&&(t+=", "),e.type+"("+t+g.visit(e.colorStops)+")"},visit_shape:function(e){var t=e.value,r=g.visit(e.at),n=g.visit(e.style);return n&&(t+=" "+n),r&&(t+=" at "+r),t},"visit_default-radial":function(e){var t="",r=g.visit(e.at);return r&&(t+=r),t},"visit_extent-keyword":function(e){var t=e.value,r=g.visit(e.at);return r&&(t+=" at "+r),t},"visit_position-keyword":function(e){return e.value},visit_position:function(e){return g.visit(e.value.x)+" "+g.visit(e.value.y)},"visit_%":function(e){return e.value+"%"},visit_em:function(e){return e.value+"em"},visit_px:function(e){return e.value+"px"},visit_literal:function(e){return g.visit_color(e.value,e)},visit_hex:function(e){return g.visit_color("#"+e.value,e)},visit_rgb:function(e){return g.visit_color("rgb("+e.value.join(", ")+")",e)},visit_rgba:function(e){return g.visit_color("rgba("+e.value.join(", ")+")",e)},visit_color:function(e,t){var r=e,n=g.visit(t.length);return n&&(r+=" "+n),r},visit_angular:function(e){return e.value+"deg"},visit_directional:function(e){return"to "+e.value},visit_array:function(e){var t="",r=e.length;return e.forEach((function(e,n){t+=g.visit(e),n<r-1&&(t+=", ")})),t},visit:function(e){if(!e)return"";if(e instanceof Array)return g.visit_array(e,"");if(e.type){var t=g["visit_"+e.type];if(t)return t(e);throw Error("Missing visitor visit_"+e.type)}throw Error("Invalid node.")}},function(e){return g.visit(e)}),(v=v||{}).parse=function(){var e={linearGradient:/^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,repeatingLinearGradient:/^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,radialGradient:/^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,repeatingRadialGradient:/^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,sideOrCorner:/^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,extentKeywords:/^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,positionKeywords:/^(left|center|right|top|bottom)/i,pixelValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,percentageValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,emValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,angleValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,startCall:/^\(/,endCall:/^\)/,comma:/^,/,hexColor:/^\#([0-9a-fA-F]+)/,literalColor:/^([a-zA-Z]+)/,rgbColor:/^rgb/i,rgbaColor:/^rgba/i,number:/^(([0-9]*\.[0-9]+)|([0-9]+\.?))/},t="";function r(e){var r=new Error(t+": "+e);throw r.source=t,r}function n(){var e=h(i);return t.length>0&&r("Invalid input not EOF"),e}function i(){return o("linear-gradient",e.linearGradient,a)||o("repeating-linear-gradient",e.repeatingLinearGradient,a)||o("radial-gradient",e.radialGradient,l)||o("repeating-radial-gradient",e.repeatingRadialGradient,l)}function o(t,n,i){return s(n,(function(n){var o=i();return o&&(y(e.comma)||r("Missing comma before color stops")),{type:t,orientation:o,colorStops:h(m)}}))}function s(t,n){var i=y(t);if(i){y(e.startCall)||r("Missing (");var o=n(i);return y(e.endCall)||r("Missing )"),o}}function a(){return x("directional",e.sideOrCorner,1)||x("angular",e.angleValue,1)}function l(){var r,n,i=u();return i&&((r=[]).push(i),n=t,y(e.comma)&&((i=u())?r.push(i):t=n)),r}function u(){var e=function(){var e=x("shape",/^(circle)/i,0);return e&&(e.style=p()||c()),e}()||function(){var e=x("shape",/^(ellipse)/i,0);return e&&(e.style=v()||c()),e}();if(e)e.at=f();else{var t=c();if(t){e=t;var r=f();r&&(e.at=r)}else{var n=d();n&&(e={type:"default-radial",at:n})}}return e}function c(){return x("extent-keyword",e.extentKeywords,1)}function f(){if(x("position",/^at/,0)){var e=d();return e||r("Missing positioning value"),e}}function d(){var e={x:v(),y:v()};if(e.x||e.y)return{type:"position",value:e}}function h(t){var n=t(),i=[];if(n)for(i.push(n);y(e.comma);)(n=t())?i.push(n):r("One extra comma");return i}function m(){var t=x("hex",e.hexColor,1)||s(e.rgbaColor,(function(){return{type:"rgba",value:h(g)}}))||s(e.rgbColor,(function(){return{type:"rgb",value:h(g)}}))||x("literal",e.literalColor,0);return t||r("Expected color definition"),t.length=v(),t}function g(){return y(e.number)[1]}function v(){return x("%",e.percentageValue,1)||x("position-keyword",e.positionKeywords,1)||p()}function p(){return x("px",e.pixelValue,1)||x("em",e.emValue,1)}function x(e,t,r){var n=y(t);if(n)return{type:e,value:n[r]}}function y(e){var r,n;return(n=/^[\n\r\t\s]+/.exec(t))&&C(n[0].length),(r=e.exec(t))&&C(r[0].length),r}function C(e){t=t.substr(e)}return function(e){return t=e.toString(),n()}}();var p=v.parse;v.stringify;var x={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},y={red:0,orange:60,yellow:120,green:180,blue:240,purple:300};var C={name:"rgb",min:[0,0,0],max:[255,255,255],channel:["red","green","blue"],alias:["RGB"]},_={name:"hsl",min:[0,0,0],max:[360,100,100],channel:["hue","saturation","lightness"],alias:["HSL"],rgb:function(e){var t,r,n,i,o,s=e[0]/360,a=e[1]/100,l=e[2]/100;if(0===a)return[o=255*l,o,o];t=2*l-(r=l<.5?l*(1+a):l+a-l*a),i=[0,0,0];for(var u=0;u<3;u++)(n=s+1/3*-(u-1))<0?n++:n>1&&n--,o=6*n<1?t+6*(r-t)*n:2*n<1?r:3*n<2?t+(r-t)*(2/3-n)*6:t,i[u]=255*o;return i}};function b(e){Array.isArray(e)&&e.raw&&(e=String.raw(...arguments));var t,r=function(e){var t,r,n=[],i=1;if("string"==typeof e)if(x[e])n=x[e].slice(),r="rgb";else if("transparent"===e)i=0,r="rgb",n=[0,0,0];else if(/^#[A-Fa-f0-9]+$/.test(e)){var o=e.slice(1);i=1,(l=o.length)<=4?(n=[parseInt(o[0]+o[0],16),parseInt(o[1]+o[1],16),parseInt(o[2]+o[2],16)],4===l&&(i=parseInt(o[3]+o[3],16)/255)):(n=[parseInt(o[0]+o[1],16),parseInt(o[2]+o[3],16),parseInt(o[4]+o[5],16)],8===l&&(i=parseInt(o[6]+o[7],16)/255)),n[0]||(n[0]=0),n[1]||(n[1]=0),n[2]||(n[2]=0),r="rgb"}else if(t=/^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(e)){var s=t[1],a="rgb"===s;r=o=s.replace(/a$/,"");var l="cmyk"===o?4:"gray"===o?1:3;n=t[2].trim().split(/\s*[,\/]\s*|\s+/).map((function(e,t){if(/%$/.test(e))return t===l?parseFloat(e)/100:"rgb"===o?255*parseFloat(e)/100:parseFloat(e);if("h"===o[t]){if(/deg$/.test(e))return parseFloat(e);if(void 0!==y[e])return y[e]}return parseFloat(e)})),s===o&&n.push(1),i=a||void 0===n[l]?1:n[l],n=n.slice(0,l)}else e.length>10&&/[0-9](?:\s|\/)/.test(e)&&(n=e.match(/([0-9]+)/g).map((function(e){return parseFloat(e)})),r=e.match(/([a-z])/gi).join("").toLowerCase());else isNaN(e)?Array.isArray(e)||e.length?(n=[e[0],e[1],e[2]],r="rgb",i=4===e.length?e[3]:1):e instanceof Object&&(null!=e.r||null!=e.red||null!=e.R?(r="rgb",n=[e.r||e.red||e.R||0,e.g||e.green||e.G||0,e.b||e.blue||e.B||0]):(r="hsl",n=[e.h||e.hue||e.H||0,e.s||e.saturation||e.S||0,e.l||e.lightness||e.L||e.b||e.brightness]),i=e.a||e.alpha||e.opacity||1,null!=e.opacity&&(i/=100)):(r="rgb",n=[e>>>16,(65280&e)>>>8,255&e]);return{space:r,values:n,alpha:i}}(e);if(!r.space)return[];const n="h"===r.space[0]?_.min:C.min,i="h"===r.space[0]?_.max:C.max;return(t=Array(3))[0]=Math.min(Math.max(r.values[0],n[0]),i[0]),t[1]=Math.min(Math.max(r.values[1],n[1]),i[1]),t[2]=Math.min(Math.max(r.values[2],n[2]),i[2]),"h"===r.space[0]&&(t=_.rgb(t)),t.push(Math.min(Math.max(r.alpha,0),1)),t}function S(e){switch(typeof e){case"string":return function(e){const t=b(e);if(!t)throw new Error(`Unable to parse color "${e}" as RGBA.`);return[t[0]/255,t[1]/255,t[2]/255,t[3]]}(e);case"number":return t.utils.hex2rgb(e);default:return e}}function T(e){const t=p(function(e){let t=e.replace(/\s{2,}/gu," ");return t=t.replace(/;/g,""),t=t.replace(/ ,/g,","),t=t.replace(/\( /g,"("),t=t.replace(/ \)/g,")"),t.trim()}(e));if(0===t.length)throw new Error("Invalid CSS gradient.");if(1!==t.length)throw new Error("Unsupported CSS gradient (multiple gradients is not supported).");const r=t[0],n=function(e){const t={"linear-gradient":0,"radial-gradient":1};if(!(e in t))throw new Error(`Unsupported gradient type "${e}"`);return t[e]}(r.type),i=function(e){const t=function(e){const t=[];for(let r=0;r<e.length;r++){const n=e[r];let i=-1;"literal"===n.type&&n.length&&"type"in n.length&&"%"===n.length.type&&"value"in n.length&&(i=parseFloat(n.length.value)/100),t.push(i)}const r=e=>{for(let r=e;r<t.length;r++)if(-1!==t[r])return{indexDelta:r-e,offset:t[r]};return{indexDelta:t.length-1-e,offset:1}};let n=0;for(let e=0;e<t.length;e++){const i=t[e];if(-1!==i)n=i;else if(0===e)t[e]=0;else if(e+1===t.length)t[e]=1;else{const i=r(e),o=(i.offset-n)/(1+i.indexDelta);for(let r=0;r<=i.indexDelta;r++)t[e+r]=n+(r+1)*o;e+=i.indexDelta,n=t[e]}}return t.map(A)}(e),r=[];for(let n=0;n<e.length;n++){const i=F(e[n]);r.push({offset:t[n],color:i.slice(0,3),alpha:i[3]})}return r}(r.colorStops),o=function(e){if(void 0===e)return 0;if("type"in e&&"value"in e)switch(e.type){case"angular":return parseFloat(e.value);case"directional":return function(e){const t={left:270,top:0,bottom:180,right:90,"left top":315,"top left":315,"left bottom":225,"bottom left":225,"right top":45,"top right":45,"right bottom":135,"bottom right":135};if(!(e in t))throw new Error(`Unsupported directional value "${e}"`);return t[e]}(e.value)}return 0}(r.orientation);return{type:n,stops:i,angle:o}}function F(e){return S(function(e){switch(e.type){case"hex":return`#${e.value}`;case"literal":return e.value;default:return`${e.type}(${e.value.join(",")})`}}(e))}function A(e){return e.toString().length>6?parseFloat(e.toString().substring(0,6)):e}C.hsl=function(e){var t,r,n=e[0]/255,i=e[1]/255,o=e[2]/255,s=Math.min(n,i,o),a=Math.max(n,i,o),l=a-s;return a===s?t=0:n===a?t=(i-o)/l:i===a?t=2+(o-n)/l:o===a&&(t=4+(n-i)/l),(t=Math.min(60*t,360))<0&&(t+=360),r=(s+a)/2,[t,100*(a===s?0:r<=.5?l/(a+s):l/(2-a-s)),100*r]};var z=Object.defineProperty,w=Object.defineProperties,P=Object.getOwnPropertyDescriptors,M=Object.getOwnPropertySymbols,D=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable,O=(e,t,r)=>t in e?z(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,R=(e,t)=>{for(var r in t||(t={}))D.call(t,r)&&O(e,r,t[r]);if(M)for(var r of M(t))k.call(t,r)&&O(e,r,t[r]);return e};const E=class extends t.Filter{constructor(e){var t,r;let n;if(n=e&&"css"in e?((e,t)=>w(e,P(t)))(R({},T(e.css||"")),{alpha:null!=(t=e.alpha)?t:E.defaults.alpha,maxColors:null!=(r=e.maxColors)?r:E.defaults.maxColors}):R(R({},E.defaults),e),!n.stops||n.stops.length<2)throw new Error("ColorGradientFilter requires at least 2 color stops.");super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vFilterCoord = vTextureCoord * inputSize.xy / outputFrame.zw;\n}\n","const float PI = 3.1415926538;\nconst float PI_2 = PI*2.;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\nuniform sampler2D uSampler;\n\nconst int TYPE_LINEAR = 0;\nconst int TYPE_RADIAL = 1;\nconst int TYPE_CONIC = 2;\nconst int MAX_STOPS = 32;\n\nuniform int uNumStops;\nuniform float uAlphas[3*MAX_STOPS];\nuniform vec3 uColors[MAX_STOPS];\nuniform float uOffsets[MAX_STOPS];\nuniform int uType;\nuniform float uAngle;\nuniform float uAlpha;\nuniform int uMaxColors;\nuniform bool uReplace;\n\nstruct ColorStop {\n    float offset;\n    vec3 color;\n    float alpha;\n};\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n    sin(angle), cos(angle));\n}\n\nfloat projectLinearPosition(vec2 pos, float angle){\n    vec2 center = vec2(0.5);\n    vec2 result = pos - center;\n    result = rotate2d(angle) * result;\n    result = result + center;\n    return clamp(result.x, 0., 1.);\n}\n\nfloat projectRadialPosition(vec2 pos) {\n    float r = distance(vFilterCoord, vec2(0.5));\n    return clamp(2.*r, 0., 1.);\n}\n\nfloat projectAnglePosition(vec2 pos, float angle) {\n    vec2 center = pos - vec2(0.5);\n    float polarAngle=atan(-center.y, center.x);\n    return mod(polarAngle + angle, PI_2) / PI_2;\n}\n\nfloat projectPosition(vec2 pos, int type, float angle) {\n    if (type == TYPE_LINEAR) {\n        return projectLinearPosition(pos, angle);\n    } else if (type == TYPE_RADIAL) {\n        return projectRadialPosition(pos);\n    } else if (type == TYPE_CONIC) {\n        return projectAnglePosition(pos, angle);\n    }\n\n    return pos.y;\n}\n\nvoid main(void) {\n    // current/original color\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n\n    // skip calculations if gradient alpha is 0\n    if (0.0 == uAlpha) {\n        gl_FragColor = currentColor;\n        return;\n    }\n\n    // project position\n    float y = projectPosition(vFilterCoord, uType, radians(uAngle));\n\n    // check gradient bounds\n    float offsetMin = uOffsets[0];\n    float offsetMax = 0.0;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (i == uNumStops-1){ // last index\n            offsetMax = uOffsets[i];\n        }\n    }\n\n    if (y  < offsetMin || y > offsetMax) {\n        gl_FragColor = currentColor;\n        return;\n    }\n\n    // limit colors\n    if (uMaxColors > 0) {\n        float stepSize = 1./float(uMaxColors);\n        float stepNumber = float(floor(y/stepSize));\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\n    }\n\n    // find color stops\n    ColorStop from;\n    ColorStop to;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (y >= uOffsets[i]) {\n            from = ColorStop(uOffsets[i], uColors[i], uAlphas[i]);\n            to = ColorStop(uOffsets[i+1], uColors[i+1], uAlphas[i+1]);\n        }\n\n        if (i == uNumStops-1){ // last index\n            break;\n        }\n    }\n\n    // mix colors from stops\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\n\n    float segmentHeight = to.offset - from.offset;\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\n\n    float gradientAlpha = uAlpha * currentColor.a;\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n    if (uReplace == false) {\n        // mix resulting color with current color\n        gl_FragColor = gradientColor + currentColor*(1.-gradientColor.a);\n    } else {\n        // replace with gradient color\n        gl_FragColor = gradientColor;\n    }\n}\n"),this._stops=[],this.autoFit=!1,Object.assign(this,n)}get stops(){return this._stops}set stops(e){const t=function(e){return[...e].sort(((e,t)=>e.offset-t.offset))}(e),r=new Float32Array(3*t.length);for(let e=0;e<t.length;e++){const n=S(t[e].color),i=3*e;r[i+0]=n[0],r[i+1]=n[1],r[i+2]=n[2]}this.uniforms.uColors=r,this.uniforms.uOffsets=t.map((e=>e.offset)),this.uniforms.uAlphas=t.map((e=>e.alpha)),this.uniforms.uNumStops=t.length,this._stops=t}set type(e){this.uniforms.uType=e}get type(){return this.uniforms.uType}set angle(e){this.uniforms.uAngle=e-90}get angle(){return this.uniforms.uAngle+90}set alpha(e){this.uniforms.uAlpha=e}get alpha(){return this.uniforms.uAlpha}set maxColors(e){this.uniforms.uMaxColors=e}get maxColors(){return this.uniforms.uMaxColors}set replace(e){this.uniforms.uReplace=e}get replace(){return this.uniforms.uReplace}};let j=E;j.LINEAR=0,j.RADIAL=1,j.CONIC=2,j.defaults={type:E.LINEAR,stops:[{offset:0,color:16711680,alpha:1},{offset:1,color:255,alpha:1}],alpha:1,angle:90,maxColors:0,replace:!1};class I extends t.Filter{constructor(e,t=!1,r=1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}"),this.mix=1,this._size=0,this._sliceSize=0,this._slicePixelSize=0,this._sliceInnerSize=0,this._nearest=!1,this._scaleMode=null,this._colorMap=null,this._scaleMode=null,this.nearest=t,this.mix=r,this.colorMap=e}apply(e,t,r,n){this.uniforms._mix=this.mix,e.applyFilter(this,t,r,n)}get colorSize(){return this._size}get colorMap(){return this._colorMap}set colorMap(e){!e||(e instanceof t.Texture||(e=t.Texture.from(e)),null!=e&&e.baseTexture&&(e.baseTexture.scaleMode=this._scaleMode,e.baseTexture.mipmap=t.MIPMAP_MODES.OFF,this._size=e.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms._size=this._size,this.uniforms._sliceSize=this._sliceSize,this.uniforms._slicePixelSize=this._slicePixelSize,this.uniforms._sliceInnerSize=this._sliceInnerSize,this.uniforms.colorMap=e),this._colorMap=e)}get nearest(){return this._nearest}set nearest(e){this._nearest=e,this._scaleMode=e?t.SCALE_MODES.NEAREST:t.SCALE_MODES.LINEAR;const r=this._colorMap;r&&r.baseTexture&&(r.baseTexture._glTextures={},r.baseTexture.scaleMode=this._scaleMode,r.baseTexture.mipmap=t.MIPMAP_MODES.OFF,r._updateID++,r.baseTexture.emit("update",r.baseTexture))}updateColorMap(){const e=this._colorMap;e&&e.baseTexture&&(e._updateID++,e.baseTexture.emit("update",e.baseTexture),this.colorMap=e)}destroy(e=!1){this._colorMap&&this._colorMap.destroy(e),super.destroy()}}class L extends t.Filter{constructor(e=0,t=1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 color;\nuniform float alpha;\n\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(mix(currentColor.rgb, color.rgb, currentColor.a * alpha), currentColor.a);\n}\n"),this._color=0,this._alpha=1,this.uniforms.color=new Float32Array(3),this.color=e,this.alpha=t}set color(e){const r=this.uniforms.color;"number"==typeof e?(t.utils.hex2rgb(e,r),this._color=e):(r[0]=e[0],r[1]=e[1],r[2]=e[2],this._color=t.utils.rgb2hex(r))}get color(){return this._color}set alpha(e){this.uniforms.alpha=e,this._alpha=e}get alpha(){return this._alpha}}class V extends t.Filter{constructor(e=16711680,t=0,r=.4){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n"),this._originalColor=16711680,this._newColor=0,this.uniforms.originalColor=new Float32Array(3),this.uniforms.newColor=new Float32Array(3),this.originalColor=e,this.newColor=t,this.epsilon=r}set originalColor(e){const r=this.uniforms.originalColor;"number"==typeof e?(t.utils.hex2rgb(e,r),this._originalColor=e):(r[0]=e[0],r[1]=e[1],r[2]=e[2],this._originalColor=t.utils.rgb2hex(r))}get originalColor(){return this._originalColor}set newColor(e){const r=this.uniforms.newColor;"number"==typeof e?(t.utils.hex2rgb(e,r),this._newColor=e):(r[0]=e[0],r[1]=e[1],r[2]=e[2],this._newColor=t.utils.rgb2hex(r))}get newColor(){return this._newColor}set epsilon(e){this.uniforms.epsilon=e}get epsilon(){return this.uniforms.epsilon}}class N extends t.Filter{constructor(e,t=200,r=200){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n"),this.uniforms.texelSize=new Float32Array(2),this.uniforms.matrix=new Float32Array(9),void 0!==e&&(this.matrix=e),this.width=t,this.height=r}get matrix(){return this.uniforms.matrix}set matrix(e){e.forEach(((e,t)=>{this.uniforms.matrix[t]=e}))}get width(){return 1/this.uniforms.texelSize[0]}set width(e){this.uniforms.texelSize[0]=1/e}get height(){return 1/this.uniforms.texelSize[1]}set height(e){this.uniforms.texelSize[1]=1/e}}class G extends t.Filter{constructor(){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n")}}const B=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n"),this.time=0,this.seed=0,this.uniforms.dimensions=new Float32Array(2),Object.assign(this,B.defaults,e)}apply(e,t,r,n){const{width:i,height:o}=t.filterFrame;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=o,this.uniforms.seed=this.seed,this.uniforms.time=this.time,e.applyFilter(this,t,r,n)}set curvature(e){this.uniforms.curvature=e}get curvature(){return this.uniforms.curvature}set lineWidth(e){this.uniforms.lineWidth=e}get lineWidth(){return this.uniforms.lineWidth}set lineContrast(e){this.uniforms.lineContrast=e}get lineContrast(){return this.uniforms.lineContrast}set verticalLine(e){this.uniforms.verticalLine=e}get verticalLine(){return this.uniforms.verticalLine}set noise(e){this.uniforms.noise=e}get noise(){return this.uniforms.noise}set noiseSize(e){this.uniforms.noiseSize=e}get noiseSize(){return this.uniforms.noiseSize}set vignetting(e){this.uniforms.vignetting=e}get vignetting(){return this.uniforms.vignetting}set vignettingAlpha(e){this.uniforms.vignettingAlpha=e}get vignettingAlpha(){return this.uniforms.vignettingAlpha}set vignettingBlur(e){this.uniforms.vignettingBlur=e}get vignettingBlur(){return this.uniforms.vignettingBlur}};let X=B;X.defaults={curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,seed:0,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0};class q extends t.Filter{constructor(e=1,t=5,r=!0){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\nuniform bool grayscale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   vec3 colorRGB = vec3(color);\n\n   if (grayscale)\n   {\n       colorRGB = vec3(color.r + color.g + color.b) / 3.0;\n   }\n\n   gl_FragColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);\n}\n"),this.scale=e,this.angle=t,this.grayscale=r}get scale(){return this.uniforms.scale}set scale(e){this.uniforms.scale=e}get angle(){return this.uniforms.angle}set angle(e){this.uniforms.angle=e}get grayscale(){return this.uniforms.grayscale}set grayscale(e){this.uniforms.grayscale=e}}var K=Object.defineProperty,W=Object.getOwnPropertySymbols,Y=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable,Z=(e,t,r)=>t in e?K(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,U=(e,t)=>{for(var r in t||(t={}))Y.call(t,r)&&Z(e,r,t[r]);if(W)for(var r of W(t))$.call(t,r)&&Z(e,r,t[r]);return e};const H=class extends t.Filter{constructor(e){super(),this.angle=45,this._distance=5,this._resolution=t.settings.FILTER_RESOLUTION;const r=e?U(U({},H.defaults),e):H.defaults,{kernels:n,blur:i,quality:s,pixelSize:a,resolution:l}=r;this._offset=new t.ObservablePoint(this._updatePadding,this),this._tintFilter=new t.Filter("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}"),this._tintFilter.uniforms.color=new Float32Array(4),this._tintFilter.uniforms.shift=this._offset,this._tintFilter.resolution=l,this._blurFilter=n?new o(n):new o(i,s),this.pixelSize=a,this.resolution=l;const{shadowOnly:u,rotation:c,distance:f,offset:d,alpha:h,color:m}=r;this.shadowOnly=u,void 0!==c&&void 0!==f?(this.rotation=c,this.distance=f):this.offset=d,this.alpha=h,this.color=m}apply(e,t,r,n){const i=e.getFilterTexture();this._tintFilter.apply(e,t,i,1),this._blurFilter.apply(e,i,r,n),!0!==this.shadowOnly&&e.applyFilter(this,t,r,0),e.returnFilterTexture(i)}_updatePadding(){const e=Math.max(Math.abs(this._offset.x),Math.abs(this._offset.y));this.padding=e+2*this.blur}_updateShift(){this._tintFilter.uniforms.shift.set(this.distance*Math.cos(this.angle),this.distance*Math.sin(this.angle))}set offset(e){this._offset.copyFrom(e),this._updatePadding()}get offset(){return this._offset}get resolution(){return this._resolution}set resolution(e){this._resolution=e,this._tintFilter&&(this._tintFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)}get distance(){return this._distance}set distance(e){t.utils.deprecation("5.3.0","DropShadowFilter distance is deprecated, use offset"),this._distance=e,this._updatePadding(),this._updateShift()}get rotation(){return this.angle/t.DEG_TO_RAD}set rotation(e){t.utils.deprecation("5.3.0","DropShadowFilter rotation is deprecated, use offset"),this.angle=e*t.DEG_TO_RAD,this._updateShift()}get alpha(){return this._tintFilter.uniforms.alpha}set alpha(e){this._tintFilter.uniforms.alpha=e}get color(){return t.utils.rgb2hex(this._tintFilter.uniforms.color)}set color(e){t.utils.hex2rgb(e,this._tintFilter.uniforms.color)}get kernels(){return this._blurFilter.kernels}set kernels(e){this._blurFilter.kernels=e}get blur(){return this._blurFilter.blur}set blur(e){this._blurFilter.blur=e,this._updatePadding()}get quality(){return this._blurFilter.quality}set quality(e){this._blurFilter.quality=e}get pixelSize(){return this._blurFilter.pixelSize}set pixelSize(e){this._blurFilter.pixelSize=e}};let Q=H;Q.defaults={offset:{x:4,y:4},color:0,alpha:.5,shadowOnly:!1,kernels:null,blur:2,quality:3,pixelSize:1,resolution:t.settings.FILTER_RESOLUTION};class J extends t.Filter{constructor(e=5){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n\tvec2 onePixel = vec2(1.0 / filterArea);\n\n\tvec4 color;\n\n\tcolor.rgb = vec3(0.5);\n\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\n\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n"),this.strength=e}get strength(){return this.uniforms.strength}set strength(e){this.uniforms.strength=e}}const ee=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n"),this.offset=100,this.fillMode=ee.TRANSPARENT,this.average=!1,this.seed=0,this.minSize=8,this.sampleSize=512,this._slices=0,this._offsets=new Float32Array(1),this._sizes=new Float32Array(1),this._direction=-1,this.uniforms.dimensions=new Float32Array(2),this._canvas=document.createElement("canvas"),this._canvas.width=4,this._canvas.height=this.sampleSize,this.texture=t.Texture.from(this._canvas,{scaleMode:t.SCALE_MODES.NEAREST}),Object.assign(this,ee.defaults,e)}apply(e,t,r,n){const{width:i,height:o}=t.filterFrame;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=o,this.uniforms.aspect=o/i,this.uniforms.seed=this.seed,this.uniforms.offset=this.offset,this.uniforms.fillMode=this.fillMode,e.applyFilter(this,t,r,n)}_randomizeSizes(){const e=this._sizes,t=this._slices-1,r=this.sampleSize,n=Math.min(this.minSize/r,.9/this._slices);if(this.average){const r=this._slices;let i=1;for(let o=0;o<t;o++){const t=i/(r-o),s=Math.max(t*(1-.6*Math.random()),n);e[o]=s,i-=s}e[t]=i}else{let r=1;const i=Math.sqrt(1/this._slices);for(let o=0;o<t;o++){const t=Math.max(i*r*Math.random(),n);e[o]=t,r-=t}e[t]=r}this.shuffle()}shuffle(){const e=this._sizes;for(let t=this._slices-1;t>0;t--){const r=Math.random()*t>>0,n=e[t];e[t]=e[r],e[r]=n}}_randomizeOffsets(){for(let e=0;e<this._slices;e++)this._offsets[e]=Math.random()*(Math.random()<.5?-1:1)}refresh(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()}redraw(){const e=this.sampleSize,t=this.texture,r=this._canvas.getContext("2d");r.clearRect(0,0,8,e);let n,i=0;for(let t=0;t<this._slices;t++){n=Math.floor(256*this._offsets[t]);const o=this._sizes[t]*e,s=n>0?n:0,a=n<0?-n:0;r.fillStyle=`rgba(${s}, ${a}, 0, 1)`,r.fillRect(0,i>>0,e,o+1>>0),i+=o}t.baseTexture.update(),this.uniforms.displacementMap=t}set sizes(e){const t=Math.min(this._slices,e.length);for(let r=0;r<t;r++)this._sizes[r]=e[r]}get sizes(){return this._sizes}set offsets(e){const t=Math.min(this._slices,e.length);for(let r=0;r<t;r++)this._offsets[r]=e[r]}get offsets(){return this._offsets}get slices(){return this._slices}set slices(e){this._slices!==e&&(this._slices=e,this.uniforms.slices=e,this._sizes=this.uniforms.slicesWidth=new Float32Array(e),this._offsets=this.uniforms.slicesOffset=new Float32Array(e),this.refresh())}get direction(){return this._direction}set direction(e){if(this._direction===e)return;this._direction=e;const r=e*t.DEG_TO_RAD;this.uniforms.sinDir=Math.sin(r),this.uniforms.cosDir=Math.cos(r)}get red(){return this.uniforms.red}set red(e){this.uniforms.red=e}get green(){return this.uniforms.green}set green(e){this.uniforms.green=e}get blue(){return this.uniforms.blue}set blue(e){this.uniforms.blue=e}destroy(){var e;null==(e=this.texture)||e.destroy(!0),this.texture=this._canvas=this.red=this.green=this.blue=this._sizes=this._offsets=null}};let te=ee;te.defaults={slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:[0,0],green:[0,0],blue:[0,0],minSize:8,sampleSize:512},te.TRANSPARENT=0,te.ORIGINAL=1,te.LOOP=2,te.CLAMP=3,te.MIRROR=4;var re="varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\nuniform float alpha;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    if (knockout) {\n      float resultAlpha = (outerGlowAlpha + innerGlowAlpha) * alpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      vec4 outerGlowColor = outerGlowStrength * glowColor.rgba * alpha;\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n";const ne=class extends t.Filter{constructor(e){const t=Object.assign({},ne.defaults,e),{outerStrength:r,innerStrength:n,color:i,knockout:o,quality:s,alpha:a}=t,l=Math.round(t.distance);super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",re.replace(/__ANGLE_STEP_SIZE__/gi,`${(1/s/l).toFixed(7)}`).replace(/__DIST__/gi,`${l.toFixed(0)}.0`)),this.uniforms.glowColor=new Float32Array([0,0,0,1]),this.uniforms.alpha=1,Object.assign(this,{color:i,outerStrength:r,innerStrength:n,padding:l,knockout:o,alpha:a})}get color(){return t.utils.rgb2hex(this.uniforms.glowColor)}set color(e){t.utils.hex2rgb(e,this.uniforms.glowColor)}get outerStrength(){return this.uniforms.outerStrength}set outerStrength(e){this.uniforms.outerStrength=e}get innerStrength(){return this.uniforms.innerStrength}set innerStrength(e){this.uniforms.innerStrength=e}get knockout(){return this.uniforms.knockout}set knockout(e){this.uniforms.knockout=e}get alpha(){return this.uniforms.alpha}set alpha(e){this.uniforms.alpha=e}};let ie=ne;ie.defaults={distance:10,outerStrength:4,innerStrength:0,color:16777215,quality:.1,knockout:!1,alpha:1};var oe="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\nuniform float alpha;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n\n}\n";const se=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",oe.replace("${perlin}","vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n")),this.parallel=!0,this.time=0,this._angle=0,this.uniforms.dimensions=new Float32Array(2);const r=Object.assign(se.defaults,e);this._angleLight=new t.Point,this.angle=r.angle,this.gain=r.gain,this.lacunarity=r.lacunarity,this.alpha=r.alpha,this.parallel=r.parallel,this.center=r.center,this.time=r.time}apply(e,t,r,n){const{width:i,height:o}=t.filterFrame;this.uniforms.light=this.parallel?this._angleLight:this.center,this.uniforms.parallel=this.parallel,this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=o,this.uniforms.aspect=o/i,this.uniforms.time=this.time,this.uniforms.alpha=this.alpha,e.applyFilter(this,t,r,n)}get angle(){return this._angle}set angle(e){this._angle=e;const r=e*t.DEG_TO_RAD;this._angleLight.x=Math.cos(r),this._angleLight.y=Math.sin(r)}get gain(){return this.uniforms.gain}set gain(e){this.uniforms.gain=e}get lacunarity(){return this.uniforms.lacunarity}set lacunarity(e){this.uniforms.lacunarity=e}get alpha(){return this.uniforms.alpha}set alpha(e){this.uniforms.alpha=e}};let ae=se;ae.defaults={angle:30,gain:.5,lacunarity:2.5,time:0,parallel:!0,center:[0,0],alpha:1};class le extends t.Filter{constructor(){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(\n        vec3(color.r * weight.r + color.g * weight.g  + color.b * weight.b),\n        color.a\n    );\n}\n")}}const ue=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float uHue;\nuniform float uAlpha;\nuniform bool uColorize;\nuniform float uSaturation;\nuniform float uLightness;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nfloat getWeightedAverage(vec3 rgb) {\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\n\nvec3 hueShift(vec3 color, float angle) {\n    float cosAngle = cos(angle);\n    return vec3(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    vec4 result = color;\n\n    // colorize\n    if (uColorize) {\n        result.rgb = vec3(getWeightedAverage(result.rgb), 0., 0.);\n    }\n\n    // hue\n    result.rgb = hueShift(result.rgb, uHue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    float average = (result.r + result.g + result.b) / 3.0;\n\n    if (uSaturation > 0.) {\n        result.rgb += (average - result.rgb) * (1. - 1. / (1.001 - uSaturation));\n    } else {\n        result.rgb -= (average - result.rgb) * uSaturation;\n    }\n\n    // lightness\n    result.rgb = mix(result.rgb, vec3(ceil(uLightness)) * color.a, abs(uLightness));\n\n    // alpha\n    gl_FragColor = mix(color, result, uAlpha);\n}\n"),this._hue=0;const t=Object.assign({},ue.defaults,e);Object.assign(this,t)}get hue(){return this._hue}set hue(e){this._hue=e,this.uniforms.uHue=this._hue*(Math.PI/180)}get alpha(){return this.uniforms.uAlpha}set alpha(e){this.uniforms.uAlpha=e}get colorize(){return this.uniforms.uColorize}set colorize(e){this.uniforms.uColorize=e}get lightness(){return this.uniforms.uLightness}set lightness(e){this.uniforms.uLightness=e}get saturation(){return this.uniforms.uSaturation}set saturation(e){this.uniforms.uSaturation=e}};let ce=ue;ce.defaults={hue:0,saturation:0,lightness:0,colorize:!1,alpha:1};class fe extends t.Filter{constructor(e=[0,0],r=5,n=0){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n"),this.kernelSize=5,this.uniforms.uVelocity=new Float32Array(2),this._velocity=new t.ObservablePoint(this.velocityChanged,this),this.setVelocity(e),this.kernelSize=r,this.offset=n}apply(e,t,r,n){const{x:i,y:o}=this.velocity;this.uniforms.uKernelSize=0!==i||0!==o?this.kernelSize:0,e.applyFilter(this,t,r,n)}set velocity(e){this.setVelocity(e)}get velocity(){return this._velocity}setVelocity(e){if(Array.isArray(e)){const[t,r]=e;this._velocity.set(t,r)}else this._velocity.copyFrom(e)}velocityChanged(){this.uniforms.uVelocity[0]=this._velocity.x,this.uniforms.uVelocity[1]=this._velocity.y,this.padding=1+(Math.max(Math.abs(this._velocity.x),Math.abs(this._velocity.y))>>0)}set offset(e){this.uniforms.uOffset=e}get offset(){return this.uniforms.uOffset}}var de="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n";class he extends t.Filter{constructor(e,t=.05,r=e.length){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",de.replace(/%maxColors%/g,r.toFixed(0))),this._replacements=[],this._maxColors=0,this.epsilon=t,this._maxColors=r,this.uniforms.originalColors=new Float32Array(3*r),this.uniforms.targetColors=new Float32Array(3*r),this.replacements=e}set replacements(e){const r=this.uniforms.originalColors,n=this.uniforms.targetColors,i=e.length;if(i>this._maxColors)throw new Error(`Length of replacements (${i}) exceeds the maximum colors length (${this._maxColors})`);r[3*i]=-1;for(let o=0;o<i;o++){const i=e[o];let s=i[0];"number"==typeof s?s=t.utils.hex2rgb(s):i[0]=t.utils.rgb2hex(s),r[3*o]=s[0],r[3*o+1]=s[1],r[3*o+2]=s[2];let a=i[1];"number"==typeof a?a=t.utils.hex2rgb(a):i[1]=t.utils.rgb2hex(a),n[3*o]=a[0],n[3*o+1]=a[1],n[3*o+2]=a[2]}this._replacements=e}get replacements(){return this._replacements}refresh(){this.replacements=this._replacements}get maxColors(){return this._maxColors}set epsilon(e){this.uniforms.epsilon=e}get epsilon(){return this.uniforms.epsilon}}const me=class extends t.Filter{constructor(e,t=0){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n"),this.seed=0,this.uniforms.dimensions=new Float32Array(2),"number"==typeof e?(this.seed=e,e=void 0):this.seed=t,Object.assign(this,me.defaults,e)}apply(e,t,r,n){var i,o;this.uniforms.dimensions[0]=null==(i=t.filterFrame)?void 0:i.width,this.uniforms.dimensions[1]=null==(o=t.filterFrame)?void 0:o.height,this.uniforms.seed=this.seed,e.applyFilter(this,t,r,n)}set sepia(e){this.uniforms.sepia=e}get sepia(){return this.uniforms.sepia}set noise(e){this.uniforms.noise=e}get noise(){return this.uniforms.noise}set noiseSize(e){this.uniforms.noiseSize=e}get noiseSize(){return this.uniforms.noiseSize}set scratch(e){this.uniforms.scratch=e}get scratch(){return this.uniforms.scratch}set scratchDensity(e){this.uniforms.scratchDensity=e}get scratchDensity(){return this.uniforms.scratchDensity}set scratchWidth(e){this.uniforms.scratchWidth=e}get scratchWidth(){return this.uniforms.scratchWidth}set vignetting(e){this.uniforms.vignetting=e}get vignetting(){return this.uniforms.vignetting}set vignettingAlpha(e){this.uniforms.vignettingAlpha=e}get vignettingAlpha(){return this.uniforms.vignettingAlpha}set vignettingBlur(e){this.uniforms.vignettingBlur=e}get vignettingBlur(){return this.uniforms.vignettingBlur}};let ge=me;ge.defaults={sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3};var ve="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterClamp;\n\nuniform float uAlpha;\nuniform vec2 uThickness;\nuniform vec4 uColor;\nuniform bool uKnockout;\n\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\nconst float ANGLE_STEP = ${angleStep};\n\nfloat outlineMaxAlphaAtPos(vec2 pos) {\n    if (uThickness.x == 0. || uThickness.y == 0.) {\n        return 0.;\n    }\n\n    vec4 displacedColor;\n    vec2 displacedPos;\n    float maxAlpha = 0.;\n\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\n        displacedColor = texture2D(uSampler, clamp(displacedPos, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\nvoid main(void) {\n    vec4 sourceColor = texture2D(uSampler, vTextureCoord);\n    vec4 contentColor = sourceColor * float(!uKnockout);\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\n    gl_FragColor = contentColor + outlineColor;\n}\n";const pe=class extends t.Filter{constructor(e=1,t=0,r=.1,n=1,i=!1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",ve.replace(/\$\{angleStep\}/,pe.getAngleStep(r))),this._thickness=1,this._alpha=1,this._knockout=!1,this.uniforms.uThickness=new Float32Array([0,0]),this.uniforms.uColor=new Float32Array([0,0,0,1]),this.uniforms.uAlpha=n,this.uniforms.uKnockout=i,Object.assign(this,{thickness:e,color:t,quality:r,alpha:n,knockout:i})}static getAngleStep(e){const t=Math.max(e*pe.MAX_SAMPLES,pe.MIN_SAMPLES);return(2*Math.PI/t).toFixed(7)}apply(e,t,r,n){this.uniforms.uThickness[0]=this._thickness/t._frame.width,this.uniforms.uThickness[1]=this._thickness/t._frame.height,this.uniforms.uAlpha=this._alpha,this.uniforms.uKnockout=this._knockout,e.applyFilter(this,t,r,n)}get alpha(){return this._alpha}set alpha(e){this._alpha=e}get color(){return t.utils.rgb2hex(this.uniforms.uColor)}set color(e){t.utils.hex2rgb(e,this.uniforms.uColor)}get knockout(){return this._knockout}set knockout(e){this._knockout=e}get thickness(){return this._thickness}set thickness(e){this._thickness=e,this.padding=e}};let xe=pe;xe.MIN_SAMPLES=1,xe.MAX_SAMPLES=100;class ye extends t.Filter{constructor(e=10){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n"),this.size=e}get size(){return this.uniforms.size}set size(e){"number"==typeof e&&(e=[e,e]),this.uniforms.size=e}}class Ce extends t.Filter{constructor(e=0,t=[0,0],r=5,n=-1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n"),this._angle=0,this.angle=e,this.center=t,this.kernelSize=r,this.radius=n}apply(e,t,r,n){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0,e.applyFilter(this,t,r,n)}set angle(e){this._angle=e,this.uniforms.uRadian=e*Math.PI/180}get angle(){return this._angle}get center(){return this.uniforms.uCenter}set center(e){this.uniforms.uCenter=e}get radius(){return this.uniforms.uRadius}set radius(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e}}const _e=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n"),this.time=0,this.uniforms.amplitude=new Float32Array(2),this.uniforms.waveLength=new Float32Array(2),this.uniforms.alpha=new Float32Array(2),this.uniforms.dimensions=new Float32Array(2),Object.assign(this,_e.defaults,e)}apply(e,t,r,n){var i,o;this.uniforms.dimensions[0]=null==(i=t.filterFrame)?void 0:i.width,this.uniforms.dimensions[1]=null==(o=t.filterFrame)?void 0:o.height,this.uniforms.time=this.time,e.applyFilter(this,t,r,n)}set mirror(e){this.uniforms.mirror=e}get mirror(){return this.uniforms.mirror}set boundary(e){this.uniforms.boundary=e}get boundary(){return this.uniforms.boundary}set amplitude(e){this.uniforms.amplitude[0]=e[0],this.uniforms.amplitude[1]=e[1]}get amplitude(){return this.uniforms.amplitude}set waveLength(e){this.uniforms.waveLength[0]=e[0],this.uniforms.waveLength[1]=e[1]}get waveLength(){return this.uniforms.waveLength}set alpha(e){this.uniforms.alpha[0]=e[0],this.uniforms.alpha[1]=e[1]}get alpha(){return this.uniforms.alpha}};let be=_e;be.defaults={mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0};class Se extends t.Filter{constructor(e=[-10,0],t=[0,10],r=[0,0]){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n"),this.red=e,this.green=t,this.blue=r}get red(){return this.uniforms.red}set red(e){this.uniforms.red=e}get green(){return this.uniforms.green}set green(e){this.uniforms.green=e}get blue(){return this.uniforms.blue}set blue(e){this.uniforms.blue=e}}const Te=class extends t.Filter{constructor(e=[0,0],t,r=0){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n"),this.center=e,Object.assign(this,Te.defaults,t),this.time=r}apply(e,t,r,n){this.uniforms.time=this.time,e.applyFilter(this,t,r,n)}get center(){return this.uniforms.center}set center(e){this.uniforms.center=e}get amplitude(){return this.uniforms.amplitude}set amplitude(e){this.uniforms.amplitude=e}get wavelength(){return this.uniforms.wavelength}set wavelength(e){this.uniforms.wavelength=e}get brightness(){return this.uniforms.brightness}set brightness(e){this.uniforms.brightness=e}get speed(){return this.uniforms.speed}set speed(e){this.uniforms.speed=e}get radius(){return this.uniforms.radius}set radius(e){this.uniforms.radius=e}};let Fe=Te;Fe.defaults={amplitude:30,wavelength:160,brightness:1,speed:500,radius:-1};class Ae extends t.Filter{constructor(e,t=0,r=1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n"),this._color=0,this.uniforms.dimensions=new Float32Array(2),this.uniforms.ambientColor=new Float32Array([0,0,0,r]),this.texture=e,this.color=t}apply(e,t,r,n){var i,o;this.uniforms.dimensions[0]=null==(i=t.filterFrame)?void 0:i.width,this.uniforms.dimensions[1]=null==(o=t.filterFrame)?void 0:o.height,e.applyFilter(this,t,r,n)}get texture(){return this.uniforms.uLightmap}set texture(e){this.uniforms.uLightmap=e}set color(e){const r=this.uniforms.ambientColor;"number"==typeof e?(t.utils.hex2rgb(e,r),this._color=e):(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],this._color=t.utils.rgb2hex(r))}get color(){return this._color}get alpha(){return this.uniforms.ambientColor[3]}set alpha(e){this.uniforms.ambientColor[3]=e}}class ze extends t.Filter{constructor(e){var r,n;super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n"),this.uniforms.blur=e.blur,this.uniforms.gradientBlur=e.gradientBlur,this.uniforms.start=null!=(r=e.start)?r:new t.Point(0,window.innerHeight/2),this.uniforms.end=null!=(n=e.end)?n:new t.Point(600,window.innerHeight/2),this.uniforms.delta=new t.Point(30,30),this.uniforms.texSize=new t.Point(window.innerWidth,window.innerHeight),this.updateDelta()}updateDelta(){this.uniforms.delta.x=0,this.uniforms.delta.y=0}get blur(){return this.uniforms.blur}set blur(e){this.uniforms.blur=e}get gradientBlur(){return this.uniforms.gradientBlur}set gradientBlur(e){this.uniforms.gradientBlur=e}get start(){return this.uniforms.start}set start(e){this.uniforms.start=e,this.updateDelta()}get end(){return this.uniforms.end}set end(e){this.uniforms.end=e,this.updateDelta()}}class we extends ze{updateDelta(){const e=this.uniforms.end.x-this.uniforms.start.x,t=this.uniforms.end.y-this.uniforms.start.y,r=Math.sqrt(e*e+t*t);this.uniforms.delta.x=e/r,this.uniforms.delta.y=t/r}}class Pe extends ze{updateDelta(){const e=this.uniforms.end.x-this.uniforms.start.x,t=this.uniforms.end.y-this.uniforms.start.y,r=Math.sqrt(e*e+t*t);this.uniforms.delta.x=-t/r,this.uniforms.delta.y=e/r}}const Me=class extends t.Filter{constructor(e,r,n,i){super(),"number"==typeof e&&(t.utils.deprecation("5.3.0","TiltShiftFilter constructor arguments is deprecated, use options."),e={blur:e,gradientBlur:r,start:n,end:i}),e=Object.assign({},Me.defaults,e),this.tiltShiftXFilter=new we(e),this.tiltShiftYFilter=new Pe(e)}apply(e,t,r,n){const i=e.getFilterTexture();this.tiltShiftXFilter.apply(e,t,i,1),this.tiltShiftYFilter.apply(e,i,r,n),e.returnFilterTexture(i)}get blur(){return this.tiltShiftXFilter.blur}set blur(e){this.tiltShiftXFilter.blur=this.tiltShiftYFilter.blur=e}get gradientBlur(){return this.tiltShiftXFilter.gradientBlur}set gradientBlur(e){this.tiltShiftXFilter.gradientBlur=this.tiltShiftYFilter.gradientBlur=e}get start(){return this.tiltShiftXFilter.start}set start(e){this.tiltShiftXFilter.start=this.tiltShiftYFilter.start=e}get end(){return this.tiltShiftXFilter.end}set end(e){this.tiltShiftXFilter.end=this.tiltShiftYFilter.end=e}};let De=Me;De.defaults={blur:100,gradientBlur:600,start:void 0,end:void 0};const ke=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n"),Object.assign(this,ke.defaults,e)}get offset(){return this.uniforms.offset}set offset(e){this.uniforms.offset=e}get radius(){return this.uniforms.radius}set radius(e){this.uniforms.radius=e}get angle(){return this.uniforms.angle}set angle(e){this.uniforms.angle=e}};let Oe=ke;Oe.defaults={radius:200,angle:4,padding:20,offset:new t.Point};var Re="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = ${maxKernelSize};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n",Ee=Object.getOwnPropertySymbols,je=Object.prototype.hasOwnProperty,Ie=Object.prototype.propertyIsEnumerable;const Le=class extends t.Filter{constructor(e){const t=Object.assign(Le.defaults,e),{maxKernelSize:r}=t,n=((e,t)=>{var r={};for(var n in e)je.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&Ee)for(var n of Ee(e))t.indexOf(n)<0&&Ie.call(e,n)&&(r[n]=e[n]);return r})(t,["maxKernelSize"]);super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",Re.replace("${maxKernelSize}",r.toFixed(1))),Object.assign(this,n)}get center(){return this.uniforms.uCenter}set center(e){this.uniforms.uCenter=e}get strength(){return this.uniforms.uStrength}set strength(e){this.uniforms.uStrength=e}get innerRadius(){return this.uniforms.uInnerRadius}set innerRadius(e){this.uniforms.uInnerRadius=e}get radius(){return this.uniforms.uRadius}set radius(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e}};let Ve=Le;return Ve.defaults={strength:.1,center:[0,0],innerRadius:0,radius:-1,maxKernelSize:32},e.AdjustmentFilter=i,e.AdvancedBloomFilter=u,e.AsciiFilter=c,e.BevelFilter=f,e.BloomFilter=d,e.BulgePinchFilter=m,e.CRTFilter=X,e.ColorGradientFilter=j,e.ColorMapFilter=I,e.ColorOverlayFilter=L,e.ColorReplaceFilter=V,e.ConvolutionFilter=N,e.CrossHatchFilter=G,e.DotFilter=q,e.DropShadowFilter=Q,e.EmbossFilter=J,e.GlitchFilter=te,e.GlowFilter=ie,e.GodrayFilter=ae,e.GrayscaleFilter=le,e.HslAdjustmentFilter=ce,e.KawaseBlurFilter=o,e.MotionBlurFilter=fe,e.MultiColorReplaceFilter=he,e.OldFilmFilter=ge,e.OutlineFilter=xe,e.PixelateFilter=ye,e.RGBSplitFilter=Se,e.RadialBlurFilter=Ce,e.ReflectionFilter=be,e.ShockwaveFilter=Fe,e.SimpleLightmapFilter=Ae,e.TiltShiftAxisFilter=ze,e.TiltShiftFilter=De,e.TiltShiftXFilter=we,e.TiltShiftYFilter=Pe,e.TwistFilter=Oe,e.ZoomBlurFilter=Ve,Object.defineProperty(e,"__esModule",{value:!0}),e}({},PIXI,PIXI.filters,PIXI.filters);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=/sm/a81fbc95f2d06fc9441bd5eab12f497356ae9e2687efa16d4866f79acc7b17b0.map

// * Данный класс вынесен в .JS со старой реализацией, чтобы
// * вызвать this.eventId = eventId перед родительским конструктором
// * Остальной код в 2_AAEnemyBattler_Impl.coffee

function AAEnemyBattler() {
    this.initialize.apply(this, arguments);
}

AAEnemyBattler.prototype = Object.create(Game_Enemy.prototype);
AAEnemyBattler.prototype.constructor = AAEnemyBattler;

// * Так же передаём номер события, чтобы был доступ к модели и логике
AAEnemyBattler.prototype.initialize = function (enemyId, eventId) {
    this.eventId = eventId;
    Game_Enemy.prototype.initialize.call(this, enemyId, 0, 0);
    this.aaInit();
};

function Game_AASpawnedEvent() {
    this.initialize.apply(this, arguments);
}

Game_AASpawnedEvent.prototype = Object.create(Game_Event.prototype);
Game_AASpawnedEvent.prototype.constructor = Game_AASpawnedEvent;

Game_AASpawnedEvent.prototype.initialize = function (refEventId, x, y) {
    this.refEventId = refEventId;
    let newEventId = $gameMap._events.length;
    Game_Event.prototype.initialize.call(this, $gameMap.mapId(), newEventId);
    DataManager.extractMetadata(this.event());
    $gameMap._events[newEventId] = this;
    if (Imported.VisuMZ_1_EventsMoveCore == true && $gameMap._eventCache) {
        $gameMap._eventCache.push(this);
    }
    this.setPosition(x, y);
    this.aaAddOnSpriteset();
    this.aaCheckAndActivateABSBehaviour();
};

//$[OVER]
Game_AASpawnedEvent.prototype.aaIsSpawned = function () {
    return true;
};

//$[OVER]
Game_AASpawnedEvent.prototype.event = function () {
    return $dataAASpawnMap.events[this.refEventId];
};


//?[NEW]
// * Добавляемм спрайт события на карту (если текущая сцена карты)
Game_AASpawnedEvent.prototype.aaAddOnSpriteset = function () {
    try {
        if (!AAUtils.isSceneMap()) {
            return;
        }
        SceneManager._scene._spriteset.aaAddSpawnedEvent(this); //this.eventId()
    } catch (e) {
        AA.w(e);
    }
};

//?[NEW]
// * Активируем ABS у события
Game_AASpawnedEvent.prototype.aaCheckAndActivateABSBehaviour = function() {
    if(this.isABS()) {
        this.initABS();
    }
};

class AA_Sprite_MapPathGrid extends KDCore.Sprite {
    constructor() {
        super();
        this._mapAnchor = new KDCore.MapAnchorPoint(0, 0);
        this.drawNodeGrid();
        this._pathSprites = [];
        this._refreshPathTimer = 0;
        this.opacity = 60;
    }

    static Show() {
        if(!this._instance) {
            this._instance = new AA_Sprite_MapPathGrid();
            SceneManager._scene.addChild(this._instance);
        } else {
            // * Remove old instance
            SceneManager._scene.removeChild(this._instance);
            this._instance = null;
            this.Show();
        }
    }

    update() {
        super.update();
        this.updatePathDrawing();
        this.x = this._mapAnchor.screenX(true) - 24;
        this.y = this._mapAnchor.screenY(true) - 48;
    }

    addNotPassableCell(x, y) {
        var cellSprite = new KDCore.Sprite(new Bitmap(48, 48));
        cellSprite.bitmap.fillAll('#FF0000');
        cellSprite.opacity = 140;
        cellSprite.x = x * 48;
        cellSprite.y = y * 48;
        this.addChild(cellSprite);
    }

    drawNodeGrid() {
        var grid = $gameMap.aaGetMapGrid();
        for(var i = 0; i < grid.width; i++) {
            for(var j = 0; j < grid.height; j++) {
                if(!grid.isWalkableAt(i, j)) {
                    this.addNotPassableCell(i, j);
                }
            }
        }
    }

    drawPath(path) {
        this.clearPath();
        if(!path) return;
        for(var i = 0; i < path.length; i++) {
            var cell = path[i];
            var cellSprite = new KDCore.Sprite(new Bitmap(48, 48));
            cellSprite.bitmap.fillAll('#0000FF');
            cellSprite.opacity = 190;
            cellSprite.x = cell[0] * 48;
            cellSprite.y = cell[1] * 48;
            this.addChild(cellSprite);
            this._pathSprites.push(cellSprite);
        }
    }

    updatePathDrawing() {
        if(this._refreshPathTimer > 0) {
            this._refreshPathTimer--;
            return;
        }

        if($gameMap._aaLastPath) {
            this.drawPath($gameMap._aaLastPath);
            this._refreshPathTimer = 30;
        }
    }

    clearPath() {
        for(var i = 0; i < this._pathSprites.length; i++) {
            this.removeChild(this._pathSprites[i]);
        }
        this._pathSprites = [];
    }

}

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){

    var _ = Game_CharacterBase.prototype;

    _.aaMakePathTo = function(x, y) {
        console.log('aaMakePathTo', x, y);
        var path = $gameMap.aaFindPathFromCharacterToPoint(this, x, y);
        if(path && path.length > 0) {
            path.shift();   // * Remove first cell (current cell)
            this.aaStartMoveByPath(path);
        } else {
            this.aaClearMovePath();
        }
    };

    _.aaMakePathToCharacter = function(character) {
        console.log('aaMakePathToCharacter', character);
        var path = $gameMap.aaFindPathBetweenCharacters(this, character);
        if(path && path.length > 0) {
            path.shift();   // * Remove first cell (current cell)
            this.aaStartMoveByPath(path);
        } else {
            this.aaClearMovePath();
        }
    };


    _.aaStartMoveByPath = function(path) {
        console.log('aaStartMoveByPath', path);
        this._aaMovePathOld = path;
    };

    _.aaIsHaveMovePath = function() {
        return this._aaMovePathOld && this._aaMovePathOld.length > 0;
    };

    _.aaGetMovePath = function() {
        return this._aaMovePathOld;
    };

    _.aaClearMovePath = function() {
        this._aaMovePathOld = null;
    };

    _.aaMakeNextMoveByPath = function() {
        if(this.aaIsHaveMovePath()) {
            console.log('aaMakeNextMoveByPath');
            var cell = this._aaMovePathOld.shift();
            var withDiagonal = this.aaIsThisCharCanUseDiagMovement();
            var direction = this.aaGetDirectionTo(cell[0], cell[1], withDiagonal);
            var isDiagonalDirection = direction % 2 === 1;
            if(isDiagonalDirection) {
                var [h, v] = AA.Utils.get8Dir(direction);
                this.moveDiagonally(h, v);
            } else
                this.moveStraight(direction);
        }
    };

    _.onMoveByPathEnd = function() {
        if(!this._aaMovePathOld) return;
        console.log('onMoveByPathEnd');
        this.aaClearMovePath();
        //console.log('Path end');
    };

    _.aaGetDirectionTo = function(x, y, withDiagonal) {

        console.log('aaGetDirectionTo', x, y);

        var dx = x - this.x;
        var dy = y - this.y;

        if (dx === 0 && dy === 0) {
            return 0;
        }

        if(withDiagonal) {
            if (dx > 0 && dy > 0) {
                return 3;
            } else if (dx < 0 && dy > 0) {
                return 1;
            } else if (dx > 0 && dy < 0) {
                return 9;
            } else if (dx < 0 && dy < 0) {
                return 7;
            }
        }

        var absDx = Math.abs(dx);
        var absDy = Math.abs(dy);
        if (absDx > absDy) {
            return dx > 0 ? 6 : 4;
        } else {
            return dy > 0 ? 2 : 8;
        }
    };

    _.aaGetRandomPointAroundMyPosition = function(radius, withDiagonal) {

        console.log('aaGetRandomPointAroundMyPosition', radius, withDiagonal);

        var angle = Math.random() * Math.PI * 2;
        var x = this.x + Math.cos(angle) * radius;
        var y = this.y + Math.sin(angle) * radius;

        if(x < 0) x = 0;
        if(y < 0) y = 0;

        if(withDiagonal) {
            return {x: Math.round(x), y: Math.round(y)};
        } else {
            return {x: Math.floor(x), y: Math.floor(y)};
        }
    };

})();
// ■ END Game_CharacterBase.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    var _ = Game_CharacterBase.prototype;

    _.aaSmartPathRefreshTime = function() {
        return 20;
    };

    _.aaMoveTypeToTarget = function() {
        try {
            var target = this.AAEntity().getTarget();
            if(!target) {
                this.aaClearMovePath();
                return;
            }
            this.aaUpdateSmartMoveToTarget(target);
            if(!this.isMoving()) {
                this.aaTurnTowardTarget();
            }
            this.aaUpdateMoveByPathForAI();
        } catch (error) {
            console.warn(error);
            this.aaClearMovePath();
        }
    };

    _.aaUpdateMoveByPathForAI = function() {
        if(this.aaIsHaveMovePath()) {
            if(!this.isMoving()) {
                this.aaMakeNextMoveByPath();
            }
        } else {
            this.onMoveByPathEnd();
        }
    };

    _.aaIsCanPerformNextMoveAction = function(target) {
        return !target.aaIsDodging();
    };

    _.aaUpdateSmartMoveToTarget = function(target) {
        if(this._aaSmartPathTimer === undefined) {
            this._aaSmartPathTimer = 0;
        }
        if(this._aaSmartPathTimer > 0) {
            this._aaSmartPathTimer--;
            return;
        } else {
            if(!this.aaIsCanPerformNextMoveAction(target)) {
                this.aaTurnTowardTarget();
                return;
            }
            this._aaSmartPathTimer = this.aaSmartPathRefreshTime();
            //console.log('MAKE PATH TO TARGET');
            this.aaMakePathToCharacter(target);
            if(!this.aaIsHaveMovePath()) {
                //console.log('Direct Path not found');
                // * Try get point around target and get closer
                var randomPoint = target.aaGetRandomPointAroundMyPosition(3, true);
                if(randomPoint) {
                    //console.log(randomPoint);
                    this.aaMakePathTo(randomPoint.x, randomPoint.y);
                }
            }
        }
    };

    _.aaMoveTypeToPoint = function(point) {
        try {
            if(!point) {
                this.aaClearMovePath();
                return;
            }
            this.aaUpdateSmartMoveToPoint(point);
            this.aaUpdateMoveByPathForAI();
        } catch (error) {
            this.aaClearMovePath();
        }
    };

    _.aaUpdateSmartMoveToPoint = function(point) {
        if(this._aaSmartPathTimer === undefined) {
            this._aaSmartPathTimer = 0;
        }
        if(this._aaSmartPathTimer > 0) {
            this._aaSmartPathTimer--;
            return;
        } else {
            this._aaSmartPathTimer = this.aaSmartPathRefreshTime();
            try {
                if(point instanceof Game_CharacterBase) {
                    this.aaMakePathToCharacter(point);
                } else {
                    this.aaMakePathTo(point.x, point.y);
                }
            } catch (error) {
                console.warn(error);
                this.aaClearMovePath();
            }
        }
    };

})();
// ■ END Game_CharacterBase.js
//---------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){
    
    var _ = Game_Event.prototype;

    _.aaIsPassableOnMap = function() {
        if(this.isThrough()) {
            return true;
        }
        if(this.isDebugThrough()) {
            return true;
        }
        if(!this.isNormalPriority()) {
            return true;
        }
        if(this._erased) {
            return true;
        }
        return false;
    };

})();
// ■ END Game_Event.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.js
//╒═════════════════════════════════════════════════════════════════════════╛
/////////////////////////////////////////////////////////////////////////////
(function(){

    var _ = Game_Map.prototype;

    _.aaFindPath = function(x1, y1, x2, y2, isDiagonal = true) {
        var finder = new PF.AStarFinder({
            allowDiagonal: isDiagonal,
            dontCrossCorners: true
        });
        var grid = this.aaGetMapGrid();
        x2 = Math.floor(x2);
        y2 = Math.floor(y2);
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        var path = finder.findPath(x1, y1, x2, y2, grid);
        this._aaLastPath = path;
        return path;
    };

    _.aaFindPathBetweenCharacters = function(char1, char2) {
        $gameTemp.aaPathFindIgnoreCharacters = [char1, char2];
        var path = this.aaFindPath(char1.x, char1.y, char2.x, char2.y, char1.aaIsThisCharCanUseDiagMovement());
        $gameTemp.aaPathFindIgnoreCharacters = null;
        return path;
    };

    _.aaFindPathFromCharacterToPoint = function(character, x, y) {
        $gameTemp.aaPathFindIgnoreCharacters = [character];
        var path = this.aaFindPath(character.x, character.y, x, y, character.aaIsThisCharCanUseDiagMovement());
        $gameTemp.aaPathFindIgnoreCharacters = null;
        return path;
    };

    _.aaGetMapGrid = function() {
        if(!this._aaMapPathGrid) {
            this.aaCreateMapGrid();
        }
        let actualGrid = this._aaMapPathGrid.clone();

        if(!$gameTemp.aaPathFindIgnoreCharacters) {
            $gameTemp.aaPathFindIgnoreCharacters = [];
        }

        // * Add dynamic colliders
        this.aaAddDynamicCollidersToGrid(actualGrid);

        return actualGrid;
    };

    _.aaCreateMapGrid = function() {
        this._aaMapPathGrid = new PF.Grid(this.width(), this.height());
            for(var x = 0; x < this.width(); x++) {
                for(var y = 0; y < this.height(); y++) {
                    if(!this.aaIsPassableForMapGrid(x, y)) {
                        this.aaSetNotWalkableCellForGrid(this._aaMapPathGrid, x, y);
                    }
                }
            }
    };

    _.aaSetNotWalkableCellForGrid = function(mapGrid, x, y) {
        x = Math.floor(x);
        y = Math.floor(y);
        mapGrid.setWalkableAt(x, y, false);
    };

    _.aaIsPassableForMapGrid = function(x, y) {
        return this.isPassable(x, y, 8);
    };

    _.aaAddDynamicCollidersToGrid = function(grid) {
        if(!$gameTemp.aaPathFindIgnoreCharacters.contains($gamePlayer)) {
            this.aaSetNotWalkableCellForGrid(grid, $gamePlayer.x, $gamePlayer.y);
        }
        var events = this.events();
        for(var i = 0; i < events.length; i++) {
            var event = events[i];
            if(!event.aaIsPassableOnMap() && !$gameTemp.aaPathFindIgnoreCharacters.contains(event)) {
                var x = event.x;
                var y = event.y;
                if(x > 0 && y > 0) {
                    this.aaSetNotWalkableCellForGrid(grid,x, y);
                }
            }
        }
    };

})();
// ■ END Game_Map.js
//---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////

if (KDCore.isMV() && !window.FontManager) {

    //-----------------------------------------------------------------------------
    // FontManager
    //
    // The static class that loads font files.

    function FontManager() {
        throw new Error("This is a static class");
    }

    FontManager._urls = {};
    FontManager._states = {};

    FontManager.load = function(family, filename) {
        if (this._states[family] !== "loaded") {
            if (filename) {
                const url = this.makeUrl(filename);
                this.startLoading(family, url);
            } else {
                this._urls[family] = "";
                this._states[family] = "loaded";
            }
        }
    };

    FontManager.isReady = function() {
        for (const family in this._states) {
            const state = this._states[family];
            if (state === "loading") {
                return false;
            }
            if (state === "error") {
                this.throwLoadError(family);
            }
        }
        return true;
    };

    FontManager.startLoading = function(family, url) {
        const source = "url(" + url + ")";
        const font = new FontFace(family, source);
        this._urls[family] = url;
        this._states[family] = "loading";
        font.load()
            .then(() => {
                document.fonts.add(font);
                this._states[family] = "loaded";
                return 0;
            })
            .catch(() => {
                this._states[family] = "error";
            });
    };

    FontManager.throwLoadError = function(family) {
        const url = this._urls[family];
        const retry = () => this.startLoading(family, url);
        throw ["LoadError", url, retry];
    };

    FontManager.makeUrl = function(filename) {
        return "fonts/" + Utils.encodeURI(filename);
    };

    Utils.encodeURI = function(str) {
        return encodeURIComponent(str).replace(/%2F/g, "/");
    };


}

// * Теперь будет работать мульти тоуч, т.е. можно будет нажимать несколько
// кнопок сразу (навыки и кнопки), работает с Mobile Controls
// можно ходить на джойстик (удерживая) и нажимать при этом атаку или навыки

AA.ApplyMultitouchMode = function(){
    
    //$[OVER]
    TouchInput._onTouchStart = function(event) {
        this._pMultiTouches = [];
        for (const touch of event.changedTouches) {
            const x = Graphics.pageToCanvasX(touch.pageX);
            const y = Graphics.pageToCanvasY(touch.pageY);
            if (Graphics.isInsideCanvas(x, y)) {
                this._screenPressed = true;
                this._pressedTime = 0;
                if (event.touches.length >= 2) {
                    //this._onCancel(x, y);
                    for(let touchX of event.touches) {
                        let xx = Graphics.pageToCanvasX(touchX.pageX);
                        let yy = Graphics.pageToCanvasX(touchX.pageY);
                        this._pMultiTouches.push({x: xx, y: yy});
                    }
                    this._onTrigger(x, y);
                } else {
                    this._onTrigger(x, y);
                }
                event.preventDefault();
            }
        }
        if (window.cordova || window.navigator.standalone) {
            event.preventDefault();
        }
    };

    TouchInput.pIsMultiTouched = function() {
        return this._pMultiTouches && this._pMultiTouches.length > 0;
    };

    TouchInput.pClearMultiTouch = function() {
        this._pMultiTouches = [];
    };

    //@[ALIAS]
    var _alias_TouchInput__onTouchEnd = TouchInput._onTouchEnd;
    TouchInput._onTouchEnd = function (event) {
        if(this.pIsMultiTouched()) {
            this.pClearMultiTouch();
            _alias_TouchInput__onTouchEnd.call(this, event);
            this._screenPressed = true;
        } else
            _alias_TouchInput__onTouchEnd.call(this, event);
    };

    // * KDCore.Sprite Extension
    (function(){
        var _ = KDCore.Sprite.prototype;

        _.isUnderMouse = function() {
            let isUnderMouseX = this.inPosition(TouchInput);
            if(isUnderMouseX) {
                return true;
            } else {
                if(TouchInput.pIsMultiTouched()) {
                    for(let touch of TouchInput._pMultiTouches) {
                        if(this.inPosition(touch)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        };
    })();

};


/*Spriteset_Base.prototype.createAnimation = function(request) {
    const animation = $dataAnimations[request.animationId];
    const targets = request.targets;
    const mirror = request.mirror;
    let delay = this.animationBaseDelay();
    const nextDelay = this.animationNextDelay();
    if (this.isAnimationForEach(animation)) {
        for (const target of targets) {
            this.createAnimationSprite([target], animation, mirror, delay);
            delay += nextDelay;
        }
    } else {
        this.createAnimationSprite(targets, animation, mirror, delay);
    }
};

Spriteset_Base.prototype.createAnimationSprite = function(
    targets, animation, mirror, delay
) {
    const mv = this.isMVAnimation(animation);
    const sprite = new (mv ? Sprite_AnimationMV : Sprite_Animation)();
    const targetSprites = this.makeTargetSprites(targets);
    const baseDelay = this.animationBaseDelay();
    const previous = delay > baseDelay ? this.lastAnimationSprite() : null;
    if (this.animationShouldMirror(targets[0])) {
        mirror = !mirror;
    }
    sprite.targetObjects = targets;
    sprite.setup(targetSprites, animation, mirror, delay, previous);
    this._effectsContainer.addChild(sprite);
    this._animationSprites.push(sprite);
};

Sprite_Animation.prototype.updateEffectGeometry = function() {
    const scale = this._animation.scale / 100;
    const r = Math.PI / 180;
    const rx = this._animation.rotation.x * r;
    const ry = this._animation.rotation.y * r;
    const rz = this._animation.rotation.z * r;
    if (this._handle) {
        this._handle.setLocation(0, 0, 0);
        this._handle.setRotation(rx, ry, rz);
        this._handle.setScale(scale, scale, scale);
        this._handle.setSpeed(this._animation.speed / 100);
    }
};

Sprite_Animation.prototype.update = function() {
    Sprite.prototype.update.call(this);
    if (this._delay > 0) {
        this._delay--;
    } else if (this._playing) {
        if (!this._started && this.canStart()) {
            if (this._effect) {
                if (this._effect.isLoaded) {
                    this._handle = Graphics.effekseer.play(this._effect);
                    this._started = true;
                } else {
                    EffectManager.checkErrors();
                }
            } else {
                this._started = true;
            }
        }
        if (this._started) {
            this.updateEffectGeometry();
            this.updateMain();
            this.updateFlash();
        }
    }
};


Game_Temp.prototype.animation = function(x, y) {

    SceneManager._scene._spriteset.aaCreateAnimationOnMap(x, y);
    
};

Game_Temp.prototype.animationCursor = function() {
    setTimeout(() => {
        "START".p();
        SceneManager._scene._spriteset.aaCreateLinkedAnimation();
    }, 250);
};
*/

/*Sprite_Animation.prototype._render = function(renderer) {
    if (this._targets.length > 0 && this._handle && this._handle.exists) {
        this.onBeforeRender(renderer);
        this.setProjectionMatrix(renderer);
        this.setCameraMatrix(renderer);
        this.setViewport(renderer);
        Graphics.effekseer.beginDraw();
        Graphics.effekseer.drawHandle(this._handle);
        Graphics.effekseer.endDraw();
        this.resetViewport(renderer);
        this.onAfterRender(renderer);
    }
};

Sprite_Animation.prototype.targetSpritePosition = function(sprite) {
    const point = new Point(0, -sprite.height / 2);
    if (this._animation.alignBottom) {
        point.y = 0;
    }
    if(!sprite.parent) {
        sprite.parent = SceneManager._scene._spriteset._tilemap;
    }
    sprite.updateTransform();
    return sprite.worldTransform.apply(point);
};*/





class Vector2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    reset(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    isZero() {
        return this.x === 0 && this.y === 0;
    }
    toString(decPlaces = 3) {
        const scalar = Math.pow(10, decPlaces);
        return `[${Math.round(this.x * scalar) / scalar}, ${Math.round(this.y * scalar) / scalar}]`;
    }
    clone() {
        return new Vector2(this.x, this.y);
    }
    copyTo(v) {
        v.x = this.x;
        v.y = this.y;
    }
    getRandomPointOnCircleEdge(radius) {
        const angle = Math.random() * Math.PI * 2;
        return new Vector2(this.x + Math.cos(angle) * radius, this.y + Math.sin(angle) * radius);
    }
    copyFrom(v) {
        this.x = v.x;
        this.y = v.y;
    }
    magnitude() {
        return Math.sqrt((this.x * this.x) + (this.y * this.y));
    }
    magnitudeSquared() {
        return (this.x * this.x) + (this.y * this.y);
    }
    normalize() {
        const m = this.magnitude();
        this.x = this.x / m;
        this.y = this.y / m;
        return this;
    }
    reverse() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    plusEq(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    plusNew(v) {
        return new Vector2(this.x + v.x, this.y + v.y);
    }
    minusEq(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    minusNew(v) {
        return new Vector2(this.x - v.x, this.y - v.y);
    }
    multiplyEq(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    multiplyNew(scalar) {
        const returnvec = this.clone();
        return returnvec.multiplyEq(scalar);
    }
    divideEq(scalar) {
        this.x /= scalar;
        this.y /= scalar;
        return this;
    }
    divideNew(scalar) {
        const returnvec = this.clone();
        return returnvec.divideEq(scalar);
    }
    dot(v) {
        return (this.x * v.x) + (this.y * v.y);
    }
    angle(useRadians = false) {
        return Math.atan2(this.y, this.x) * (useRadians ? 1 : Vector2Const.TO_DEGREES);
    }
    facingAngleTo(v, useRadians = false) {
        const dx = v.x - this.x;
        const dy = v.y - this.y;
        return Math.atan2(dy, dx) * (useRadians ? 1 : Vector2Const.TO_DEGREES);
    }
    rotate(angle, useRadians = false) {
        const cosRY = Math.cos(angle * (useRadians ? 1 : Vector2Const.TO_RADIANS));
        const sinRY = Math.sin(angle * (useRadians ? 1 : Vector2Const.TO_RADIANS));
        Vector2Const.temp.copyFrom(this);
        this.x = (Vector2Const.temp.x * cosRY) - (Vector2Const.temp.y * sinRY);
        this.y = (Vector2Const.temp.x * sinRY) + (Vector2Const.temp.y * cosRY);
        return this;
    }
    equals(v) {
        return (this.x === v.x) && (this.y === v.y);
    }
    isCloseTo(v, tolerance) {
        if (this.equals(v))
            return true;
        Vector2Const.temp.copyFrom(this);
        Vector2Const.temp.minusEq(v);
        return (Vector2Const.temp.magnitudeSquared() < tolerance * tolerance);
    }
    rotateAroundPoint(point, angle, useRadians = false) {
        Vector2Const.temp.copyFrom(this);
        Vector2Const.temp.minusEq(point);
        Vector2Const.temp.rotate(angle, useRadians);
        Vector2Const.temp.plusEq(point);
        this.copyFrom(Vector2Const.temp);
    }
    isMagLessThan(distance) {
        return (this.magnitudeSquared() < distance * distance);
    }
    isMagGreaterThan(distance) {
        return (this.magnitudeSquared() > distance * distance);
    }
}
window['Vector2'] = Vector2;
const Vector2Const = {
    TO_DEGREES: 180 / Math.PI,
    TO_RADIANS: Math.PI / 180,
    temp: new Vector2()
};


// * Основной (родительский) класс объекта АБС на карте (монстр, игрок и т.д.)
var EntityType;
(function (EntityType) {
    EntityType[EntityType["PLAYER"] = 0] = "PLAYER";
    EntityType[EntityType["EVENT"] = 1] = "EVENT";
    EntityType[EntityType["FOLLOWER"] = 2] = "FOLLOWER";
    EntityType[EntityType["GLOBAL_SKILL"] = 1000] = "GLOBAL_SKILL";
})(EntityType || (EntityType = {}));
//@[STORABLE]
//@[GLOBAL]
class AAEntity {
    static Pack(character) {
        try {
            if (!character)
                return null;
            //@ts-ignore
            if (character instanceof AADummyCharacter) {
                return {
                    type: EntityType.GLOBAL_SKILL,
                    //@ts-ignore
                    id: character.uId
                };
            }
            // Для сетевой игры отдельный метод с учётом NetCharacter
            //@ts-ignore
            if (AA.Network.isNetworkGame()) {
                //@ts-ignore
                return AA.Network.packMapChar(character);
            }
            else {
                if (character == $gamePlayer) {
                    return {
                        type: EntityType.PLAYER,
                        id: 0
                    };
                }
                if (character instanceof Game_Event) {
                    return {
                        type: EntityType.EVENT,
                        id: character.eventId(),
                        mapId: $gameMap.mapId()
                    };
                }
                if (character instanceof Game_Follower) {
                    return {
                        type: EntityType.FOLLOWER,
                        //@ts-ignore
                        id: character.actorId()
                    };
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    static Unpack(entity) {
        try {
            if (!entity)
                return null;
            if (entity.type == EntityType.GLOBAL_SKILL) {
                //@ts-ignore
                return $gameMap.aaGetGlobalSkill(entity.id);
            }
            // Для сетевой игры отдельный метод с учётом NetCharacter
            //@ts-ignore
            if (AA.Network.isNetworkGame()) {
                //@ts-ignore
                return AA.Network.unpackMapChar(entity);
            }
            else {
                if (entity.type == EntityType.PLAYER) {
                    return $gamePlayer;
                }
                if (entity.type == EntityType.EVENT) {
                    if ($gameMap.mapId() == entity.mapId) {
                        //@ts-ignore
                        return $gameMap.event(entity.id);
                    }
                    else {
                        return null;
                    }
                }
                if (entity.type == EntityType.FOLLOWER) {
                    //@ts-ignore
                    return $gamePlayer.followers().aaGetFollowerByActorId(entity.id);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    constructor() {
        this._active = false;
        this._dead = false;
        this._target = null;
        this.netDataObserver = null;
        //@ts-ignore
        if (AA.Network.isNetworkGame()) {
            this._setupForNetwork();
        }
    }
    update() { }
    initABS() {
        this.activate();
    }
    activate() {
        this._active = true;
    }
    isActive() {
        return this._active == true;
    }
    deactivate() {
        this._active = false;
    }
    isHaveTeamId() {
        //@ts-ignore
        return this.battler() && this.battler().aaNetGetTeamId() != null;
    }
    teamId() { return 0; }
    character() {
        return null;
    }
    battler() {
        return null;
    }
    sprite() {
        try {
            let spriteset = SceneManager._scene['_spriteset'];
            let character = this.character();
            if (spriteset && character) {
                return spriteset.findTargetSprite(character);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    //TODO: Logic class
    logic() {
        return null;
    }
    isMyEnemy(entity) {
        try {
            if (!entity)
                return false;
            if (!entity.isActive())
                return false;
            if (entity.teamId() != this.teamId())
                return true;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    isPlayer() {
        return false;
    }
    isAlly() {
        return false;
    }
    isNetChar() {
        return false;
    }
    isEnemy() {
        return false;
    }
    setTarget(target) {
        this._target = AAEntity.Pack(target);
    }
    resetTarget() {
        this._target = null;
    }
    getTarget() {
        return AAEntity.Unpack(this._target);
    }
    isHasTarget() {
        return this._target != null;
    }
    inBattle() {
        return this.isHasTarget();
    }
    resetBattle() {
        this.resetTarget();
    }
    isDead() {
        return this._dead;
    }
    setDead() {
        this._dead = true;
    }
    resetDead() {
        this._dead = false;
    }
    _setupForNetwork() {
        try {
            // * Для сетевой игры (DataObserver class from AnetZ plugin)
            this.netDataObserver = new Window['DataObserver']();
            // @ts-ignore
            this.netDataObserver.setCheckInterval(ANET.PP.playerDataRefreshRate());
            this.netDataObserver.addFields(this, ['_active', '_target']);
            this.netDataObserver.refreshAll(this);
        }
        catch (error) {
            console.warn(error);
        }
    }
    updateDataObserver() {
        try {
            if (!this.netDataObserver)
                return;
            this.netDataObserver.check(this);
            if (this.netDataObserver.isDataChanged()) {
                this.dataObserverHaveChanges();
                this.netDataObserver.refreshAll(this);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    dataObserverHaveChanges() {
        let data = this.getObserverDataForNetwork();
        if (!data)
            return;
        try {
            // @ts-ignore
            AANetworkManager.syncAAEntityObserver(this.character(), data);
        }
        catch (error) {
            console.warn(error);
        }
    }
    getObserverDataForNetwork() {
        try {
            return this.netDataObserver.getDataForNetwork(this);
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    applyObserverData(data) {
        if (!this.netDataObserver)
            return;
        try {
            this.netDataObserver.setDataFromNetwork(this, data);
        }
        catch (error) {
            console.warn(error);
        }
    }
}
window['AAEntity'] = AAEntity;


// Generated by CoffeeScript 2.6.1
// * Глабольный менеджер расширений (кода совместимости)

//rev 26.02.2022 (используется аналогичный в NETZ)
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ IMPLEMENTATION.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA;
  // * Добавить метод расширения
  _.extend = function(method) {
    if (AA.__extenders == null) {
      AA.__extenders = [];
    }
    AA.__extenders.push(method);
  };
  // * Загрузить (выполнить) все методы расширения
  _.loadExtensions = function() {
    var i, len, method, ref;
    if (AA.__extenders == null) {
      return;
    }
    ref = AA.__extenders;
    for (i = 0, len = ref.length; i < len; i++) {
      method = ref[i];
      method();
    }
    // * Освобождение памяти
    AA.__extenders = null;
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Глабольный менедреж управления персонажем в АБС
AA.Input = function() {};

// * Кнопки управления
AA.IKey = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Input;
  // * Коэффицент скорости перемещения по диагонали
  _.diagonalSpeed = 0.95; // TEMP
  
  // * Клавишы навыков (ячеек) для левой и правой кнопок мыши
  _.primarySkillSymbol = function() {
    return this.skillPanelSymbols[0];
  };
  _.secondarySkillSymbol = function() {
    return this.skillPanelSymbols[1];
  };
  // * Количество ячеек для навыков (и соответсвенно кнопок для них)
  // * Кнопки имеют имя SKL_(INDEX), от 0
  _.skillsSymbolsCount = function() {
    return this.skillPanelSymbols.length;
  };
  _.getTriggeredSkillSymbol = function() {
    var i, key, len, ref;
    ref = this.__skillSymbols;
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (Input.isTriggered(AA.IKey[key[0]])) {
        return key[1];
      }
    }
    return null;
  };
  _.init = function(settings1) {
    this.settings = settings1;
    _.diagonalSpeed = AAPluginParams.getDiagonalMoveSpeedMod();
    _.IsDiagonal = this.settings.isDiagonalMovement;
    // * Параметр был добавлен позже, поэтому проверка что он существует
    if (this.settings.isDiagonalMovementAI == null) {
      _.IsDiagonalForAI = _.IsDiagonal;
    } else {
      _.IsDiagonalForAI = this.settings.isDiagonalMovementAI;
    }
    _.IsStaticAttackWhenRotating = this.settings.isStaticAtkRot;
    this._loadSkillPanelSymbols();
    this.applyInputSettings();
    this.applyKeybindings();
    return this.applyMultitouch();
  };
  //"INIT ABS INPUT SUB SYSTEM".p()

  // * Загружаем кнопки, которые назначены для панели навыков
  _._loadSkillPanelSymbols = function() {
    return this.skillPanelSymbols = AA.PP.getUISkillsItems().map(function(item) {
      return item.symbol;
    });
  };
  // * Загружает данные с настроек плагина
  _.applyKeybindings = function() {
    // * WASD нельзя переопределить из параметров
    this._asignKeyForAASymbol("ML", "a");
    this._asignKeyForAASymbol("MR", "d");
    this._asignKeyForAASymbol("MU", "w");
    this._asignKeyForAASymbol("MD", "s");
    this._asignDefaultActionsKeys();
    this._asingSkillPanelKeys();
  };
  _._asignKeyForAASymbol = function(symbol, key) {
    key = this.convertUnsafeKey(key);
    AA.IKey[symbol] = key;
  };
  _._asignDefaultActionsKeys = function() {
    this._asignKeyForAASymbol("REL", this.settings.kbReload);
    this._asignKeyForAASymbol("CMD", this.settings.kbCommandMenu);
    this._asignKeyForAASymbol("ROT", this.settings.kbRotate);
  };
  _._asingSkillPanelKeys = function() {
    var i, index, key, len, ref, symb;
    // * Дополнительно присвоим для атак свои индтификаторы кнопок
    this._asignKeyForAASymbol("ATK1", this.primarySkillSymbol());
    this._asignKeyForAASymbol("ATK2", this.secondarySkillSymbol());
    // * Теперь для всех навыков (включая атаки тоже, дублируются)
    // * Для более быстрой проверки нажатия, отдельный массив
    this.__skillSymbols = [];
    ref = this.skillPanelSymbols;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      symb = ref[index];
      key = "SKL_" + index;
      this._asignKeyForAASymbol(key, symb);
      this.__skillSymbols.push([key, symb]);
    }
  };
  // * Проверка на кнопки, которые переопределены RPG Maker'ом и не будут работать так
  _.convertUnsafeKey = function(key) {
    if (key == null) {
      return '';
    }
    key = key.toLowerCase();
    switch (key) {
      case 'q':
        return 'pageup';
      case 'w':
        return 'pagedown';
      case 'x':
        return 'escape';
      case 'z':
      case 'space':
        return 'ok';
      default:
        return key;
    }
  };
  _.applyInputSettings = function() {
    this._applyMoveType();
    this._applyLMBMapTouchMode();
    this._applyRMBMapTouchMode();
    this._applyLMBTargetTouchMode();
    this._applyRMBTargetTouchMode();
  };
  _._applyMoveType = function() {
    var mt;
    mt = this.settings.moveType;
    if (mt.contains("WASD")) {
      this._applyWasdAndArrowMoveType();
    }
  };
  // * Движение и на WASD и на стрелки
  _._applyWasdAndArrowMoveType = function() {
    var signXAA, signXAAmc, signYAA, signYAAmc;
    // * Store default methods
    AA.Input.__Input_signX = Input._signX;
    AA.Input.__Input_signY = Input._signY;
    signXAA = function() {
      var x;
      x = 0;
      if (this.isPressed(AA.IKey.ML) || this.isPressed("left")) {
        x--;
      }
      if (this.isPressed(AA.IKey.MR) || this.isPressed("right")) {
        x++;
      }
      return x;
    };
    signYAA = function() {
      var y;
      y = 0;
      if (this.isPressed(AA.IKey.MU) || this.isPressed("up")) {
        y--;
      }
      if (this.isPressed(AA.IKey.MD) || this.isPressed("down")) {
        y++;
      }
      return y;
    };
    if (Imported.PKD_MobileControls === true) {
      signXAAmc = function() {
        if (PKD_MobileControls.IsInputInJoystick()) {
          return AA.Input.__Input_signX();
        } else {
          return signXAA.bind(Input)();
        }
      };
      signYAAmc = function() {
        if (PKD_MobileControls.IsInputInJoystick()) {
          return AA.Input.__Input_signY();
        } else {
          return signYAA.bind(Input)();
        }
      };
    }
    //$[OVER]
    // * Переопределяет методы Input
    if (Imported.PKD_MobileControls === true) {
      Input._signX = signXAAmc;
      Input._signY = signYAAmc;
    } else {
      Input._signX = signXAA;
      Input._signY = signYAA;
    }
  };
  // * Режим нажатия ЛЕВОЙ кнопкой мыши ПО КАРТЕ (без цели)
  //? 0 - Attack only
  //? 1 - Default (move)
  //? 2 - Nothing
  _._applyLMBMapTouchMode = function() {
    var option;
    _.LMBMapTouchMode = 1; // * Deafult
    option = this.settings.LMBMapTouchMode;
    if (option.contains("att")) {
      _.LMBMapTouchMode = 0;
    } else if (option.contains("Noth")) {
      _.LMBMapTouchMode = 2;
    }
  };
  // * Режим нажатия ПРАВОЙ кнопкой мыши ПО КАРТЕ (без цели)
  //? 0 - Default (open menu)
  //? 1 - Attack only (second skill)
  //? 2 - Move
  //? 3 - Turn
  //? 4 - Nothing
  _._applyRMBMapTouchMode = function() {
    var option;
    _.RMBMapTouchMode = 0; // Default
    option = this.settings.RMBMapTouchMode;
    if (option.contains("att")) {
      _.RMBMapTouchMode = 1;
    } else if (option.contains("Mov")) {
      _.RMBMapTouchMode = 2;
    } else if (option.contains("Tur")) {
      _.RMBMapTouchMode = 3;
    } else if (option.contains("Noth")) {
      _.RMBMapTouchMode = 4;
    }
  };
  //? 0 - Attack only
  //? 1 - Default (move)
  //? 2 - Smart attack
  //? 3 - Turn
  // * Режим нажатия ЛЕВОЙ кнопкой мыши ПО ЦЕЛИ
  _._applyLMBTargetTouchMode = function() {
    var option;
    _.LMBTargetTouchMode = 1; // * Default (Move)
    option = this.settings.LMBTargetTouchMode;
    if (option.contains("Smar")) {
      _.LMBTargetTouchMode = 2;
    } else if (option.contains("Primary")) {
      _.LMBTargetTouchMode = 0;
    } else if (option.contains("Tur")) {
      _.LMBTargetTouchMode = 3;
    }
  };
  //? 0 - Attack only
  //? 1 - Move
  //? 2 - Smart attack
  //? 3 - Turn
  // * Режим нажатия ПРАВОЙ кнопкой мыши ПО ЦЕЛИ
  _._applyRMBTargetTouchMode = function() {
    var option;
    _.RMBTargetTouchMode = 0; // * Attack only
    option = this.settings.RMBTargetTouchMode;
    if (option.contains("Smart")) {
      _.RMBTargetTouchMode = 2;
    } else if (option.contains("Mov")) {
      _.RMBTargetTouchMode = 1;
    } else if (option.contains("Tur")) {
      _.RMBTargetTouchMode = 3;
    }
  };
  // * Вспомогательные методы
  // ==================================================================

  // * Данный слот можно редактировать
  _.isEditableSymbol = function(symbol) {
    var e, settings;
    try {
      settings = AA.PP.getUISkillItemSlotSettings(symbol);
      if (settings == null) {
        return true;
      }
      // * Для совместимости со старыми настройками
      // (когда не было isEditable) исп. != false
      return settings.isEditable !== false;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * Слот поддерживает автоматическое добавление в него
  _.isSymbolSupportAutoBinding = function(symbol) {
    var e, settings;
    try {
      settings = AA.PP.getUISkillItemSlotSettings(symbol);
      if (settings == null) {
        return true;
      }
      // * Для совместимости со старыми настройками
      // (когда не было isAutoset) исп. != false
      return settings.isAutoset !== false;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * MULTITOUCH (mobile only)
  // ======================================================================
  _.applyMultitouch = function() {
    var e;
    try {
      if (this.settings.multiTouch !== true) {
        return;
      }
      return AA.ApplyMultitouchMode();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Глабольный менеджер сетевого режима (совместимость с Alpha NET Z)
AA.Network = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Network;
  //@[DEPRECATED]
  _.NETCmdPrefix = "aabsz:";
  _.setPvPMode = function() {
    return $gameSystem.aaIsPvPActive = true;
  };
  _.setPvEMode = function() {
    return $gameSystem.aaIsPvPActive = false;
  };
  //TODO: Network support!
  _.isNetworkGame = function() {
    if (Imported.Alpha_NETZ === true) {
      alert("Alpha ABS Z Beta 0.10.X: Multiplayer is not supported yet. Wait for updates.");
      AA.Network.isNetworkGame = function() {
        return false;
      };
    }
    //return ANNetwork.isConnected()
    //else
    //    AA.Network.isNetworkGame = -> false
    //    return false
    return false;
  };
  _.isNetworkPvPGame = function() {
    // * load default value
    if ($gameSystem.aaIsPvPActive == null) {
      $gameSystem.aaIsPvPActive = AA.PP.isNetworkPvPGame();
    }
    return this.isNetworkGame() && $gameSystem.aaIsPvPActive === true;
  };
  //TODO: Это скорее всего можно убрать, новый метод broadcast
  _.isShouldIgnoreServerCommand = function(servCommand) {
    var actorId;
    ({actorId} = servCommand);
    return actorId === ANGameManager.myActorId();
  };
  _.isAvailableForVisual = function(servCommand) {
    return $gameTemp._aaCanReceiveVisualFromServer === true && this.isOnSameMap(servCommand) && AAUtils.isSceneMap() && !SceneManager.isSceneChanging();
  };
  _.isOnSameMap = function(servCommand) {
    var mapId;
    ({mapId} = servCommand);
    return $gameMap.mapId() === mapId;
  };
  //TODO: На новый формат ANNetwork.send(NMS.AABSZ(name, data))
  // * Теперь broadcast, т.е. можно проверку myActorId пропускать

  // * Собирает базовую команду для отправки на сервер
  _.createServCommand = function(content) {
    return {
      mapId: $gameMap.mapId(),
      actorId: ANGameManager.myActorId(),
      content
    };
  };
  _.packMapChar = function(character) {
    var e;
    if (character == null) {
      return null;
    }
    try {
      if (character === $gamePlayer) {
        return {
          type: 0,
          id: ANNetwork.myId()
        };
      } else if (character instanceof Game_Event) {
        return {
          type: 1,
          id: character.eventId(),
          mapId: $gameMap.mapId()
        };
      } else if (character instanceof NETCharacter) {
        return {
          type: 0,
          id: character.id
        };
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return null; // * Unknown
  };
  _.unpackMapChar = function(packed) {
    var e;
    try {
      if (packed == null) {
        return null;
      }
      if (packed.type == null) {
        return null;
      }
      switch (packed.type) {
        case 0:
          if (packed.id === ANNetwork.myId()) {
            return $gamePlayer;
          } else {
            return $gameMap.networkCharacterById(packed.id);
          }
          break;
        case 1:
          if ($gameMap.mapId() === packed.mapId) {
            return $gameMap.event(packed.id);
          }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return null;
  };
  //TODO: вообще не вызывается?
  _.refreshABSMembers = function() {
    var char, e, i, len, ref, ref1, results;
    try {
      ref = $gameMap.netChars();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        char = ref[i];
        results.push((ref1 = char.AASprite()) != null ? ref1.initABS() : void 0);
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  return _.loadExtensions = function() {
    var __alias_ANGM_jdc, __alias_ANGM_orgm, __alias_ANPM_bar, _alias_GCB_fillNetworkObserver, _alias_SA_r, _alias_SA_tsp;
    if (Imported.Alpha_NETZ !== true) {
      return;
    }
    this.SetupNETCharacter(); // AA_Network/3_NETCharacter_AA.coffee
    
    //@[ALIAS]
    // * Запускать АБС по готовности персонажа
    __alias_ANPM_bar = ANPlayersManager.bindActorResult;
    ANPlayersManager.bindActorResult = function(result) {
      __alias_ANPM_bar.call(this, ...arguments);
      if (!result) {
        return;
      }
      // * На всякий случай с задержкой
      AAUtils.callDelayed(AA.System.checkABSPlayerExists.bind(AA.System), 10);
    };
    //@[ALIAS]
    __alias_ANGM_jdc = ANGameManager.applyJoinedDataCorrects;
    ANGameManager.applyJoinedDataCorrects = function(result) {
      __alias_ANGM_jdc.call(this, ...arguments);
      // * Без этой паузы будет StackOverflow
      uAPI.pauseABS(true);
    };
    //@[ALIAS]
    __alias_ANGM_orgm = ANGameManager.onRefreshGameParty;
    ANGameManager.onRefreshGameParty = function() {
      __alias_ANGM_orgm.call(this, ...arguments);
      // * В PVP режиме, других игроков не будет в партии (пока так)
      if (AA.Network.isNetworkPvPGame()) {
        AAUtils.callDelayed(ANGameManager.aaRefreshGamePartyOnPvPMode.bind(ANGameManager), 10);
      }
      AA.Network.refreshABSMembers();
    };
    //?[NEW]
    ANGameManager.aaRefreshGamePartyOnPvPMode = function() {
      var e;
      try {
        $gameParty.nClearBeforeRefresh();
        $gameParty._actors.push(ANGameManager.myActorId());
        $gamePlayer.refresh();
        $gameMap.nSafeRefresh();
        return KDCore.GEventsManager.call("netzRefreshNameplate");
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Старый способ (через nAPI)
    /*_alias_nAPI_onCustomCommandABSZ = nAPI.onCustomCommand
    nAPI.onCustomCommand = (name) ->
        _alias_nAPI_onCustomCommandABSZ.call(@, ...arguments)
        if name.contains(AA.Network.NETCmdPrefix)
            AANetworkManager.onServerCommand(...arguments)
        return*/
    //$[OVER]
    NetClientMethodsManager.event_aabz = function(name, data) {
      AANetworkManager.onServerCommand(...arguments);
    };
    _alias_GCB_fillNetworkObserver = Game_CharacterBase.prototype._fillNetworkObserver;
    Game_CharacterBase.prototype._fillNetworkObserver = function() {
      _alias_GCB_fillNetworkObserver.call(this);
      this.aaFillNetworkDataObserver();
    };
    // * На всякий случай, с анимацией были проблемы
    _alias_SA_r = Sprite_Animation.prototype._render;
    Sprite_Animation.prototype._render = function() {
      var e;
      try {
        _alias_SA_r.call(this, ...arguments);
      } catch (error) {
        e = error;
        AA.w(e);
        this._render = function() {}; // * EMPTY
      }
    };
    // * Почему-то случается Game Crush при проигрывании анимаций по сети
    // * Теряется родитель, присваиваю на авось (вроде работает)
    _alias_SA_tsp = Sprite_Animation.prototype.targetSpritePosition;
    Sprite_Animation.prototype.targetSpritePosition = function(sprite) {
      var e;
      try {
        if (sprite instanceof Sprite_Character && (sprite.parent == null) && AAUtils.isSceneMap()) {
          sprite.parent = SceneManager._scene._spriteset._tilemap;
        }
        return _alias_SA_tsp.call(this, sprite);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return {
          x: 0,
          y: 0
        };
      }
    };
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Глабольный менеджер с основными методами системы
AA.System = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.System;
  (function() {    // * Начальная загрузка компонентов
    // -----------------------------------------------------------------------
    //TODO: * Лог свой для сообщений версий
    _.initSystem = function() {
      //"INIT ABS SYSTEM".p()
      //AA.EV.init()
      this.initGEvents();
      this.loadParameters();
      this.loadExtensions();
    };
    _.loadParameters = function() {
      AA.PP = new AA.ParamsManager();
      AA.Input.init(AA.PP.getParam('inputSettings'));
    };
    // * Загрузка доп. методов совместимости с другими плагинами
    _.loadExtensions = function() {
      var e;
      try {
        AA.loadExtensions();
        return AA.Network.loadExtensions();
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.loadFonts = function() {
      var font, i, len, ref;
      ref = ["AABS_0", "AABS_1", "AABS_2", "AABS_3"];
      // * Загрузка стандартных шрифтов системы
      for (i = 0, len = ref.length; i < len; i++) {
        font = ref[i];
        KDCore.Utils.loadFont(font);
      }
      this.loadUserFonts();
    };
    // * Загрузка пользовательских шрифтов (из параметров плагина)
    _.loadUserFonts = function() {
      var font, i, len, ref;
      if (AA.PP == null) {
        return;
      }
      ref = AA.PP.fonts();
      for (i = 0, len = ref.length; i < len; i++) {
        font = ref[i];
        if (String.any(font)) {
          KDCore.Utils.loadFont(font);
        }
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Управление АБС системой
    // -----------------------------------------------------------------------
    // * Этот метод выполняется всегда когда загружается карта
    // * Не зависимо, ABS в паузе или нет
    _.startABS = function() {
      var _prevPause;
      if ($gameSystem._isABS == null) {
        //"START ABS SESSION ON MAP".p()
        // * По умлочанию, система всегда активированна
        $gameSystem._isABS = true;
      }
      _prevPause = !$gameSystem._isABS;
      $gameMap.initABS();
      this.checkABSPlayerExists();
      if (_prevPause === true) {
        setTimeout((function() {
          return uAPI.pauseABS();
        }), 1);
      }
    };
    _.resumeABS = function() {
      // * Нельзя возобновить, если игрока нету
      if (!$gamePlayer.isABS()) {
        return;
      }
      $gameSystem._isABS = true;
    };
    _.pauseABS = function() {
      if (!this.isABSActive()) {
        return;
      }
      //"PAUSE ABS SESSION ON MAP".p()
      $gameSystem._isABS = false;
      $gamePlayer.gev_onABSPaused();
      $gameMap.eventsAA().forEach(function(e) {
        return e.gev_onABSPaused();
      });
      $gameMap.followersAA().forEach(function(f) {
        return f.gev_onABSPaused();
      });
    };
    _.isABSActive = function() {
      return $gameSystem._isABS === true && !$gameTemp._noABSPlayer;
    };
    _.isExCollisionActive = function() {
      return false;
    };
    // * Сейчас игра находится в режиме UI редактора
    // * Данный метод используется чтобы некоторые UI элементы отображали себя в редакторе иначе
    // * например невидимые становились видимыми
    _.isUIEditor = function() {
      if (AA.isPro()) {
        return SceneManager._scene instanceof AA.Scene_UIEditor;
      } else {
        return false;
      }
    };
    _.update = function() {};
    _.checkABSPlayerExists = function() {
      // * Если нет персонажа, АБС не запускаем
      if ($gameParty.leader() == null) {
        this.onNoABSPlayer();
      } else {
        this.onNewABSPlayer();
      }
    };
    // * Когда в партии стало пусто (убрали всех, нет gameParty.leader())
    _.onNoABSPlayer = function() {
      $gameTemp._noABSPlayer = true;
      this.pauseABS();
      AA.EV.call("ABSPartyLeaderNone");
    };
    // * Когда появился хоть один член партии (gameParty.leader())
    _.onNewABSPlayer = function() {
      $gameTemp._noABSPlayer = false;
      if ($gameSystem._isABS === true) {
        this.resumeABS();
      }
      AA.EV.call("ABSPartyLeaderReady");
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Управление переходами и состояниями
    // -----------------------------------------------------------------------
    // * Главное меню (или Scene_Boot)
    _.onGameDataLoaded = function() {
      // * Применяем динамические параметры
      AA.PP.applyParameters();
      // * Парсим (читаем) АБС параметры в БД
      AAParametersParser.processABSSkillsNotetags();
      AAParametersParser.processABSEnemiesNotetags();
      AAParametersParser.processABSStatesNotetags();
      AAParametersParser.processABSActorsNotetags();
      AAParametersParser.processABSWeaponsNotetags();
    };
    // * Сцена карты загрузилась (или попали на сцену из меню, или Transfer)
    _.onMapSceneLoaded = function() {
      AA.UI.init();
      $gameSystem.aaOnMapLoaded();
      this.startABS();
      AA.UI.refresh();
    };
    // * Сцена карты завершается (переключение сцены)
    _.onMapSceneStopped = function() {
      AA.UI.terminate();
      $gameSystem.aaBeforeMapStopped();
      $gamePlayer.aaOnMapSceneEnd();
      $gameTemp.aaClearAllAILogicThreads();
      this.clearSceneMapGEvents();
    };
    // * Новая карта (Data)
    _.onNewMapLoaded = function() {
      // * Сброс всех предыдущих потоков АИ
      $gameTemp.aaClearAllAILogicThreads();
      // * Ссылка на последнее событие, которое было динамически создано
      $gameTemp.aaLastSpawnedEvent = null;
      AAEventsLocatorsManager.onNewMapLoaded();
      AASpawnPointsManager.onNewMapLoaded();
      $gameSystem.aaBeforeMapLoaded();
    };
    // * Перед сохранением
    _.onBeforeGameSave = function() {
      var e;
      try {
        return $gameScreen.aaOnBeforeSave();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * После загрузки
    _.onGameLoaded = function() {
      var e;
      try {
        $gameScreen.onAfterLoad();
        $gameMap.refreshABSMembers();
        return $gamePlayer.aaAfterLoad();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Глобальные события KDCore 2.9+
    // -----------------------------------------------------------------------
    // * Очищаем события которые существют только на сцене карты
    _.clearSceneMapGEvents = function() {
      AA.EV.clear('PlayerSkillSelector');
      AA.EV.clear('MapSkillsRequestsClean');
      AA.EV.clear('UnderMouseEventChanged');
      AA.EV.clear('ABSPartyLeaderReady');
      AA.EV.clear('ABSPartyLeaderNone');
    };
    _.initGEvents = function() {
      var i, item, len, list;
      //@[SHORTCUT]
      AA.EV = KDCore.GEventsManager;
      list = [
        'PlayerSkillSelector', // * Когда игрок начинает выбирать зону действия навыка
        // * Когда выполнился (закончился) навык Projectile на карте
        // * Запрашивает очистку кеша
        'MapSkillsRequestsClean',
        'UnderMouseEventChanged', // * Смена события под курсором
        'ABSPartyLeaderReady', // * Персонаж игрока готов
        'ABSPartyLeaderNone' // * Больше нет персонажа игрока (пустая партия)
      ];
      for (i = 0, len = list.length; i < len; i++) {
        item = list[i];
        KDCore.GEventsManager.register(item);
      }
    };
  })();
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// * Машина состояний для АИ
// @[STORABLE]
class AIFlowMachine {
    constructor(id) {
        this.id = id;
        this.state = 0;
        this.prevState = -1;
        this._stateFlows = [];
        this._setup();
        //@ts-ignore
        if (AA.Network.isNetworkGame()) {
            this._setupForNetwork();
        }
    }
    registerFlowForState(stateId, flowObject) {
        this._stateFlows[stateId] = flowObject;
    }
    char() {
        return $gameMap.event(this.id);
    }
    entity() {
        //@ts-ignore
        return this.char().AAEntity();
    }
    battler() {
        //@ts-ignore
        return this.char().AABattler();
    }
    isActive() {
        //@ts-ignore
        return this.char().isActive();
    }
    logic() {
        //@ts-ignore
        return this.char().AALogic();
    }
    //TODO: Model class
    model() {
        //@ts-ignore
        return this.char().AAModel();
    }
    getStateFlow(stateId) {
        return this._stateFlows[stateId];
    }
    // * Сбросить состояние
    resetState() {
        this.setState(0);
    }
    // * Установить состояние
    setState(newState) {
        // * Предыдущее состояние
        this.prevState = this.state;
        // * Текущее состояние (новое)
        this.state = newState;
        this._onStateChanged();
    }
    // * Перейти в состояние (без сброса данных, плавно)
    translateToState(newState) {
        this.prevState = this.state;
        this.state = newState;
        this._onStateTranslated();
    }
    update() {
        if (!this.char())
            return;
        if (!this.isActive())
            return;
        // * Логика состояний работает только на мастере карты
        //@ts-ignore
        if (AA.Network.isNetworkGame() && !ANGameManager.isMapMaster())
            return;
        this._updateStates();
        this._updateForNetwork();
    }
    applyObserverData(data) {
        if (!this.netDataObserver)
            return;
        this.netDataObserver.setDataFromNetwork(this, data);
    }
    _setup() {
        // * EMPTY
    }
    _setupForNetwork() {
        // * Сетевые методы вынесенны отдельно
        this._createNetworkObserver();
    }
    _updateStates() {
        if (this.state < 0)
            return;
        if (this._stateFlows.length === 0)
            return;
        this._stateFlows[this.state].update();
    }
    _onStateChanged() {
        if (this.prevState >= 0) {
            this._stateFlows[this.prevState].onStateEnd();
        }
        this._stateFlows[this.state].onStateStart();
    }
    _onStateTranslated() {
        if (this.prevState >= 0) {
            this._stateFlows[this.prevState].onStatePause();
        }
        this._stateFlows[this.state].onStateResume(this.prevState);
    }
    _updateForNetwork() {
        this._updateDataObserver();
    }
    _createNetworkObserver() {
        try {
            this.netDataObserver = new window['DataObserver']();
            this.netDataObserver.setCheckInterval(10);
            this.netDataObserver.addFields(this, ['state', 'prevState']);
            this.netDataObserver.refreshAll(this);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateDataObserver() {
        if (!this.netDataObserver)
            return;
        this.netDataObserver.check(this);
        if (this.netDataObserver.isDataChanged()) {
            this.dataObserverHaveChanges();
            this.netDataObserver.refreshAll(this);
        }
    }
    dataObserverHaveChanges() {
        try {
            //@ts-ignore
            AANetworkManager.syncAIFlowMachineObserver(this.id, this._getObserverDataForNetwork());
        }
        catch (error) {
            console.warn(error);
        }
    }
    _getObserverDataForNetwork() {
        return this.netDataObserver.getDataForNetwork(this);
    }
}
window['AIFlowMachine'] = AIFlowMachine;


// Generated by CoffeeScript 2.6.1
//TODO: переместить в A_CORE или KDCOre

//TODO: см метод hitIndex в Window_Selectable - Там конверт глобал координат в локальные простой

//TODO: Убрать когда во всех моих плагинах будет KDCore 2.8
setTimeout((function() {
  return String.isNullOrEmpty = function(str) {
    if (str != null) {
      return str.toString().isEmpty();
    } else {
      return true;
    }
  };
}), 1000);

(function() {  // * Расширение, чтобы без XDev работал плагин
  var __STR_P;
  __STR_P = String.prototype.p;
  String.prototype.p = function(anotherText) {
    if (AA.isDEV()) {
      if (__STR_P != null) {
        __STR_P.call(this, anotherText);
      } else {
        console.log(this.toString(), anotherText);
      }
    } else {

    }
  };
  // * NOTHING
  Bitmap.prototype.drawTriangle = function(w, h, color) {
    var sy;
    this._context.save();
    this._context.fillStyle = color;
    this._context.beginPath();
    sy = this.height / 2;
    this._context.moveTo(0, sy);
    this._context.lineTo(w, sy - h);
    this._context.lineTo(w, sy + h);
    this._context.lineTo(0, sy);
    this._context.fill();
    this._context.restore();
    if (KDCore.isMV()) {
      this._setDirty();
    }
  };
})();


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ 1_PatchForMV.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _ALIAS_GHWG, _ALIAS_IMLA;
  if (KDCore.isMZ()) {
    return;
  }
  _ALIAS_GHWG = Graphics.hasWebGL;
  Graphics.hasWebGL = function() {
    if (Graphics.__hasWebGl != null) {
      return Graphics.__hasWebGl;
    }
    Graphics.__hasWebGl = _ALIAS_GHWG.call(this);
    return Graphics.__hasWebGl;
  };
  _ALIAS_IMLA = ImageManager.loadAnimation;
  ImageManager.loadAnimation = function(filename, hue) {
    if (Graphics.hasWebGL()) {
      hue = 0;
    }
    return _ALIAS_IMLA.call(this, filename, hue);
  };
  (function() {
    var ALIAS_SA_IM, ALIAS_SA_LB, ALIAS_SA_UCS, _;
    
    //@[DEFINES]
    _ = Sprite_Animation.prototype;
    ALIAS_SA_IM = _.initMembers;
    _.initMembers = function() {
      ALIAS_SA_IM.call(this);
      if (!Graphics.hasWebGL()) {
        return;
      }
      this._filter = this._filter || [];
      this._colorMatrix1 = new PIXI.filters.ColorMatrixFilter();
      return this._colorMatrix2 = new PIXI.filters.ColorMatrixFilter();
    };
    ALIAS_SA_LB = _.loadBitmaps;
    _.loadBitmaps = function() {
      if (Graphics.hasWebGL()) {
        this._colorMatrix1.hue(this._animation.animation1Hue);
        this._colorMatrix2.hue(this._animation.animation2Hue);
      }
      return ALIAS_SA_LB.call(this);
    };
    ALIAS_SA_UCS = _.updateCellSprite;
    _.updateCellSprite = function(sprite, cell) {
      var a;
      ALIAS_SA_UCS.call(this, sprite, cell);
      if (!Graphics.hasWebGL()) {
        return;
      }
      a = cell[0];
      if (a >= 0 && a < 100) {
        this._colorMatrix1.blendMode = sprite.blendMode;
        return sprite._filters = [this._colorMatrix1];
      } else if (a >= 0 && a >= 100) {
        this._colorMatrix2.blendMode = sprite.blendMode;
        return sprite._filters = [this._colorMatrix2];
      }
    };
  })();
  (function() {
    var _ALIAS_WBTC;
    AA.__CCACHE = {};
    _ALIAS_WBTC = Window_Base.prototype.textColor;
    Window_Base.prototype.textColor = function(color) {
      var colorD;
      if (AA.__CCACHE[color] != null) {
        return AA.__CCACHE[color];
      } else {
        colorD = _ALIAS_WBTC.call(this, color);
        AA.__CCACHE[color] = colorD;
        return colorD;
      }
    };
  })();
})();

// ■ END Patch_00.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var UIElementController;
  // * Общий класс для UI контролллеров (которые должны обновлять UI элементы)

    //?rev 17.10.20
  UIElementController = class UIElementController {
    constructor() {}

    setup(source) { // * EMPTY
      this.source = source;
      this._setup();
      return this._setupThread();
    }

    // * DYNAMIC значит что тело метода может быть изменнено позже
    //?DYNAMIC
    update() {} // * DUMMY

    
      // * Общий метод
    refresh() {
      var e;
      if (this.source == null) {
        return;
      }
      try {
        this._refresh();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        // * Убираем источник с ошибкой и отключаем поток
        this.clear();
      }
    }

    clear() {
      this.source = null;
      this.thread = null;
      return this.update = function() {};
    }

    // * Создать поток обнолвения
    createThread(t = 10, dt = 4) {
      this.thread = new KDCore.TimedUpdate(t, () => {
        return this.refresh();
      });
      // * чтобы все контроллеры не делали проверку в один фрейм
      this.thread.applyTimeRange(-dt, dt);
      // * Добавим поток в метод Update
      this.update = () => {
        return this.thread.update();
      };
      // * Обновим значения сразу
      return this.thread.call();
    }

  };
  AA.link(UIElementController);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UIElementController.prototype;
  _._setup = function() {}; // * Метод для потомков (настройка)
  _._setupThread = function() {}; // * Метод для потомков (создание потока)
  _._refresh = function() {}; // * Метод для потомков (обновление)
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


class AAAllyEntity extends AAEntity {
    constructor(actorId) {
        super();
        //TODO: classes
        this.aaModel = null;
        this.aaLogic = null;
        this.actorId = actorId;
    }
    teamId() {
        return 0;
    }
    character() {
        //@ts-ignore
        return $gamePlayer.followers().aaGetFollowerByActorId(this.actorId);
    }
    battler() {
        //@ts-ignore
        return $gameActors.actor(this.actorId);
    }
    isAlly() {
        return true;
    }
    logic() {
        return this.aaLogic;
    }
    model() {
        return this.aaModel;
    }
    initABS() {
        if (!this.model()) {
            super.initABS();
            // * Инициализация системы в первый раз
            //@ts-ignore
            this.aaModel = new AAAllyModelData(this.actorId);
            //@ts-ignore
            this.aaLogic = new AllyAI_FlowMachine(this.actorId);
        }
        else {
            // * Ничего
            // * Повторная инициализация (например после выхода из меню) не нужна
        }
    }
}
window['AAAllyEntity'] = AAAllyEntity;


class AADummyEntity extends AAEntity {
    constructor(ownerId, _teamId, _uId) {
        super();
        this.ownerId = ownerId;
        this._teamId = _teamId;
        this._uId = _uId;
        this.aaBattler = null;
        this.initABS(); // * Сразу
    }
    initABS() {
        if (!this.battler()) {
            super.initABS();
            this.aaBattler = new Game_Enemy(this.ownerId, 0, 0);
        }
        else {
            // * Ничего
            // * Повторная инициализация (например после выхода из меню) не нужна
        }
    }
    teamId() {
        return this._teamId;
    }
    character() {
        //@ts-ignore
        return $gameMap.aaGetGlobalSkill(this._uId);
    }
    battler() {
        if (this.ownerId <= 0) {
            //@ts-ignore
            return $gameParty.leader();
        }
        else {
            //@ts-ignore
            return this.aaBattler;
        }
    }
}
window['AADummyEntity'] = AADummyEntity;


// Generated by CoffeeScript 2.6.1
// * Определение класса в файле 1_AAEnemyBattler.js
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAEnemyBattler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AAEnemyBattler.prototype;
  _.aaInit = function() {
    // * Проверка делается один раз, так как навыки не меняются
    this._isHaveAnyAASkill = this._checkAASkillsInActions();
    this._aaAttackHitAnimationId = this.char().AAModel().hitAnimationId;
  };
  _.AACharacter = function() {
    return this.char();
  };
  _.char = function() {
    return $gameMap.event(this.eventId);
  };
  _.getAASkills = function() {
    return this._selectAASkillsFromActions().map(function(skillId) {
      return $dataSkills[skillId];
    });
  };
  
  // * Если ли у врага хотябы одно действие с АБС навыком
  _.isHaveAnyAASkill = function() {
    return this._isHaveAnyAASkill === true;
  };
  _.aaIsActionValid = function(action) {
    return AASkill2.IsAAObject(action.skillId);
  };
  _.isActionValid = function(action) {
    var isABS;
    isABS = this.aaIsActionValid(action);
    return isABS && Game_Enemy.prototype.isActionValid.call(this, action);
  };
  _.attackAnimationId1 = function() {
    return this._aaAttackHitAnimationId;
  };
  // * У монстров не может быть двуручной атаки, поэтому всегда 0
  _.attackAnimationId2 = function() {
    return 0;
  };
  //$[OVER]
  return _.getDefaultWeaponMotionAnimationWeaponId = function() {
    var e;
    try {
      return this.char().AAModel().weaponMotionType;
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return 0;
  };
})();

(function() {
  var _;
  //@[DEFINES]
  _ = AAEnemyBattler.prototype;
  // * Среди всех действий врага, есть хотябы одно АБC
  // * Эта проверка нужна, чтобы сразу отметить врага как неспособного сражаться
  _._checkAASkillsInActions = function() {
    var aaActions;
    aaActions = this.enemy().actions.filter((a) => {
      return this.aaIsActionValid(a);
    });
    return aaActions.length > 0;
  };
  // * Выборка всех возможных АБС навыков из доступных действий
  // * (Тут смотритеся и canUse и можно ли использовать действие по условию в самом действии)
  _._selectAASkillsFromActions = function() {
    var aaSkills, actionList;
    aaSkills = [];
    actionList = this.enemy().actions.filter((a) => {
      return this.isActionValid(a);
    });
    if (actionList.length > 0) {
      aaSkills = this._aaSelectAllABSActions(actionList);
    }
    return aaSkills;
  };
  
  // * Метод аналогичен selectAllActions, только изменён под АБС
  // * Возвращает все АА навыки, которые проходят условия Action из БД
  _._aaSelectAllABSActions = function(actionList) {
    var aaSkills, action, i, j, ratingMax, ratingZero, ref;
    aaSkills = [];
    ratingMax = Math.max(...actionList.map(function(a) {
      return a.rating;
    }));
    ratingZero = ratingMax - 3;
    actionList = actionList.filter(function(a) {
      return a.rating > ratingZero;
    });
    for (i = j = 0, ref = actionList.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      action = this.selectAction(actionList, ratingZero);
      if (action != null) {
        aaSkills.push(action.skillId);
      }
    }
    return aaSkills;
  };
})();

// ■ END AAEnemyBattler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AAEnemyBattler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AAEnemyBattler.prototype;
  //$[OVER]
  _.dataObserverHaveChanges = function() {
    AANetworkManager.syncAAEnemyBattlerObserver(this.AACharacter(), this.getObserverDataForNetwork());
  };
})();

// ■ END AAEnemyBattler.coffee
//---------------------------------------------------------------------------


class AAEnemyEntity extends AAEntity {
    constructor(eventId) {
        super();
        //TODO: implement this classes in TypeScript
        this.aaModel = null;
        this.aaBattler = null;
        this.aaLogic = null;
        this.eventId = eventId;
    }
    teamId() {
        return this.model().gTeamId();
    }
    character() {
        //@ts-ignore
        return $gameMap.event(this.eventId);
    }
    battler() {
        return this.aaBattler;
    }
    isEnemy() {
        return true;
    }
    logic() {
        return this.aaLogic;
    }
    model() {
        return this.aaModel;
    }
    initABS() {
        if (!this.model()) {
            super.initABS();
            // * Инициализация системы в первый раз
            //@ts-ignore
            this.aaModel = new AAEnemyModelData(this.eventId);
            //@ts-ignore
            this.aaBattler = new AAEnemyBattler(this.aaModel.enemyId, this.eventId);
            //@ts-ignore
            this.aaLogic = new EnemyAI_FlowMachine(this.eventId);
        }
        else {
            // * Ничего
            // * Повторная инициализация (например после выхода из меню) не нужна
        }
    }
}
window['AAEnemyEntity'] = AAEnemyEntity;


class AANetworkCharEntity extends AAEntity {
    constructor(netId) {
        super();
        this.aaModel = null;
        this.netId = netId;
    }
    // * Номер команды игрока (и группы) всегда 0
    teamId() {
        if (this.isHaveTeamId()) {
            //@ts-ignore
            return this.battler().aaNetGetTeamId();
        }
        else {
            //@ts-ignore
            if (AA.Network.isNetworkPvPGame()) {
                return 100;
            }
            else {
                return 0;
            }
        }
    }
    isNetChar() {
        return true;
    }
    isAlly() {
        if (this.isHaveTeamId()) {
            //@ts-ignore
            return this.teamId() === $gamePlayer.AAEntity().teamId();
        }
        else {
            //@ts-ignore
            return !AA.Network.isNetworkPvPGame();
        }
    }
    character() {
        //@ts-ignore
        return $gameMap.networkCharacterById(this.netId);
    }
    battler() {
        //@ts-ignore
        return this.character().actor();
    }
    // * Network character определяется на карте почти как событие
    // * Сейчас используется для показа UIEnemyTargetInfo
    model() {
        return this.aaModel;
    }
    initABS() {
        super.initABS();
        const battler = this.battler();
        if (battler) {
            this.aaModel = {
                //@ts-ignore
                faceName: battler.faceName(),
                //@ts-ignore
                faceIndex: battler.faceIndex()
            };
        }
    }
}
window['AANetworkCharEntity'] = AANetworkCharEntity;


class AAPlayerEntity extends AAEntity {
    teamId() {
        //@ts-ignore
        if (AA.Network.isNetworkGame() && this.isHaveTeamId()) {
            //@ts-ignore
            return this.battler().aaNetGetTeamId();
        }
        else {
            return 0;
        }
    }
    isPlayer() {
        return true;
    }
    character() {
        return $gamePlayer;
    }
    battler() {
        //@ts-ignore
        return $gameParty.leader();
    }
    setTarget(target) {
        super.setTarget(target);
        //@ts-ignore
        AA.EV.call("PlayerTarget");
    }
}
window['AAPlayerEntity'] = AAPlayerEntity;


// * Состояние АИ
class AIFlow extends AIFlowMachine {
    constructor(id) {
        super(id);
        // * Состояние в режиме ожидания
        this.paused = false;
        this.translatedFrom = -1;
    }
    update() {
        super.update();
        this._updateFlow();
    }
    onStateStart() { }
    onStateEnd() { }
    // * При "переходе" в это состояние
    // * Поддерживает инициацию, если не было паузы
    // * Запоминает номер состояния после которого был запущен
    onStateResume(_translatedFrom) {
        this.translatedFrom = _translatedFrom;
    }
    // * При "переходе" в другое состояние
    onStatePause() { }
    _updateFlow() { }
}
window['AIFlow'] = AIFlow;


// Generated by CoffeeScript 2.6.1
//? Методы для улучшенной совместимости с Extended Loot

//@[EXTENSION]
AA.extend(function() {
  // * Методы ниже даже не учитываются, если плагин не подключён
  if (Imported.PKD_ExtendedLoot !== true) {
    return;
  }
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_Party.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__pelOnSomeItemBeenGained, _;
    
    //@[DEFINES]
    _ = Game_Party.prototype;
    
    //@[ALIAS]
    ALIAS__pelOnSomeItemBeenGained = _.pelOnSomeItemBeenGained;
    _.pelOnSomeItemBeenGained = function() {
      var e;
      try {
        this.pOnItemBeenGainedProcess();
      } catch (error) {
        e = error;
        AA.w(e);
      }
      ALIAS__pelOnSomeItemBeenGained.call(this);
    };
  })();
  return (function() {    // ■ END Game_Party.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Scene_Map.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__createSpriteset, _;
    
    //@[DEFINES]
    _ = Scene_Map.prototype;
    
    //TODO: Временное решение, до обновления Extended Loot 1.2
    //@[ALIAS]
    ALIAS__createSpriteset = _.createSpriteset;
    _.createSpriteset = function() {
      ALIAS__createSpriteset.call(this);
      if (this._pelVisualDropSpriteset == null) {
        this._pelVisualDropSpriteset = new Sprite();
        this.addChild(this._pelVisualDropSpriteset);
      }
    };
  })();
});

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//? Методы для улучшенной совместимости с MapInventory

//@[EXTENSION]
AA.extend(function() {
  // * Методы ниже даже не учитываются, если плагин не подключён
  if (Imported.PKD_MapInventory !== true) {
    return;
  }
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PKD_MI.LIBS.MapChestController.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS___onGainItemFinal, _;
    
    //@[DEFINES]
    _ = PKD_MI.LIBS.MapChestController.prototype;
    
    //@[ALIAS]
    ALIAS___onGainItemFinal = _._onGainItemFinal;
    _._onGainItemFinal = function() {
      ALIAS___onGainItemFinal.call(this, ...arguments);
      AAUtils.callDelayed($gameParty.pOnSomeItemBeenGained.bind($gameParty), 1);
    };
  })();
  (function() {    // ■ END PKD_MI.LIBS.MapChestController.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PKD_MI.LIBS.MapUserChestController.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS___onStoreItemFinal, _;
    
    //@[DEFINES]
    _ = PKD_MI.LIBS.MapUserChestController.prototype;
    
    //@[ALIAS]
    ALIAS___onStoreItemFinal = _._onStoreItemFinal;
    _._onStoreItemFinal = function() {
      ALIAS___onStoreItemFinal.call(this, ...arguments);
      return AAUtils.callDelayed($gameParty.pOnSomeItemBeenGained.bind($gameParty), 1);
    };
  })();
  return (function() {    // ■ END PKD_MI.LIBS.MapUserChestController.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Spriteset_InvUI.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS___onReleaseDraggingCell, _;
    
    // * Возможность перетаскивания с инвентаря на панель навыков (только предметы)

    //@[DEFINES]
    _ = Spriteset_InvUI.prototype;
    if (!PKD_MI.isPro()) {
      return;
    }
    //@[ALIAS]
    ALIAS___onReleaseDraggingCell = _._onRelaseDragginCell;
    _._onRelaseDragginCell = function() {
      var symbol;
      symbol = AA.UI.getSkillSymbolUnderMouse();
      if (String.any(symbol)) {
        if (this._aaIsProperItemToPutInSkillPanelSlot(symbol)) {
          uAPI.setItemToPanel(this._dragItem.id, symbol);
        } else {
          SoundManager.playBuzzer();
        }
        return;
      }
      return ALIAS___onReleaseDraggingCell.call(this);
    };
    //?[NEW]
    _._aaIsProperItemToPutInSkillPanelSlot = function(symbol) {
      return DataManager.isItem(this._dragItem) && AASkill2.IsAAObject(this._dragItem) && AA.Input.isEditableSymbol(symbol);
    };
  })();
});

// ■ END Spriteset_InvUI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ NETCharacter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
AA.Network.SetupNETCharacter = function() {
  var ALIAS__initMembersAABSZNET, ALIAS__isABS, _;
  //@[DEFINES]
  _ = NETCharacter.prototype;
  //TODO: Синхронизировать Active состояние?

  //@[ALIAS]
  ALIAS__initMembersAABSZNET = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembersAABSZNET.call(this, ...arguments);
    // * Чтобы ID определился (Character_Base вызывает initMembers без ID)
    AAUtils.callDelayed(this._initMembersABS.bind(this), 100);
  };
  //@[ALIAS]
  ALIAS__isABS = _.isABS;
  _.isABS = function() {
    return ALIAS__isABS.call(this) && (this.playerData() != null) && (this.actor() != null);
  };
  //$[OVER]
  // * Сам ничего не обновляет, принимает команду от сервера (если надо)
  _.aaUpdateABSAnimaXInBattleState = function() {}; // * EMPTY
  _.aaIsSupportMotion = function() {
    return AA.PP.getShowDeadMotionOnDeathType() > 0;
  };
  // * =================================================================
  _._initMembersABS = function() {
    if (this.id == null) {
      return;
    }
    this.aaEntity = new AANetworkCharEntity(this.id);
    this.initABS();
  };
  // * Переопределяем
  //$[OVER]
  _.aaGetExtendedHitBoxes = function() {
    if (this.isABS()) {
      return this.actor().aaGetExtendedHitBoxes();
    } else {
      return null;
    }
  };
};

// ■ END NETCharacter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//? Правильная обработка Dead состояния игрока

//@[EXTENSION]
AA.extend(function() {
  // * Методы ниже даже не учитываются, если плагин не подключён
  if (Imported.PKD_AnimaX !== true) {
    return;
  }
  //TODO: Remove this after PKD_AnimaX update 140
  if (PKD_ANIMAX.version <= 131) {
    //$[FIX]
    Game_Character.prototype.resetXAnima = function() {
      if (this.isInAnimXAction()) {
        this.onAnimaXActionEnd();
        if (this.__axShouldResetAnimaXAfterAction === true) {
          this.deleteAnimaX();
          this.__axShouldReloadBitmaps = true;
          this.__axShouldResetAnimaXAfterAction = null;
          return;
        }
      }
      this._xAnimaToIdleTimer = 0;
      this._setAnimaXToMovement();
    };
  }
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ XAnimaSetController.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS___nextActionFrame, ALIAS___updateAction, _;
    
    //@[DEFINES]
    _ = XAnimaSetController.prototype;
    
    //@[ALIAS]
    ALIAS___updateAction = _._updateAction;
    _._updateAction = function(c) {
      var isInitialFrame;
      isInitialFrame = this._initialFrame === true;
      ALIAS___updateAction.call(this, ...arguments);
      if (this.rootAnimation.aaNoRepeatFlag === true && isInitialFrame === false && c._aaAnimaXDeathPlayedFlag === true) {
        this._initialFrame = false; // * Чтобы метод _setInitialFrame сработал ещё раз
        this._setInitialFrame(this.rootAnimation.frames - 1);
        this._nextActionFrame(c); // * Ставим сразу последний кадр
      }
    };
    
    //@[ALIAS]
    ALIAS___nextActionFrame = _._nextActionFrame;
    _._nextActionFrame = function(c) {
      var isLastFrame;
      isLastFrame = this.cFrame === this.rootAnimation.frames - 1;
      ALIAS___nextActionFrame.call(this, ...arguments);
      if (this.rootAnimation.aaNoRepeatFlag === true && isLastFrame === true) {
        this.cFrame = this.rootAnimation.frames - 1;
        c._aaAnimaXDeathPlayedFlag = true;
        this.requestRefresh();
      }
    };
    //$[OVER]
    _._isNextFrameBitmapIsReady = function() {
      return true;
    };
  })();
});

// ■ END XAnimaSetController.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//? Исправление Damage PopUp

//@[EXTENSION]
AA.extend(function() {
  if (Imported.VisuMZ_1_BattleCore !== true) {
    return;
  }
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_Battler.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__clearDamagePopup, ALIAS__isDamagePopupRequested, ALIAS__startDamagePopup, _;
    
    //@[DEFINES]
    _ = Game_Battler.prototype;
    
    //@[ALIAS]
    ALIAS__startDamagePopup = _.startDamagePopup;
    _.startDamagePopup = function() {
      ALIAS__startDamagePopup.call(this, ...arguments);
      if (AA.isMap()) {
        this._aaDamagePopUpRequested = true;
      }
    };
    //@[ALIAS]
    ALIAS__isDamagePopupRequested = _.isDamagePopupRequested;
    _.isDamagePopupRequested = function() {
      if (this._aaDamagePopUpRequested === true) {
        return true;
      } else {
        return ALIAS__isDamagePopupRequested.call(this, ...arguments);
      }
    };
    
    //@[ALIAS]
    ALIAS__clearDamagePopup = _.clearDamagePopup;
    _.clearDamagePopup = function() {
      ALIAS__clearDamagePopup.call(this, ...arguments);
      this._aaDamagePopUpRequested = null;
    };
  })();
});

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//@[EXTENSION]
AA.extend(function() {
  if (Imported.SAN_AnalogMove !== true) {
    return;
  }
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Game_CharacterBase.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__updateAnalogMove, _;
    
    //@[DEFINES]
    _ = Game_CharacterBase.prototype;
    
    //@[ALIAS]
    ALIAS__updateAnalogMove = _.updateAnalogMove;
    _.updateAnalogMove = function() {
      var e;
      ALIAS__updateAnalogMove.call(this, ...arguments);
      try {
        return this._aaUpdate();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
});

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var AA_NUI_Sprite_PlayerCastingProgressBar;

AA_NUI_Sprite_PlayerCastingProgressBar = class AA_NUI_Sprite_PlayerCastingProgressBar extends KDCore.Sprite {
  constructor() {
    super();
    this._progress = 0;
    this._create();
    return;
  }

  static Show() {
    var e, element;
    try {
      AA_NUI_Sprite_PlayerCastingProgressBar.Hide();
      element = new AA_NUI_Sprite_PlayerCastingProgressBar();
      AA.UI.addToUI(element);
      return AA.UI._playerCastingProgressBar = element;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  static Hide() {
    var e, element;
    try {
      element = AA.UI._playerCastingProgressBar;
      if (element != null) {
        element.removeFromParent();
      }
      return AA.UI._playerCastingProgressBar = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  // * Создание спрайта
  _create() {
    this.nuiElement = KDCore.Sprite_NUI.FromScheme($aabsz_NUI_PlayerCastingProgressBar, this, this);
    this.nuiElement.refreshBindings(this);
    this._setPositionFromUIBuilder();
  }

  _setPositionFromUIBuilder() {} //TODO: Set stored pos if user edit in UI Editor

  castingProgressRate() {
    return this._progress;
  }

  skillData() {
    return $gamePlayer._aaCastingNowSkill;
  }

  skillName() {
    if ($gamePlayer.aaInSkillCastingProcess()) {
      if (this.skillData() != null) {
        return this.skillData().name();
      }
    }
    return "";
  }

  castingTime() {
    if ($gamePlayer.aaInSkillCastingProcess()) {
      return $gamePlayer._aaCastingTimeMax;
    } else {
      return 0;
    }
  }

  castingTimeNow() {
    if ($gamePlayer.aaInSkillCastingProcess()) {
      return $gamePlayer._aaCastingTimer;
    } else {
      return 0;
    }
  }

  castingTimeLeft() {
    var timeLeft;
    timeLeft = this.castingTime() - this.castingTimeNow();
    timeLeft /= 60;
    // * Return time in 0.0 format
    return timeLeft.toFixed(1);
  }

  update() {
    super.update();
    return this._updateGaugeProgressValues();
  }

  _updateGaugeProgressValues() {
    var ref;
    if (!$gamePlayer.aaInSkillCastingProcess()) {
      this._progress = 0;
    } else {
      this._progress = this.castingTimeNow() / this.castingTime();
    }
    if ((ref = this.playerCastingProgressBarBase) != null) {
      ref.refreshBindings(this);
    }
  }

};

//TODO: UI EDITOR!


// Generated by CoffeeScript 2.6.1
// * Класс, который содержит все настройки и параметры AA сущности союзника на карте

//@[STORABLE]
//@[GLOBAL]
var AAAllyModelData;

AAAllyModelData = (function() {
  class AAAllyModelData {
    constructor(actorId) {
      this.actorId = actorId;
      this._initBaseParameters();
      this._applyParametersFromDB();
      this._convertParameters();
    }

    actor() {
      return $gameActors.actor(this.actorId);
    }

    actorData() {
      return this.actor().actor();
    }

    getBattleStartConditions() {
      return this.activateWhen;
    }

    getBattleStartUserCondition() {
      return this.extraActivateCond;
    }

    getCertainActionId() {
      return this.activateActionId;
    }

    getBestTargetCondition(index) {
      if (index < 4 && index > 0) {
        return this['bestTarget' + index];
      } else {
        return null;
      }
    }

    getBestSupportTargetCondition(index) {
      if (index < 4 && index > 0) {
        return this['bestHelp' + index];
      } else {
        return null;
      }
    }

    getBestTargetGroupCondition() {
      return this.bestTargetGroup;
    }

    getBestTargetUserCondition() {
      return this.extraTargetCond;
    }

    getBestSupportTargetUserCondition() {
      return this.helpCondition;
    }

    gNoMoveInBattle() {
      return AAExtendedValues.getSafeEValue(this.noMoveInBattle, 0);
    }

    gNoApproach() {
      return AAExtendedValues.getSafeEValue(this.noApproach, 0);
    }

    isHeavy() {
      return AAExtendedValues.getSafeEValue(this.heavy, 0) > 0;
    }

    gViewRadius() {
      return AAExtendedValues.getSafeEValue(this.viewRadius, 5);
    }

    gReturnRadius() {
      return AAExtendedValues.getSafeEValue(this.returnRadius, 12);
    }

    getRefreshBattleTargetTimeMax() {
      return this.bestTarRefreshTime;
    }

    isHaveSupportSkills() {
      return (this.supportSkills != null) && this.supportSkills.length > 0;
    }

    getSupportSkillsList() {
      if (this.isHaveSupportSkills()) {
        return this.supportSkills;
      } else {
        return [];
      }
    }

    getBattleSkillsPriorityList() {
      if ((this.skillsPriority != null) && this.skillsPriority.length > 0) {
        return this.skillsPriority;
      } else {
        return [];
      }
    }

    isCanSupport() {
      return String.any(this.getBestSupportTargetCondition(1)) && this.isHaveSupportSkills();
    }

    isSupportInPriority() {
      return this.isCanSupport() && this.supportInPriority > 0;
    }

    isHaveOnDeathAction() {
      return AAScriptActions.isProper(this.onDeath);
    }

    isHaveOnDeathVariable() {
      return this.onDeathVar > 0;
    }

  };

  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = AAAllyModelData.prototype;
    
    // * Инициализация базовых настроек
    _._initBaseParameters = function() {
      this._initAI();
      this._initMain();
      this._initMovingSettings();
      this._initOnMapSettings();
      this._initOtherSettings();
      this._initVisualSettings();
      this._initAnimationSettings();
    };
    _._initAI = function() {
      // seeEnemy - увидел врага (враг в области видимости)
      // gotDamage - получил урон
      // playerGotDamage - игрок получил урон
      // playerInDanger - игрок является целью кого-либо
      // playerAttacksSomeone - игрок нанёс урон по врагу
      // playerAction - игрок просто выполнил действие (навык или атака) (без урона даже)
      // condition - условие игрока (script)
      this.activateWhen = 'seeEnemy'; // * можно писать через | или &
      // можно исползовать a. (свой Battler) и b. (Battler игрока)
      this.extraActivateCond = ""; // * Script условие перехода в режим боя
      this.activateActionId = 0; // * Для playerAction -> 0 = любое действие игрока (X - номер навыка)
      
      // any - любой враг (случайный)
      // condition - враг, который попадает под условие (script) игрока
      // damaged - раненный враг
      // full - враг с полным здоровьем
      // playerTarget - враг, которого атаковал игрок
      // playerOpponent - враг, который атакует игрока
      // notMyOpponent - любой, кто не атакует меня
      // myOpponent - любой, кто атакует меня
      // none - не атакует никого
      this.bestTarget1 = "any"; // * можно писать any|nearest|playerTarget (много, через | или &)
      this.bestTarget2 = "";
      this.bestTarget3 = "";
      // nearest - ближний
      // further - дальний
      // weakest - слабый
      // strongest - сильный
      // lowHp - меньше всех здоровья
      // highHp - больше всех здоровья
      // nearestToPlayer - ближайший к игроку
      // furtherFromPlayer - дальше от игрока
      // * Только одно значение может быть
      this.bestTargetGroup = "";
      // можно исползовать a. (свой Battler) и b. (Battler игрока) и t. (Battler цели)
      this.extraTargetCond = ""; // * Script условие выбора цели
      // * Если нет цели, удовлетворяющей условию inBattleBestTarget, атаковать любую?
      this.bestTarRefreshTime = 60; // * Менять цель каждые Х кадров (делать проверку условия)
      this.skillsPriority = []; // * Номера навыков через запятую, от самого лучшего, до самого худшего
      
      // * Если есть лучшая цель для навыков Support, то выбираем её всегда первой
      this.supportInPriority = 0;
      // * Если пусто, то так же не поддерживает суппорт
      this.supportSkills = []; // * номера навыков через запятую
      //TODO: PARTY UPD : healInPriority
      //@healInPriority = true # * Если true, то навык, который лечит - в приоритете
      // none - не поддерживает суппорт
      // any - любой союзник
      // damaged - раненный
      // full - здоровый
      // player - игрок
      // ally - союзник
      // self - я (себя)
      // other - любой, но НЕ я
      // lowHp - мало здоровья
      // partyMember - член партии
      // condition - условие (скрипт) игрока
      // * поддерживают | и &
      this.bestHelp1 = "none";
      this.bestHelp2 = "";
      this.bestHelp3 = "";
      // можно исползовать a. (свой Battler) и b. (Battler игрока) и t. (Battler цели)
      this.helpCondition = "";
    };
    _._initMain = function() {
      this.onDeath = 0; //AScript
      this.viewRadius = 5; //@[EVal]
      // * Как далеко может от игрока отойти
      this.returnRadius = 8; //@[EVal]
      //TODO: PARTY UPD this two not used now (maybe don't need at all)
      this.noPassVisionRegions = [];
      this.noPassVisionTerrains = [];
    };
    _._initMovingSettings = function() {
      //@[EVal]
      this.noMoveInBattle = 0; // * Если 1 - не будет двигаться в бою (вообще)
      //@[EVal]
      this.noApproach = 0; // * Не преследовать цель в бою (своё движение остаётся, например Random или отступать от игрока)
      // Range (when start), Freq, Speed
      this.approachMoveData = [3, 5, 3];
      // Min dist, Freq, Speed, isRandomStep
      this.inBattleMoveData = [1, 3, 3, 0];
    };
    _._initOnMapSettings = function() {
      // * Нельзя сдвинуть импульсом
      this.heavy = 1; //@[EVal]
    };
    _._initVisualSettings = function() {
      //TODO: PARTY UPD : info??? as Enemy Info when under cursor?
      //TODO: PARTY UPD some portrait config?
      this.miniHpGaugeStyle = "";
      this.miniHPGaugeOffset = [0, 0];
    };
    _._initOtherSettings = function() {
      this.onSeeTarget = 0; //AScript
      // * При получении урона (AABS навыка от кого либо)
      this.onHit = 0; //AScript
      // * Переменная для +1 когда этот юнит погибает
      this.onDeathVar = 0;
      // * Даные действия выполняются каждую секунд (каждую секунду в битве)
      this.turnAction = 0; //AScript
      this.turnActionInBattle = 0; //AScript
      // * Когда был отброшен навыком с Impluse
      //TODO:PARTY UPD реализовать выполенние
      this.onKnocked = 0; //AScript
    };
    _._initAnimationSettings = function() {};
    _._applyParametersFromDB = function() {
      var i, len, p, params;
      params = this.actorData().AAAllyChar;
      if (params == null) {
        return;
      }
      for (i = 0, len = params.length; i < len; i++) {
        p = params[i];
        this[p[0]] = p[1];
      }
    };
    // * Преобразует некоторые параметры
    _._convertParameters = function() {
      this.supportSkills = AAParametersParser.convertArrayFromParameter(this.supportSkills);
      this.skillsPriority = AAParametersParser.convertArrayFromParameter(this.skillsPriority);
      this.approachMoveData = AAParametersParser.convertArrayFromParameter(this.approachMoveData);
      this.inBattleMoveData = AAParametersParser.convertArrayFromParameter(this.inBattleMoveData);
    };
  })();

  return AAAllyModelData;

}).call(this);

// ■ END PRIVATE
//---------------------------------------------------------------------------


var AAArrayUtils;
(function (AAArrayUtils) {
    function GetArrayChanges(oldArray, newArray) {
        let added = newArray.filter(x => !oldArray.includes(x));
        let removed = oldArray.filter(x => !newArray.includes(x));
        return { added, removed };
    }
    AAArrayUtils.GetArrayChanges = GetArrayChanges;
})(AAArrayUtils || (AAArrayUtils = {}));


// * Класс для Action для навыков ABS
// * Большинство методов из Game_Action просто не используются
// * Вынесен в отдельный класс чтобы не мешать обычной битве
class AABattleAction extends Game_Action {
    constructor(subject, aaSkill) {
        super(null, true);
        this.setAASkill(aaSkill);
        this._direction = subject.direction();
        this._packedSubject = AAEntity.Pack(subject);
    }
    setSubject(subject) { }
    setAASkill(aaSkill) {
        if (!aaSkill) {
            this.clear();
        }
        if (aaSkill.isItem()) {
            this.setItem(aaSkill.databaseId());
        }
        else {
            this.setSkill(aaSkill.idA);
        }
    }
    // * Направление навыка
    direction() {
        return this._direction;
    }
    AASkill() {
        return this.item()['AASkill'];
    }
    // * Данное действие принадлежит игроку?
    // * Используется чтобы не давать опыт, если врага убил другой АИ или глобал
    isPlayerActionOwner() {
        //@ts-ignore
        return this.isValid() && this.subject() === $gameParty.leader();
    }
    isPlayerTeamOwner() {
        return this.isPlayerActionOwner() || this.isAllyActionOwner();
    }
    isAllyActionOwner() {
        //@ts-ignore
        return this.isValid() && $gameParty.members().includes(this.subject());
    }
    // * Данное действие используется в PvP режиме, чтобы зарегестрировтать callback
    // * кто кого "убил"
    isNetCharActionOwner() {
        //@ts-ignore
        return this.isValid() && this.character() instanceof NETCharacter;
    }
    // * canUse проверяется перед выполнением действия, поэтому тут пропускаем
    isValid() {
        return !!this._packedSubject && !!this.item() && !!this.AASkill();
    }
    // * Проверки сокращены, так как не используются стандартные настройки
    testApply(target) {
        return true;
    }
    // * Нет необходимости в этой проверке
    //@ts-ignore
    testLifeAndDeath(target) {
        return true;
    }
    subject() {
        const char = this.character();
        return char ? AsAAChar(char).AABattler() : null;
    }
    character() {
        return AAEntity.Unpack(this._packedSubject);
    }
    applyOn(target) {
        const b = AsAAChar(target).AABattler();
        super.apply(b);
        //@ts-ignore
        b.result().setUsedAASkill(this.AASkill());
    }
    //@ts-ignore
    updateLastSubject() { }
    subjectTeamId() {
        var _a, _b;
        try {
            return (_b = (_a = AsAAChar(this.character())) === null || _a === void 0 ? void 0 : _a.AAEntity().teamId()) !== null && _b !== void 0 ? _b : -1;
        }
        catch (e) {
            console.warn(e);
            return -1;
        }
    }
}
window['AABattleAction'] = AABattleAction;


var AABattleActionsManager2;
(function (AABattleActionsManager2) {
    function performBattleAction(skill, user, targets) {
        try {
            if (!skill)
                return;
            if (!user)
                return;
            if (!targets)
                return;
            let action = new AABattleAction(user, skill);
            if (!action.isValid())
                return;
            startAction(action, targets);
            endAction(action);
            onActionFinished(skill, user);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AABattleActionsManager2.performBattleAction = performBattleAction;
    function startAction(action, targets) {
        try {
            action.applyGlobal();
            for (let i = 0; i < targets.length; i++) {
                invokeAciton(targets[i], action);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function invokeAciton(target, action) {
        try {
            if (!target)
                return;
            //TODO: Network game (later, see old _invokeAction)
            action.applyOn(target);
            let battler = AsAAChar(target).AABattler();
            if (!battler.result().used)
                return;
            performActionResult(battler, battler.result());
            battler.startDamagePopup();
            action.subject().startDamagePopup();
            AsAAChar(target).aaOnActionOnMe(action);
            //TODO: last action and target API data save
            let skill = action.AASkill();
            try {
                AAScriptActions.execute(skill.onHit, target);
            }
            catch (error) {
                console.warn(error);
            }
            performSkillEffects(skill, target, action);
        }
        catch (error) {
            console.warn(error);
        }
    }
    function performActionResult(battler, result) {
        try {
            if (!battler)
                return;
            if (!result)
                return;
            if (result.missed) {
                battler.performMiss();
            }
            else if (result.evaded) {
                if (result.physical) {
                    battler.performEvasion();
                }
                else {
                    battler.performMagicEvasion();
                }
            }
            else {
                if (result.hpAffected) {
                    if (result.hpDamage > 0 && !result.drain) {
                        battler.performDamage();
                    }
                    if (result.hpDamage < 0) {
                        battler.performRecovery();
                    }
                }
                if (battler.isAlive() && (result.mpDamage != 0 || result.tpDamage != 0)) {
                    if (result.mpDamage < 0 || result.tpDamage < 0) {
                        battler.performRecovery();
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function performSkillEffects(skill, target, action) {
        try {
            if (!skill)
                return;
            if (!target)
                return;
            if (!action)
                return;
            if (skill.isExplosive()) {
                AASkillExplosionHandler.performExplosion(skill, target, action);
            }
            if (skill.isHaveImpulsePower()) {
                performSkillImpulseEffectByAction(skill, target, action);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function performSkillExplosionEffect(skill, target, action) {
        try {
        }
        catch (error) {
            console.warn(error);
        }
    }
    function performSkillImpulseEffectByAction(skill, target, action) {
        try {
            //TODO: Implement projectiles direction
            //if(skill.isProjectile()) { return; } // Projectiles have their own impulse
            let directionVector = { x: 0, y: 0 };
            if (skill.isAroundUser()) {
                let user = action.character();
                directionVector = AAMath.getDirectionVetorToPoint(user, target, true);
            }
            else {
                directionVector = AAMath.getDirectionVector(action.direction());
            }
            performSkillImpulseEffectInDirection(skill, target, directionVector);
        }
        catch (error) {
            console.warn(error);
        }
    }
    function performSkillImpulseEffectInDirection(skill, target, directionVector) {
        try {
            let impulsePower = skill.getImpulsePower();
            if (impulsePower <= 0)
                return;
            if (!AsAAChar(target).aaIsCanMoveByImpulse())
                return;
            if (skill.isRandomImpulseDirection()) {
                let randomDirection = AAMath.getRandomDirection(true);
                directionVector = AAMath.getDirectionVector(randomDirection);
            }
            if (skill.isReversedImpulseType()) {
                // * Reverse direction vector
                directionVector = { x: -directionVector.x, y: -directionVector.y };
            }
            AACharMovementController.makeImpulseMovementInDirection(target, directionVector, impulsePower, skill.isJumpImpulseType());
        }
        catch (error) {
            console.warn(error);
        }
    }
    function endAction(action) {
        try {
            let battler = action.subject();
            if (!battler)
                return;
            //@ts-ignore
            battler.onAAActionComplete();
        }
        catch (error) {
            console.warn(error);
        }
    }
    function onActionFinished(skill, user) {
        try {
            try {
                AAScriptActions.execute(skill.onDone, user);
            }
            catch (error) {
                console.warn(error);
            }
            //TODO: Это в отдельный метод (класс)
            // Снимаем Skill Extension, если он был
            let dbItem = skill.dbItem();
            if (!dbItem['__aaDefCopy'])
                return;
            let skillId = skill.databaseId();
            $dataSkills[skillId]['AASkill'] = $dataSkills[skillId]['__aaDefCopy'];
            $dataSkills[skillId]['__aaDefCopy'] = null;
        }
        catch (error) {
            console.warn(error);
        }
    }
})(AABattleActionsManager2 || (AABattleActionsManager2 = {}));
window["AABattleActionsManager2"] = AABattleActionsManager2;


var AABattleAnimationsManager;
(function (AABattleAnimationsManager) {
    let mapAnimationOwnerSprites = [];
    let animationsClearThread = 0;
    //TODO: Навык должен иметь анимацию запуска
    //TODO: Отдельная анимация для каждой цели
    // Если сцена карты остановлена, то очищаем анимации (так как спрайты удаляются)
    function clearAll() {
        clearAnimations();
        clearInterval(animationsClearThread);
        animationsClearThread = 0;
        mapAnimationOwnerSprites = [];
    }
    AABattleAnimationsManager.clearAll = clearAll;
    function playSkillStartAnimation(skill, skillPosition) {
        //TODO: Implement
    }
    AABattleAnimationsManager.playSkillStartAnimation = playSkillStartAnimation;
    function playSkillHitAnimation(skill, user, skillPosition, targets) {
        if (skill.isHaveExtraAnimation()) {
            Sprite_AAExtraSkillAnimation.Create(skillPosition, skill);
            return;
        }
        let skillAnimationId = skill.getAnimationIdForBattler(user.AABattler());
        if (targets.length == 0) {
            if (!skill.isRequireContact() || skill.isAnimationOnMap()) {
                playAnimationOnMap(skillAnimationId, skillPosition);
            }
        }
        else {
            if (skill.isAnimationOnMap()) {
                playAnimationOnMap(skillAnimationId, skillPosition);
            }
            else {
                targets.forEach(target => {
                    playAnimationOnCharacter(skillAnimationId, target);
                });
            }
        }
    }
    AABattleAnimationsManager.playSkillHitAnimation = playSkillHitAnimation;
    function playAnimationOnCharacter(animationId, char) {
        try {
            if (!isValidScene())
                return;
            if (!char)
                return;
            if (animationId == 0)
                return;
            //@ts-ignore
            AANetworkManager.playAnimationOnCharacter(char, animationId);
            if (AAUtils.isMZ()) {
                //@ts-ignore
                $gameTemp.requestAnimation([char], animationId, false);
            }
            else {
                //@ts-ignore
                char.requestAnimation(animationId, true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AABattleAnimationsManager.playAnimationOnCharacter = playAnimationOnCharacter;
    function playAnimationOnMap(animationId, position) {
        //@ts-ignore
        AANetworkManager.playAnimationOnMap(position.x, position.y, animationId);
        createMapAnimation(animationId, position);
    }
    AABattleAnimationsManager.playAnimationOnMap = playAnimationOnMap;
    function createMapAnimation(animationId, position) {
        try {
            if (!isValidScene())
                return;
            clearAnimationsThreadStart();
            let animation = $dataAnimations[animationId];
            if (animation) {
                //@ts-ignore
                let character = new Game_Character();
                character.setPosition(position.x, position.y);
                let character_sprite = new Sprite_Character(character);
                mapAnimationOwnerSprites.push(character_sprite);
                let spriteset = mapSpriteset();
                spriteset._characterSprites.push(character_sprite);
                if (AAUtils.isMZ()) {
                    //@ts-ignore
                    spriteset._effectsContainer.addChild(character_sprite);
                }
                else {
                    spriteset._tilemap.addChild(character_sprite);
                }
                playAnimationOnCharacter(animationId, character);
            }
            else {
                AALog.warn("Animation with id " + animationId + " not found");
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function isValidScene() {
        return SceneManager._scene instanceof Scene_Map;
    }
    function mapSpriteset() {
        //@ts-ignore
        return SceneManager._scene._spriteset;
    }
    function clearAnimationsThreadStart() {
        try {
            if (animationsClearThread == 0) {
                //console.log("Clearing animations thread started");
                animationsClearThread = setInterval(() => {
                    if (!isValidScene()) {
                        clearInterval(animationsClearThread);
                        return;
                    }
                    //console.log("Clearing animations...");
                    clearAnimations();
                    if (mapAnimationOwnerSprites.length == 0) {
                        //console.log("Animations cleared");
                        clearInterval(animationsClearThread);
                        animationsClearThread = 0;
                    }
                }, 1000);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function clearAnimations() {
        let animationsToClear = [];
        if (!isValidScene())
            return;
        try {
            let spriteset = mapSpriteset();
            //@ts-ignore
            if (KDCore.isMV()) {
                mapAnimationOwnerSprites.forEach(sprite => {
                    if (sprite && !sprite.isAnimationPlaying()) {
                        animationsToClear.push(sprite);
                    }
                });
            }
            else {
                // @ts-ignore
                if (spriteset._animationSprites.length == 0) {
                    animationsToClear = mapAnimationOwnerSprites;
                }
            }
            animationsToClear.forEach(sprite => {
                mapAnimationOwnerSprites.splice(mapAnimationOwnerSprites.indexOf(sprite), 1);
                spriteset._characterSprites.splice(spriteset._characterSprites.indexOf(sprite), 1);
                //@ts-ignore
                sprite.removeFromParent();
                sprite.destroy();
            });
        }
        catch (error) {
            console.warn(error);
        }
    }
})(AABattleAnimationsManager || (AABattleAnimationsManager = {}));
window["AABattleAnimationsManager"] = AABattleAnimationsManager;


var AABattleMapManager;
(function (AABattleMapManager) {
    const _CACHE_TIMEOUT = 1000;
    let _eventsWithHitboxCache = [];
    let _eventsWithHitboxCacheTimeout = 0;
    function getAllHitboxOwners(insideScreen) {
        let hitboxOwners = [];
        try {
            let events = getEventsWithHitbox();
            if (insideScreen) {
                events = events.filter(event => {
                    return event.isNearTheScreen();
                });
            }
            events.forEach(event => {
                hitboxOwners.push(event);
            });
            let player = $gamePlayer;
            if (AAHitBox.isHaveHitBoxes(player)) {
                hitboxOwners.push(player);
            }
            let followers = $gamePlayer.followers().visibleFollowers();
            followers.forEach(follower => {
                if (follower && AAHitBox.isHaveHitBoxes(follower)) {
                    hitboxOwners.push(follower);
                }
            });
        }
        catch (error) {
            console.warn(error);
        }
        return hitboxOwners;
    }
    AABattleMapManager.getAllHitboxOwners = getAllHitboxOwners;
    function getEventsWithHitbox() {
        if (_eventsWithHitboxCache.length != 0) {
            //console.log("Returning events with hitbox cache");
            return _eventsWithHitboxCache;
        }
        let eventsWithhitbox = [];
        try {
            let events = $gameMap.events();
            events.forEach(event => {
                if (AAHitBox.isHaveHitBoxes(event)) {
                    eventsWithhitbox.push(event);
                }
            });
        }
        catch (error) {
            console.warn(error);
        }
        _eventsWithHitboxCache = eventsWithhitbox;
        if (_eventsWithHitboxCacheTimeout) {
            clearTimeout(_eventsWithHitboxCacheTimeout);
        }
        _eventsWithHitboxCacheTimeout = setTimeout(_clearEventsWithHitboxCache, _CACHE_TIMEOUT);
        return eventsWithhitbox;
    }
    function _clearEventsWithHitboxCache() {
        try {
            //console.log("Clearing events with hitbox cache");
            _eventsWithHitboxCacheTimeout = 0;
            _eventsWithHitboxCache = [];
        }
        catch (error) {
            console.warn(error);
        }
    }
})(AABattleMapManager || (AABattleMapManager = {}));
window["AABattleMapManager"] = AABattleMapManager;


var AABattleSkillsExecutionManager;
(function (AABattleSkillsExecutionManager) {
    function startSkill(skill, user, targetPosition) {
        if (!skill)
            return;
        try {
            AAScriptActions.execute(skill.onStart, user);
            if (skill.isRepeatableOnUse()) {
                let delay = skill.gRepeatDelay();
                let repeats = skill.gRepeatOnUse();
                for (let i = 0; i < repeats; i++) {
                    setTimeout(() => {
                        try {
                            let subject = AsAAChar(user);
                            if (!subject)
                                return;
                            if (!subject.isActive())
                                return;
                            if (!subject.AABattler().isAlive())
                                return;
                            startSkillInstance(skill, user, targetPosition);
                        }
                        catch (error) {
                            console.warn(error);
                        }
                    }, delay * i);
                }
            }
            else {
                startSkillInstance(skill, user, targetPosition);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AABattleSkillsExecutionManager.startSkill = startSkill;
    function applySkillAction(skill, user, skillPosition) {
        if (!skill)
            return;
        try {
            if (skill.isRepeatable()) {
                let delay = skill.gRepeatDelay();
                let repeats = skill.gRepeat();
                for (let i = 0; i < repeats; i++) {
                    setTimeout(() => {
                        try {
                            applySkillActionInstance(skill, user, skillPosition);
                        }
                        catch (error) {
                            console.warn(error);
                        }
                    }, delay * i);
                }
            }
            else {
                applySkillActionInstance(skill, user, skillPosition);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AABattleSkillsExecutionManager.applySkillAction = applySkillAction;
    function startSkillInstance(skill, user, targetPosition) {
        if (!skill)
            return;
        try {
            if (skill.isSelfAction()) {
                // We ignore the target position and use the user position
                applySkillAction(skill, user, user);
            }
            else if (skill.isInstant()) {
                if (skill.isInDirection()) {
                    let skillRange = Math.round(skill.gRange());
                    if (skillRange <= 0)
                        skillRange = 1;
                    let distance = skill.gRadius();
                    let directionVector = AAMath.getDirectionVector(user.direction());
                    let nextPoint = user;
                    for (let i = 1; i <= skillRange; i++) {
                        nextPoint = AAMath.getNextPoint(nextPoint, directionVector, distance);
                        applySkillAction(skill, user, nextPoint);
                    }
                }
                else {
                    applySkillAction(skill, user, targetPosition);
                }
            }
            else if (skill.isProjectile()) {
                if (skill.isMultiProjectile()) {
                    AAMultiProjectilesHelper.startMultiProjectile(skill, user);
                }
                else {
                    AAProjectile.Create(user, skill, targetPosition);
                }
            }
            else {
                AALog.warn("Can't start skill: " + skill.name());
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function applySkillActionInstance(skill, user, skillPosition) {
        if (!skill)
            return;
        try {
            AABattleAnimationsManager.playSkillStartAnimation(skill, skillPosition);
            if (skill.isTeleport()) {
                try {
                    //@ts-ignore
                    user.aaTeleport(skillPosition, skill.teleportInAnim, skill.teleportOutAnim);
                }
                catch (error) {
                    console.warn(error);
                }
            }
            let targets = AATargetsManager2.getTargetsForSkill(user, skill, skillPosition);
            AABattleAnimationsManager.playSkillHitAnimation(skill, AsAAChar(user), skillPosition, targets);
            AABattleActionsManager2.performBattleAction(skill, user, targets);
        }
        catch (error) {
            console.warn(error);
        }
    }
})(AABattleSkillsExecutionManager || (AABattleSkillsExecutionManager = {}));
window["AABattleSkillsExecutionManager"] = AABattleSkillsExecutionManager;


var AACharCollider;
(function (AACharCollider) {
    function setupForEventFromCurrentPage(event) {
        try {
            _clearCharacterCollider(event);
            if (_isNotHaveCollider(event)) {
                return;
            }
            let colliderConfig = _getUserDefinedColliderForEvent(event);
            if (colliderConfig) {
                _registerCollider(event, colliderConfig);
            }
            else {
                if (_isEventSupportAutoCollider(event)) {
                    let autoConfig = AAPluginParams.getEventDefaultColliderConfig();
                    autoConfig.flag = 'event';
                    _registerCollider(event, autoConfig);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharCollider.setupForEventFromCurrentPage = setupForEventFromCurrentPage;
    function setupForCharacter(character) {
        if (character instanceof Game_Event) {
            setupForEventFromCurrentPage(character);
        }
        else {
            try {
                _clearCharacterCollider(character);
                //@ts-ignore
                let actor = character.AABattler();
                if (actor) {
                    let configString = actor.actor()['meta'].aCollider;
                    if (configString) {
                        if (configString === "none") {
                            return;
                        }
                        let collider = AACollider.ParseConfigString(configString, 'char');
                        if (collider) {
                            _registerCollider(character, collider);
                        }
                    }
                    else {
                        let autoConfig = AAPluginParams.getActorDefaultColliderConfig();
                        autoConfig.flag = 'char';
                        _registerCollider(character, autoConfig);
                    }
                }
            }
            catch (error) {
                console.warn(error);
            }
        }
    }
    AACharCollider.setupForCharacter = setupForCharacter;
    function clearFor(character) {
        try {
            _clearCharacterCollider(character);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharCollider.clearFor = clearFor;
    function getFor(character) {
        try {
            let collider = _getCharacterCollider(character);
            if (collider) {
                collider.refreshPositionForChar(character);
            }
            return collider;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    AACharCollider.getFor = getFor;
    function checkCollision(character, collider) {
        try {
            let charCollider = getFor(character);
            if (charCollider.isCollideWith(collider)) {
                return true;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AACharCollider.checkCollision = checkCollision;
    function isHaveCollider(character) {
        try {
            return _getCharacterCollider(character) != null;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AACharCollider.isHaveCollider = isHaveCollider;
    function _getCharacterCollider(character) {
        if (!character['_aaCollider']) {
            _clearCharacterCollider(character);
        }
        return character['_aaCollider'];
    }
    function _clearCharacterCollider(character) {
        character['_aaCollider'] = null;
    }
    // Player can force disable collider on event page
    // aCollider:none
    function _isNotHaveCollider(event) {
        try {
            let value = KGameEvents.GetCommentCodeValue("aCollider", event);
            if (value) {
                return value === "none";
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function _getUserDefinedColliderForEvent(event) {
        let collider = null;
        try {
            let value = KGameEvents.GetCommentCodeValue("aCollider", event);
            if (value) {
                collider = AACollider.ParseConfigString(value, 'event');
            }
        }
        catch (error) {
            console.warn(error);
        }
        return collider;
    }
    function _isEventSupportAutoCollider(event) {
        try {
            if (AsAAChar(event).isABS()) {
                return AAPluginParams.isEnemiesShouldHaveDefaultCollider();
            }
            else
                return event.isNormalPriority();
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function _registerCollider(character, collider) {
        if (collider instanceof AACollider) {
            character['_aaCollider'] = collider;
        }
        else {
            let colliderObj = new AACollider(collider);
            character['_aaCollider'] = colliderObj;
        }
    }
})(AACharCollider || (AACharCollider = {}));
window['AACharCollider'] = AACharCollider;


var AACharHighlightEffect;
(function (AACharHighlightEffect) {
    //TODO: Специальный комментарий на страницу события, чтобы он не поддерживал выделение (т.е. отключить выделение для события)
    function highlight(char) {
        try {
            if (!AAPluginParams.isHighlightInteractableEvents())
                return;
            let sprite = AAUtils.getCharacterSprite(char);
            if (!sprite) {
                console.warn("AACharHighlightEffect: Sprite not found for character");
                return;
            }
            addEffect(sprite);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharHighlightEffect.highlight = highlight;
    function unhighlight(char) {
        let sprite = AAUtils.getCharacterSprite(char);
        if (!sprite)
            return;
        removeEffect(sprite);
    }
    AACharHighlightEffect.unhighlight = unhighlight;
    function highlightForSkillImpact(char) {
        try {
            let sprite = AAUtils.getCharacterSprite(char);
            if (!sprite) {
                console.warn("AACharHighlightEffect: Sprite not found for character");
                return;
            }
            addEffect(sprite, { color: 0xFF0000, innerStrength: 0.5, outerStrength: 1, quality: 0.5 });
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharHighlightEffect.highlightForSkillImpact = highlightForSkillImpact;
    function addEffect(sprite, settings = {}) {
        if (sprite['_aaAddedFilter'])
            return;
        if (!sprite.filters) {
            sprite.filters = [];
        }
        let color = settings.color || 0xffffff;
        let distance = settings.distance || 10;
        let outerStrength = settings.outerStrength || 4;
        let innerStrength = settings.innerStrength || 0;
        let quality = settings.quality || 0.1;
        let knockout = settings.knockout || false;
        /*@ts-ignore*/
        let filterObject = new PIXI.filters.GlowFilter({ distance, outerStrength, innerStrength, color, quality, knockout });
        sprite.filters.push(filterObject);
        sprite['_aaAddedFilter'] = filterObject;
    }
    function removeEffect(sprite) {
        if (sprite['_aaAddedFilter']) {
            sprite.filters = sprite.filters.filter(f => f !== sprite['_aaAddedFilter']);
            sprite['_aaAddedFilter'] = null;
        }
    }
})(AACharHighlightEffect || (AACharHighlightEffect = {}));
window['AACharHighlightEffect'] = AACharHighlightEffect;


var AACharInteractionArea;
(function (AACharInteractionArea) {
    function setupForEventFromCurrentPage(event) {
        try {
            _clearCharacterInteractionCollider(event);
            if (_isNotHaveInteractionCollider(event)) {
                return;
            }
            let colliderConfig = _getUserDefinedInteractionColliderForEvent(event);
            if (colliderConfig) {
                _registerInteractionCollider(event, colliderConfig);
            }
            else {
                if (_isEventSupportAutoInteractionCollider(event)) {
                    let autoConfig = AAPluginParams.getEventDefaultInteractionColliderConfig();
                    autoConfig.flag = 'interaction';
                    _registerInteractionCollider(event, autoConfig);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharInteractionArea.setupForEventFromCurrentPage = setupForEventFromCurrentPage;
    function clearFor(character) {
        try {
            _clearCharacterInteractionCollider(character);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharInteractionArea.clearFor = clearFor;
    function getFor(character) {
        try {
            let collider = _getCharacterCollider(character);
            if (collider) {
                collider.refreshPositionForChar(character);
            }
            return collider;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    AACharInteractionArea.getFor = getFor;
    function checkCollision(character, collider) {
        try {
            let charCollider = getFor(character);
            if (charCollider.isCollideWith(collider)) {
                return true;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AACharInteractionArea.checkCollision = checkCollision;
    function isHaveInteractionCollider(character) {
        try {
            return _getCharacterCollider(character) != null;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AACharInteractionArea.isHaveInteractionCollider = isHaveInteractionCollider;
    function _getCharacterCollider(character) {
        if (!character['_aaInteractionCollider']) {
            _clearCharacterInteractionCollider(character);
        }
        return character['_aaInteractionCollider'];
    }
    function _clearCharacterInteractionCollider(character) {
        character['_aaInteractionCollider'] = null;
    }
    // Player can force disable collider on event page
    // aInteractionArea:none
    function _isNotHaveInteractionCollider(event) {
        try {
            let value = KGameEvents.GetCommentCodeValue("aInteractionArea", event);
            if (value) {
                return value === "none";
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function _getUserDefinedInteractionColliderForEvent(event) {
        let collider = null;
        try {
            let value = KGameEvents.GetCommentCodeValue("aInteractionArea", event);
            if (value) {
                collider = AACollider.ParseConfigString(value, 'interaction');
            }
        }
        catch (error) {
            console.warn(error);
        }
        return collider;
    }
    function _isEventSupportAutoInteractionCollider(event) {
        try {
            if (AsAAChar(event).isABS()) {
                return false;
            }
            else {
                if (event._trigger >= 3)
                    return false;
                let page = event.page();
                if (page) {
                    let list = page.list;
                    let listWithoutComments = list.filter(command => command.code !== 108 && command.code !== 408);
                    return (listWithoutComments.length > 1);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function _registerInteractionCollider(character, collider) {
        if (collider instanceof AACollider) {
            character['_aaInteractionCollider'] = collider;
        }
        else {
            let colliderObj = new AACollider(collider);
            character['_aaInteractionCollider'] = colliderObj;
        }
    }
})(AACharInteractionArea || (AACharInteractionArea = {}));
window['AACharInteractionArea'] = AACharInteractionArea;


var AACharMovementController;
(function (AACharMovementController) {
    const maxDistanceForPath = 6; //TODO: Parameterize this value
    const minDistanceForPath = 2;
    const goalDistance = 0.5;
    function makeImpulseMovementInDirection(char, directionVector, distance, withJump) {
        try {
            let config = {
                directionVector: directionVector,
                speedModifier: 1.5,
                distance: distance
            };
            AAPathMover.stopMoveByPath(char);
            AAVectorMover.clearMovementVector(char);
            if (char instanceof Game_Player && AAMainSystem.isExtendedPlayerMovementSystemActive()) {
                AATranslationMover.startTranslationMovement(char, config);
                if (withJump) {
                    char.jump(0, 0);
                }
            }
            else {
                let direction = AAMath.convertDirectionVectorToNumberDirection(directionVector);
                char['aaApplyImpulse'](distance, direction, withJump);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharMovementController.makeImpulseMovementInDirection = makeImpulseMovementInDirection;
    function moveTo(char, targetPosition, callback, limitByMaxDistance = true) {
        try {
            if (!char)
                return;
            if (!targetPosition)
                return;
            let distance = AAMath.distance(char, targetPosition);
            if (distance <= goalDistance) {
                if (callback)
                    callback();
                return;
            }
            let initialTargetPosition = targetPosition;
            if (distance < minDistanceForPath) {
                //TODO: Disable this if used for event and isExtendedPlayerMovementSystemActive is false
                let vector = AAMath.getDirectionVetorToPoint(char, targetPosition, false);
                AAVectorMover.setMovementVector(char, vector, true);
                if (AAVectorMover.isShouldMoveByVector(char)) {
                    AAPathMover.stopMoveByPath(char);
                }
                else {
                    if (callback)
                        callback();
                }
                return;
            }
            else if (distance > maxDistanceForPath && limitByMaxDistance) {
                let direction = AAMath.getDirectionVetorToPoint(char, targetPosition, true);
                // * new target position
                targetPosition = AAMath.getNextPoint(char, direction, maxDistanceForPath);
            }
            // * Move by path
            let path = AAGridMapManager.findPath(char, targetPosition);
            if (path.length == 0) {
                let points = AAMath.getAdjacentPointsInSquare(targetPosition.x, targetPosition.y, 1);
                for (let point of points) {
                    let newPath = AAGridMapManager.findPath(char, point);
                    if (newPath.length != 0) {
                        path = newPath;
                        break;
                    }
                }
                if (path.length != 0 && limitByMaxDistance) {
                    moveTo(char, initialTargetPosition, callback, false);
                    return;
                }
            }
            if (path.length != 0) {
                let aligned = path.map(p => AAGridMapManager.alignGridPointWithMap(p));
                AAPathMover.startMoveByPath(char, aligned);
            }
            else {
                if (callback)
                    callback();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharMovementController.moveTo = moveTo;
    function processMovementFor(char) {
        if (AATranslationMover.isShouldTranslate(char)) {
            console.log('Update move by translation');
            AATranslationMover.updateTranslationMoveFor(char);
            return true;
        }
        if (AAVectorMover.isShouldMoveByVector(char)) {
            //console.log('Update move by vector');
            AAVectorMover.updateMoveByVectorFor(char);
            return true;
        }
        else if (AAPathMover.isHavePathFor(char)) {
            //console.log('Update move by path');
            AAPathMover.updateMoveByPathFor(char);
            return true;
        }
        return false;
    }
    AACharMovementController.processMovementFor = processMovementFor;
    function chaseCharacter(char, target) {
        try {
            //TODO: Temporary solution for followers
            // Нужно сперва проверять дистанцию наверное, а затем уже проверять путь
            if (!char || !target)
                return;
            var targetMovePath = AAPathMover.getMovePathFor(target);
            if (targetMovePath && targetMovePath.isValidPath()) {
                var targetPosition = targetMovePath.getPreivousPoint();
                if (targetPosition) {
                    AAPathMover.startMoveByPath(char, [targetPosition]);
                }
                else {
                    AAPathMover.stopMoveByPath(char);
                }
            }
            else {
                var distance = AAMath.distance(char, target);
                if (distance > 1) {
                    let testPath = AAGridMapManager.findPath(char, target);
                    if (testPath.length != 0) {
                        let copyPath = testPath.map(p => AAGridMapManager.alignGridPointWithMap(p));
                        AAPathMover.startMoveByPath(char, copyPath);
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharMovementController.chaseCharacter = chaseCharacter;
})(AACharMovementController || (AACharMovementController = {}));


var AACharMovementUtils;
(function (AACharMovementUtils) {
    function isCharCanMoveTo(char, point) {
        try {
            let collider = AACharCollider.getFor(char);
            if (!collider)
                return true;
            collider.setPositionXY(point.x, point.y, false);
            return !AAMapCollisionsManager.isCollideWithMovementObstacles(collider);
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AACharMovementUtils.isCharCanMoveTo = isCharCanMoveTo;
    function isCharCanMoveInDirection(char, direction) {
        try {
            let movementVector = AAMath.getDirectionVector(direction);
            return isCharCanMoveByVector(char, movementVector);
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AACharMovementUtils.isCharCanMoveInDirection = isCharCanMoveInDirection;
    function isCharCanMoveByVector(char, movementVector) {
        try {
            let currentPosition = {
                x: char._realX,
                y: char._realY
            };
            let position = AAMath.getNextPoint(currentPosition, movementVector, char.moveSpeed());
            return isCharCanMoveTo(char, position);
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AACharMovementUtils.isCharCanMoveByVector = isCharCanMoveByVector;
    function charSingleStepDistance(char) {
        return Math.pow(2, char.moveSpeed()) / 256;
    }
    AACharMovementUtils.charSingleStepDistance = charSingleStepDistance;
    function translateCharacterToPoint(char, point, keepDirection = false, speedMultiplier = 1, pointReachCallback, isCheckCollisions = false, collideCallback = null) {
        let current_position = {
            x: char._realX,
            y: char._realY
        };
        if (AAMath.distance(current_position, point) <= 0) {
            //console.log('Translate point reached');
            AACharMovementUtils.applyLocation(char);
            if (pointReachCallback) {
                pointReachCallback();
            }
            return;
        }
        let distance = AACharMovementUtils.charSingleStepDistance(char) * speedMultiplier;
        let directionVector = AAMath.getDirectionVetorToPoint(current_position, point, true);
        let nextPosition = AAMath.getNextPoint(current_position, directionVector, distance);
        let distanceToNext = AAMath.distance(current_position, nextPosition);
        let distanceToTarget = AAMath.distance(current_position, point);
        if (distanceToNext >= distanceToTarget) {
            nextPosition = point;
        }
        if (!keepDirection) {
            let direction = AAMath.convertDirectionVectorToNumberDirection(directionVector);
            if (!AACharMovementUtils.isCharSupportDiagonalDirection(char)) {
                direction = AAMath.convert8DirectionTo4Direction(direction);
            }
            char.setDirection(direction);
        }
        if (isCheckCollisions) {
            if (!AACharMovementUtils.isCharCanMoveTo(char, nextPosition)) {
                if (collideCallback) {
                    collideCallback();
                }
                else {
                    if (pointReachCallback) {
                        pointReachCallback();
                    }
                    else {
                        console.warn('Translate point collide! But no callback!');
                    }
                }
                //console.log('Translate point collide!');
                AACharMovementUtils.applyLocation(char);
                return;
            }
        }
        char._realX = nextPosition.x;
        char._realY = nextPosition.y;
        AACharMovementUtils.applyLocation(char);
        if (char.isJumping()) {
            char.updateJump();
        }
        if (current_position.x != nextPosition.x || current_position.y != nextPosition.y) {
            char.increaseSteps();
        }
    }
    AACharMovementUtils.translateCharacterToPoint = translateCharacterToPoint;
    function translateCharacterInDirection(char, directionVector, keepDirection = false, speedMultiplier = 1, isCheckCollisions = false, collideCallback = null) {
        let currentPosition = {
            x: char._realX,
            y: char._realY
        };
        let nextPosition = AAMath.getNextPoint(currentPosition, directionVector, char.moveSpeed() * speedMultiplier);
        AACharMovementUtils.translateCharacterToPoint(char, nextPosition, keepDirection, speedMultiplier, collideCallback, isCheckCollisions, collideCallback);
    }
    AACharMovementUtils.translateCharacterInDirection = translateCharacterInDirection;
    function alignCharToGrid(char, isInstant = false) {
        try {
            // We change float position to grid position
            char._x = Math.round(char.x);
            char._y = Math.round(char.y);
            if (isInstant) {
                char._realX = char._x;
                char._realY = char._y;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharMovementUtils.alignCharToGrid = alignCharToGrid;
    function applyLocation(char) {
        try {
            char._x = char._realX;
            char._y = char._realY;
        }
        catch (error) {
            console.warn(error);
        }
    }
    AACharMovementUtils.applyLocation = applyLocation;
    //TODO: Check AnimaX as well
    function isCharSupportDiagonalDirection(char) {
        return char instanceof Game_Player;
    }
    AACharMovementUtils.isCharSupportDiagonalDirection = isCharSupportDiagonalDirection;
})(AACharMovementUtils || (AACharMovementUtils = {}));
window['AACharMovementUtils'] = AACharMovementUtils;


function AsAAChar(char) {
    //TODO: Temp solution while we don't have a proper TS classes
    //@ts-ignore
    return char;
}


class AACollider {
    /**
     * Creates an instance of Collider.
     * @param config - Configuration object for the collider.
     */
    constructor(config) {
        this._lastResponse = null;
        this.config = Object.assign(AACollider.DefaultConfig(), config);
        this.type = this.config.type;
        this.dx = this.config.dx || 0;
        this.dy = this.config.dy || 0;
        this.flag = this.config.flag;
        // Convert from old format (for compatibility)
        this.dx /= $gameMap.tileWidth();
        this.dy /= $gameMap.tileHeight();
        this.config.width /= $gameMap.tileWidth();
        this.config.height /= $gameMap.tileHeight();
        this.config.radius /= $gameMap.tileWidth();
        this._halfWidth = this.config.width / 2;
        this.mapCellIndex = 0;
        this._create();
    }
    /**
    * Returns the default configuration for the collider.
    */
    static DefaultConfig(flag = 'other') {
        return {
            flag,
            type: "b",
            width: $gameMap.tileWidth(),
            height: $gameMap.tileHeight(),
            radius: 12,
            dx: 0,
            dy: 0
        };
    }
    //any:c,0,0,30
    //c,0,0,30
    //b,0,0,42,42
    static ParseConfigString(configString, flag = 'other') {
        try {
            if (configString.includes(':')) {
                configString = configString.split(":")[1];
            }
            let parameters = configString.split(',');
            let type = parameters[0];
            if (['c', 'circle', 'b', 'box'].indexOf(type) < 0) {
                console.warn('Invalid collider type: ' + type);
                return null;
            }
            let config = {
                flag,
                type: type,
                dx: Number(parameters[1] || 0),
                dy: Number(parameters[2] || 0)
            };
            if (type == 'c' || type == 'circle') {
                config.radius = Number(parameters[3] || $gameMap.width() / 2);
            }
            else {
                config.width = Number(parameters[3] || $gameMap.tileWidth());
                config.height = Number(parameters[4] || $gameMap.tileHeight());
            }
            return config;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    /**
     * Checks if the collider is a circle.
     */
    isCircle() {
        return this.type === 'c' || this.type === 'circle';
    }
    /**
     * Checks if the collider is a box.
     */
    isBox() {
        return !this.isCircle();
    }
    /**
     * Checks if the collider is valid.
     */
    isValid() {
        return !!this.colliderObj;
    }
    /**
     * Clones the collider.
     */
    clone() {
        const _clone = new AACollider(this.config);
        _clone.setPositionXY(this.colliderObj.pos.x, this.colliderObj.pos.y, true);
        return _clone;
    }
    mapCellPoint() {
        return AAUtils.indexToMapPoint(this.mapCellIndex);
    }
    neighborIndexes(range = 1) {
        let myPoint = this.mapCellPoint();
        let points = AAMath.getAdjacentPointsInSquareIncludeCenter(myPoint.x, myPoint.y, range);
        return points.map(p => AAUtils.mapPointToIndex(p));
    }
    /**
     * Checks if the collider is inside another collider.
     * @param collider - The other collider to check against.
     */
    isInCollider(collider) {
        try {
            this._lastResponse = null;
            if (this.isCollideWith(collider)) {
                if (this._lastResponse && (this._lastResponse.aInB === true || this._lastResponse.bInA === true)) {
                    return true;
                }
            }
        }
        catch (e) {
            console.warn(e);
        }
        return false;
    }
    isPointInsideCollider(point) {
        try {
            if (!this.isValid())
                return false;
            if (this.isCircle()) {
                /*@ts-ignore*/
                return SAT.pointInCircle(point, this.colliderObj);
            }
            else {
                /*@ts-ignore*/
                return SAT.pointInPolygon(point, this.colliderObj);
            }
        }
        catch (e) {
            console.warn(e);
        }
        return false;
    }
    /**
     * Checks if the collider collides with another collider.
     * @param collider - The other collider to check against.
     */
    isCollideWith(collider) {
        try {
            if (!collider || !this.isValid() || !collider.isValid())
                return false;
            if (this.isCircle() && collider.isCircle()) {
                /*@ts-ignore*/
                return SAT.testCircleCircle(this.colliderObj, collider.colliderObj, this._lastResponse);
            }
            if (this.isCircle() && collider.isBox()) {
                /*@ts-ignore*/
                return SAT.testCirclePolygon(this.colliderObj, collider.colliderObj, this._lastResponse);
            }
            if (this.isBox() && collider.isBox()) {
                /*@ts-ignore*/
                return SAT.testPolygonPolygon(this.colliderObj, collider.colliderObj, this._lastResponse);
            }
            if (this.isBox() && collider.isCircle()) {
                /*@ts-ignore*/
                return SAT.testPolygonCircle(this.colliderObj, collider.colliderObj, this._lastResponse);
            }
        }
        catch (e) {
            console.warn(e);
        }
        return false;
    }
    distanceToCollider(collider) {
        try {
            if (!collider || !this.isValid() || !collider.isValid())
                return -1;
            let pointA = { x: this.x(), y: this.y() };
            let pointB = { x: collider.x(), y: collider.y() };
            return AAMath.distanceQuick(pointA, pointB);
        }
        catch (e) {
            console.warn(e);
        }
        return -1;
    }
    /**
     * Refreshes the position of the collider for a character.
     * @param char - The character to refresh the position for.
     */
    refreshPositionForChar(char) {
        try {
            if (!this.isValid() || !char)
                return;
            this.setPositionXY(char._realX, char._realY, false);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the position of the collider.
     * @param x - The x-coordinate.
     * @param y - The y-coordinate.
     * @param isStrict - Whether to set the position strictly.
     */
    setPositionXY(x, y, isStrict = false) {
        try {
            if (!this.isValid())
                return;
            let exWidth = this._halfWidth;
            let exHeight = this.config.height;
            let exHeightCircle = 0.5;
            if (isStrict) {
                exWidth = 0;
                exHeight = 0;
                exHeightCircle = 0;
            }
            if (this.isBox()) {
                this.colliderObj.pos.x = x - exWidth + this.dx;
                this.colliderObj.pos.y = y - exHeight + this.dy;
            }
            else {
                this.colliderObj.pos.x = x + this.dx;
                this.colliderObj.pos.y = y + this.dy - exHeightCircle;
            }
            this._recalculateMapCellIndex();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Modifies the position of the collider.
     * @param x - The x-coordinate to modify by.
     * @param y - The y-coordinate to modify by.
     */
    modPositionXY(x, y) {
        try {
            if (!this.isValid())
                return;
            this.colliderObj.pos.x += x;
            this.colliderObj.pos.y += y;
            this._recalculateMapCellIndex();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Gets the x-coordinate of the collider.
     */
    x() {
        return this.colliderObj.pos.x;
    }
    /**
     * Gets the y-coordinate of the collider.
     */
    y() {
        return this.colliderObj.pos.y;
    }
    /**
     * Gets the screen x-coordinate of the collider.
     */
    px() {
        try {
            if (!this.isValid())
                return 0;
            let x = this.colliderObj.pos.x;
            if (this.isCircle()) {
                x -= this.config.radius;
            }
            return AAUtils.screenXOfMapX(x);
        }
        catch (e) {
            console.warn(e);
            return 0;
        }
    }
    /**
     * Gets the screen y-coordinate of the collider.
     */
    py() {
        try {
            if (!this.isValid())
                return 0;
            let y = this.colliderObj.pos.y;
            if (this.isCircle()) {
                y -= this.config.radius;
            }
            return AAUtils.screenYOfMapY(y);
        }
        catch (e) {
            console.warn(e);
            return 0;
        }
    }
    /**
     * Creates the collider object based on its type.
     */
    _create() {
        try {
            if (this.isCircle()) {
                const { radius } = this.config;
                /*@ts-ignore*/
                this.colliderObj = new SAT.Circle(new SAT.Vector(0, 0), radius);
            }
            else {
                const { width, height } = this.config;
                /*@ts-ignore*/
                this.colliderObj = new SAT.Box(
                /*@ts-ignore*/
                new SAT.Vector(0, 0), width, height).toPolygon();
            }
        }
        catch (e) {
            console.warn(e);
            this.colliderObj = null; // Not valid
        }
    }
    _recalculateMapCellIndex() {
        try {
            if (!this.isValid())
                return;
            let x = this.x();
            let y = this.y();
            if (y < 0)
                y = 0;
            if (x < 0)
                x = 0;
            let cellX = Math.floor(x);
            let cellY = Math.floor(y);
            this.mapCellIndex = AAUtils.mapPointToIndex({ x: cellX, y: cellY });
        }
        catch (e) {
            console.warn(e);
        }
    }
}
window['AACollider'] = AACollider;


var AACollisionsUtils;
(function (AACollisionsUtils) {
    function filterCollidersInPoint(colliders, point, distance) {
        let points = AAMath.getAdjacentPointsInSquareIncludeCenter(point.x, point.y, distance);
        let indexes = points.map(p => AAUtils.mapPointToIndex(p));
        let _colliders = colliders.filter(c => c && indexes.indexOf(c.mapCellIndex) >= 0);
        return _colliders;
    }
    AACollisionsUtils.filterCollidersInPoint = filterCollidersInPoint;
})(AACollisionsUtils || (AACollisionsUtils = {}));
window['AACollisionsUtils'] = AACollisionsUtils;


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ COMMON.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Utils;
  (function() {    // * Общее
    // -----------------------------------------------------------------------
    // * Является ли символ кнопкой панели навыков
    _.isSkillPanelSymbol = function(symbol) {
      var symbols;
      if (!String.any(symbol)) {
        return false;
      }
      symbols = AA.Input.skillPanelSymbols;
      return symbols.contains(symbol);
    };
    // * Получить значение опыта с врага (с учётом специальной переменной для опыта)
    _.getExpFromAAEnemy = function(enemyDbData) {
      var e, expVarId, param;
      try {
        if (enemyDbData == null) {
          return 0;
        }
        if (enemyDbData.AAEnemy != null) {
          param = enemyDbData.AAEnemy.find(function(p) {
            return p[0] === 'expVar';
          });
          if (param != null) {
            expVarId = parseInt(param[1]);
            if ((expVarId != null) && expVarId > 0) {
              return $gameVariables.value(expVarId);
            }
          }
        }
        return enemyDbData.exp;
      } catch (error) {
        e = error;
        AA.w(e);
        return 0;
      }
    };
    _.isValidGlobalSkillForExecute = function(skillId, type) {
      var aaSkill, e;
      try {
        if (!AA.isABSActive()) {
          return false;
        }
        skillId = AAExtendedValues.getEValue(skillId);
        if ($dataSkills[skillId] == null) {
          AA.w("Global Skill execution: Skill with ID " + skillId + " not found");
          return false;
        }
        aaSkill = $dataSkills[skillId].AASkill;
        if (aaSkill == null) {
          AA.w("Global Skill execution: Skill with ID " + skillId + " is not ABS skill");
          return false;
        }
        switch (type) {
          case "OnMap":
            if (aaSkill.isInstant()) {
              return true;
            } else {
              AA.w("uAPI.executeAASkillOnMap: for projectile ABS skills use uAPI.executeAASkillOnMapProjFromPoint");
              return false;
            }
            break;
          case "ByDirection":
            if (!aaSkill.isInstant()) {
              return true;
            } else {
              AA.w("uAPI.executeAASkillOnMapProjFromPoint: for instant ABS skills use uAPI.executeAASkillOnMap");
              return false;
            }
            break;
          default:
            return false;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
    return _.createDummyCharacterByParameters = function(ownerId, teamId, x, y, d) {
      var e, subject;
      try {
        ownerId = AAExtendedValues.getEValue(ownerId);
        x = AAExtendedValues.getEValue(x);
        y = AAExtendedValues.getEValue(y);
        if (ownerId > 0) { // * Game Event ID, but we need battler
          try {
            ownerId = $gameMap.event(ownerId).AABattler().enemyId();
          } catch (error) {
            e = error;
            KDCore.warning(e);
            ownerId = 1;
          }
        }
        subject = new AADummyCharacter(ownerId, teamId);
        try {
          if ((x != null) && (y != null)) {
            x = AAExtendedValues.getEValue(x);
            y = AAExtendedValues.getEValue(y);
            subject.setPosition(x, y);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        try {
          if (d != null) {
            d = AAExtendedValues.getEValue(d);
            subject.setDirection(d);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return subject;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
  })();
  (function() {    // * Навыки и предметы
    // -----------------------------------------------------------------------
    // * Навык (или предмет) имеют AASkill данные в себе
    _.isAAObject = function(skillIdOrObject) {
      return AASkill2.IsAAObject(skillIdOrObject);
    };
    _.isAASkill = function(skillId) {
      return AASkill2.IsAASkill(skillId);
    };
    _.isAAItem = function(skillId) {
      return AASkill2.IsAAItem(skillId);
    };
    _.getAASkillObject = function(skillId) {
      return AASkill2.GetAASkillObject(skillId);
    };
    _.isAAState = function(stateIdOrObject) {
      var obj;
      if (stateIdOrObject == null) {
        return false;
      }
      if (isFinite(stateIdOrObject)) {
        obj = this.getAAStateObject(stateIdOrObject);
      } else {
        obj = stateIdOrObject;
      }
      if (obj != null) {
        return obj.AAState != null;
      } else {
        return false;
      }
    };
    _.getAAStateObject = function(stateId) {
      if (stateId <= 0) {
        return null;
      }
      return $dataStates[stateId];
    };
    // * Получить иконку оружия навыка атаки (или иконку навыка атаки, если нет оружия)
    _.getAttackSkillWeaponIconIndex = function(skill, battler) {
      var e, weapon;
      try {
        weapon = battler.weapons()[0];
        if ((weapon != null) && weapon.iconIndex > 0) {
          return this.getSkillSlotImgOrIcon(weapon); //.iconIndex
        } else {
          return this.getSkillSlotImgOrIcon(skill); //.iconIndex
        }
      } catch (error) {
        e = error;
        AA.w(e);
        return 0;
      }
    };
    // * Получить иконку или картинку для слота навыка
    // * Возвращает либо имя картинки, либо номер иконки
    _.getSkillSlotImgOrIcon = function(dataItem) {
      var e;
      try {
        if (dataItem == null) {
          return 0;
        }
        if (this.isAAObject(dataItem) && String.any(dataItem.AASkill.ssImg)) {
          return dataItem.AASkill.ssImg;
        } else if ((dataItem.meta != null) && String.any(dataItem.meta.ssImg)) {
          return dataItem.meta.ssImg;
        }
        return dataItem.iconIndex;
      } catch (error) {
        e = error;
        AA.w(e);
        return 0;
      }
    };
    return _.isAnyItemHaveNotetag = function(items, notetag) {
      var e, i, item, len;
      try {
        if (items == null) {
          return false;
        }
        if (items.length === 0) {
          return false;
        }
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          if (item == null) {
            continue;
          }
          if (item.meta == null) {
            continue;
          }
          if (item.meta[notetag] != null) {
            return true;
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
  })();
  (function() {    // * Методы распаковки и запаковки данных для хранения и сохранения игры
    // -----------------------------------------------------------------------
    _.unpackAASkill = function(idA) {
      return AASkill2.UnpackAASkill(idA);
    };
    _.packAAPoint = function(point) {
      var x, y;
      if (point instanceof Game_Character) {
        return this.packAAEntity(point);
      } else {
        x = point.x;
        y = point.y;
        return {x, y};
      }
    };
    _.unpackAAPoint = function(data) {
      if (data.x != null) {
        return new KDCore.Point(data.x, data.y);
      } else {
        return this.unpackAAEntity(data);
      }
    };
    _.packAAEntity = function(entity) {
      return AAEntity.Pack(entity);
    };
    return _.unpackAAEntity = function(data) {
      return AAEntity.Unpack(data);
    };
  })();
  (function() {    // * Конвертирование направлений
    // -----------------------------------------------------------------------
    _.get8Dir = function(d) {
      switch (d) {
        case 1:
          return [4, 2];
        case 3:
          return [6, 2];
        case 7:
          return [4, 8];
        case 9:
          return [6, 8];
        default:
          return [0, 0];
      }
    };
    return _.get4Dir = function(horz, vert) {
      if (horz === 4 && vert === 2) {
        return 1;
      }
      if (horz === 6 && vert === 2) {
        return 3;
      }
      if (horz === 4 && vert === 8) {
        return 7;
      }
      if (horz === 6 && vert === 8) {
        return 9;
      }
      return 0;
    };
  })();
})();

// ■ END COMMON.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
var AACustomGauge;

AACustomGauge = class AACustomGauge {
  constructor(varId, gaugeParams) {
    this.varId = varId;
    this.gaugeParams = gaugeParams;
    this.id = "gauge_" + this.varId + "_" + KDCore.makeid(6);
    this.bindedTo = -1;
    this.x = 0;
    this.y = 0;
    this.mapId = $gameMap.mapId();
    this._isDisposed = false;
    return;
  }

  setGlobal() {
    return this.mapId = 0;
  }

  setEnemyEventId(enemyEvId) {
    this.enemyEvId = enemyEvId;
  }

  isEnemyHpGauge() {
    return this.enemyEvId > 0;
  }

  isDisposed() {
    return this._isDisposed === true;
  }

  disposeGauge() {
    return this._isDisposed = true;
  }

  isEnemyValid() {
    var e, event;
    try {
      if (!this.isEnemyHpGauge()) {
        return false;
      }
      event = $gameMap.event(this.enemyEvId);
      if (event == null) {
        return false;
      }
      if (!event.isABS()) {
        return false;
      }
      if (event.AABattler() == null) {
        return false;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
    return true;
  }

  getCurrentRate() {
    var e, event;
    try {
      if (this.isEnemyHpGauge()) {
        event = $gameMap.event(this.enemyEvId);
        if (event == null) {
          return 0;
        }
        if (!event.isABS()) {
          return 0;
        }
        if (event.AABattler() == null) {
          return 0;
        }
        return event.AABattler().hpRate();
      } else {
        return $gameVariables.value(this.varId) / 100.0;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  }

  getCurrentValue() {
    var e;
    try {
      if (this.isEnemyHpGauge()) {
        if (this.isEnemyValid()) {
          return $gameMap.event(this.enemyEvId).AABattler().hp;
        } else {
          return 0;
        }
      } else {
        return $gameVariables.value(this.varId);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  }

  getMaxValue() {
    var e;
    try {
      if (this.isEnemyHpGauge()) {
        if (this.isEnemyValid()) {
          return $gameMap.event(this.enemyEvId).AABattler().mhp;
        } else {
          return 0;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 100; // * If variable, always 100 is max
  }

  bindedEvent() {
    if (this.bindedTo > 0) {
      return $gameMap.event(this.bindedTo);
    } else if (this.bindedTo === 0) {
      return $gamePlayer;
    } else {
      return null;
    }
  }

  bindToEvent(bindedTo) {
    this.bindedTo = bindedTo;
  }

  bindToPlayer() {
    return this.bindedEvent(0);
  }

  getScreenPos() {
    var bindedEvent;
    bindedEvent = this.bindedEvent();
    if (bindedEvent != null) {
      return {
        x: bindedEvent.screenX() + this.x,
        y: bindedEvent.screenY() + this.y
      };
    } else {
      return {
        x: this.x,
        y: this.y
      };
    }
  }

};


// Generated by CoffeeScript 2.6.1
var AACustomGaugesSystem;

AACustomGaugesSystem = class AACustomGaugesSystem {
  constructor() {
    this.gauges = [];
    $gameTemp._aaGaugeSprites = [];
    return;
  }

  static Instance() {
    return $gameSystem.aaGetCustomGaugesSystem();
  }

  getGaugeDataById(gaugeId) {
    return this.gauges.find(function(g) {
      return g.id === gaugeId;
    });
  }

  getGaugeDataByVarId(varId) {
    return this.gauges.find(function(g) {
      return g.varId === varId;
    });
  }

  getGaugeDataByEnemyId(enemyEvId) {
    return this.gauges.find(function(g) {
      return g.enemyEvId = enemyEvId;
    });
  }

  getGlobalGauges() {
    return this.gauges.filter(function(g) {
      return g.mapId === 0;
    });
  }

  getCurrentMapGauges() {
    return this.gauges.filter(function(g) {
      return g.mapId === $gameMap.mapId();
    });
  }

  isExistsGaugeForVariable(varId) {
    return this.getGaugeDataByVarId(varId) != null;
  }

  static test() {
    return AACustomGaugesSystem.Instance().addGauge(1, AA.PP.getCustomGauges()[0], 0, 0, 15, 0, false);
  }

  addGauge(variableId, parameters, x, y, bindedEventId, bindedEnemy, isGlobal) {
    var e, gauge;
    try {
      gauge = new AACustomGauge(variableId, parameters);
      gauge.x = x;
      gauge.y = y;
      if (bindedEnemy != null) {
        gauge.setEnemyEventId(bindedEnemy);
      }
      if (bindedEventId != null) {
        gauge.bindToEvent(bindedEventId);
      }
      if (isGlobal) {
        gauge.setGlobal();
      }
      this.gauges.push(gauge);
      return this._addGaugeToScene(gauge.id);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  removeGauge(gaugeId) {
    var e, gauge;
    try {
      gauge = this.getGaugeDataById(gaugeId);
      if (gauge == null) {
        return;
      }
      gauge.disposeGauge();
      return this.gauges.delete(gauge);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  removeGaugeByVarId(variableId) {
    var e, gauge;
    try {
      gauge = this.getGaugeDataByVarId(variableId);
      if (gauge != null) {
        return this.removeGauge(gauge.id);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  removeGaugeByEnemyId(enemyId) {
    var e, gauge;
    try {
      gauge = this.getGaugeDataByEnemyId(enemyId);
      if (gauge != null) {
        return this.removeGauge(gauge.id);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  onMapLoaded() {
    var e, gauge, i, j, len, len1, ref, ref1, results;
    try {
      $gameTemp._aaGaugeSprites = [];
      ref = this.getGlobalGauges();
      for (i = 0, len = ref.length; i < len; i++) {
        gauge = ref[i];
        this._addGaugeToScene(gauge.id);
      }
      ref1 = this.getCurrentMapGauges();
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        gauge = ref1[j];
        results.push(this._addGaugeToScene(gauge.id));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  onBeforeMapStopped() {
    var e, i, len, ref, results, spr;
    try {
      if ($gameTemp._aaGaugeSprites == null) {
        return;
      }
      ref = $gameTemp._aaGaugeSprites;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        spr = ref[i];
        if (spr != null) {
          results.push(spr.visible = false);
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _addGaugeToScene(gaugeId) {
    var e, gauge, gaugeSpr;
    try {
      gauge = this.getGaugeDataById(gaugeId);
      if (gauge == null) {
        return;
      }
      if (!AAUtils.isSceneMap()) {
        return;
      }
      gaugeSpr = new Sprite_AACustomGauge(gaugeId);
      SceneManager._scene.addChild(gaugeSpr);
      return $gameTemp._aaGaugeSprites.push(gaugeSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

};


// * Методы формирования Damage PopUp на персонаже
var AADamagePopUpFactory;
(function (AADamagePopUpFactory) {
    // * Создание данных для PopUp опыта
    function createExpPopUpData(value) {
        try {
            //@ts-ignore
            const valueText = AA.PP.getExpPopUpSettings().textFormat.replace("%1", value.toString());
            //@ts-ignore
            const styleId = AA.PP.getExpPopUpSettings().styleId;
            return _createFromSettings(styleId, valueText);
        }
        catch (e) {
            console.warn(e);
            return null;
        }
    }
    AADamagePopUpFactory.createExpPopUpData = createExpPopUpData;
    // * Создание данных для PopUp золота
    function createGoldPopUpData(value) {
        try {
            //@ts-ignore
            const textFormat = AA.PP.getGoldPopUpSettings().textFormat;
            let valueText = textFormat.replace("%1", value.toString());
            let sign = value >= 0 ? "+" : "-";
            if (value < 0) {
                // * Отрицательное число уже несёт в себе знак -, мы его удаляем
                valueText = valueText.replace("-", "");
            }
            valueText = valueText.replace("%2", sign);
            const settings = "gold"; // * Зарезервированный стиль
            return _createFromSettings(settings, valueText);
        }
        catch (e) {
            console.warn(e);
            return null;
        }
    }
    AADamagePopUpFactory.createGoldPopUpData = createGoldPopUpData;
    // * Создание данных для PopUp урона
    function createDamagePopUpData(battler) {
        // * Если отключены, то ничего не возвращяем
        //@ts-ignore
        if (!AA.PP.isPopUpIsActive())
            return null;
        const result = battler.result();
        if (result.missed || result.evaded) {
            return _createMiss();
        }
        else if (result.hpAffected) {
            return _createHpDamage(result, battler.isEnemy());
        }
        else if (battler.isAlive() && result.mpDamage !== 0) {
            return _createMpDamage(result);
        }
        return null; // * Нет ничего
    }
    AADamagePopUpFactory.createDamagePopUpData = createDamagePopUpData;
    function _createMiss() {
        //@ts-ignore
        return _createFromSettings("Miss_For_All", AA.PP.getTextForPopUpMiss());
    }
    function CreateFromSettings(styleId, value) {
        return _createFromSettings(styleId, value);
    }
    AADamagePopUpFactory.CreateFromSettings = CreateFromSettings;
    function _createFromSettings(styleId, value) {
        return {
            //@ts-ignore
            settings: AA.PP.getPopUpDamageSettings(styleId),
            value: value
        };
    }
    function _createHpDamage(result, isEnemy) {
        const isHeal = result.hpDamage < 0;
        const value = _convertValue(result.hpDamage);
        if (_isHaveSpecialStyle(result)) {
            //@ts-ignore
            return _createFromSettings(result.getUsedAASkill().popUpStyleId, value);
        }
        else {
            if (isHeal) {
                return _createFromSettings("Heal_For_All", value);
            }
            else {
                let styleId = isEnemy ? "Damage_HP_For_Enemy" : "Damage_HP_For_Player";
                if (result.critical)
                    styleId += "_Critical";
                return _createFromSettings(styleId, value);
            }
        }
    }
    function _createMpDamage(result) {
        const value = _convertValue(result.mpDamage);
        if (_isHaveSpecialStyle(result)) {
            //@ts-ignore
            return _createFromSettings(result.getUsedAASkill().popUpStyleId, value);
        }
        else {
            return _createFromSettings("Damage_Other_For_All", value);
        }
    }
    // * Чтобы лечение было с +
    function _convertValue(value) {
        if (value >= 0)
            return value.toString();
        value *= -1;
        return "+" + value;
    }
    // * Есть ли у навыка специальный пользовательский стиль урона?
    function _isHaveSpecialStyle(result) {
        //@ts-ignore
        const aaSkill = result.getUsedAASkill();
        return aaSkill && String(aaSkill.popUpStyleId).length > 0;
    }
})(AADamagePopUpFactory || (AADamagePopUpFactory = {}));


// * Данный класс используется для сотворения глобальных скилов (на карте)
class AADummyCharacter extends Game_Character {
    constructor(ownerId, teamId, uId = null) {
        super();
        this._isFromNetwork = false;
        this.ownerId = ownerId;
        this.teamId = teamId;
        this.uId = uId;
        if (!this.uId) {
            this.generateId();
            //@ts-ignore
            AANetworkManager.sendDummyCharacterData(this.ownerId, this.teamId, this.uId);
        }
        this.aaEntity = new AADummyEntity(this.ownerId, this.teamId, this.uId);
        //@ts-ignore
        $gameMap.aaRegisterGlobalSkill(this.uId, this);
    }
    setFromNetwork() {
        this._isFromNetwork = true;
    }
    AASprite() {
        return null;
    }
    AAEntity() {
        return this.aaEntity;
    }
    isActive() {
        return true;
    }
    generateId() {
        //@ts-ignore
        this.uId = this.ownerId + this.teamId + $gameMap.mapId() + KDCore.makeId(3);
    }
    dispose() {
        // * Те, которые пришли от сервера, от него и уничтожаться
        if (!this._isFromNetwork) {
            //@ts-ignore
            AANetworkManager.sendDisposeDummyCharacter(this.uId);
        }
        //@ts-ignore
        $gameMap.aaDisposeGlobalSkill(this.uId);
    }
}
window['AADummyCharacter'] = AADummyCharacter;




// Generated by CoffeeScript 2.6.1
// * Класс, который содержит все настройки и параметры AA сущности врага на карте
// * Аналог AIBehavModel из ABS MV

//@[STORABLE]
//@[GLOBAL]
var AAEnemyModelData;

AAEnemyModelData = (function() {
  class AAEnemyModelData {
    constructor(eventId) {
      this.eventId = eventId;
      this.enemyId = this.eventSettings().getEnemyId();
      this._initBaseParameters();
      this._applyParametersFromDB();
      this._applyParametersFromEvent();
      this._convertParameters();
    }

    //TODO: Делать редактор или нет?

      //TODO: Игрок должен иметь возмможность менять значения во время игры
    //TODO: basik shake effect strength when hitted
    enemy() {
      return $dataEnemies[this.enemyId];
    }

    eventSettings() {
      return $gameMap.event(this.eventId).aaEventSettings;
    }

    isHaveDeadSwitch() {
      return AAUtils.isSelfSwitch(this.deadSwitch);
    }

    isHaveOnDeathAction() {
      return AAScriptActions.isProper(this.onDeath);
    }

    isHaveOnSeeTargetAction() {
      return AAScriptActions.isProper(this.onSeeTarget);
    }

    isHaveSpecialExpValue() {
      return this.expVar > 0;
    }

    isHaveOnDeathVariable() {
      return this.onDeathVar > 0;
    }

    isHeavy() {
      return AAExtendedValues.getSafeEValue(this.heavy, 0) > 0;
    }

    isNotAgressive() {
      return AAExtendedValues.getSafeEValue(this.notAgressive, 0) > 0;
    }

    gReturnRadius() {
      return AAExtendedValues.getSafeEValue(this.returnRadius, 12);
    }

    gViewRadius() {
      return AAExtendedValues.getSafeEValue(this.viewRadius, 5);
    }

    gTVisor() {
      return this.tVisor; //AAExtendedValues.getSafeEValue(@tVisor, 0)
    }

    gTeamId() {
      return AAExtendedValues.getSafeEValue(this.teamId, 1);
    }

    gNoMoveInBattle() {
      return AAExtendedValues.getSafeEValue(this.noMoveInBattle, 0);
    }

    gNoApproach() {
      return AAExtendedValues.getSafeEValue(this.noApproach, 0);
    }

    isTVision() {
      return this.tVisor > 0; //@gTVisor() > 0
    }

    isCanTeleportIn() {
      return this.gTeleportDistIn() > 0;
    }

    isCanTeleportOut() {
      return this.gTeleportDistOut() > 0;
    }

    gTeleportDistIn() {
      return AAExtendedValues.getSafeEValue(this.teleportDistIn, 0);
    }

    gTeleportDistOut() {
      return AAExtendedValues.getSafeEValue(this.teleportDistOut, 0);
    }

    gTeleportDelay() {
      return AAExtendedValues.getSafeEValue(this.teleportDelay, 3);
    }

    gTeleportRate() {
      return AAExtendedValues.getSafeEValue(this.teleportRate, 1);
    }

    isHaveAfterDeathBonus() {
      return (this.bonusOnDeadIds != null) && this.bonusOnDeadIds.length > 0;
    }

  };

  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = AAEnemyModelData.prototype;
    
    // * Инициализация базовых настроек
    _._initBaseParameters = function() {
      this._initMain();
      this._initOnMapSettings();
      this._initOtherSettings();
      this._initVisualSettings();
      this._initAnimationSettings();
      this._initMovingSettings();
    };
    _._initMain = function() {
      this.onDeath = 0; //AScript
      this.returnRadius = 12; //@[EVal]
      this.viewRadius = 5; //@[EVal]
      this.noPassVisionRegions = [];
      this.noPassVisionTerrains = [];
      this.tVisor = 0; // From 1 to X (Длина основания треугольника (fov))
      this.sideVisor = 0; // Сколько клеток по сторонам (слева и справа)
      this.notAgressive = 0;
      this.activeOutOfScreen = 0;
    };
    _._initOnMapSettings = function() {
      this.shatterEffect = 1;
      this.deadSwitch = 0; //Switch (A, B, C, D)
      this.eraseOnDead = 1;
      // * Тип атаки Motion, если у навыка есть isHaveWeaponMotion
      this.weaponMotionType = 0;
      // * Работает только с Extended Loot и Visual Drop ON
      this.lootDropOnDeath = 1;
      // * Врага нельзя сдвинуть импульсом
      this.heavy = 0; //@[EVal]
      // * Система "летающих" бонусов
      this.bonusOnDeadIds = [];
    };
    _._initVisualSettings = function() {
      this.faceName = ""; // имя файла в папке faces
      this.faceIndex = 0;
      this.UIInfo = 1; // * Если 1 - показывать Target UI при наведени курсора
      this.miniHpGaugeStyle = "";
      this.miniHPGaugeOffset = [0, 0];
      return this.damagePopUpYOffset = 0;
    };
    _._initOtherSettings = function() {
      this.onSeeTarget = 0; //AScript
      // * Переменная для опыта (отдельное значение, а не из БД)
      this.expVar = 0;
      // * За данного врага опыт даётся автоматически ( если 1)
      this.autoExp = 1;
      // * При получении урона (AABS навыка от кого либо)
      this.onHit = 0; //AScript
      // * Номер команды (по умолчанию у всех врагов 1)
      this.teamId = 1; //@[EVal]
      // * Переменная для +1 когда этот враг погибает
      this.onDeathVar = 0;
      // * Метка, для uAPI
      this.label = "";
      // * Даные действия выполняются каждую секунд (каждую секунду в битве)
      this.turnAction = 0; //AScript
      this.turnActionInBattle = 0; //AScript
      // * Когда враг был отброшен навыком с Impluse
      //TODO: реализовать выполенние
      this.onKnocked = 0; //AScript
      this.saveHp = 0;
    };
    _._initAnimationSettings = function() {
      this.hitAnimationId = 1; // ID анимации
    };
    _._initMovingSettings = function() {
      //@[EVal]
      this.noMoveInBattle = 0; // * Если 1 - враг не будет двигаться в бою (вообще)
      //@[EVal]
      this.noApproach = 0; // * Не преследовать цель в бою (своё движение остаётся, например Random или отступать от игрока)
      // Range (when start), Freq, Speed
      this.approachMoveData = [3, 5, 4];
      // Min dist, Freq, Speed, isRandomStep
      this.inBattleMoveData = [1, 3, 3, 0];
      //TODO: returnMoveData
      //@[EVal]
      this.teleportDistIn = 0;
      //@[EVal]
      this.teleportDistOut = 0;
      //@[EVal]
      this.teleportRate = 1;
      //@[EVal]
      this.teleportDelay = 3;
      this.teleportStartAnim = 0;
      this.teleportEndAnim = 0;
      this.smartPathRefreshTime = 20;
    };
    _._applyParametersFromDB = function() {
      var i, len, p, params;
      params = this.enemy().AAEnemy;
      if (params == null) {
        return;
      }
      for (i = 0, len = params.length; i < len; i++) {
        p = params[i];
        this[p[0]] = p[1];
      }
    };
    // * Применяем параметры из страницы события
    _._applyParametersFromEvent = function() {
      var i, len, param, ref, settings;
      settings = this.eventSettings();
      if (!settings.isHaveExtraParameters()) {
        return;
      }
      ref = settings.getParameters();
      for (i = 0, len = ref.length; i < len; i++) {
        param = ref[i];
        this[param[0]] = param[1];
      }
    };
    // * Преобразует некоторые параметры
    _._convertParameters = function() {
      if (this.miniHpGaugeStyle === 0) {
        this.miniHpGaugeStyle = "";
      }
      this.miniHPGaugeOffset = AAParametersParser.convertArrayFromParameter(this.miniHPGaugeOffset);
      this.approachMoveData = AAParametersParser.convertArrayFromParameter(this.approachMoveData);
      this.inBattleMoveData = AAParametersParser.convertArrayFromParameter(this.inBattleMoveData);
      this.noPassVisionRegions = AAParametersParser.convertArrayFromParameter(this.noPassVisionRegions);
      this.noPassVisionTerrains = AAParametersParser.convertArrayFromParameter(this.noPassVisionTerrains);
      this.bonusOnDeadIds = AAParametersParser.convertArrayFromParameter(this.bonusOnDeadIds);
    };
  })();

  return AAEnemyModelData;

}).call(this);

// ■ END PRIVATE
//---------------------------------------------------------------------------


class AAEventSettingsParser {
    constructor(list) {
        this.list = []; // Initialize the list of comments
        this.absParameters = []; // Initialize ABS parameters
        this.param = null; // Initialize plugin parameter
        this.mainLine = ""; // Initialize main line
        this.parsedParams = []; // Initialize parsed parameters
        this._pasreEventList(list);
        this._parseABSParamsBase();
        this._parseABSParamsSequence();
        this._parseParams();
        this._parsePluginCommand();
    }
    isHaveExtraParameters() {
        return this.parsedParams.length > 0;
    }
    getParameters() {
        return this.parsedParams;
    }
    // * Получить значение переменной опыта
    // * Данный метод используется чтобы получить опыт с уже мёртвого врага (т.е. NOT ACTIVE ABS)
    // * (нету модели и Entity, только остались эти данные)
    // * (используется если коммент был задан на событии, а в БД нету)
    getExpVarId() {
        const param = this.getParameters().find((p) => p[0] === "expVar");
        if (!param)
            return 0;
        return parseInt(param[1]);
    }
    getEnemyId() {
        const param = AAParametersParser.extractABSParameter(this.mainLine);
        if (!param)
            return 0;
        return param[1];
    }
    // * Извлечает из списка команд только комменатрии или определённую команду плагина
    _pasreEventList(list) {
        var _a;
        for (const line of list) {
            if (!line)
                continue;
            if (line.code === 108 || line.code === 408) {
                this.list.push(line.parameters[0]);
            }
            else if (line.code === 357 && ((_a = line.parameters) === null || _a === void 0 ? void 0 : _a[1]) === "ABSEventSettings") {
                this.param = line;
            }
        }
    }
    // * Собирает параметры в базовом представлении < > (как в оригинале)
    _parseABSParamsBase() {
        for (const l of this.list) {
            if (!l)
                continue;
            const param = AAParametersParser.extractABSParameter(l);
            if (!param)
                continue;
            // * Do not add ABS, it is handled separately
            if (param[0] === "ABS")
                continue;
            this.parsedParams.push(param);
        }
    }
    // * Собирает все строки с АБС параметрами от <ABS> до </ABS>
    _parseABSParamsSequence() {
        this.mainLine = this.list.find((l) => l.includes("<ABS")) || "";
        const endElement = this.list.find((l) => l.includes("</ABS>"));
        if (!endElement)
            return;
        const startIndex = this.list.indexOf(this.mainLine);
        if (startIndex < 0)
            return;
        for (let i = startIndex + 1; i < this.list.length; i++) {
            if (this.list[i] === endElement)
                break;
            this.absParameters.push(this.list[i]);
        }
    }
    // * Парсинг всех параметров из строк в структуру (имя: значение)
    _parseParams() {
        if (this.absParameters.length === 0)
            return;
        for (const param of this.absParameters) {
            const pair = AAParametersParser.extractABSParameter(param);
            if (!pair)
                continue;
            // * Skip another ABS parameter if added
            if (pair[0] === "ABS")
                continue;
            this.parsedParams.push(pair);
        }
    }
    // * Извлекает параметры из команды плагина
    _parsePluginCommand() {
        if (!this.param)
            return;
        if (!AAUtils.isMZ())
            return;
        const params = this.param.parameters[3];
        if (!params)
            return;
        for (const [k, v] of Object.entries(params)) {
            // * Пропускаем заголовки групп
            if (k.includes("Group"))
                continue;
            const p = [k, AAParametersParser.convertParameterValue(v)];
            this.parsedParams.push(p);
        }
    }
}
window['AAEventSettingsParser'] = AAEventSettingsParser;


var AAEventsInteractionsManager;
(function (AAEventsInteractionsManager) {
    const _CACHE_TIMEOUT = 1000;
    let _eventsCache = [];
    let _eventsCacheTimeout = 0;
    let _playerInteractions = [];
    let _secondUpdateThread = null;
    function getAllInteractionOwners(insideScreen) {
        let interactionAreaOwners = [];
        try {
            let events = getEventsWithInteractionArea();
            if (insideScreen) {
                events = events.filter(event => {
                    return event.isNearTheScreen();
                });
            }
            events.forEach(event => {
                interactionAreaOwners.push(event);
            });
        }
        catch (error) {
            console.warn(error);
        }
        return interactionAreaOwners;
    }
    AAEventsInteractionsManager.getAllInteractionOwners = getAllInteractionOwners;
    function getEventsWithInteractionArea() {
        if (_eventsCache.length != 0) {
            return _eventsCache;
        }
        let eventsWithInteraction = [];
        try {
            let events = $gameMap.events();
            events.forEach(event => {
                if (AACharInteractionArea.isHaveInteractionCollider(event)) {
                    eventsWithInteraction.push(event);
                }
            });
        }
        catch (error) {
            console.warn(error);
        }
        _eventsCache = eventsWithInteraction;
        if (_eventsCacheTimeout) {
            clearTimeout(_eventsCacheTimeout);
        }
        _eventsCacheTimeout = setTimeout(_clearEventsCache, _CACHE_TIMEOUT);
        return eventsWithInteraction;
    }
    AAEventsInteractionsManager.getEventsWithInteractionArea = getEventsWithInteractionArea;
    function isPlayerTouchInteraction() {
        try {
            if (!isHaveInteractions())
                return false;
            let event = getInteractionEvent();
            if (!event)
                return false;
            if (event.isTriggerIn([0, 1, 2])) {
                return isPointInsideInteractionArea(event, TouchInput);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AAEventsInteractionsManager.isPlayerTouchInteraction = isPlayerTouchInteraction;
    function isEventAreTouchInteraction(event) {
        try {
            if (!event)
                return false;
            if (event.isTriggerIn([1, 2])) {
                return true;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function isPointInsideInteractionArea(event, screenPoint) {
        let collider = AACharInteractionArea.getFor(event);
        if (collider) {
            let mapPoint = AAUtils.screenPointToMapPoint(screenPoint);
            return collider.isPointInsideCollider(mapPoint);
        }
        return false;
    }
    function isHaveInteractions() {
        return _playerInteractions.length > 0;
    }
    AAEventsInteractionsManager.isHaveInteractions = isHaveInteractions;
    function getInteractionEvent() {
        if (_playerInteractions.length > 0) {
            return _playerInteractions[0];
        }
        return null;
    }
    AAEventsInteractionsManager.getInteractionEvent = getInteractionEvent;
    function _clearEventsCache() {
        try {
            _eventsCacheTimeout = 0;
            _eventsCache = [];
        }
        catch (error) {
            console.warn(error);
        }
    }
    function Update() {
        if (!AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            return;
        }
        if ($gamePlayer.isMoving()) {
            if (!_secondUpdateThread) {
                //@ts-ignore
                _secondUpdateThread = new KDCore.TimedUpdate(3, updateInteractionsCollisions);
            }
            _secondUpdateThread.update();
        }
        else {
            updateInteractionsCollisions();
        }
        if (AAPluginParams.isHighlightInteractableEventsUnderCursor() && !Sprite_AAImpactZone.Instance()) {
            updateHighlightUnderCursor();
        }
    }
    AAEventsInteractionsManager.Update = Update;
    function updateInteractionsCollisions() {
        try {
            let interactableEvents = getAllInteractionOwners(true);
            let playerCollider = AACharCollider.getFor($gamePlayer);
            for (let i = 0; i < interactableEvents.length; i++) {
                let event = interactableEvents[i];
                let collider = AACharInteractionArea.getFor(event);
                if (collider) {
                    if (playerCollider.isCollideWith(collider) && isInteractionInLookDirection(event)) {
                        if (!_playerInteractions.includes(event)) {
                            registerInteraction(event);
                        }
                    }
                    else {
                        if (_playerInteractions.includes(event)) {
                            unregisterInteraction(event);
                        }
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function isInteractionInLookDirection(event) {
        if (AAPluginParams.isMobileDevicePriority()) {
            return true;
        }
        if (isEventAreTouchInteraction(event)) {
            return true;
        }
        return AAMath.isLookingAt($gamePlayer, event, $gamePlayer.direction());
    }
    function registerInteraction(event) {
        // * unhighlight all
        for (let otherEvent of _playerInteractions) {
            unhighlightInteraction(otherEvent);
        }
        // * add as first and highlight
        _playerInteractions.unshift(event);
        highlightInteraction(event);
        if (isEventAreTouchInteraction(event)) {
            let { x, y } = event;
            $gamePlayer.startMapEvent(x, y, [1, 2], event.isNormalPriority());
        }
    }
    function unregisterInteraction(event) {
        unhighlightInteraction(event);
        _playerInteractions = _playerInteractions.filter(e => e != event);
        // * call "highlight" for the first object in the list
        if (_playerInteractions.length > 0) {
            highlightInteraction(_playerInteractions[0]);
        }
    }
    function highlightInteraction(event) {
        try {
            AACharHighlightEffect.highlight(event);
            console.log('highlightInteraction', event.eventId());
        }
        catch (error) {
            console.warn(error);
        }
    }
    function unhighlightInteraction(event) {
        try {
            AACharHighlightEffect.unhighlight(event);
            console.log('unhighlightInteraction', event.eventId());
        }
        catch (error) {
            console.warn(error);
        }
    }
    function clearInteractions() {
        _playerInteractions = [];
        _secondUpdateThread = null;
    }
    AAEventsInteractionsManager.clearInteractions = clearInteractions;
    function getInteractionEventUnderCursor() {
        try {
            let allEvents = getAllInteractionOwners(true);
            for (let event of allEvents) {
                if (isPointInsideInteractionArea(event, TouchInput)) {
                    return event;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    AAEventsInteractionsManager.getInteractionEventUnderCursor = getInteractionEventUnderCursor;
    function updateHighlightUnderCursor() {
        try {
            let allEvents = getAllInteractionOwners(true);
            for (let event of allEvents) {
                if (isPointInsideInteractionArea(event, TouchInput)) {
                    AACharHighlightEffect.highlight(event);
                }
                else {
                    if (getInteractionEvent() != event) {
                        AACharHighlightEffect.unhighlight(event);
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function clearHighlightUnderCursorForAll() {
        try {
            let allEvents = getAllInteractionOwners(true);
            for (let event of allEvents) {
                AACharHighlightEffect.unhighlight(event);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAEventsInteractionsManager.clearHighlightUnderCursorForAll = clearHighlightUnderCursorForAll;
})(AAEventsInteractionsManager || (AAEventsInteractionsManager = {}));
window['AAEventsInteractionsManager'] = AAEventsInteractionsManager;


var AAEventsLocatorsManager;
(function (AAEventsLocatorsManager) {
    var _updateThread = null;
    var _isLocatorEventExistsOnMap = false;
    AAEventsLocatorsManager.lastLocatorTarget = null;
    AAEventsLocatorsManager.lastActivatedLocator = null;
    function onNewMapLoaded() {
        AAEventsLocatorsManager.lastLocatorTarget = null;
        AAEventsLocatorsManager.lastActivatedLocator = null;
        _updateThread = null;
        _isLocatorEventExistsOnMap = false;
    }
    AAEventsLocatorsManager.onNewMapLoaded = onNewMapLoaded;
    function update() {
        if (_updateThread == null) {
            _initUpdateThread();
        }
        _updateThread.update();
    }
    AAEventsLocatorsManager.update = update;
    function extractLocatorConfig(ev) {
        //@ts-ignore
        let configString = KDCore.Utils.getEventCommentValue("absLocator", ev.list());
        if (!configString || configString.length == 0) {
            return null;
        }
        let parameter = AAParametersParser.extractABSParameterAny(configString);
        if (!parameter)
            return null;
        let config = AAParametersParser.convertArrayFromParameter(parameter[1]);
        if (!config)
            return null;
        try {
            let loopType = (config[3]) === 0 ? 0 : 1;
            let locatorConfig = {
                radius: config[0] || 1,
                searchType: config[1] || 0,
                commonEvent: config[2] || 0,
                loopType
            };
            if (locatorConfig.commonEvent == 0) {
                // Оптимизация, так как нет смысла, если нет общего события на запуск
                return null;
            }
            _isLocatorEventExistsOnMap = true;
            return locatorConfig;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    AAEventsLocatorsManager.extractLocatorConfig = extractLocatorConfig;
    function _initUpdateThread() {
        //@ts-ignore
        _updateThread = new KDCore.TimedUpdate(60, _refreshLocators);
    }
    function _refreshLocators() {
        if (_isSystemActive()) {
            if (_isAtLeastOneLocatorExistsOnMap()) {
                _updateLocators();
            }
        }
    }
    function _isAtLeastOneLocatorExistsOnMap() {
        return _isLocatorEventExistsOnMap == true;
    }
    function _isSystemActive() {
        //@ts-ignore
        return AA.isABSMap();
    }
    function getAllLocatorEvents() {
        //@ts-ignore
        return $gameMap.events().filter(e => e['_aaLocatorConfig']);
    }
    AAEventsLocatorsManager.getAllLocatorEvents = getAllLocatorEvents;
    function _updateLocators() {
        getAllLocatorEvents().forEach(e => {
            _updateLocator(e);
        });
    }
    function _updateLocator(ev) {
        try {
            let config = _getEventLocatorConfig(ev);
            if (!config)
                return;
            var isTargetFound = false;
            let { searchType } = config;
            let teamId = 0;
            if (searchType >= -1) {
                if (searchType == -1) {
                    //@ts-ignore
                    if (ev.isABS()) {
                        //@ts-ignore
                        teamId = ev.AAEntity().teamId();
                    }
                }
                else {
                    teamId = searchType;
                }
            }
            isTargetFound = _isLocatorHaveProperTarget(ev, config.radius, teamId);
            if (isTargetFound) {
                // Запускаем общее событие относительно события
                try {
                    //@ts-ignore
                    ev.aaStartCommonEvent(config.commonEvent);
                    AAEventsLocatorsManager.lastActivatedLocator = ev;
                }
                catch (error) {
                    console.warn(error);
                }
                // * Отключаем локатор, если он одноразовый
                if (config.loopType == 1) {
                    _clearEventLocatorConfig(ev);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function _getEventLocatorConfig(ev) {
        let config = ev['_aaLocatorConfig'];
        if (!config)
            return null;
        try {
            // * For compatibility with old versions
            if (Array.isArray(config)) {
                ev['_aaLocatorConfig'] = extractLocatorConfig(ev);
            }
            return ev['_aaLocatorConfig'];
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    function _clearEventLocatorConfig(ev) {
        ev['_aaLocatorConfig'] = null;
    }
    function _isLocatorHaveProperTarget(ev, searchRadius, teamId) {
        try {
            //@ts-ignore
            let candidates = AATargetsManager.collectAllABSEntitiesOnMap();
            //@ts-ignore
            candidates = candidates.filter(c => c.AAEntity().teamId() == teamId);
            //@ts-ignore
            candidates = AATargetsManager.getFilteredInRadius(ev, searchRadius, candidates);
            if (candidates.length > 0) {
                AAEventsLocatorsManager.lastLocatorTarget = candidates[0];
                return true;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
})(AAEventsLocatorsManager || (AAEventsLocatorsManager = {}));
window['AAEventsLocatorsManager'] = AAEventsLocatorsManager;


var AAEventsProjectilesInteractions;
(function (AAEventsProjectilesInteractions) {
    function setupProjectileInteractionsFor(event) {
        try {
            createProjectileInteractionsFor(event);
            createProjectilesBlockList(event);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAEventsProjectilesInteractions.setupProjectileInteractionsFor = setupProjectileInteractionsFor;
    // * Извлекает все onProjectileHit действия
    // * Пример: onProjectileHit#ID:SA
    // * Можно 0 - тогда будет для всех навыков (для любого) или просто onProjectileHit:SA>
    function createProjectileInteractionsFor(event) {
        try {
            event['_aaProjectileInteractionsList'] = null;
            let comments = KGameEvents.GetCommentLines('onProjectileHit', event);
            if (comments.length > 0) {
                for (let i = 0; i < comments.length; i++) {
                    addProjectileInteractionFor(event, comments[i]);
                }
                //console.log(event['_aaProjectileInteractionsList']);
            }
            else {
                // * Для совместимости со старыми версиями
                comments = KGameEvents.GetCommentLines('<onVectorHit', event);
                if (comments.length > 0) {
                    for (let i = 0; i < comments.length; i++) {
                        let comment_without_brackets = comments[i].replace(/<|>/g, "");
                        comment_without_brackets = comment_without_brackets.replace("Hit_", "Hit#");
                        addProjectileInteractionFor(event, comment_without_brackets);
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    function addProjectileInteractionFor(event, comment) {
        try {
            let skillId = 0;
            let sAction = "";
            if (comment.includes("#")) {
                let commentData = comment.split("#")[1];
                let data = commentData.split(":");
                skillId = parseInt(data[0]);
                sAction = data[1];
            }
            else {
                let data = comment.split(":");
                skillId = 0;
                sAction = data[1];
            }
            if (!event['_aaProjectileInteractionsList']) {
                event['_aaProjectileInteractionsList'] = {};
            }
            let list = event['_aaProjectileInteractionsList'];
            if (list[skillId] === undefined) {
                list[skillId] = [];
            }
            list[skillId].push(sAction);
        }
        catch (error) {
            console.warn(error);
        }
    }
    function getEventInteractionsForProjectile(event, projectileSkillId) {
        try {
            if (event['_aaProjectileInteractionsList'] === null) {
                return [];
            }
            else {
                let list = event['_aaProjectileInteractionsList'];
                if (list[projectileSkillId] != undefined) {
                    return list[projectileSkillId];
                }
                else {
                    return list[0] !== undefined ? list[0] : [];
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return [];
    }
    function isEventHaveInteractionForProjectile(event, projectileSkillId) {
        try {
            if (!event['_aaProjectileInteractionsList']) {
                return false;
            }
            else {
                let list = event['_aaProjectileInteractionsList'];
                if (list[0] != undefined) {
                    return true;
                }
                return list[projectileSkillId] !== undefined;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function isEventBlockProjectile(event, projectileSkill) {
        try {
            if (!event)
                return false;
            if (event._erased)
                return false;
            if (event.isThrough())
                return false;
            if (!isEventOnSameLevelAsProjectile(event, projectileSkill)) {
                return false;
            }
            let skillId = projectileSkill.databaseId();
            let blockList = event['_aaProjectileBlockList'];
            let passList = event['_aaProjectilePassList'];
            if (blockList === null) {
                if (passList.includes(skillId)) {
                    return false;
                }
                else {
                    return true;
                }
            }
            else {
                if (blockList.includes(skillId)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AAEventsProjectilesInteractions.isEventBlockProjectile = isEventBlockProjectile;
    function isEventInteractWithProjectile(event, projectileSkill) {
        try {
            if (!event['_aaProjectileInteractionsList']) {
                return false;
            }
            if (!isEventOnSameLevelAsProjectile(event, projectileSkill)) {
                return false;
            }
            let skillId = projectileSkill.databaseId();
            return isEventHaveInteractionForProjectile(event, skillId);
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function tryActivateEventInteractionsForProjectile(event, projectileSkill) {
        try {
            if (!isEventInteractWithProjectile(event, projectileSkill)) {
                return;
            }
            let interactions = getEventInteractionsForProjectile(event, projectileSkill.databaseId());
            for (let i = 0; i < interactions.length; i++) {
                let interaction = interactions[i];
                try {
                    AAScriptActions.execute(interaction, event);
                }
                catch (error) {
                    console.warn(error);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAEventsProjectilesInteractions.tryActivateEventInteractionsForProjectile = tryActivateEventInteractionsForProjectile;
    function isEventOnSameLevelAsProjectile(event, projectileSkill) {
        try {
            return projectileSkill.isOnSameLevelWith(event);
        }
        catch (error) {
            console.warn(error);
        }
        return true;
    }
    ;
    // * Извлекает список ID навыков, которые блокирет данное событие
    // * blockProjectiles:no - ничего не блокирует
    // * blockProjectiles: ID, ID, ... - блокирует только ID навыков
    // * blockProjectilesExcept: ID, ID, ... - НЕ блокирует ID навыков
    function createProjectilesBlockList(event) {
        try {
            event['_aaProjectileBlockList'] = null;
            var commentData = KGameEvents.GetCommentCodeValue('blockProjectiles', event);
            if (KString.any(commentData)) {
                if (commentData === 'no') {
                    event['_aaProjectileBlockList'] = [];
                }
                // * Если есть HitBox, то всё равно будет блокировать, так что all не нужно
                // * Если нет HitBox, то всё равно НЕ удет блокировать, даже если есть all
                /*else if(commentData === 'all') {
                    event['_aaProjectileBlockList'] = null;
                }*/
                else {
                    let skillsIds = AAParametersParser.convertArrayFromParameter(commentData);
                    // * Remove NaN and null values
                    skillsIds = skillsIds.filter(id => !isNaN(id) && id !== null);
                    if (skillsIds.length > 0) {
                        event['_aaProjectileBlockList'] = skillsIds;
                        console.log(`Event ${event.eventId()} block projectiles:`, skillsIds);
                    }
                }
            }
            else {
                // * Попробуем найти старые версии комментариев и преобразовать их
                // Ищем <vectorBlock:no> - не блокирует
                var commentData = KGameEvents.GetCommentCodeValue('<vectorBlock:no>', event);
                if (KString.any(commentData)) {
                    event['_aaProjectileBlockList'] = [];
                }
            }
            event['_aaProjectilePassList'] = [];
            var commentData = KGameEvents.GetCommentCodeValue('blockProjectilesExcept', event);
            if (KString.any(commentData)) {
                let skillsIds = AAParametersParser.convertArrayFromParameter(commentData);
                skillsIds = skillsIds.filter(id => !isNaN(id) && id !== null);
                event['_aaProjectilePassList'] = skillsIds;
                if (skillsIds.length > 0) {
                    event['_aaProjectileBlockList'] = null;
                }
            }
            else {
                // * Попробуем найти старые версии комментариев и преобразовать их
                // Ищем <vectorBlock:ID,ID,...> - не блокирует
                var commentData = KGameEvents.GetCommentCodeValue('<vectorBlock:', event);
                if (KString.any(commentData)) {
                    // Remove brackets
                    commentData = commentData.replace(/<|>/g, "");
                    let skillsIds = AAParametersParser.convertArrayFromParameter(commentData);
                    skillsIds = skillsIds.filter(id => !isNaN(id) && id !== null);
                    event['_aaProjectilePassList'] = skillsIds;
                    if (skillsIds.length > 0) {
                        event['_aaProjectileBlockList'] = null;
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
})(AAEventsProjectilesInteractions || (AAEventsProjectilesInteractions = {}));
window['AAEventsProjectilesInteractions'] = AAEventsProjectilesInteractions;


var AAGridMapManager;
(function (AAGridMapManager) {
    let dynamicCollidersRefreshTimeout = 0;
    let dynamicCollidersRefreshTime = 500; //TODO: Option
    let dynamicCollidersCache = [];
    let gridMapCache = {};
    let grid = null;
    function onNewMapIsLoaded() {
        clearTimeout(dynamicCollidersRefreshTimeout);
        dynamicCollidersRefreshTimeout = 0;
        dynamicCollidersCache = [];
        grid = createGridForMap();
    }
    AAGridMapManager.onNewMapIsLoaded = onNewMapIsLoaded;
    function getMapGrid() {
        if (!grid) {
            grid = createGridForMap();
        }
        let actualGrid = grid.clone();
        addDynamicCollidersToGrid(actualGrid);
        return actualGrid;
    }
    AAGridMapManager.getMapGrid = getMapGrid;
    function mapGridWidth() {
        return ($gameMap.tileWidth() / gridSize()) * $gameMap.width();
    }
    AAGridMapManager.mapGridWidth = mapGridWidth;
    function mapGridHeight() {
        return ($gameMap.tileHeight() / gridSize()) * $gameMap.height();
    }
    AAGridMapManager.mapGridHeight = mapGridHeight;
    // * Only 48, 24, 16, 12
    function gridSize() {
        return AAPluginParams.getMovementGridSize();
    }
    AAGridMapManager.gridSize = gridSize;
    function isGridSize48() {
        return gridSize() == 48;
    }
    AAGridMapManager.isGridSize48 = isGridSize48;
    function isGridSize24() {
        return gridSize() == 24;
    }
    AAGridMapManager.isGridSize24 = isGridSize24;
    function isGridSize16() {
        return gridSize() == 16;
    }
    AAGridMapManager.isGridSize16 = isGridSize16;
    function isGridSize12() {
        return gridSize() == 12;
    }
    AAGridMapManager.isGridSize12 = isGridSize12;
    function isCreateGridForMapWithPointIn() {
        return false;
    }
    function createGridForMap() {
        console.time('Create grid for map');
        console.log('Create grid for map');
        if (gridMapCache[$gameMap.mapId()]) {
            console.timeEnd('Grid from cache');
            return gridMapCache[$gameMap.mapId()];
        }
        let newGrid;
        if (isCreateGridForMapWithPointIn()) {
            newGrid = createGridForMapWithPointIn();
        }
        else {
            newGrid = createGridForMapWithCollider();
        }
        console.timeEnd('Create grid for map');
        gridMapCache[$gameMap.mapId()] = newGrid;
        return newGrid;
    }
    function createGridForMapWithPointIn() {
        let mapWidth = mapGridWidth();
        let mapHeight = mapGridHeight();
        //@ts-ignore
        let newGrid = new PF.Grid(mapWidth, mapHeight);
        let colliders = AAMapCollisionsManager.getTilemapColliders();
        let _gridSize = gridSize();
        let dw = $gameMap.tileWidth() / _gridSize;
        let dh = $gameMap.tileHeight() / _gridSize;
        let hw = (_gridSize / 2) / $gameMap.tileWidth();
        let hh = (_gridSize / 2) / $gameMap.tileHeight();
        /*if(_gridSize == 24) {
            hh += 0.5;
        } else if (_gridSize == 16 || _gridSize == 12) {
            hw += 0.25;
            hh += 0.75;
        } else if (_gridSize == 8) {
            hw += 0.33;
            hh += 0.77;
        }*/
        if (isGridSize24()) {
            hh += 0.5;
        }
        else if (isGridSize16() || isGridSize12()) {
            hw += 0.25;
            hh += 0.75;
        }
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                let passable = true;
                let mcx = (i / dw) - hw;
                let mcy = (j / dh) - hh;
                //console.log(`Test at ${mcx}, ${mcy}`);
                for (let collider of colliders) {
                    if (collider.isPointInsideCollider({ x: mcx, y: mcy })) {
                        //console.log(` --- Collider at ${mcx}, ${mcy}`);
                        passable = false;
                        break;
                    }
                }
                newGrid.setWalkableAt(i, j, passable);
            }
        }
        return newGrid;
    }
    function createGridForMapWithCollider() {
        let mapWidth = mapGridWidth();
        let mapHeight = mapGridHeight();
        let dw = $gameMap.tileWidth() / gridSize();
        let dh = $gameMap.tileHeight() / gridSize();
        //@ts-ignore
        let newGrid = new PF.Grid(mapWidth, mapHeight);
        let mapColliders = AAMapCollisionsManager.getTilemapColliders();
        let collider = getGridCellCollider();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                let passable = true;
                let cpx = i / dw;
                let cpy = j / dh;
                //console.log(`Test at ${cpx}, ${cpy}`);
                collider.setPositionXY(cpx, cpy, true);
                for (let mapCollider of mapColliders) {
                    if (collider.isCollideWith(mapCollider)) {
                        passable = false;
                        break;
                    }
                }
                newGrid.setWalkableAt(i, j, passable);
            }
        }
        return newGrid;
    }
    function getGridCellCollider() {
        let size = gridSize();
        let collider = new AACollider({
            width: size - 4,
            height: size - 4,
            type: 'b',
            dx: -(($gameMap.tileWidth() / 2) - 2),
            dy: -($gameMap.tileHeight() - 2),
            radius: 0,
            flag: 'other'
        });
        return collider;
    }
    function findPath(start, end) {
        try {
            let grid = getMapGrid();
            //@ts-ignore
            let finder = new PF.AStarFinder({
                allowDiagonal: true,
                dontCrossCorners: true
            });
            if (start.x < 0) {
                start.x = 0;
            }
            if (start.y < 0) {
                start.y = 0;
            }
            start = alignMapPointWithGrid(start);
            start = convertMapPointToGridPoint(start);
            end = alignMapPointWithGrid(end);
            end = convertMapPointToGridPoint(end);
            if (start.x < 0 || start.y < 0 || end.x < 0 || end.y < 0) {
                return [];
            }
            let mapWidth = mapGridWidth();
            let mapHeight = mapGridHeight();
            if (start.x >= mapWidth || start.y >= mapHeight || end.x >= mapWidth || end.y >= mapHeight) {
                return [];
            }
            let path = finder.findPath(start.x, start.y, end.x, end.y, grid);
            if (!path || path.length == 0)
                return [];
            //@ts-ignore
            //path = PF.Util.smoothenPath(grid, path);
            //@ts-ignore
            //path = PF.Util.compressPath(path);
            let result = [];
            let skipStartCount = 1;
            if (isGridSize16()) {
                skipStartCount = 3;
            }
            else if (isGridSize24()) {
                skipStartCount = 2;
            }
            if (path.length <= skipStartCount) {
                skipStartCount = 0;
            }
            for (let i = skipStartCount; i < path.length; i++) {
                let point = path[i];
                let mapPoint = convertGridPointToMapPoint({ x: point[0], y: point[1] });
                result.push(mapPoint);
            }
            return result;
        }
        catch (error) {
            console.warn(error);
        }
        return [];
    }
    AAGridMapManager.findPath = findPath;
    function alignGridPointWithMap(point) {
        if (isGridSize12()) {
            return { x: point.x - 0.33, y: point.y - 0.66 };
        }
        else if (isGridSize16()) {
            return { x: point.x - 0.33, y: point.y - 0.55 };
        }
        else if (isGridSize24()) {
            return { x: point.x - 0.25, y: point.y - 0.4 };
        }
        return point;
    }
    AAGridMapManager.alignGridPointWithMap = alignGridPointWithMap;
    function alignMapPointWithGrid(point) {
        if (isGridSize12()) {
            return { x: point.x + 0.33, y: point.y + 0.66 };
        }
        else if (isGridSize16()) {
            return { x: point.x + 0.33, y: point.y + 0.55 };
        }
        else if (isGridSize24()) {
            return { x: point.x + 0.25, y: point.y + 0.4 };
        }
        return point;
    }
    AAGridMapManager.alignMapPointWithGrid = alignMapPointWithGrid;
    function convertMapPointToGridPoint(point) {
        let _gridSize = gridSize();
        if (isGridSize48()) {
            return { x: Math.round(point.x), y: Math.round(point.y) };
        }
        let dw = $gameMap.tileWidth() / _gridSize;
        let dh = $gameMap.tileHeight() / _gridSize;
        let mcx = (point.x * dw);
        let mcy = (point.y * dh);
        return { x: Math.round(mcx), y: Math.round(mcy) };
    }
    AAGridMapManager.convertMapPointToGridPoint = convertMapPointToGridPoint;
    function convertGridPointToMapPoint(point) {
        let _gridSize = gridSize();
        if (isGridSize48()) {
            return point;
        }
        let dw = $gameMap.tileWidth() / _gridSize;
        let dh = $gameMap.tileHeight() / _gridSize;
        let mcx = (point.x / dw);
        let mcy = (point.y / dh);
        return { x: mcx, y: mcy };
    }
    AAGridMapManager.convertGridPointToMapPoint = convertGridPointToMapPoint;
    function addDynamicCollidersToGrid(grid) {
        if (dynamicCollidersRefreshTimeout != 0) {
            //console.log('Skip refresh dynamic colliders');
            for (let [i, j] of dynamicCollidersCache) {
                grid.setWalkableAt(i, j, false);
            }
            return;
        }
        dynamicCollidersCache = [];
        //console.log('Refresh dynamic colliders');
        let dynamicColliders = AAMapCollisionsManager.getDynamicObstacles(true);
        let gridCellCollider = getGridCellCollider();
        let mapWidth = mapGridWidth();
        let mapHeight = mapGridHeight();
        let dw = $gameMap.tileWidth() / gridSize();
        let dh = $gameMap.tileHeight() / gridSize();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                let cpx = i / dw;
                let cpy = j / dh;
                gridCellCollider.setPositionXY(cpx, cpy, true);
                for (let collider of dynamicColliders) {
                    if (collider && collider.isCollideWith(gridCellCollider)) {
                        grid.setWalkableAt(i, j, false);
                        dynamicCollidersCache.push([i, j]);
                        break;
                    }
                }
            }
        }
        dynamicCollidersRefreshTimeout = setTimeout(() => {
            dynamicCollidersRefreshTimeout = 0;
        }, dynamicCollidersRefreshTime);
    }
})(AAGridMapManager || (AAGridMapManager = {}));
window['AAGridMapManager'] = AAGridMapManager;


var AAHitBox;
(function (AAHitBox) {
    function setupForEventFromCurrentPage(event) {
        try {
            _clearCharacterHitBoxes(event);
            if (_isNotHaveHitBoxes(event)) {
                return;
            }
            let hitboxes = _getUserDefinedHitboxesForEvent(event);
            if (hitboxes && hitboxes.length > 0) {
                hitboxes.forEach(hitbox => {
                    _registerHitbox(event, hitbox);
                });
            }
            else {
                if (_isEventSupportAutoHitbox(event)) {
                    let hitboxConfig = AAPluginParams.getEnemyDefaultHitBoxConfig();
                    hitboxConfig.flag = 'hitbox';
                    _registerHitbox(event, hitboxConfig);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAHitBox.setupForEventFromCurrentPage = setupForEventFromCurrentPage;
    function setupForCharacter(character) {
        if (character instanceof Game_Event) {
            setupForEventFromCurrentPage(character);
        }
        else {
            try {
                _clearCharacterHitBoxes(character);
                //@ts-ignore
                let actor = character.AABattler();
                if (actor) {
                    let configString = actor.actor()['meta'].aHitbox;
                    if (configString) {
                        if (configString === "none") {
                            return;
                        }
                        let hitbox = AACollider.ParseConfigString(configString, 'hitbox');
                        if (hitbox) {
                            _registerHitbox(character, hitbox);
                        }
                    }
                    else {
                        let hitboxConfig = AAPluginParams.getActorDefaultHitBoxConfig();
                        hitboxConfig.flag = 'hitbox';
                        _registerHitbox(character, hitboxConfig);
                    }
                }
            }
            catch (error) {
                console.warn(error);
            }
        }
    }
    AAHitBox.setupForCharacter = setupForCharacter;
    function clearFor(character) {
        try {
            _clearCharacterHitBoxes(character);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAHitBox.clearFor = clearFor;
    function getFor(character) {
        try {
            let hitboxes = _getCharacterHitBoxes(character);
            hitboxes.forEach(hitbox => {
                hitbox.refreshPositionForChar(character);
            });
            return hitboxes;
        }
        catch (error) {
            console.warn(error);
        }
        return [];
    }
    AAHitBox.getFor = getFor;
    function checkCollision(character, collider) {
        try {
            let hitboxes = getFor(character);
            for (let i = 0; i < hitboxes.length; i++) {
                if (hitboxes[i].isCollideWith(collider)) {
                    return true;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AAHitBox.checkCollision = checkCollision;
    function isHaveHitBoxes(character) {
        try {
            return _getCharacterHitBoxes(character).length > 0;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AAHitBox.isHaveHitBoxes = isHaveHitBoxes;
    function _getCharacterHitBoxes(character) {
        if (!character['_aaHitBoxes']) {
            _clearCharacterHitBoxes(character);
        }
        return character['_aaHitBoxes'];
    }
    function _clearCharacterHitBoxes(character) {
        character['_aaHitBoxes'] = [];
    }
    // Player can force disable hitboxes on event page
    // hitbox:none
    function _isNotHaveHitBoxes(event) {
        try {
            let value = KGameEvents.GetCommentCodeValue("aHitbox", event);
            if (value) {
                return value === "none";
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function _getUserDefinedHitboxesForEvent(event) {
        let hitboxes = [];
        try {
            let values = KGameEvents.GetCommentLines("aHitbox", event);
            for (let i = 0; i < values.length; i++) {
                let hitbox = AACollider.ParseConfigString(values[i], 'hitbox');
                if (hitbox) {
                    hitboxes.push(hitbox);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return hitboxes;
    }
    function _isEventSupportAutoHitbox(event) {
        try {
            //@ts-ignore
            return event.isABS() && event.isNormalPriority();
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    function _registerHitbox(character, hitbox) {
        let hitboxes = _getCharacterHitBoxes(character);
        if (hitbox instanceof AACollider) {
            hitboxes.push(hitbox);
        }
        else {
            let collider = new AACollider(hitbox);
            hitboxes.push(collider);
        }
    }
})(AAHitBox || (AAHitBox = {}));
window["AAHitBox"] = AAHitBox;


var AALog;
(function (AALog) {
    let _isDebugMode = false;
    function log(message) {
        console.log(`%c${"AABSZ: " + message}`, "background-color:#191a19; color:green; padding: 2px 5px; border-radius: 3px;");
    }
    AALog.log = log;
    function warn(message) {
        console.log(`%c${"AABSZ Warning: " + message}`, "background-color:#191a19; color:orange; padding: 5px 10px; border-radius: 5px;");
    }
    AALog.warn = warn;
    function debug(message) {
        if (!_isDebugMode)
            return;
        console.log(`%c${"AABSZ Debug: " + message}`, "background-color:#cccc77; color:black; padding: 2px 5px;");
    }
    AALog.debug = debug;
})(AALog || (AALog = {}));
window["AALog"] = AALog;


var AAMainGameLoopManager;
(function (AAMainGameLoopManager) {
    // called from Scene_Boot.prototype.start
    function onAfterSceneBoot() {
        try {
            AAPluginParams.loadPluginSettings();
            AAMainSystem.init();
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onAfterSceneBoot = onAfterSceneBoot;
    // called from Scene_Map.prototype.onMapLoaded
    function onMapAfterSceneLoaded() {
        try {
            AAProjectileManager.onAfterMapIsLoaded();
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onMapAfterSceneLoaded = onMapAfterSceneLoaded;
    // called from Scene_Map.prototype.stop
    function onBeforeMapSceneStop() {
        try {
            AAEventsInteractionsManager.clearInteractions();
            AABattleAnimationsManager.clearAll();
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onBeforeMapSceneStop = onBeforeMapSceneStop;
    // called from Scene_Map.prototype.update
    function onMapSceneUpdate() {
        try {
            Sprite_AAGridMapLayer.updateTool();
            Sprite_AACollisionsLayer.updateTool();
            Sprite_AAProjectilesCollisionsLayer.updateTool();
            AAEventsInteractionsManager.Update();
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onMapSceneUpdate = onMapSceneUpdate;
    // called from Scene_Map.prototype.start
    function onMapAfterSceneStart() {
        try {
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onMapAfterSceneStart = onMapAfterSceneStart;
    // called from Game_Map.prototype.setup (last line)
    function onAfterGameMapSetup(mapId) {
        try {
            AAMapCollisionsManager.onNewMapIsLoaded();
            AAGridMapManager.onNewMapIsLoaded();
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onAfterGameMapSetup = onAfterGameMapSetup;
    // called from Game_Map.prototype.setup (first line)
    function onBeforeGameMapLeave(mapId) {
        try {
            AAProjectileManager.onBeforeMapIsChanged();
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onBeforeGameMapLeave = onBeforeGameMapLeave;
    // called from Scene_Title.prototype.start
    function onSceneTitleStart() {
        try {
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onSceneTitleStart = onSceneTitleStart;
    // called from Game_System.prototype.onBeforeSave
    function onBeforeGameSave() {
        try {
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onBeforeGameSave = onBeforeGameSave;
    // called from Game_System.prototype.onAfterLoad
    function onAfterGameLoad() {
        try {
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMainGameLoopManager.onAfterGameLoad = onAfterGameLoad;
})(AAMainGameLoopManager || (AAMainGameLoopManager = {}));
window["AAMainGameLoopManager"] = AAMainGameLoopManager;


var AAMainSystem;
(function (AAMainSystem) {
    //TODO: From 1_AASystem
    function init() {
        AALog.log("System is initialized!");
        // initial value!
        //AAPluginParams.isUseExtendedMovementSystem();
    }
    AAMainSystem.init = init;
    //TODO: When we disable this system during game, we should align all characters on map to grid 48x48
    //TODO: If we enable this system during game, we should recreate gridmap and map colliders
    function isExtendedPlayerMovementSystemActive() {
        return AAPluginParams.isUseExtendedMovementSystem();
    }
    AAMainSystem.isExtendedPlayerMovementSystemActive = isExtendedPlayerMovementSystemActive;
})(AAMainSystem || (AAMainSystem = {}));
window['AAMainSystem'] = AAMainSystem;


var AAMapCollisionsManager;
(function (AAMapCollisionsManager) {
    //TODO: Separate methods for checking collision with map and with other colliders (projectiles, visions and ect)
    const _CACHE_TIMEOUT = 1000;
    let _eventsWithCollidersCache = [];
    let _eventsWithCollidersCacheTimeout = 0;
    let mapTilemapColliders = null;
    let mapTilemapCollidersForProjectiles = null;
    let tilemapCollidersForMapIndexCache = {};
    let tilemapCollidersForProjectilesIndexCache = {};
    function onNewMapIsLoaded() {
        tilemapCollidersForMapIndexCache = {};
        tilemapCollidersForProjectilesIndexCache = {};
        if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            mapTilemapColliders = createTilemapCollidersForMap();
        }
        else {
            mapTilemapColliders = [];
        }
        mapTilemapCollidersForProjectiles = createTilemapCollidersForProjectiles();
    }
    AAMapCollisionsManager.onNewMapIsLoaded = onNewMapIsLoaded;
    function getAllMovementObstaclesOwners(insideScreen) {
        let collidersOwners = [];
        try {
            let events = getEventsWithColliders();
            if (insideScreen) {
                events = events.filter(event => {
                    return event.isNearTheScreen();
                });
            }
            events.forEach(event => {
                collidersOwners.push(event);
            });
        }
        catch (error) {
            console.warn(error);
        }
        return collidersOwners;
    }
    AAMapCollisionsManager.getAllMovementObstaclesOwners = getAllMovementObstaclesOwners;
    function getEventsWithColliders() {
        if (_eventsWithCollidersCache.length != 0) {
            return _eventsWithCollidersCache;
        }
        let eventsWithColliders = [];
        try {
            let events = $gameMap.events();
            events.forEach(event => {
                if (AACharCollider.isHaveCollider(event)) {
                    eventsWithColliders.push(event);
                }
            });
        }
        catch (error) {
            console.warn(error);
        }
        _eventsWithCollidersCache = eventsWithColliders;
        if (_eventsWithCollidersCacheTimeout) {
            clearTimeout(_eventsWithCollidersCacheTimeout);
        }
        _eventsWithCollidersCacheTimeout = setTimeout(_clearEventsWithCollidersCache, _CACHE_TIMEOUT);
        return eventsWithColliders;
    }
    AAMapCollisionsManager.getEventsWithColliders = getEventsWithColliders;
    function _clearEventsWithCollidersCache() {
        try {
            _eventsWithCollidersCacheTimeout = 0;
            _eventsWithCollidersCache = [];
        }
        catch (error) {
            console.warn(error);
        }
    }
    function getTilemapColliders() {
        if (!mapTilemapColliders) {
            mapTilemapColliders = createTilemapCollidersForMap();
        }
        return mapTilemapColliders;
    }
    AAMapCollisionsManager.getTilemapColliders = getTilemapColliders;
    function getTilemapCollidersForProjectiles() {
        if (!mapTilemapCollidersForProjectiles) {
            mapTilemapCollidersForProjectiles = createTilemapCollidersForProjectiles();
        }
        return mapTilemapCollidersForProjectiles;
    }
    AAMapCollisionsManager.getTilemapCollidersForProjectiles = getTilemapCollidersForProjectiles;
    function isCollideWithProjectileObstacles(collider) {
        if (!collider)
            return false;
        try {
            let collidersToCheck = getProjectileObsctaclesInPoint(collider.mapCellPoint(), 2);
            for (let i = 0; i < collidersToCheck.length; i++) {
                let nextToCheck = collidersToCheck[i];
                // * Skip self
                if (collider == nextToCheck) {
                    continue;
                }
                if (collider.isCollideWith(nextToCheck)) {
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            console.warn(error);
        }
        return true;
    }
    AAMapCollisionsManager.isCollideWithProjectileObstacles = isCollideWithProjectileObstacles;
    function isCollideWithMovementObstacles(collider) {
        if (!collider)
            return false;
        try {
            let collidersToCheck = getMovementObsctaclesInPoint(collider.mapCellPoint(), 2);
            for (let i = 0; i < collidersToCheck.length; i++) {
                let nextToCheck = collidersToCheck[i];
                // * Skip self
                if (collider == nextToCheck) {
                    continue;
                }
                if (collider.isCollideWith(nextToCheck)) {
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            console.warn(error);
        }
        return true;
    }
    AAMapCollisionsManager.isCollideWithMovementObstacles = isCollideWithMovementObstacles;
    function getMovementObsctaclesInPoint(point, distance) {
        let tilemapObstacles = getTilemapCollidersInPoint(point, distance);
        let dynamicObstacles = AACollisionsUtils.filterCollidersInPoint(getDynamicObstacles(true), point, distance);
        return tilemapObstacles.concat(dynamicObstacles);
    }
    function getTilemapCollidersInPoint(point, distance) {
        if (distance == 2) {
            let mapIndex = AAUtils.mapPointToIndex(point);
            if (tilemapCollidersForMapIndexCache[mapIndex]) {
                return tilemapCollidersForMapIndexCache[mapIndex];
            }
            else {
                let colliders = AACollisionsUtils.filterCollidersInPoint(getTilemapColliders(), point, distance);
                tilemapCollidersForMapIndexCache[mapIndex] = colliders;
                return colliders;
            }
        }
        else {
            return AACollisionsUtils.filterCollidersInPoint(getTilemapColliders(), point, distance);
        }
    }
    AAMapCollisionsManager.getTilemapCollidersInPoint = getTilemapCollidersInPoint;
    function getDynamicObstacles(insideScreen) {
        return getAllMovementObstaclesOwners(insideScreen).map(event => {
            return AACharCollider.getFor(event);
        });
    }
    AAMapCollisionsManager.getDynamicObstacles = getDynamicObstacles;
    function getProjectileObsctaclesInPoint(point, distance) {
        let tilemapObstacles = getProjectileCollidersInPoint(point, distance);
        return tilemapObstacles;
    }
    function getProjectileCollidersInPoint(point, distance) {
        if (distance == 2) {
            let mapIndex = AAUtils.mapPointToIndex(point);
            if (tilemapCollidersForProjectilesIndexCache[mapIndex]) {
                return tilemapCollidersForProjectilesIndexCache[mapIndex];
            }
            else {
                let colliders = AACollisionsUtils.filterCollidersInPoint(getTilemapCollidersForProjectiles(), point, distance);
                tilemapCollidersForProjectilesIndexCache[mapIndex] = colliders;
                return colliders;
            }
        }
        else {
            return AACollisionsUtils.filterCollidersInPoint(getTilemapCollidersForProjectiles(), point, distance);
        }
    }
    AAMapCollisionsManager.getProjectileCollidersInPoint = getProjectileCollidersInPoint;
    function isMapCellPassable(x, y) {
        // * We should check all directions (2, 4, 6, 8)
        let passable = false;
        for (let i = 2; i <= 8; i += 2) {
            if ($gameMap.checkPassage(x, y, i)) {
                passable = true;
                break;
            }
        }
        return passable;
    }
    function isMapCellRestricted(x, y) {
        let restrictedRegions = AAPluginParams.getNotPassableRegions();
        if (restrictedRegions && restrictedRegions.length > 0) {
            let regionId = $gameMap.regionId(x, y);
            if (restrictedRegions.includes(regionId)) {
                return true;
            }
        }
        let restrictedTerrainTags = AAPluginParams.getNotPassableTerrainTags();
        if (restrictedTerrainTags && restrictedTerrainTags.length > 0) {
            let terrainTag = $gameMap.terrainTag(x, y);
            if (restrictedTerrainTags.includes(terrainTag)) {
                return true;
            }
        }
    }
    function isMapCellRestrictedForProjectile(x, y) {
        let restrictedRegions = AAPluginParams.getProjectileForbiddenRegions();
        if (restrictedRegions && restrictedRegions.length > 0) {
            let regionId = $gameMap.regionId(x, y);
            if (restrictedRegions.includes(regionId)) {
                return true;
            }
        }
        let restrictedTerrainTags = AAPluginParams.getProjectileFrobiddenTerrainTags();
        if (restrictedTerrainTags && restrictedTerrainTags.length > 0) {
            let terrainTag = $gameMap.terrainTag(x, y);
            if (restrictedTerrainTags.includes(terrainTag)) {
                return true;
            }
        }
    }
    //TODO: Implement user defined colliders
    function createUserDefinedCollidersForMap() {
        return [];
    }
    //TODO: Implement user defined colliders
    function createUserDefinedCollidersForProjectiles() {
        return [];
    }
    function createTilemapCollidersForMap() {
        let colliders = [];
        let tw = $gameMap.tileWidth();
        let th = $gameMap.tileHeight();
        for (let x = 0; x < $gameMap.width(); x++) {
            for (let y = 0; y < $gameMap.height(); y++) {
                let isPassable = !isMapCellRestricted(x, y) && isMapCellPassable(x, y);
                if (!isPassable) {
                    let collider = new AACollider({
                        width: tw,
                        height: th,
                        type: 'b',
                        flag: 'tilemap',
                        dx: 0,
                        dy: 0
                    });
                    collider.setPositionXY(x, y, false);
                    colliders.push(collider);
                }
            }
        }
        return colliders;
    }
    function createTilemapCollidersForProjectiles() {
        let colliders = [];
        let tw = $gameMap.tileWidth();
        let th = $gameMap.tileHeight();
        for (let x = 0; x < $gameMap.width(); x++) {
            for (let y = 0; y < $gameMap.height(); y++) {
                let isPassable = !isMapCellRestrictedForProjectile(x, y);
                if (!isPassable) {
                    let collider = new AACollider({
                        width: tw,
                        height: th,
                        type: 'b',
                        flag: 'projectileCollision',
                        dx: 0,
                        dy: 0
                    });
                    collider.setPositionXY(x, y, false);
                    colliders.push(collider);
                }
            }
        }
        return colliders;
    }
})(AAMapCollisionsManager || (AAMapCollisionsManager = {}));
window['AAMapCollisionsManager'] = AAMapCollisionsManager;


class AAMapFlyBonusInstance {
    constructor(mapX, mapY, settings) {
        this.settings = settings;
        this.x = this._convertPointValue(mapX);
        this.y = this._convertPointValue(mapY);
        const r = this.settings.startOffsetRadiusInPx;
        if (r > 1) {
            const anyPointWithOffset = AAMath.getPointsInRadius(this.x, this.y, r);
            const point = anyPointWithOffset[Math.floor(Math.random() * anyPointWithOffset.length)];
            if (point) {
                this.x = point.x;
                this.y = point.y;
            }
        }
    }
    isPhantom() {
        return false;
    }
    image() {
        return this.settings.image;
    }
    speed() {
        return this.settings.flySpeed;
    }
    delay() {
        return this.settings.stayFrames;
    }
    onHit() {
        try {
            //@ts-ignore
            KDCore.Utils.playSE(this.settings.actionSE);
            if (String(this.settings.actionSA).length > 0) {
                //@ts-ignore
                uAPI.scriptAction(this.settings.actionSA, $gamePlayer);
            }
            let value = AAExtendedValues.getSafeEValue(this.settings.hpGainE, 0);
            if (value != null && value != 0)
                this._gainHp(value);
            value = AAExtendedValues.getSafeEValue(this.settings.mpGainE, 0);
            if (value != null && value != 0)
                this._gainMp(value);
            value = AAExtendedValues.getSafeEValue(this.settings.expGainE, 0);
            if (value != null && value > 0)
                this._gainExp(value);
            value = AAExtendedValues.getSafeEValue(this.settings.goldGainE, 0);
            if (value != null && value != 0)
                this._gainGold(value);
        }
        catch (e) {
            console.warn(e);
        }
    }
    _gainHp(value) {
        //@ts-ignore
        uAPI.gainHpForBattler(0, value, false);
    }
    _gainMp(value) {
        //@ts-ignore
        uAPI.gainMpForBattler(0, value, false);
    }
    _gainExp(value) {
        //@ts-ignore
        uAPI.gainExpForParty(value);
    }
    _gainGold(value) {
        //@ts-ignore
        uAPI.gainGoldForParty(value);
    }
    getTargetPoint() {
        return {
            x: this._convertPointValue($gamePlayer.x),
            y: this._convertPointValue($gamePlayer.y)
        };
    }
    _convertPointValue(value) {
        const tw = $gameMap.tileWidth();
        return Number(value * tw + tw / 2);
    }
}
window['AAMapFlyBonusInstance'] = AAMapFlyBonusInstance;


var AAMath;
(function (AAMath) {
    function getDistanceToPlayerFrom(mapPoint) {
        try {
            return $gameMap.distance($gamePlayer.x, $gamePlayer.y, mapPoint.x, mapPoint.y);
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    AAMath.getDistanceToPlayerFrom = getDistanceToPlayerFrom;
    // All in Radius (expect center)
    function getPointsInRadius(x, y, radius) {
        try {
            if (radius == null || radius <= 1)
                return [];
            const points = [];
            for (let i = x - radius; i <= x + radius; i++) {
                for (let j = y - radius; j <= y + radius; j++) {
                    if (Math.sqrt(Math.pow((i - x), 2) + Math.pow((j - y), 2)) <= radius) {
                        points.push({ x: i, y: j });
                    }
                }
            }
            return points.filter(p => p.x !== x && p.y !== y);
        }
        catch (e) {
            console.warn(e);
            return [];
        }
    }
    AAMath.getPointsInRadius = getPointsInRadius;
    function distance(p1, p2) {
        return Math.sqrt(distanceQuick(p1, p2));
    }
    AAMath.distance = distance;
    function distanceXY(x1, y1, x2, y2) {
        return distance({ x: x1, y: y1 }, { x: x2, y: y2 });
    }
    AAMath.distanceXY = distanceXY;
    function distanceQuick(p1, p2) {
        return Math.pow((p1.x - p2.x), 2) + Math.pow((p1.y - p2.y), 2);
    }
    AAMath.distanceQuick = distanceQuick;
    function distanceQuickXY(x1, y1, x2, y2) {
        return distanceQuick({ x: x1, y: y1 }, { x: x2, y: y2 });
    }
    AAMath.distanceQuickXY = distanceQuickXY;
    function getRandomDirection(includeDiagonals) {
        if (!includeDiagonals) {
            //@ts-ignore
            return Math.randomInt(4) * 2 + 2;
        }
        else {
            //@ts-ignore
            let direction = Math.randomInt(8) + 1;
            if (direction == 5)
                return 2;
            return direction;
        }
    }
    AAMath.getRandomDirection = getRandomDirection;
    function getDirectionVector(direction) {
        switch (direction) {
            case 1: return { x: -1, y: 1 };
            case 3: return { x: 1, y: 1 };
            case 7: return { x: -1, y: -1 };
            case 9: return { x: 1, y: -1 };
            case 2: return { x: 0, y: 1 };
            case 4: return { x: -1, y: 0 };
            case 6: return { x: 1, y: 0 };
            case 8: return { x: 0, y: -1 };
        }
        return { x: 0, y: 0 };
    }
    AAMath.getDirectionVector = getDirectionVector;
    function getNextPoint(startPoint, directionVector, distance) {
        return { x: startPoint.x + directionVector.x * distance, y: startPoint.y + directionVector.y * distance };
    }
    AAMath.getNextPoint = getNextPoint;
    function getDirectionVetorToPoint(startPoint, endPoint, normalized) {
        let vector = { x: endPoint.x - startPoint.x, y: endPoint.y - startPoint.y };
        if (normalized) {
            return normalizePoint(vector);
        }
        return vector;
    }
    AAMath.getDirectionVetorToPoint = getDirectionVetorToPoint;
    function convertDirectionVectorToNumberDirection(vector) {
        vector = normalizePoint(vector);
        if (vector.x == 0 && vector.y == 0)
            return 0;
        if (vector.x == 0) {
            if (vector.y > 0)
                return 2;
            if (vector.y < 0)
                return 8;
        }
        if (vector.y == 0) {
            if (vector.x > 0)
                return 6;
            if (vector.x < 0)
                return 4;
        }
        if (vector.x > 0) {
            if (vector.y > 0)
                return 3;
            if (vector.y < 0)
                return 9;
        }
        if (vector.x < 0) {
            if (vector.y > 0)
                return 1;
            if (vector.y < 0)
                return 7;
        }
        return 0;
    }
    AAMath.convertDirectionVectorToNumberDirection = convertDirectionVectorToNumberDirection;
    function convert8DirectionTo4Direction(direction) {
        switch (direction) {
            case 1: return 4;
            case 3: return 6;
            case 7: return 4;
            case 9: return 6;
        }
        return direction;
    }
    AAMath.convert8DirectionTo4Direction = convert8DirectionTo4Direction;
    function normalizePoint(point) {
        let length = Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        if (length == 0)
            return { x: 0, y: 0 };
        return { x: point.x / length, y: point.y / length };
    }
    AAMath.normalizePoint = normalizePoint;
    function getFacingAngleFromTo(point1, point2, useRadians = false) {
        let dx = point2.x - point1.x;
        let dy = point2.y - point1.y;
        return Math.atan2(dy, dx) * (useRadians ? 1 : Vector2Const.TO_DEGREES);
    }
    AAMath.getFacingAngleFromTo = getFacingAngleFromTo;
    /**
     * Retrieves an array of points representing the adjacent points in a square grid around a given center point,
     * including the center point itself.
     *
     * @param x - The x-coordinate of the center point.
     * @param y - The y-coordinate of the center point.
     * @param distance - The distance from the center point to the edge of the square. Defaults to 2.
     * @returns An array of points (IPoint[]) representing the adjacent points in the square grid, including the center point.
     * @throws Will log a warning to the console if an error occurs during the execution.
     */
    function getAdjacentPointsInSquareIncludeCenter(x, y, distance = 2) {
        try {
            let points = getAdjacentPointsInSquare(x, y, distance);
            points.push({ x, y });
            return points;
        }
        catch (error) {
            console.warn(error);
        }
        return [];
    }
    AAMath.getAdjacentPointsInSquareIncludeCenter = getAdjacentPointsInSquareIncludeCenter;
    /**
     * Returns an array of points that are adjacent to a given point (x, y) within a specified distance.
     * The points are calculated in a square pattern around the given point.
     *
     * @param x - The x-coordinate of the central point.
     * @param y - The y-coordinate of the central point.
     * @param distance - The distance from the central point to the adjacent points. Defaults to 1.
     * @returns An array of points that are adjacent to the given point within the specified distance.
     */
    function getAdjacentPointsInSquare(x, y, distance = 1) {
        try {
            let points = [];
            for (let i = -distance; i <= distance; i++) {
                for (let j = -distance; j <= distance; j++) {
                    if (i == 0 && j == 0)
                        continue;
                    points.push({ x: x + i, y: y + j });
                }
            }
            return points;
        }
        catch (error) {
            console.warn(error);
        }
        return [];
    }
    AAMath.getAdjacentPointsInSquare = getAdjacentPointsInSquare;
    /**
     * Determines if a point (`who`) is looking at another point (`at`) based on a given direction.
     *
     * @param whoLooking - The point that is looking.
     * @param lookTarget - The point being looked at.
     * @param lookDirection - The direction in which `who` is looking.
     *                       It can be one of the following values:
     *                       - 2: Down
     *                       - 4: Left
     *                       - 6: Right
     *                       - 8: Up
     *                       - 1: Down-Left
     *                       - 3: Down-Right
     *                       - 7: Up-Left
     *                       - 9: Up-Right
     * @returns `true` if `who` is looking at `at` in the specified direction, otherwise `false`.
     */
    function isLookingAt(whoLooking, lookTarget, lookDirection) {
        try {
            let x = whoLooking.x;
            let y = whoLooking.y;
            let x2 = lookTarget.x;
            let y2 = lookTarget.y;
            switch (lookDirection) {
                case 2:
                    return y2 > y;
                case 4:
                    return x2 < x;
                case 6:
                    return x2 > x;
                case 8:
                    return y2 < y;
                case 1:
                    return y2 > y && x2 < x;
                case 3:
                    return y2 > y && x2 > x;
                case 7:
                    return y2 < y && x2 < x;
                case 9:
                    return y2 < y && x2 > x;
                default: return false;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AAMath.isLookingAt = isLookingAt;
    function getNearestPointFromArray(position, targets) {
        try {
            let nearestPoint = null;
            let nearestDistance = Number.MAX_VALUE;
            for (let i = 0; i < targets.length; i++) {
                let distance = distanceQuick(position, targets[i]);
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestPoint = targets[i];
                }
            }
            return nearestPoint;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    AAMath.getNearestPointFromArray = getNearestPointFromArray;
})(AAMath || (AAMath = {}));


class AAMovePath {
    constructor(path) {
        this.path = path;
        this.index = 0;
    }
    points() {
        return this.path;
    }
    isValidPath() {
        return this.path && this.path.length > 0;
    }
    isPathEnd() {
        return this.index >= this.path.length;
    }
    getPoint() {
        return this.path[this.index];
    }
    getGoalPoint() {
        return this.path[this.path.length - 1];
    }
    onPointReached() {
        this.index++;
    }
    getPreivousPoint() {
        if (this.index > 0) {
            return this.path[this.index - 1];
        }
        return null;
    }
}
window['AAMovePath'] = AAMovePath;


var AAMultiProjectilesHelper;
(function (AAMultiProjectilesHelper) {
    function startMultiProjectile(skill, user) {
        try {
            let mode = skill.gMultiProjectileMode();
            let projectileDirections = [];
            switch (mode) {
                case 1: // 4 directions
                    projectileDirections = [2, 4, 6, 8];
                    break;
                case 2: // only diagonal
                    projectileDirections = [1, 3, 7, 9];
                    break;
                case 3: // all directions
                    projectileDirections = [1, 2, 3, 4, 6, 7, 8, 9];
                    break;
                case 4: // custom directions
                    projectileDirections = skill.getMultiProjectileModeCustomSet();
                    break;
                default: // handle unexpected mode
                    console.warn("Unexpected multi projectile mode:", mode);
                    break;
            }
            // * Мы должны повернуть направления с учетом направления персонажа
            if (mode == 4 && skill.isMultiProjectileFixed()) {
                projectileDirections = rotateProjectileDirections(user, projectileDirections);
            }
            let targetPositions = projectileDirections.map((dir) => {
                let direcitonVector = AAMath.getDirectionVector(dir);
                return AAMath.getNextPoint(user, direcitonVector, 1000);
            });
            for (let position of targetPositions) {
                AAProjectile.Create(user, skill, position);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAMultiProjectilesHelper.startMultiProjectile = startMultiProjectile;
    function rotateProjectileDirections(user, projectileDirections) {
        let userDirection = user.direction();
        let rotatedDirections = [];
        // * Initial (down), don't need to adjust
        if ([1, 2, 3].includes(userDirection)) {
            rotatedDirections = projectileDirections;
        }
        if ([7, 8, 9].includes(userDirection)) {
            // * Reverse directions
            rotatedDirections = projectileDirections.map((dir) => { return 10 - dir; });
        }
        if ([4, 6].includes(userDirection)) {
            // Define clockwise and counterclockwise mappings
            const clockwise = { 1: 3, 2: 6, 3: 9, 6: 8, 9: 7, 8: 4, 7: 1, 4: 2 };
            const counterclockwise = { 1: 7, 2: 4, 3: 1, 6: 2, 9: 3, 8: 6, 7: 9, 4: 8 };
            // Rotate the directions based on the user direction
            rotatedDirections = projectileDirections.map((dir) => {
                if (userDirection == 4) { // Counterclockwise
                    return counterclockwise[dir] || dir;
                }
                else if (userDirection == 6) { // Clockwise
                    return clockwise[dir] || dir;
                }
                return dir; // Default case, no rotation
            });
        }
        console.log("Adjusted projectile directions:", rotatedDirections);
        return rotatedDirections;
    }
})(AAMultiProjectilesHelper || (AAMultiProjectilesHelper = {}));


// Generated by CoffeeScript 2.6.1
// * Глабольный менеджер обработки (отправки) сетевых запросов
var AANetworkManager;

AANetworkManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AANetworkManager;
  (function() {    // * Методы (запросы - отправка на сервер, requests)
    // * ======================================================================
    // -----------------------------------------------------------------------
    // * В этих методах всегда много проверок, чтобы не загружать лишний раз севрер
    _.sendDummyCharacterData = function(ownerId, teamId, uId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("sendDummyCharacterData", {ownerId, teamId, uId});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.sendDisposeDummyCharacter = function(uId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("sendDisposeDummyCharacter", uId);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.refreshPvPGameModeState = function() {
      var e, newState;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        newState = $gameSystem.aaIsPvPActive;
        return this.sendToServer("refreshPvPGameModeState", newState);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.setActorNetworkTeamId = function(actorId, teamId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("setActorNetworkTeamId", {actorId, teamId});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //TODO: В MV другой метод немного
    _.playAnimationOnCharacter = function(character, animationId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (character == null) {
          return;
        }
        if (animationId <= 0) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("playAnimationOnCharacter", {character, animationId});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.playAnimationOnMap = function(x, y, animationId, sx, sy) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (animationId <= 0) {
          return;
        }
        return this.sendToServer("playAnimationOnMap", {x, y, animationId, sx, sy});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.showDamagePopUpOnCharacter = function(character, data) {
      var e, styleId, value;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (character == null) {
          return;
        }
        if (data == null) {
          return;
        }
        character = AA.Network.packMapChar(character);
        styleId = data.settings.id;
        value = data.value;
        return this.sendToServer("showDamagePopUpOnCharacter", {character, styleId, value});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterShakeEffect = function(character, time) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("requestCharacterShakeEffect", {character, time});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterShatterEffect = function(character, dx, dy) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("requestCharacterShatterEffect", {character, dx, dy});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestWeaponAnimation = function(battler, weaponImageId) {
      var character, e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = battler.AACharacter();
        if (character == null) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("requestWeaponAnimation", {character, weaponImageId});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterMotion = function(character, motionType) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (character == null) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("requestCharacterMotion", {character, motionType});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Смена состояния AnimaX (боевая стойка, кастинг, смерть и т.д.)
    // * Свой метод (у AnimaX 1.2 и ниже нету автосинхронизации на этот метод)
    _.animaXChangeState = function(newState, character) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (character == null) {
          return;
        }
        if (!String.any(newState)) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("animaXChangeState", {newState, character});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.executeSA = function(action, character) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("executeSA", {action, character});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Враги с eraseOnDead = 1 синхронизируются автоматически
    _.executeEraseOnDeadAAEvent = function(eventId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("executeEraseOnDeadAAEvent", eventId);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAAEntityObserver = function(character, observerData) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("syncAAEntityObserver", {character, observerData});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAIFlowMachineObserver = function(eventId, observerData) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("syncAIFlowMachineObserver", {eventId, observerData});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAAEnemyBattlerObserver = function(character, observerData) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        return this.sendToServer("syncAAEnemyBattlerObserver", {character, observerData});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.sendTurnTowardCharacter = function(character, point) {
      var e, x, y;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        character = AA.Network.packMapChar(character);
        ({x, y} = point);
        return this.sendToServer("sendTurnTowardCharacter", {character, x, y});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.applyActionOnTarget = function(target, action) {
      var e, skill, subject;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (target == null) {
          return;
        }
        if (action == null) {
          return;
        }
        target = AA.Network.packMapChar(target);
        subject = action._packedSubject;
        skill = action.AASkill().idA;
        return this.sendToServer("applyActionOnTarget", {subject, skill, target});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Добавить MapSkill на карту (визуально, расчёт на мастере карты)
    _.startAASkillOnMap = function(skill, subject, targetPoint, uniqueId) {
      var diagonalDir, direction, e, x, y;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (subject == null) {
          return;
        }
        if (skill == null) {
          return;
        }
        if (targetPoint == null) {
          return;
        }
        direction = subject.direction;
        diagonalDir = subject._diagonalDir;
        subject = AA.Network.packMapChar(subject);
        skill = skill.idA;
        ({x, y} = targetPoint);
        return this.sendToServer("startAASkillOnMap", {
          subject,
          skill,
          targetPoint: {x, y},
          uniqueId,
          direction,
          diagonalDir
        });
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Удалить MapSkill (чисто визуально)
    _.endAASkillOnMap = function(uniqueId) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        return this.sendToServer("endAASkillOnMap", uniqueId);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Когда идёт спавн монстра
    _.spawnEnemy = function(id, x, y) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        // * Спавн точно произошёл?
        if (uAPI.isEnemyBeenSpawned()) {
          return this.sendToServer("spawnEnemy", {id, x, y});
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.gainExpFor = function(char, value, isVisible) {
      var e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (value <= 0) {
          return;
        }
        if (char == null) {
          return;
        }
        char = AA.Network.packMapChar(char);
        return this.sendToServer("gainExpFor", {char, value, isVisible});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Обработка методов ОТ сервера (responses)
    // * ======================================================================
    // -----------------------------------------------------------------------
    _.playAnimationOnCharacter_RESP = function(response) {
      var animationId, character, e;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, animationId} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        return AABattleAnimationsManager.playAnimationOnCharacter(animationId, character);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.playAnimationOnMap_RESP = function(response) {
      var animationId, e, sx, sy, x, y;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({x, y, animationId, sx, sy} = response.content);
        return AABattleAnimationsManager.playAnimationOnMap(animationId, {x, y});
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.showDamagePopUpOnCharacter_RESP = function(response) {
      var character, data, e, ref, styleId, value;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, styleId, value} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (character !== $gamePlayer) {
          styleId = "Damage_HP_For_Enemy";
        }
        data = AADamagePopUpFactory.CreateFromSettings(styleId, value);
        if (data == null) {
          return;
        }
        Sprite_AADamagePopUpItem.CreateOnCharacterBinded(character, data.settings, data.value);
        // * Чтобы HP минибар обновился
        return (ref = character.AASprite()) != null ? ref._aaRefreshExtraInfoOnDamage() : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterShakeEffect_RESP = function(response) {
      var character, e, time;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, time} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (character.aaIsShakeRequested()) {
          return;
        }
        if ((time != null) && time > 0) {
          return character != null ? character.aaRequestShakeEffect(time) : void 0;
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterShatterEffect_RESP = function(response) {
      var character, dx, dy, e;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, dx, dy} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (character.aaIsShatterRequested()) {
          return;
        }
        return character.aaRequestShatterEffect(dx, dy);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestWeaponAnimation_RESP = function(response) {
      var character, e, ref, weaponImageId;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, weaponImageId} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        return (ref = character.AABattler()) != null ? ref.startWeaponAnimation(weaponImageId) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.requestCharacterMotion_RESP = function(response) {
      var character, e, motionType;
      try {
        //TODO: Есть проблема создания множества DeadMotion
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, motionType} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (motionType != null) {
          if (!character.aaIsMotionRequested()) {
            return character.aaRequestMotion(motionType);
          }
        } else {
          return character.aaClearMotion();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.executeSA_RESP = function(response) {
      var action, character, cmd, e, mapId, unpackedCharacter;
      try {
        ({mapId} = response);
        ({action, character} = response.content);
        cmd = action.split("_")[0];
        // * Self.Switch - своя обработка
        if (cmd === "ss") {
          // * Тут используется  запакованный персонаж (чтобы передать EVENT ID другой карты)
          return AAScriptActions.executeSelfSwitchActionFromNetwork(action, character, mapId);
        } else {
          // * Проверки определённых действий (только на карте и на сцене)
          if (["an", "ef", "ba", "se", "ev", "ce"].contains(cmd)) {
            if (!AA.Network.isAvailableForVisual(response)) {
              return;
            }
          }
          unpackedCharacter = AA.Network.unpackMapChar(character);
          return AAScriptActions.execute(action, unpackedCharacter);
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.executeEraseOnDeadAAEvent_RESP = function(response) {
      var e, event, eventId;
      try {
        // * Тут сцена не важна
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        eventId = response.content;
        if (eventId <= 0) {
          return;
        }
        event = $gameMap.event(eventId);
        if (event == null) {
          return;
        }
        //TODO: Может проверку что это ABS событие?
        return event.erase();
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAAEntityObserver_RESP = function(response) {
      var character, e, observerData, ref;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({character, observerData} = response.content);
        if (observerData == null) {
          return;
        }
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        return (ref = character.AAEntity()) != null ? ref.applyObserverData(observerData) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAIFlowMachineObserver_RESP = function(response) {
      var e, event, eventId, observerData, ref;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({eventId, observerData} = response.content);
        if (eventId <= 0) {
          return;
        }
        if (observerData == null) {
          return;
        }
        event = $gameMap.event(eventId);
        if (event == null) {
          return;
        }
        if (event.isABS() == null) {
          return;
        }
        return (ref = event.AALogic()) != null ? ref.applyObserverData(observerData) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.syncAAEnemyBattlerObserver_RESP = function(response) {
      var character, e, observerData, ref;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({character, observerData} = response.content);
        if (observerData == null) {
          return;
        }
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        return (ref = character.AABattler()) != null ? ref.applyObserverData(observerData) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.animaXChangeState_RESP = function(response) {
      var character, e, newState;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({character, newState} = response.content);
        character = AA.Network.unpackMapChar(character);
        if (character == null) {
          return;
        }
        if (String.any(newState) == null) {
          return;
        }
        if (!character.isAnimX()) {
          return;
        }
        if (newState === 'base') {
          return character.resetXAnimaState();
        } else {
          return character.switchToXAnimaState(newState);
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.sendTurnTowardCharacter_RESP = function(response) {
      var character, e, x, y;
      try {
        if (!AA.Network.isAvailableForVisual(response)) {
          return;
        }
        ({character, x, y} = response.content);
        character = AA.Network.unpackMapChar(character);
        return character != null ? character.turnTowardCharacter({x, y}) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.applyActionOnTarget_RESP = function(response) {
      var action, e, skill, subject, target;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({subject, skill, target} = response.content);
        // * Мы брали запакованный Subject из Game_Action напрямую,
        // а там он так упакован (через AA.Utils)
        subject = AA.Utils.unpackAAEntity(subject);
        if (subject == null) {
          return;
        }
        skill = AA.Utils.unpackAASkill(skill);
        if (skill == null) {
          return;
        }
        action = new AABattleAction(subject, skill);
        target = AA.Network.unpackMapChar(target);
        if (target == null) {

        }
      } catch (error) {
        //TODO:!!!!
        //AABattleActionsManager._applyActionOnTarget(target, action)
        e = error;
        return AA.w(e);
      }
    };
    _.startAASkillOnMap_RESP = function(response) {
      var diagonalDir, direction, e, skill, subject, targetPoint, uniqueId;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({subject, skill, targetPoint, uniqueId, direction, diagonalDir} = response.content);
        subject = AA.Network.unpackMapChar(subject);
        if (subject == null) {
          return;
        }
        subject.setDirection(direction);
        subject._diagonalDir = diagonalDir;
        skill = AA.Utils.unpackAASkill(skill);
        if (skill == null) {
          return;
        }
        $gameMap.startAASkill(skill, subject, targetPoint);
        // * Метод на gameMap () сохраняет последний созданный
        // * навык в $gameTemp.__lastAAMapSkill, чтобы можно
        // * было установить ID из сети (по индексу нельзя)
        if ($gameTemp.__lastAAMapSkill != null) {
          $gameTemp.__lastAAMapSkill.setUniqueId(uniqueId);
          return $gameTemp.__lastAAMapSkill = null;
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.endAASkillOnMap_RESP = function(response) {
      var e, skill, uniqueId;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        uniqueId = response.content;
        skill = $gameMap.aaMapSkills().find(function(s) {
          return (s != null) && s.uniqueId === uniqueId;
        });
        if (skill == null) {
          return;
        }
        // * Намеренно устанавливаем время в 0, чтобы удалился
        skill.totalFlyTime = 0;
        return skill.forceEndFromNetwork = true;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _.spawnEnemy_RESP = function(response) {
      var e, id, x, y;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({id, x, y} = response.content);
        return uAPI.spawnEnemyForced(id, x, y);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.refreshPvPGameModeState_RESP = function(response) {
      var e, newState;
      try {
        newState = response.content;
        // * Not using uAPI for not send to server again
        if (newState === true) {
          return AA.Network.setPvPMode();
        } else {
          return AA.Network.setPvEMode();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.setActorNetworkTeamId_RESP = function(response) {
      var actorId, e, teamId;
      try {
        ({actorId, teamId} = response.content);
        return uAPI.setTeamIdFor("actorId", actorId, teamId, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.sendDummyCharacterData_RESP = function(response) {
      var dummyChar, e, ownerId, teamId, uId;
      try {
        if (!AA.Network.isOnSameMap(response)) {
          return;
        }
        ({ownerId, teamId, uId} = response.content);
        return dummyChar = new AADummyCharacter(ownerId, teamId, uId);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.sendDisposeDummyCharacter_RESP = function(response) {
      var e, uId;
      try {
        uId = response.content;
        if (uId != null) {
          return $gameMap.aaDisposeGlobalSkill(uId);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.gainExpFor_RESP = function(responce) {
      var char, e, isVisible, value;
      try {
        if (responce == null) {
          return;
        }
        ({char, value, isVisible} = responce.content);
        char = AA.Network.unpackMapChar(char);
        if (char === $gamePlayer) {
          $gameParty.leader().gainExp(value);
          if (isVisible === true) {
            return $gameParty._aaShowExpPopUpVisually([char], value);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  return (function() {    // * Общие методы отправки и приёма команд
    // * ======================================================================
    // -----------------------------------------------------------------------
    // * Обработка ответа (команды) от сервера (общий метод)
    _.onServerCommand = function(cmd, response) {
      var e, method;
      try {
        //return if SceneManager.isSceneChanging()
        if (AA.Network.isShouldIgnoreServerCommand(response)) {
          return;
        }
        // * Получить только имя команды (без префикса)
        //cmd = cmd.replace(AA.Network.NETCmdPrefix, "")
        method = this[cmd + "_RESP"];
        if (method != null) {
          $gameTemp.aaIsLocalOnly = true;
          try {
            method(response);
          } catch (error) {
            e = error;
            AA.w(cmd, e);
          }
          return $gameTemp.aaIsLocalOnly = false;
        } else {
          return AA.w('Network: Handler for ' + cmd + ' not found');
        }
      } catch (error) {
        e = error;
        return AA.w(e, "onServerCommand");
      }
    };
    // * Отправка команды на сервер (общий метод)
    return _.sendToServer = function(cmd, content) {
      var data, e;
      try {
        if ($gameTemp.aaIsLocalOnly === true) {
          return;
        }
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        if (SceneManager.isSceneChanging()) {
          return;
        }
        // * Все команды только с карыт можно отправлять
        if (!AAUtils.isSceneMap()) {
          return;
        }
        // * Это старый способ (через nAPI)
        /*nAPI.sendCustomCommand(
            AA.Network.NETCmdPrefix + cmd,
            AA.Network.createServCommand(content)
        )*/
        data = AA.Network.createServCommand(content);
        return ANNetwork.send(NMS.ABSZ(cmd, data));
      } catch (error) {
        e = error;
        return AA.w(e, "sendToServer");
      }
    };
  })();
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


var AAParametersParser;
(function (AAParametersParser) {
    //TODO: check classes @ts-ignore after
    //TODO: check types (any???)
    // * Преобразовывает значение (строка или цифра)
    function convertParameterValue(paramValue) {
        if (isFinite(paramValue)) {
            return Number(paramValue);
        }
        else {
            if (paramValue == "true") {
                return 1;
            }
            else if (paramValue == "false") {
                return 0;
            }
            else {
                return paramValue;
            }
        }
    }
    AAParametersParser.convertParameterValue = convertParameterValue;
    // * Извлекает из строки (линии) имя параметра и его значение
    function extractABSParameter(line) {
        let match;
        // * Для параметров одиночных < >
        if (line.match(/<.*>/i)) {
            match = line.match(/<(\w+)\s*:\s*(.+)>/i);
        }
        else { // * Для параметров в группе (без < > )
            match = line.match(/(\w+)\s*:\s*(.+)/i);
        }
        if (match) {
            const name = match[1];
            const value = convertParameterValue(match[2]);
            return [name, value];
        }
        else {
            return null;
        }
    }
    AAParametersParser.extractABSParameter = extractABSParameter;
    // * Извлекает из строки (линии) значение конкретного параметра
    // * Например используется чтобы достать ID врага из <ABS:X>
    function _extractCertainABSParameter(name, line) {
        const param = extractABSParameter(line);
        // * Если в этой строке есть этот параметр, то вернём его значение
        if (param && param[0] == name) {
            return param[1];
        }
        else {
            // * Иначе нету ничего
            return null;
        }
    }
    // * Shortcut для проверки ABS событий
    function getABSEnemyId(line) {
        return _extractCertainABSParameter('ABS', line);
    }
    AAParametersParser.getABSEnemyId = getABSEnemyId;
    // *  Извлечь линии (строки) АБС параметров из группы в Note
    function parseNoteGroup(tag, note) {
        try {
            let result = [];
            const sTag = "<" + tag;
            const eTag = "</" + tag + ">";
            const notes = note.split(/[\r\n]+/);
            let startLineIndex = -1;
            let endLineIndex = -1;
            for (let index = 0; index < notes.length; index++) {
                const line = notes[index];
                if (line.includes(sTag)) {
                    startLineIndex = index + 1; // * Себя не включает начальный таг
                }
                if (startLineIndex >= 0 && line.includes(eTag)) {
                    endLineIndex = index;
                    break;
                }
            }
            if (startLineIndex > -1 && endLineIndex > -1) {
                result = notes.slice(startLineIndex, endLineIndex);
            }
            return result;
        }
        catch (e) {
            console.warn(e);
            return [];
        }
    }
    AAParametersParser.parseNoteGroup = parseNoteGroup;
    // * Для навыков (навыки, оружие, предметы)
    function processABSSkillsNotetags() {
        //TODO: Оружие не имеет своих ABS параметров, только ссылка на НАВЫК
        for (const item of $dataSkills) {
            if (!item)
                continue;
            _processABSSkillParamsInItem(item, false);
        }
        for (const item of $dataItems) {
            if (!item)
                continue;
            _processABSSkillParamsInItem(item, true);
            _processABSExtensionItemParamsInItem(item);
        }
        //TODO: checkWeapon aaAttackSkill Note
        _checkInitialAttackABSSkill();
    }
    AAParametersParser.processABSSkillsNotetags = processABSSkillsNotetags;
    // * Для врагов
    function processABSEnemiesNotetags() {
        for (const item of $dataEnemies) {
            if (!item)
                continue;
            _processABSEnemyParams(item);
        }
    }
    AAParametersParser.processABSEnemiesNotetags = processABSEnemiesNotetags;
    // * Для персонажей (члены партии)
    function processABSActorsNotetags() {
        for (const item of $dataActors) {
            if (!item)
                continue;
            _processABSAllyParams(item);
        }
    }
    AAParametersParser.processABSActorsNotetags = processABSActorsNotetags;
    // * Для состояний
    function processABSStatesNotetags() {
        for (const item of $dataStates) {
            if (!item)
                continue;
            _processABSStateParamsInItem(item);
        }
    }
    AAParametersParser.processABSStatesNotetags = processABSStatesNotetags;
    // * Для оржуия AAExt
    function processABSWeaponsNotetags() {
        try {
            for (const item of $dataWeapons) {
                if (!item)
                    continue;
                _processABSExtensionParamsInWeapon(item);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    AAParametersParser.processABSWeaponsNotetags = processABSWeaponsNotetags;
    // * Навык атаки всегда должен быть АБС 0
    function _checkInitialAttackABSSkill() {
        try {
            const attackSkill = $dataSkills[1];
            // * Если игрок не настроил навык Атаки, то применим стандартные настройки
            //@ts-ignore
            if (!attackSkill.meta.ABS) {
                //@ts-ignore
                attackSkill.meta.ABS = true;
                //@ts-ignore
                attackSkill.idA = 1;
                //@ts-ignore
                attackSkill.AASkill = new AASkill2(attackSkill.idA);
                //@ts-ignore
                attackSkill.AASkill.applyDefaultAttack001();
            }
        }
        catch (e) {
            console.error(e, 'Something wrong with Attack skill [1] settings');
        }
    }
    function _processABSSkillParamsInItem(item, isItem) {
        var _a;
        if (!((_a = item.meta) === null || _a === void 0 ? void 0 : _a.ABS))
            return;
        try {
            const params = [];
            const paramsRaw = _extractABSParametersFromDBItem(item);
            for (const param of paramsRaw) {
                const paramPair = extractABSParameter(param);
                if (paramPair)
                    params.push(paramPair);
            }
            // * АБС использует свой ID, чтобы предметы и навыки различать
            item.idA = item.id;
            //@ts-ignore
            if (isItem)
                item.idA += AAITEMS_ID_START;
            // * Данные АБС навыка храняться у предмета
            //@ts-ignore
            item.AASkill = new AASkill2(item.idA);
            item.AASkill.setNoteParameters(params);
        }
        catch (e) {
            console.warn(e);
        }
    }
    function _processABSExtensionItemParamsInItem(item) {
        if (!item)
            return;
        if (!item.meta)
            return;
        if (!item.meta['AAExt'])
            return;
        try {
            const params = [];
            const paramsRaw = parseNoteGroup("AAExt", item.note);
            for (const param of paramsRaw) {
                const paramPair = extractABSParameter(param);
                if (paramPair)
                    params.push(paramPair);
            }
            // * Данные АБС навыка храняться у предмета
            let extensionItem = new AASkillExtensionItem(item.id);
            extensionItem.setNoteParameters(params);
            item['AAExtItem'] = extensionItem;
        }
        catch (e) {
            console.warn(e);
        }
    }
    function _processABSExtensionParamsInWeapon(item) {
        if (!item)
            return;
        if (!item.meta)
            return;
        if (!item.meta['AAExt'])
            return;
        try {
            const params = [];
            const paramsRaw = parseNoteGroup("AAExt", item.note);
            for (const param of paramsRaw) {
                const paramPair = extractABSParameter(param);
                if (paramPair)
                    params.push(paramPair);
            }
            // * Данные АБС навыка храняться у предмета
            let extension = new AASkillExtensionDefinition(item.id);
            extension.setNoteParameters(params);
            item['AAExtDefinition'] = extension;
        }
        catch (e) {
            console.warn(e);
        }
    }
    // * Извлечь группу из объекта ДБ
    function _extractABSParametersFromDBItem(item) {
        var _a;
        try {
            if ((_a = item.meta) === null || _a === void 0 ? void 0 : _a.ABS) {
                return parseNoteGroup("ABS", item.note);
            }
        }
        catch (e) {
            console.warn(e);
        }
        return [];
    }
    // * Извлекает из строки (линии) имя параметра и его значение
    // * Учитывается сложный параметр (массив или строка)
    function extractABSParameterAny(line) {
        const match = line.match(/<*(\w+)\s*:\s*([\d,\w\s*]+)>*/i);
        if (match) {
            const name = match[1];
            const value = match[2];
            return [name, value];
        }
        else {
            return null;
        }
    }
    AAParametersParser.extractABSParameterAny = extractABSParameterAny;
    // * Конвертирует массив из строки 1,2,3 в [1, 2, 3] (цифры)
    function convertArrayFromParameter(values) {
        if (values == null || values == undefined)
            return [];
        if (values instanceof Array)
            return values;
        try {
            // * Тут надо toString, так как может быть только цифра одна
            return values.toString().split(",").map((i) => parseInt(i.trim()));
        }
        catch (e) {
            console.warn(e);
            return [];
        }
    }
    AAParametersParser.convertArrayFromParameter = convertArrayFromParameter;
    // * Чтение параметров врагов
    function _processABSEnemyParams(item) {
        var _a;
        if (!((_a = item.meta) === null || _a === void 0 ? void 0 : _a.ABS))
            return;
        try {
            const params = [];
            const paramsRaw = _extractABSParametersFromDBItem(item);
            for (const param of paramsRaw) {
                const paramPair = extractABSParameter(param);
                if (paramPair)
                    params.push(paramPair);
            }
            item.AAEnemy = params;
        }
        catch (e) {
            console.warn(e);
        }
    }
    // * Чтение параметров персонажей
    function _processABSAllyParams(item) {
        var _a;
        if (!((_a = item.meta) === null || _a === void 0 ? void 0 : _a.ABS))
            return;
        try {
            const params = [];
            const paramsRaw = _extractABSParametersFromDBItem(item);
            for (const param of paramsRaw) {
                const paramPair = extractABSParameter(param);
                if (paramPair)
                    params.push(paramPair);
            }
            item.AAAllyChar = params;
        }
        catch (e) {
            console.warn(e);
        }
    }
    // * Чтение параметров состояний
    function _processABSStateParamsInItem(item) {
        var _a;
        if (!((_a = item.meta) === null || _a === void 0 ? void 0 : _a.ABS))
            return;
        try {
            const params = [];
            const paramsRaw = _extractABSParametersFromDBItem(item);
            for (const param of paramsRaw) {
                const paramPair = extractABSParameter(param);
                if (paramPair)
                    params.push(paramPair);
            }
            // * Данные АБС состояния храняться у состояния
            //@ts-ignore
            item.AAState = new AAState(item.id);
            item.AAState.setNoteParameters(params);
        }
        catch (e) {
            console.warn(e);
        }
    }
})(AAParametersParser || (AAParametersParser = {}));
window['AAParametersParser'] = AAParametersParser;


var AAPathMover;
(function (AAPathMover) {
    function isHavePathFor(char) {
        return getMovePathFor(char) != null;
    }
    AAPathMover.isHavePathFor = isHavePathFor;
    function getMovePathFor(char) {
        return char['_aaMovePath'];
    }
    AAPathMover.getMovePathFor = getMovePathFor;
    function startMoveByPath(char, path) {
        stopMoveByPath(char);
        //console.log('Start move by path');
        char['_aaMovePath'] = new AAMovePath(path);
    }
    AAPathMover.startMoveByPath = startMoveByPath;
    function stopMoveByPath(char) {
        if (!char['_aaMovePath']) {
            return;
        }
        //console.log('Stop move by path');
        char['_aaMovePath'] = null;
        AACharMovementUtils.applyLocation(char);
    }
    AAPathMover.stopMoveByPath = stopMoveByPath;
    function updateMoveByPathFor(char) {
        try {
            let path = getMovePathFor(char);
            if (!path)
                return;
            if (!path.isValidPath()) {
                stopMoveByPath(char);
                return;
            }
            getMoveFunction()(char, path);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAPathMover.updateMoveByPathFor = updateMoveByPathFor;
    function getMoveFunction() {
        if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            return translationPathMoveFunction;
        }
        else {
            return directionStepsPathMoveFunction;
        }
    }
    function translationPathMoveFunction(char, path) {
        AACharMovementUtils.translateCharacterToPoint(char, path.getPoint(), false, 1, () => {
            path.onPointReached();
            if (path.isPathEnd()) {
                stopMoveByPath(char);
            }
        });
    }
    function directionStepsPathMoveFunction(char, path) {
        try {
            let point = path.getPoint();
            //console.log('Move to point', point.x, point.y);
            if (char.pos(point.x, point.y)) {
                //console.log('Point reached', point.x, point.y);
                path.onPointReached();
                if (path.isPathEnd()) {
                    stopMoveByPath(char);
                    return;
                }
            }
            else {
                if (char.isMoving()) {
                    return;
                }
                //@ts-ignore
                char.moveTowardCharacter(point);
                if (!char.isMovementSucceeded(point.x, point.y)) {
                    //console.log("Move not succeeded", point.x, point.y);
                    stopMoveByPath(char);
                }
            }
        }
        catch (error) {
            console.warn(error);
            if (char) {
                stopMoveByPath(char);
            }
        }
    }
})(AAPathMover || (AAPathMover = {}));
window['AAPathMover'] = AAPathMover;


var AAPluginParams;
(function (AAPluginParams) {
    AAPluginParams._loader = null;
    /**
        * Load plugin settings
    */
    function loadPluginSettings() {
        AAPluginParams._loader = new KDX.ParamLoader("AABSZ");
    }
    AAPluginParams.loadPluginSettings = loadPluginSettings;
    /**
        * Get parameter from plugin settings
        * @param {string} paramName - Name of parameter
        * @param {any} defaultValue - Default value if not found
        * @returns {any} - Value of parameter
    */
    function getLoaderParam(paramName, defaultValue) {
        try {
            if (!AAPluginParams._loader) {
                loadPluginSettings();
            }
            return AAPluginParams._loader.getParam(paramName, defaultValue);
        }
        catch (error) {
            console.warn(error);
            return null;
        }
    }
    function getDiagonalMoveSpeedMod() {
        return getLoaderParam("diagonalMoveSpeedMod", 0.95);
    }
    AAPluginParams.getDiagonalMoveSpeedMod = getDiagonalMoveSpeedMod;
    function isUseExtendedMovementSystem() {
        return getLoaderParam("useExtendedMovementSystem", true);
    }
    AAPluginParams.isUseExtendedMovementSystem = isUseExtendedMovementSystem;
    // * Only 48, 24, 16, 12
    function getMovementGridSize() {
        let size = getLoaderParam("movementGridSize", 24);
        if (size != 48 && size != 24 && size != 16 && size != 12) {
            console.warn("Invalid movement grid size! Defaulting to 24.");
            return 24;
        }
        return size;
    }
    AAPluginParams.getMovementGridSize = getMovementGridSize;
    function getEventDefaultColliderConfig() {
        return getLoaderParam("eventDefaultColliderConfig", {
            flag: 'event',
            type: "c",
            width: 0,
            height: 0,
            radius: 14,
            dx: 0,
            dy: 4
        });
    }
    AAPluginParams.getEventDefaultColliderConfig = getEventDefaultColliderConfig;
    function getActorDefaultColliderConfig() {
        return getLoaderParam("actorDefaultColliderConfig", {
            flag: 'char',
            type: "c",
            width: 0,
            height: 0,
            radius: 10,
            dx: 0,
            dy: 12
        });
    }
    AAPluginParams.getActorDefaultColliderConfig = getActorDefaultColliderConfig;
    function getEventDefaultInteractionColliderConfig() {
        return getLoaderParam("eventDefaultInteractionColliderConfig", {
            flag: 'interaction',
            type: "c",
            width: 0,
            height: 0,
            radius: 30,
            dx: 0,
            dy: 8
        });
    }
    AAPluginParams.getEventDefaultInteractionColliderConfig = getEventDefaultInteractionColliderConfig;
    function isEnemiesShouldHaveDefaultCollider() {
        return getLoaderParam("enemiesShouldHaveDefaultCollider", false);
    }
    AAPluginParams.isEnemiesShouldHaveDefaultCollider = isEnemiesShouldHaveDefaultCollider;
    function getEnemyDefaultHitBoxConfig() {
        return getLoaderParam("enemyDefaultHitBoxConfig", {
            flag: 'hitbox',
            type: "b",
            width: 36,
            height: 42,
            radius: 18,
            dx: 0,
            dy: -4
        });
    }
    AAPluginParams.getEnemyDefaultHitBoxConfig = getEnemyDefaultHitBoxConfig;
    function getActorDefaultHitBoxConfig() {
        return getLoaderParam("actorDefaultHitBoxConfig", {
            flag: 'hitbox',
            type: "b",
            width: 36,
            height: 42,
            radius: 18,
            dx: 0,
            dy: -4
        });
    }
    AAPluginParams.getActorDefaultHitBoxConfig = getActorDefaultHitBoxConfig;
    function getShowPathfindingGridKey() {
        return getLoaderParam("showPathfindingGridKey", "p");
    }
    AAPluginParams.getShowPathfindingGridKey = getShowPathfindingGridKey;
    function getShowCollisionLayerKey() {
        return getLoaderParam("showCollisionLayerKey", "c");
    }
    AAPluginParams.getShowCollisionLayerKey = getShowCollisionLayerKey;
    function getShowProjectilesCollisionLayerKey() {
        return getLoaderParam("showProjectilesCollisionLayerKey", "j");
    }
    AAPluginParams.getShowProjectilesCollisionLayerKey = getShowProjectilesCollisionLayerKey;
    function isHighlightInteractableEvents() {
        return getLoaderParam("highlightInteractableEvents", true);
    }
    AAPluginParams.isHighlightInteractableEvents = isHighlightInteractableEvents;
    function isHighlightInteractableEventsUnderCursor() {
        return getLoaderParam("highlightInteractableEventsUnderCursor", true);
    }
    AAPluginParams.isHighlightInteractableEventsUnderCursor = isHighlightInteractableEventsUnderCursor;
    function getProjectileForbiddenRegions() {
        return getLoaderParam("noProjectilesPassRegionIds", []);
    }
    AAPluginParams.getProjectileForbiddenRegions = getProjectileForbiddenRegions;
    function getProjectileFrobiddenTerrainTags() {
        return getLoaderParam("noProjectilesPassTerrainTags", []);
    }
    AAPluginParams.getProjectileFrobiddenTerrainTags = getProjectileFrobiddenTerrainTags;
    function getNotPassableRegions() {
        return getLoaderParam("noMovementPassRegionIds", []);
    }
    AAPluginParams.getNotPassableRegions = getNotPassableRegions;
    function getNotPassableTerrainTags() {
        return getLoaderParam("noMovementPassTerrainTags", []);
    }
    AAPluginParams.getNotPassableTerrainTags = getNotPassableTerrainTags;
    //TODO: Implement later
    function isMobileDevicePriority() {
        return getLoaderParam("mobileDevicePriority", false);
    }
    AAPluginParams.isMobileDevicePriority = isMobileDevicePriority;
})(AAPluginParams || (AAPluginParams = {}));
window["AAPluginParams"] = AAPluginParams;


class AAProjectile {
    static Create(owner, skill, targetPosition) {
        let projectile = new AAProjectile(skill, owner);
        if (skill.isInDirection()) {
            let ownerDirection = owner.direction();
            let directionVector = AAMath.getDirectionVector(ownerDirection);
            projectile.startInDirection(directionVector);
        }
        else if (skill.isInCertainPoint()) {
            projectile.startToPosition(targetPosition);
        }
        else { // isInPointDirection
            let directionToTarget = AAMath.getDirectionVetorToPoint(owner, targetPosition, false);
            projectile.startInDirection(directionToTarget);
        }
        if (skill.isHomingProjectile()) {
            projectile.setStickToNearestTarget(true);
        }
        AAProjectileManager.addProjectile(projectile);
    }
    static ExtractOffset(char) {
        try {
            if (char instanceof Game_Event) {
                let offsetValue = KGameEvents.GetCommentCodeValue('vectorOffset', char);
                if (KString.any(offsetValue)) {
                    return parseInt(offsetValue);
                }
            }
            else {
                //@ts-ignore
                let actor = AsAAChar(char).AABattler().actor();
                return KGameItems.GetMetaAsNumber('vectorOffset', actor, 0);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    constructor(skill, owner) {
        this._owner = null;
        this._followTarget = null;
        this._stickToNearestTarget = false;
        this._followRefreshTimer = 0;
        this._isRestored = false;
        this._outOfScreenCheckTimer = 0;
        this._collider = null;
        this._flySpeed = 0.05;
        this._isDisposed = false;
        this._isCanHitPosition = false;
        this._isCanHitSameTarget = false;
        this._piercedTargetsLeft = 0;
        this._hittedActorsIds = [];
        this._hittedEventIds = [];
        this._activatedEventIds = [];
        this._nextCheckFrame = 0;
        //TODO: as skill setting
        this._nextCheckFrameInterval = 3;
        this._isHaveForbiddenRegions = false;
        this._isHaveForbiddenTerrainTags = false;
        this._uniqueId = AAUtils.generateUUID();
        this._skillId = skill.databaseId();
        this._owner = AAEntity.Pack(owner);
        this._startPosition = { x: owner.x, y: owner.y };
        this._targetPosition = { x: 0, y: 0 };
        this._currentPosition = this._startPosition;
        this._checkForbiddenData(skill);
        this._applyStartPointOffset(owner);
        this._readSkillParameters(skill);
        this._createCollider();
    }
    get uniqueId() {
        return this._uniqueId;
    }
    isFollowingAnyTarget() {
        return this._followTarget != null;
    }
    isShouldStickToNearestTarget() {
        return this._stickToNearestTarget;
    }
    isHaveFollowMode() {
        return this.isFollowingAnyTarget() || this.isShouldStickToNearestTarget();
    }
    startToPosition(targetPosition) {
        this._targetPosition = targetPosition;
    }
    startInDirection(directionVector) {
        this._targetPosition = AAMath.getNextPoint(this._currentPosition, directionVector, 1000);
    }
    startFollowTarget(target) {
        this._followTarget = AAEntity.Pack(target);
        this._refreshFollowTarget();
    }
    stopFollowTarget() {
        this._followTarget = null;
    }
    setStickToNearestTarget(value) {
        this._stickToNearestTarget = value;
    }
    ownerCharacter() {
        return AAEntity.Unpack(this._owner);
    }
    skillData() {
        return AASkill2.UnpackAASkill(this._skillId);
    }
    getCollider() {
        return this._collider;
    }
    zLevel() {
        return this.skillData().z;
    }
    isCanRotate() {
        return !this.skillData().isNoRotationImage();
    }
    isDisposed() {
        return this._isDisposed;
    }
    isCanPierceMore() {
        return this._piercedTargetsLeft > 0;
    }
    // We call this method after we recreate projectiles from save or after pause menu
    restore() {
        this._isRestored = true;
    }
    fadeOutTime() {
        if (this._isRestored) {
            return 0;
        }
        else
            return 0.5;
    }
    projectileHeadImage() {
        return this.skillData().skillImg;
    }
    currentPositionOnMap() {
        return this._currentPosition;
    }
    currentPositionOnScreen() {
        return AAUtils.mapPointToScreenPoint(this._currentPosition);
    }
    targetPositionOnMap() {
        return this._targetPosition;
    }
    targetPositionOnScreen() {
        return AAUtils.mapPointToScreenPoint(this._targetPosition);
    }
    update() {
        if (this.isDisposed()) {
            return;
        }
        this._updateFollowMode();
        this._updatePosition();
        if (this._nextCheckFrame != this._nextCheckFrameInterval) {
            this._nextCheckFrame += 1;
        }
        else {
            this._updateProjectileCollision();
            this._nextCheckFrame = 0;
        }
    }
    _checkForbiddenData(skill) {
        if (skill.noPassRegions && skill.noPassRegions.length > 0) {
            this._isHaveForbiddenRegions = true;
        }
        if (skill.noPassTerrains && skill.noPassTerrains.length > 0) {
            this._isHaveForbiddenTerrainTags = true;
        }
        if (AAPluginParams.getProjectileForbiddenRegions().length > 0) {
            this._isHaveForbiddenRegions = true;
        }
        if (AAPluginParams.getProjectileFrobiddenTerrainTags().length > 0) {
            this._isHaveForbiddenTerrainTags = true;
        }
    }
    _applyStartPointOffset(owner) {
        let offset = AAProjectile.ExtractOffset(owner);
        this._startPosition.y += (offset / $gameMap.tileHeight());
    }
    _readSkillParameters(skill) {
        this._flySpeed = skill.gSpeed() / $gameMap.tileWidth();
        this._isCanHitPosition = skill.isInCertainPoint();
        this._isCanHitSameTarget = skill.isCanHitSameTarget();
        this._piercedTargetsLeft = skill.getPiercePower();
    }
    _createCollider() {
        let skill = this.skillData();
        this._collider = new AACollider({
            type: 'c',
            radius: skill.colliderRadius || 8,
            flag: 'projectile'
        });
    }
    //TODO: Add network characters support
    _updateProjectileCollision() {
        this._updateOutOfScreenCheck();
        this._updateDistanceCheck();
        if (this._isCanHitPosition == true) {
            this._updateHitPositionCheck();
        }
        this._updateHitWithMapObstacles();
        this._updateHitWithEntitiesAndEvents();
    }
    _updateOutOfScreenCheck() {
        this._outOfScreenCheckTimer++;
        if (this._outOfScreenCheckTimer >= 20) {
            this._outOfScreenCheckTimer = 0;
            if (!AAUtils.isPointOnScreen(this.currentPositionOnScreen())) {
                this._onOutOfScreen();
            }
        }
    }
    _onOutOfScreen() {
        //console.log('Projectile out of screen');
        this._dispose();
    }
    _dispose() {
        let owner = this.ownerCharacter();
        // Do we need to dispose owner?
        if (owner && owner instanceof AADummyCharacter) {
            setTimeout(() => {
                owner.dispose();
            }, 1000);
        }
        this._isDisposed = true;
        this._collider = null;
        AAProjectileManager.removeProjectile(this);
    }
    _refreshFollowTarget() {
        //console.log('Refreshing follow target');
        if (this.isFollowingAnyTarget()) {
            let targetCharacter = AAEntity.Unpack(this._followTarget);
            if (targetCharacter) {
                if (!AATargetsManager2.isValidTarget(targetCharacter)) {
                    this._followTarget = null;
                    //console.log('Follow target is invalid');
                }
                else {
                    this._targetPosition = { x: targetCharacter.x, y: targetCharacter.y };
                    //console.log('Follow target refreshed');
                    return;
                }
            }
        }
        if (this.isShouldStickToNearestTarget()) {
            //console.log('Searching for nearest target');
            this._searchForNearestTarget();
        }
    }
    _searchForNearestTarget() {
        try {
            var targets = AATargetsManager2.getTargetsForSkillInRadius(this.ownerCharacter(), this.skillData(), this.currentPositionOnMap(), this.skillData().gRadius() * 2);
            let nearestTarget = AAMath.getNearestPointFromArray(this.currentPositionOnMap(), targets);
            if (nearestTarget) {
                this._followTarget = AAEntity.Pack(nearestTarget);
                this._targetPosition = { x: nearestTarget.x, y: nearestTarget.y };
                //console.log('Nearest target found and set as follow target');
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateFollowMode() {
        if (!this.isHaveFollowMode()) {
            return;
        }
        this._followRefreshTimer++;
        if (this._followRefreshTimer >= 10) {
            this._refreshFollowTarget();
        }
    }
    _updatePosition() {
        let directionVector = AAMath.getDirectionVetorToPoint(this._currentPosition, this._targetPosition, true);
        let nextPoint = AAMath.getNextPoint(this._currentPosition, directionVector, this._flySpeed);
        this._currentPosition = nextPoint;
        this._collider.setPositionXY(nextPoint.x, nextPoint.y, true);
    }
    _updateHitWithMapObstacles() {
        if (this._isHaveForbiddenRegions || this._isHaveForbiddenTerrainTags) {
            if (AAMapCollisionsManager.isCollideWithProjectileObstacles(this.getCollider())) {
                this._executeNoContactHit();
                return; // No need to check further
            }
        }
        this._updateHitWithForbiddenRegions();
        this._updateHitWithForbiddenTerrainTags();
    }
    _updateHitWithForbiddenRegions() {
        try {
            if (!this._isHaveForbiddenRegions) {
                return;
            }
            let regionId = this._getRegionIdUnderMyPosition();
            if (regionId > 0 && this._isRegionForbidden(regionId)) {
                this._executeNoContactHit();
            }
        }
        catch (error) {
            console.warn(error);
            this._isHaveForbiddenRegions = false; // Disable if error occurs
        }
    }
    _updateHitWithForbiddenTerrainTags() {
        try {
            if (!this._isHaveForbiddenTerrainTags) {
                return;
            }
            let terrainTag = this._getTerrainTagUnderMyPosition();
            if (terrainTag > 0 && this._isTerrainTagForbidden(terrainTag)) {
                this._executeNoContactHit();
            }
        }
        catch (error) {
            console.warn(error);
            this._isHaveForbiddenTerrainTags = false; // Disable if error occurs
        }
    }
    _getRegionIdUnderMyPosition() {
        let myPosition = this.currentPositionOnMap();
        let alignedPosition = { x: Math.round(myPosition.x), y: Math.round(myPosition.y) };
        let regionId = $gameMap.regionId(alignedPosition.x, alignedPosition.y);
        if (regionId > 0) {
            return regionId;
        }
        return -1; // No region
    }
    _getTerrainTagUnderMyPosition() {
        let myPosition = this.currentPositionOnMap();
        let alignedPosition = { x: Math.round(myPosition.x), y: Math.round(myPosition.y) };
        let terrainTag = $gameMap.terrainTag(alignedPosition.x, alignedPosition.y);
        if (terrainTag > 0) {
            return terrainTag;
        }
        return -1; // No terrain tag
    }
    _isRegionForbidden(regionId) {
        let skill = this.skillData();
        if (skill.noPassRegions && skill.noPassRegions.includes(regionId)) {
            return true;
        }
        /*if(AAPluginParams.getProjectileForbiddenRegions().includes(regionId)) {
            return true;
        }*/
        return false; // Not forbidden
    }
    _isTerrainTagForbidden(terrainTag) {
        let skill = this.skillData();
        if (skill.noPassTerrains && skill.noPassTerrains.includes(terrainTag)) {
            return true;
        }
        /*if(AAPluginParams.getProjectileFrobiddenTerrainTags().includes(terrainTag)) {
            return true;
        }*/
        return false; // Not forbidden
    }
    _updateDistanceCheck() {
        try {
            let flyDistance = AAMath.distance(this._startPosition, this._currentPosition);
            let maxDistance = this.skillData().gRange();
            if (flyDistance >= maxDistance) {
                if (this.skillData().isNoContact()) {
                    //console.log('Projectile reached max distance without contact');
                    this._executeNoContactHit();
                }
                else {
                    //console.log('Projectile reached max distance, disposing');
                    this._dispose();
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateHitPositionCheck() {
        try {
            let distance = AAMath.distance(this._currentPosition, this._targetPosition);
            if (distance <= 0.1) {
                //console.log('Projectile reached target position, executing hit');
                this._executeNoContactHit();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateHitWithEntitiesAndEvents() {
        try {
            let candidates = AATargetsManager2.getTargetsForCollider(this._collider);
            let owner = this.ownerCharacter();
            let skillData = this.skillData();
            // Exclude owner from candidates
            candidates = candidates.filter(candidate => {
                return candidate !== owner && skillData.isOnSameLevelWith(candidate);
            });
            // Get ABS entities
            let entities = candidates.filter(candidate => {
                return AsAAChar(candidate).isABS();
            });
            // Filter by relationships
            entities = AATargetsManager2.filterTargetsByRelationship(owner, entities, skillData);
            if (entities.length > 0) {
                var nearestTarget = entities[0];
                if (entities.length > 1) {
                    nearestTarget = AAMath.getNearestPointFromArray(this._currentPosition, entities);
                }
                this._executeHit(nearestTarget);
                return;
            }
            // If no ABS entities found, check for events
            this._checkForHitWithBaseEvents(candidates, skillData);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _checkForHitWithBaseEvents(candidates, skillData) {
        try {
            let events = candidates.filter(candidate => {
                return candidate instanceof Game_Event;
            });
            events = events.filter(event => {
                return !AsAAChar(event).isABS();
            });
            for (let event of events) {
                if (AAEventsProjectilesInteractions.isEventBlockProjectile(event, skillData)) {
                    this._executeHit(event);
                    return; // Exit after first hit
                }
                else {
                    this._tryExecuteProjectileAction(event);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _executeHit(target) {
        if (!target) {
            return;
        }
        //console.log('Executing hit on target: ', target);
        if (target instanceof Game_Event) {
            this._tryExecuteProjectileAction(target);
        }
        if (this._isCanHitTarget(target)) {
            this._registerTargetHit(target);
            if (!this.isCanPierceMore()) {
                this._dispose();
            }
        }
    }
    _isCanHitTarget(target) {
        if (this._isCanHitSameTarget == true) {
            return true;
        }
        return this._isTargetAlreadyBeenHitted(target) == false;
    }
    _isTargetAlreadyBeenHitted(target) {
        if (target instanceof Game_Event) {
            return this._hittedEventIds.includes(target.eventId());
        }
        else if (target['aaCharId']) {
            //@ts-ignore
            return this._hittedActorsIds.includes(target.aaCharId());
        }
        else {
            console.warn('Unknown target:', target);
            return false;
        }
    }
    _registerTargetHit(target) {
        this.stopFollowTarget();
        this.setStickToNearestTarget(false);
        if (!this._isTargetAlreadyBeenHitted(target)) {
            this._piercedTargetsLeft -= 1;
        }
        if (target instanceof Game_Event) {
            this._hittedEventIds.push(target.eventId());
        }
        else if (target['aaCharId']) {
            //@ts-ignore
            this._hittedActorsIds.push(target.aaCharId());
        }
        else {
            console.warn('Unknown target:', target);
        }
        this._executeSkill();
    }
    _tryExecuteProjectileAction(event) {
        try {
            if (this._activatedEventIds.includes(event.eventId())) {
                return;
            }
            //console.log('Executing projectile action on event: ', event);
            AAEventsProjectilesInteractions.tryActivateEventInteractionsForProjectile(event, this.skillData());
            this._activatedEventIds.push(event.eventId());
        }
        catch (error) {
            console.warn(error);
        }
    }
    _executeNoContactHit() {
        //console.log('Executing no contact hit');
        this._executeSkill();
        this._dispose();
    }
    _executeSkill() {
        AABattleSkillsExecutionManager.applySkillAction(this.skillData(), this.ownerCharacter(), this.currentPositionOnMap());
    }
}
window['AAProjectile'] = AAProjectile;


var AAProjectileManager;
(function (AAProjectileManager) {
    function onAfterMapIsLoaded() {
        for (const projectile of getAllProjectiles()) {
            projectile.restore();
            Sprite_AAProjectile.CreateFor(projectile);
        }
    }
    AAProjectileManager.onAfterMapIsLoaded = onAfterMapIsLoaded;
    function onBeforeMapIsChanged() {
        clearProjectiles();
    }
    AAProjectileManager.onBeforeMapIsChanged = onBeforeMapIsChanged;
    function addProjectile(projectile) {
        try {
            getAllProjectiles();
            $gameMap['_aaProjectiles'].push(projectile);
            Sprite_AAProjectile.CreateFor(projectile);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAProjectileManager.addProjectile = addProjectile;
    function getProjectileById(projectileId) {
        try {
            const projectiles = getAllProjectiles();
            for (const projectile of projectiles) {
                if (projectile.uniqueId === projectileId) {
                    return projectile;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    AAProjectileManager.getProjectileById = getProjectileById;
    function removeProjectileById(projectileId) {
        try {
            const projectile = getProjectileById(projectileId);
            if (projectile) {
                removeProjectile(projectile);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAProjectileManager.removeProjectileById = removeProjectileById;
    function removeProjectile(projectile) {
        try {
            if (!projectile)
                return;
            const projectiles = getAllProjectiles();
            const index = projectiles.indexOf(projectile);
            if (index >= 0) {
                projectiles.splice(index, 1);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAProjectileManager.removeProjectile = removeProjectile;
    function clearProjectiles() {
        try {
            $gameMap['_aaProjectiles'] = [];
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAProjectileManager.clearProjectiles = clearProjectiles;
    function getAllProjectiles() {
        if (!$gameMap['_aaProjectiles']) {
            $gameMap['_aaProjectiles'] = [];
        }
        return $gameMap['_aaProjectiles'];
    }
    AAProjectileManager.getAllProjectiles = getAllProjectiles;
})(AAProjectileManager || (AAProjectileManager = {}));
window['AAProjectileManager'] = AAProjectileManager;


var AAScriptActions;
(function (AAScriptActions) {
    const ACTIONS = ["ss", "sw", "vr", "ce", "ap", "ev", "an", "ef", "se", "ba", "es", "ax", "as"];
    function isProper(actionLine) {
        if (!actionLine)
            return false;
        //@ts-ignore
        if (isFinite(actionLine))
            return false;
        try {
            let parts = actionLine.split("_");
            let command = parts[0];
            if (!command)
                return false;
            return ACTIONS.indexOf(command) >= 0;
        }
        catch (error) {
            console.warn(error);
            return false;
        }
    }
    AAScriptActions.isProper = isProper;
    function execute(action, char) {
        if (!isProper(action))
            return;
        if (char instanceof Game_Interpreter) {
            char = extractCharFromInterpreter(char);
        }
        //@ts-ignore
        AANetworkManager.executeSA(action, char);
        try {
            const command = action.split("_")[0];
            switch (command) {
                case "ss":
                    executeSelfSwitchAction(action, char);
                    break;
                case "sw":
                    executeSwitchAction(action);
                    break;
                case "vr":
                    executeVariableAction(action);
                    break;
                case "ce":
                    executeCommonEventAction(action, char);
                    break;
                case "ap":
                    executeAIModelAction(action, char);
                    break;
                case "ev":
                    executeMapEventAction(action);
                    break;
                case "an":
                    executeAnimationAction(action, char);
                    break;
                case "ef":
                    executeEffectAction(action, char);
                    break;
                case "se":
                    executeSESoundAction(action);
                    break;
                case "ba":
                    executeBallonIcon(action, char);
                    break;
                case "es":
                    executeSkill(action, char);
                    break;
                case "ax":
                    executeAnimaXAction(action, char);
                    break;
                case "as":
                    executeAddState(action, char);
                    break;
                default:
                    console.warn("Unknown script action: " + action);
                    break;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAScriptActions.execute = execute;
    function extractCharFromInterpreter(interpreter) {
        let char = $gameMap.event(interpreter.eventId());
        if (!char)
            return null;
        return char;
    }
    function extractEventFromArgument(arg) {
        let eventId = parseInt(arg);
        let char = $gameMap.event(eventId);
        if (!char)
            return null;
        return char;
    }
    function parseAction(actionLine, minimumArgs = 1) {
        let parts = actionLine.split("_");
        let command = parts[0];
        let args = parts.slice(1);
        if (args.length < minimumArgs) {
            console.warn("Not enough arguments for action: " + actionLine);
            return [command, []];
        }
        return [command, args];
    }
    // * ss_A_true_2 , ss_B_false, ss_C_false_3 (evId)
    function executeSelfSwitchAction(actionLine, char, mapId = 0) {
        const args = parseAction(actionLine, 2)[1];
        if (args.length == 0)
            return;
        try {
            const switchId = args[0];
            if (!AAUtils.isSelfSwitch(switchId))
                return;
            const switchState = Boolean(args[1].toLocaleLowerCase());
            let eventId = 0;
            if (args[2]) {
                eventId = parseInt(args[2]);
            }
            else {
                if (!char)
                    return;
                if (!char.eventId)
                    return;
                eventId = char.eventId();
            }
            if (mapId == 0) {
                mapId = $gameMap.mapId();
            }
            const key = [mapId, eventId, switchId];
            $gameSelfSwitches.setValue(key, switchState);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * Данный метод вызывается от севрера, поддерживает смену переключателя на другой карте
    function executeSelfSwitchActionFromNetwork(actionLine, forceEventId, mapId) {
        try {
            executeSelfSwitchAction(actionLine, {
                eventId() {
                    return forceEventId;
                }
            }, mapId);
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAScriptActions.executeSelfSwitchActionFromNetwork = executeSelfSwitchActionFromNetwork;
    // * sw_43_true, sw_222_false
    function executeSwitchAction(actionLine) {
        const args = parseAction(actionLine, 2)[1];
        if (args.length == 0)
            return;
        try {
            const switchId = parseInt(args[0]);
            if (switchId <= 0)
                return;
            const switchState = Boolean(args[1].toLocaleLowerCase());
            $gameSwitches.setValue(switchId, switchState);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * vr_54_2123, vr_44_9932
    function executeVariableAction(actionLine) {
        const args = parseAction(actionLine, 2)[1];
        if (args.length == 0)
            return;
        try {
            const variableId = parseInt(args[0]);
            if (variableId <= 0)
                return;
            const value = parseInt(args[1]);
            $gameVariables.setValue(variableId, value);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * ce_43, ce_11_this (?)
    function executeCommonEventAction(actionLine, char) {
        const args = parseAction(actionLine, 1)[1];
        if (args.length == 0)
            return;
        try {
            const commonEventId = parseInt(args[0]);
            if (commonEventId <= 0)
                return;
            if (args[1] && args[1] == 'this' && char) {
                //@ts-ignore
                char.aaStartCommonEvent(commonEventId);
            }
            else {
                AAUtils.startCE(commonEventId);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * ap_viewRadius_5, ap_viewRadius_4_12 (evId)
    function executeAIModelAction(actionLine, char) {
        const args = parseAction(actionLine, 1)[1];
        if (args.length == 0)
            return;
        try {
            const paramName = args[0];
            let paramValue = args[1];
            // * Преобразование числа
            if (isFinite(paramValue)) {
                paramValue = parseInt(paramValue);
            }
            if (args[2]) {
                //@ts-ignore
                char = extractEventFromArgument(args[2]);
            }
            if (!char)
                return;
            //@ts-ignore
            if (!char.isABS())
                return;
            //@ts-ignore
            char.aaChangeModelParam(paramName, paramValue);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * ev_5 ; start event 5 on this map
    function executeMapEventAction(actionLine) {
        const args = parseAction(actionLine, 1)[1];
        if (args.length == 0)
            return;
        try {
            const event = extractEventFromArgument(args[0]);
            if (!event)
                return;
            event.start();
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * an_4 (self), an_5_3 (evId), an_2_1_2 (x,y)
    function executeAnimationAction(actionLine, char) {
        const args = parseAction(actionLine, 1)[1];
        if (args.length == 0)
            return;
        try {
            const animationId = parseInt(args[0]);
            if (animationId <= 0)
                return;
            // * x, y
            if (args[2]) {
                let x = parseInt(args[1]);
                let y = parseInt(args[2]);
                AABattleAnimationsManager.playAnimationOnMap(animationId, { x, y });
            }
            else if (args[1]) { // * eventId
                //@ts-ignore
                const event = extractEventFromArgument(args[1]);
                if (!event)
                    return;
                AABattleAnimationsManager.playAnimationOnCharacter(animationId, event);
            }
            else // * on self
             {
                if (!char)
                    return;
                AABattleAnimationsManager.playAnimationOnCharacter(animationId, char);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * ef_shake_10, ef_shake_10_12 (evId)
    // * ef_shatter_4_4 (dx, dy), ef_shatter_4_4_2 (evId)
    function executeEffectAction(actionLine, char) {
        const args = parseAction(actionLine, 2)[1];
        if (args.length == 0)
            return;
        try {
            const effectName = args[0];
            switch (effectName) {
                case "shatter":
                    const dx = parseInt(args[1]);
                    const dy = parseInt(args[2]);
                    if (args[3] != undefined) {
                        const event = extractEventFromArgument(args[3]);
                        if (event) {
                            //@ts-ignore
                            event.aaRequestShatterEffect(dx, dy);
                        }
                    }
                    else {
                        if (char) {
                            //@ts-ignore
                            char.aaRequestShatterEffect(dx, dy);
                        }
                    }
                    break;
                case "shake":
                    const time = parseInt(args[1]);
                    if (args[2] != undefined) {
                        const event = extractEventFromArgument(args[2]);
                        if (event) {
                            //@ts-ignore
                            event.aaRequestShakeEffect(time);
                        }
                    }
                    else {
                        if (char) {
                            //@ts-ignore
                            char.aaRequestShakeEffect(time);
                        }
                    }
                    break;
                default:
                    console.warn("Script Action: Unknown effect name: " + effectName);
                    break;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * ba_1, ba_2_4 (evId)
    function executeBallonIcon(actionLine, char) {
        const args = parseAction(actionLine, 1)[1];
        if (args.length == 0)
            return;
        try {
            const balloonId = parseInt(args[0]);
            if (balloonId <= 0)
                return;
            if (args[1]) {
                //@ts-ignore
                char = extractEventFromArgument(args[1]);
            }
            if (!char)
                return;
            //@ts-ignore
            if (KDCore.isMV()) {
                char.requestBalloon(balloonId);
            }
            else {
                //@ts-ignore
                $gameTemp.requestBalloon(char, balloonId);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * es_0_-1_303, es_0_0_304_0 (gamePlayer), es_0_0_304_10_20 (XY)
    function executeSkill(actionLine, char) {
        const args = parseAction(actionLine, 3)[1];
        if (args.length == 0)
            return;
        try {
            let ownerId = parseInt(args[0]);
            let teamId = parseInt(args[1]);
            let skillId = parseInt(args[2]);
            // * X, Y
            if (args[3] != undefined && args[4] != undefined) {
                let x = parseInt(args[3]);
                let y = parseInt(args[4]);
                //@ts-ignore
                uAPI.executeAASkillOnMap(ownerId, teamId, skillId, x, y);
            }
            else if (args[3] != undefined) {
                let charId = parseInt(args[3]);
                //@ts-ignore
                uAPI.executeAASkillOnChar(ownerId, teamId, skillId, charId);
            }
            else {
                if (!char)
                    return;
                let { x, y } = char;
                //@ts-ignore
                uAPI.executeAASkillOnMap(ownerId, teamId, skillId, x, y);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * se_Bell1_90_100 (volume, pitch)
    function executeSESoundAction(actionLine) {
        const args = parseAction(actionLine, 1)[1];
        if (args.length == 0)
            return;
        try {
            let name = args[0];
            if (!name)
                return;
            if (name == "")
                return;
            let volume = 100;
            let pitch = 100;
            if (args[1]) {
                volume = parseInt(args[1]);
                if (args[2]) {
                    pitch = parseInt(args[2]);
                }
            }
            //@ts-ignore
            KDCore.Utils.playSE(name, volume, pitch);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * ax_name, ax_name_0 (0 - player, X - event ID)
    function executeAnimaXAction(actionLine, char) {
        const args = parseAction(actionLine, 1)[1];
        if (args.length == 0)
            return;
        try {
            const animationActionName = args[0];
            if (args[1]) {
                //@ts-ignore
                char = extractEventFromArgument(args[1]);
            }
            if (!char)
                return;
            //@ts-ignore
            if (char.isAnimX()) {
                //@ts-ignore
                char.startAnimaXCustomAction(animationActionName, false, true);
            }
            else {
                console.warn(actionLine + " Character not have AnimaX controller on it, add XA: comment");
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * as_STATE, as_STATE_0 (0 - player, X - event ID)
    function executeAddState(actionLine, char) {
        const args = parseAction(actionLine, 1)[1];
        if (args.length == 0)
            return;
        try {
            const stateId = parseInt(args[0]);
            if (!$dataStates[stateId])
                return;
            if (args[1]) {
                //@ts-ignore
                char = extractEventFromArgument(args[1]);
            }
            if (!char)
                return;
            //@ts-ignore
            if (char.isABS() && char.AABattler) {
                //@ts-ignore
                char.AABattler().addState(stateId);
            }
            else {
                console.warn(actionLine + " Character is not ABS supported one");
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
})(AAScriptActions || (AAScriptActions = {}));
window['AAScriptActions'] = AAScriptActions;


class AASimpleTween {
    static Create(config) {
        return new AASimpleTween(config);
    }
    static CreateAuto(object, config) {
        let tween = new AASimpleTween(config);
        tween.setObject(object);
        tween.start();
        return tween;
    }
    constructor(_config) {
        this._config = _config;
        this._isAutoStart = false;
        this._delayTimer = 0;
        this._delayTime = 0;
        this._duration = _config.duration * 60; // Convert seconds to frames
        this._changeValue = _config.endValue - _config.startValue;
        this._currentTime = 0;
        this._delayTime = (_config.delay || 0) * 60;
    }
    setObject(object) {
        this._object = object;
        //if(this._delayTime > 0) {
        //    this._object[this._config.fieldName] = this.getValue(0);
        //}
    }
    start() {
        this.reset();
        this._isAutoStart = true;
    }
    /**
     * Checks if the animation has ended.
     * @returns True if the animation has ended, otherwise false.
     */
    isEnd(time) {
        return time >= this._duration || this._duration <= 0;
    }
    /**
         * Resets the animation timer.
         */
    reset() {
        this._currentTime = 0;
        this._delayTimer = 0;
    }
    update() {
        if (!this._isAutoStart)
            return;
        if (!this._object)
            return;
        if (this.isEnd(this._currentTime))
            return;
        if (this._delayTimer < this._delayTime) {
            this._delayTimer += 1;
            return;
        }
        if (this._currentTime < this._duration) {
            this._currentTime += 1;
        }
        this._object[this._config.fieldName] = this.getValue(this._currentTime);
    }
    getValue(time) {
        if (this.isEnd(time)) {
            return this._config.endValue;
        }
        else {
            return this.function(time, this._config.startValue, this._changeValue, this._duration);
        }
    }
    /**
         * Default linear easing function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
    function(t, b, c, d) {
        return c * t / d + b;
    }
}
window['AASimpleTween'] = AASimpleTween;


// * Класс АБС навыка (дейсвтия), может быть спелл или предмет
// * Содержки настройки навыка
// * Новая версия - не требует целей
// * В ABS Z предметы и навыки имеют свои уникальные ID (поле idA)
// * Это сделано так как предметы имели одинаковые ID что и навыки и было не удобно их различать
// * Теперь предметы имеют idA = id + это значение
const AAITEMS_ID_START = 9000;
//@[STORABLE]
class AASkill2 {
    constructor(idA) {
        this.radius = 1;
        this.range = 1;
        this.direction = 0;
        this.speed = 0;
        this.targetLimit = 0; // * Нет ограничения по количеству целей
        this.targetLimitType = 0;
        this.friendlyEffect = 0; // * Еффект на дружественную команду (и себя)
        this.opponentsEffect = 1; // * Еффект на противоположную команду
        this.reloadTime = 0; // в секундах
        this.repeat = 1; // Количество повторений 0 = 1 (0 - игнорируется, т.е. = 1)
        this.repeatOnUse = 1; // Количество повторений старта 0 = 1 (0 - игнорируется, т.е = 1)
        this.repeatDelay = 120; // Задержка между повторами (в миллисекундах)
        this.usableIfState = 0; // Проверка состояний условий
        this.usableIfTargetState = 0;
        this.impulse = 0;
        this.impulseRandom = 0;
        this.impulseJump = 0;
        this.impulseReversed = 0;
        this.pierce = 0; // Только для Projectile
        this.keepOutScreen = 0;
        this.colliderRadius = 8;
        this.explosive = 0;
        this.explosiveDmgKoef = 1;
        this.explosiveDmgSkill = 0;
        this.multiProjectile = 0;
        this.fixProjWithCharDir = 1;
        this.homingProjectile = 0;
        this.swing = 0;
        this.swingKoef = 1;
        this.teleport = 0;
        this.teleportInAnim = 0; // Animation ID
        this.teleportOutAnim = 0; // Animation ID
        this.castingAnimation = ""; // XAnima Looped Action Name
        this.castingTime = 0; // in seconds
        this.onCastingStartCE = 0;
        this.onCastingCompletedCE = 0;
        this.onCastingAbortedCE = 0;
        this.castingRotation = 1;
        this.castingSE = "";
        this.z = 3;
        this.selectZone = 0;
        this.skillImg = "";
        this.hitOffset = 28;
        // * Если 1, то навык срабатывает в конце своего пути в любом случае
        // * Если 0, то навык, НЕ достигнув цели, просто изчезнет
        this.noContact = 0;
        this.popUpStyleId = "";
        // Дополнительная анимация (используется на АБС карте, используется взамен параметра из БД)
        this.hitAnimationId = 0;
        // * Если 1 , то в любом случае анимация будет на карте
        this.animationOnMap = 0;
        // Непроходимые регионы
        this.noPassRegions = [];
        // Непроходимые Terrain tags
        this.noPassTerrains = [];
        this.selectorColor = "#bf9324";
        this.selectorImg = null;
        this.selectorOpacity = 220;
        // Анимация взмаха оружием (стандартная)
        this.weaponMotion = 0;
        // Только если weaponMotion > 0
        // * 0 - оружие в руке (Actor), 1-X тип оружия из списка Types
        this.weaponMotionType = 0;
        // Приоритет анимации ( 1 - в приоритете, 0 - нет. 2 - вместе)
        this.animaXPriority = 1;
        this.extraAnimation = null;
        this.extraAnimationOX = 0;
        this.extraAnimationOY = 0;
        this.extraAnimationSE = "";
        this.hideOutsideABS = 0;
        // * Когда навык поражает цель (попадает в цель)
        this.onHit = null;
        // * Когда запускаем (используем) навык
        this.onStart = null;
        this.ssImg = null; // * Изображение для слота навыка
        this.onDone = null; // * Когда навык был выполнен
        this.animaXAction = null;
        this.actionStartDelay = 0;
        this.idA = idA;
    }
    static IsAAItem(id) {
        return id >= AAITEMS_ID_START;
    }
    static IsAASkill(id) {
        return !AASkill2.IsAAItem(id);
    }
    // * Навык (или предмет) имеют AASkill данные в себе
    static IsAAObject(idOrItem) {
        try {
            if (!idOrItem)
                return false;
            if (typeof idOrItem === "number") {
                idOrItem = AASkill2.GetAASkillObject(idOrItem);
            }
            return idOrItem && idOrItem['AASkill'];
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    static GetAASkillObject(id) {
        try {
            if (!id || id <= 0)
                return null;
            if (AASkill2.IsAAItem(id)) {
                return $dataItems[id - AAITEMS_ID_START];
            }
            else {
                return $dataSkills[id];
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    static UnpackAASkill(id) {
        try {
            var object = AASkill2.GetAASkillObject(id);
            if (object) {
                return object['AASkill'];
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    name() {
        var _a;
        return (_a = this.dbItem()) === null || _a === void 0 ? void 0 : _a.name;
    }
    isItem() {
        return AASkill2.IsAAItem(this.idA);
    }
    isSkill() {
        return !this.isItem();
    }
    isOnSameLevelWith(char) {
        try {
            let zLevel = this.z;
            let eventLevel = char._priorityType;
            if (zLevel <= 2) {
                // * Below Character
                return eventLevel === 0;
            }
            if (zLevel <= 4) {
                // * Same as Character
                return eventLevel === 1;
            }
            // * Above Character
            return eventLevel === 2;
        }
        catch (error) {
            console.warn(error);
        }
        return true;
    }
    databaseId() {
        if (this.isItem()) {
            return this.idA - AAITEMS_ID_START;
        }
        else {
            return this.idA;
        }
    }
    // * Установить набор параметров из Note (принимает массив пар: имя - значение)
    setNoteParameters(params) {
        for (const p of params) {
            this[p[0]] = p[1];
        }
        this._convertParameters();
    }
    animationId() {
        const hitAnimationId = this.gHitAnimationId();
        if (hitAnimationId > 0) {
            return hitAnimationId;
        }
        else {
            return this.dbItem().animationId;
        }
    }
    getAnimationIdForBattler(battler) {
        try {
            let skillAnimationId = this.animationId();
            //@ts-ignore
            if (skillAnimationId == -1 && battler && battler.attackAnimationId1) {
                //@ts-ignore
                return battler.attackAnimationId1();
            }
            return skillAnimationId;
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    isCanHitSameTarget() {
        return this.pierceContinues > 0;
    }
    isAnimationOnMap() {
        return this.animationOnMap > 0;
    }
    gHitAnimationId() {
        return AAExtendedValues.getSafeEValue(this.hitAnimationId, 0);
    }
    dbItem() {
        return AASkill2.GetAASkillObject(this.idA);
    }
    // * Надо выбирать зону поражения для навыка
    isNeedSelectZone() {
        return this.selectZone == 1 && this.gRange() > 0;
    }
    // * Нет "полёта", приминение сразу в точке (зоне поражения)
    isInstant() {
        return this.gSpeed() <= 0;
    }
    isProjectile() {
        return !this.isInstant();
    }
    gMultiProjectileMode() {
        return AAExtendedValues.getSafeEValue(this.multiProjectile, 0);
    }
    getMultiProjectileModeCustomSet() {
        return this.customProjDirs || [];
    }
    isMultiProjectile() {
        return this.isProjectile() && this.isInPoint() && this.gMultiProjectileMode() > 0;
    }
    isMultiProjectileFixed() {
        return this.isMultiProjectile() && this.fixProjWithCharDir > 0;
    }
    isHomingProjectile() {
        return this.isProjectile() && this.homingProjectile > 0;
    }
    isNoRotationImage() {
        return this.isProjectile() && this.noRotationImage > 0;
    }
    gSpeed() {
        return AAExtendedValues.getSafeEValue(this.speed, 0);
    }
    // * Имеет направление (точка)
    isInPoint() {
        return this.direction > 0;
    }
    isInDirection() {
        return this.direction == 0;
    }
    // * Имеет конечную точку (летит прямо в точку)
    isInCertainPoint() {
        return this.direction == 1;
    }
    // * Летит по направлению точки
    isInPointDirection() {
        return this.direction == 2;
    }
    isNoContact() {
        return this.noContact > 0;
    }
    isRequireContact() {
        return !this.isNoContact();
    }
    // * Поражает только одну цель
    isSingleTargetArea() {
        return this.gRadius() <= 1;
    }
    gRadius() {
        return AAExtendedValues.getSafeEValue(this.radius, 1);
    }
    isSelfAction() {
        return this.gRange() <= 0 && this.isInstant();
    }
    gRange() {
        return AAExtendedValues.getSafeEValue(this.range, 1);
    }
    isHaveTimer() {
        const reloadTime = this.gReloadTime();
        //@ts-ignore
        return String.any(reloadTime) || reloadTime > 0;
    }
    // * Ближний бой = дистанция 1 и по направлению
    isMelee() {
        return !this.isInPoint() && this.gRange() == 1;
    }
    isForEnemies() {
        return this.opponentsEffect === 1;
    }
    isForEnemiesOnly() {
        return this.isForEnemies() && !this.isForFriends();
    }
    isForFriends() {
        return this.friendlyEffect === 1;
    }
    isForFriendsOnly() {
        return this.isForFriends() && !this.isForEnemies();
    }
    isHaveWeaponMotion() {
        return this.weaponMotion >= 1;
    }
    isHaveTargetLimit() {
        return !this.isSingleTargetArea() && this.gTargetLimit() > 0;
    }
    isHaveWeaponMotionSpecialType() {
        return this.weaponMotionType > 0;
    }
    isRepeatable() {
        return this.gRepeat() > 1;
    }
    gRepeat() {
        return AAExtendedValues.getSafeEValue(this.repeat, 1);
    }
    isRepeatableOnUse() {
        return this.gRepeatOnUse() > 1;
    }
    gRepeatOnUse() {
        return AAExtendedValues.getSafeEValue(this.repeatOnUse, 1);
    }
    gRepeatDelay() {
        return AAExtendedValues.getSafeEValue(this.repeatDelay, 120);
    }
    isRequireStateOnUser() {
        return this.gUsableIfState() > 0;
    }
    gUsableIfState() {
        return AAExtendedValues.getSafeEValue(this.usableIfState, 0);
    }
    isRequireStateOnTarget() {
        return this.gUsableIfTargetState() > 0;
    }
    gUsableIfTargetState() {
        return AAExtendedValues.getSafeEValue(this.usableIfTargetState, 0);
    }
    isHaveExtraAnimation() {
        return !!this.extraAnimation;
    }
    isHaveImpulsePower() {
        return this.getImpulsePower() > 0;
    }
    isRandomImpulseDirection() {
        return this.impulseRandom > 0;
    }
    isJumpImpulseType() {
        return this.impulseJump > 0;
    }
    isReversedImpulseType() {
        return this.impulseReversed > 0;
    }
    isAroundUser() {
        return this.isInstant() && !this.isSingleTargetArea() && this.direction == 0;
    }
    getImpulsePower() {
        return AAExtendedValues.getSafeEValue(this.impulse, 0);
    }
    getPiercePower() {
        return AAExtendedValues.getSafeEValue(this.pierce, 0);
    }
    isExplosive() {
        return this.getExplosiveRadius() > 0;
    }
    isExplosiveHaveSkill() {
        return this.getExplosiveDmgSkillId() > 0;
    }
    getExplosiveRadius() {
        return AAExtendedValues.getSafeEValue(this.explosive, 0);
    }
    getExplosiveDmgKoef() {
        return AAExtendedValues.getSafeEValue(this.explosiveDmgKoef, 0);
    }
    getExplosiveDmgSkillId() {
        return AAExtendedValues.getSafeEValue(this.explosiveDmgSkill, 0);
    }
    isSwing() {
        return this.swing > 0 && this.getSwingKoef() > 0 && this.isSingleTargetArea();
    }
    getSwingKoef() {
        return AAExtendedValues.getSafeEValue(this.swingKoef, 1);
    }
    isTeleport() {
        return this.teleport > 0;
    }
    isValidExplosiveSkill() {
        const id = this.getExplosiveDmgSkillId();
        //TODO: Может наоборот только обычные навыки чтобы урон получать?
        return id > 0 && $dataSkills[id] && $dataSkills[id]['AASkill'];
    }
    getAnimaXActionName() {
        //@ts-ignore
        if (String.any(this.animaXAction)) {
            return this.animaXAction;
        }
        else {
            return "Skill"; // * По умолчанию
        }
    }
    // * Время перезарядки навыка (cooldown)
    getReloadTime(battlerOrChar) {
        const reloadTime = this.gReloadTime();
        if (isFinite(reloadTime)) {
            return reloadTime;
        }
        else {
            if (!battlerOrChar) {
                return 0;
            }
            else {
                if (battlerOrChar instanceof Game_Character) {
                    //@ts-ignore
                    battlerOrChar = battlerOrChar.AABattler();
                }
                return battlerOrChar.aaCalculateFormula(reloadTime);
            }
        }
    }
    gReloadTime() {
        return AAExtendedValues.getSafeEValue(this.reloadTime, 0);
    }
    // * Приминить стандартные настройки навыка 001 Атака
    applyDefaultAttack001() {
        // * Ближний бой перед собой (контактный только)
        this.radius = 0.35;
        this.range = 1;
        this.direction = 0;
        this.speed = 0;
        this.noContact = 0;
        this.skillImg = "";
        this.actionStartDelay = 10;
        this.reloadTime = 1.2;
        this.animaXAction = "Attack";
        this.animaXPriority = 1;
        this.weaponMotion = 1;
    }
    // * Extended Values =========================================
    getETargetLimitType() {
        return this.targetLimitType;
    }
    gTargetLimit() {
        return AAExtendedValues.getSafeEValue(this.targetLimit, 0);
    }
    // * Casting ==================================================
    gCastingTime() {
        return AAExtendedValues.getSafeEValue(this.castingTime, 0);
    }
    isHaveCastingAnimation() {
        //@ts-ignore
        return String.any(this.castingAnimation);
    }
    isNeedCasting() {
        return this.gCastingTime() > 0;
    }
    getHurtbox() {
        let radius = this.gRadius();
        if (radius <= 0) {
            radius = 0.5;
        }
        return new AACollider({
            type: 'c',
            radius: radius * $gameMap.tileWidth(),
            flag: 'hurtbox'
        });
    }
    //TODO: splash damage (от каждой цели считается ещё доп. цели)
    // * Преобразует некоторые параметры
    _convertParameters() {
        // * Из строки 1,2,3 в массив [1,2,3]
        this.noPassRegions = AAParametersParser.convertArrayFromParameter(this.noPassRegions);
        this.noPassTerrains = AAParametersParser.convertArrayFromParameter(this.noPassTerrains);
        this.customProjDirs = AAParametersParser.convertArrayFromParameter(this.customProjDirs);
    }
}
window['AASkill2'] = AASkill2;


var AASkillExplosionHandler;
(function (AASkillExplosionHandler) {
    function performExplosion(skill, target, action) {
        try {
            let user = action.character();
            let explosionEffectRadius = skill.getExplosiveRadius();
            let targetsForExplosion = AATargetsManager2.getTargetsForSkillInRadius(user, skill, target, explosionEffectRadius);
            targetsForExplosion = targetsForExplosion.filter(t => t !== target); // Remove the target itself from the explosion targets
            if (targetsForExplosion.length == 0)
                return;
            if (skill.isValidExplosiveSkill()) {
                performExplosionSkillDamage(skill, action, target, targetsForExplosion);
            }
            else {
                performExplosionBlastWaveDamage(skill, action, targetsForExplosion);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    AASkillExplosionHandler.performExplosion = performExplosion;
    function performExplosionBlastWaveDamage(skill, action, targets) {
        try {
            if (!targets)
                return;
            targets.forEach(target => {
                try {
                    let battler = AsAAChar(target).AABattler();
                    let damageValue = action.makeDamageValue(battler, false);
                    damageValue *= skill.getExplosiveDmgKoef();
                    //@ts-ignore
                    battler.aaGainHpWithPopUp(damageValue * -1, false);
                }
                catch (error) {
                    console.warn(error);
                }
            });
        }
        catch (error) {
            console.warn(error);
        }
    }
    function performExplosionSkillDamage(baseSkill, action, startPosition, targets) {
        try {
            if (!targets)
                return;
            let skillToPerform = $dataSkills[baseSkill.getExplosiveDmgSkillId()];
            if (!skillToPerform) {
                console.warn(`Skill ${baseSkill.getExplosiveDmgSkillId()} not found`);
                return;
            }
            let skillToPerformInstance = skillToPerform['AASkill'];
            if (!skillToPerformInstance) {
                console.warn(`Skill ${baseSkill.getExplosiveDmgSkillId()} is not an AASkill2 instance`);
                return;
            }
            let baseSkillOwnerId = action.subjectTeamId();
            //@ts-ignore
            let explosionSkillOwner = AA.Utils.createDummyCharacterByParameters(baseSkillOwnerId, baseSkillOwnerId, startPosition.x, startPosition.y);
            if (!explosionSkillOwner) {
                console.warn(`Error while try create dummy explosion skill owner`);
                return;
            }
            targets.forEach(target => {
                try {
                    AABattleSkillsExecutionManager.startSkill(skillToPerformInstance, explosionSkillOwner, target);
                }
                catch (error) {
                    console.warn(error);
                }
            });
        }
        catch (error) {
            console.warn(error);
        }
    }
})(AASkillExplosionHandler || (AASkillExplosionHandler = {}));


// * Это класс определяет настройки Extension у оружия
class AASkillExtensionDefinition {
    constructor(id) {
        this.id = id;
        this._initBase();
    }
    databaseId() {
        return this.id;
    }
    dbItem() {
        return $dataWeapons[this.id];
    }
    isValidDefinition() {
        return this.extensions && this.extensions.length > 0;
    }
    isRequireExtensionItem() {
        return this.extensionRequire > 0;
    }
    isConsumeExtensionItem() {
        return this.extensionConsume > 0;
    }
    // * Установить набор параметров из Note (принимает массив пар: имя - значение)
    setNoteParameters(params) {
        for (const p of params) {
            this[p[0]] = p[1];
        }
        this._convertParameters();
    }
    _initBase() {
        this.extensions = [];
        this.extensionRequire = 0;
        this.extensionConsume = 0;
    }
    // * Преобразует некоторые параметры
    _convertParameters() {
        this.extensions = AAParametersParser.convertArrayFromParameter(this.extensions);
    }
}
window['AASkillExtensionDefinition'] = AASkillExtensionDefinition;


// * Этот класс хранит свойства Extension предмета
class AASkillExtensionItem {
    constructor(id) {
        this.id = id;
        this._params = {};
    }
    databaseId() {
        return this.id;
    }
    dbItem() {
        return $dataItems[this.id];
    }
    getParameters() {
        return this._params;
    }
    // * Установить набор параметров из Note (принимает массив пар: имя - значение)
    setNoteParameters(params) {
        this._params = params;
    }
}
window['AASkillExtensionItem'] = AASkillExtensionItem;


// * Класс хранит набор навыков на панели для персонажей
// * Хранит настройку панели навыков для каждого персонажа группы
class AASkillsSet {
    constructor() {
        // Map of actor IDs to skill bindings by symbol
        this.bindings = {};
        this.currentActorId = 0;
        // * Позиции на панели для навыков
        this.bindings = {};
        this.currentActorId = 0;
    }
    // * Установить ActorId из Game_Player (shortcut)
    setPlayerActorId() {
        // Assume $gamePlayer.AABattler().actorId() returns a number
        //@ts-ignore
        this.setActorId(AsAAChar($gamePlayer).AABattler().actorId());
    }
    // * Установить персонажа, с которым будем работать
    setActorId(currentActorId) {
        this.currentActorId = currentActorId;
        // * Если персонаж не настроен, то показать стандартные навыки
        if (!this.bindings[this.currentActorId]) {
            this.bindings[this.currentActorId] = {};
            this.setupDefaultSkillsForActor();
        }
    }
    allSymbols() {
        //@ts-ignore
        return AA.Input.skillPanelSymbols;
    }
    currentSet() {
        return this.bindings[this.currentActorId] || {};
    }
    setSkillInEmptySlot(skillId) {
        const symbols = this.allSymbols();
        for (const s of symbols) {
            //@ts-ignore
            if (!AA.Input.isSymbolSupportAutoBinding(s))
                continue;
            // * Автоматически нельзя поставить в E и Q слоты
            const tempId = this.getSkillForSymbol(s);
            if (tempId <= 0 && this.isCanAutoSetSkillToSymbol(skillId, s)) {
                this.setSymbolForSkill(skillId, s);
                break;
            }
        }
    }
    isCanAutoSetSkillToSymbol(skillId, symbol) {
        try {
            //@ts-ignore
            const settings = AA.PP.getUISkillItemSlotSettings(symbol);
            if (!settings)
                return true;
            // * Проверка что данные актуальные (существуют поля)
            if (!settings.filter)
                return true;
            if (settings.filter === "Skills") {
                if (AASkill2.IsAAItem(skillId))
                    return false;
            }
            if (settings.filter === "Items") {
                if (AASkill2.IsAASkill(skillId))
                    return false;
            }
            let specifiedIds = null;
            try {
                if (KString.any(settings.specifiedIds)) {
                    specifiedIds = AAParametersParser.convertArrayFromParameter(settings.specifiedIds);
                }
            }
            catch (e) {
                console.warn(e);
                specifiedIds = null;
            }
            if (specifiedIds && specifiedIds.length > 0) {
                const obj = AASkill2.GetAASkillObject(skillId);
                if (obj)
                    return specifiedIds.contains(obj.id);
            }
        }
        catch (e) {
            console.warn(e);
        }
        return true;
    }
    setSymbolForSkill(skillId, symbNew) {
        const set = this.currentSet();
        // * Проверяем чтобы дубликатов не было
        try {
            if (skillId > 0) {
                const existsValues = Object.values(set);
                if (existsValues.includes(skillId)) {
                    const existsOnSymb = this.getSymbolForSkill(skillId);
                    if (existsOnSymb) {
                        this.setSymbolForSkill(0, existsOnSymb);
                    }
                }
            }
        }
        catch (e) {
            console.warn(e);
        }
        set[symbNew] = skillId;
    }
    getSymbolForSkill(skillId) {
        const set = this.currentSet();
        for (const key in set) {
            if (set.hasOwnProperty(key) && set[key] === skillId) {
                return key;
            }
        }
        return null;
    }
    getSkillForSymbol(symbol) {
        const skillId = this.currentSet()[symbol];
        if (skillId && skillId > 0) {
            return skillId;
        }
        return 0;
    }
    setupDefaultSkillsForActor() {
        try {
            this.setupActorAttackSkillInPrimarySlot();
            const battler = $gameParty.leader();
            if (!battler)
                return;
            //@ts-ignore
            const attackSkillId = battler.attackSkillId();
            // * Добавляем остальные навыки
            //@ts-ignore
            const secondarySkillId = battler.aaGetDefaultSecondarySkillId();
            if (secondarySkillId > 0) {
                this.setSkillInEmptySlot(secondarySkillId);
            }
            //@ts-ignore
            for (const s of battler.getAASkills()) {
                if (s.idA === attackSkillId)
                    continue;
                if (s.idA === secondarySkillId)
                    continue;
                this.setSkillInEmptySlot(s.idA);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    setupActorAttackSkillInPrimarySlot() {
        const battler = $gameParty.leader();
        if (!battler)
            return;
        //@ts-ignore
        const attackSkillId = battler.attackSkillId();
        //@ts-ignore
        this.setSymbolForSkill(attackSkillId, AA.Input.primarySkillSymbol());
    }
    // * Возвращает ID всех предметов на панели
    getAllItemsFromPanel() {
        const items = [];
        const symbols = this.allSymbols();
        for (const s of symbols) {
            const id = this.getSkillForSymbol(s);
            if (AASkill2.IsAAItem(id)) {
                items.push(id);
            }
        }
        return items;
    }
    // * Есть ли предмет на панели
    // * Этот метод используется в автоматическом добавлении новых предметов
    // * Чтобы не добавлять один и тот же предмет несколько раз
    isHaveItemOnPanel(id) {
        return this.getAllItemsFromPanel().includes(id);
    }
    // * Переопределяет навык Атаки на панели, если было экипировано оружие
    // * с другим навыком атаки
    refreshAttackSkillBinding() {
        this.setupActorAttackSkillInPrimarySlot();
    }
}
window['AASkillsSet'] = AASkillsSet;


// * Класс хранит таймеры для набора АБС навыков (и предметов) для Battler
class AASkillsTimers {
    constructor() {
        // * Таймеры для навыков
        this._timers = [];
        // * Для оптимизации, ID навыков для которых запущен таймер храняться отдельно
        this._skills = [];
    }
    startTimerForSkill(skillId, time) {
        const timer = new AATimer();
        timer.skillId = skillId;
        // * Перевод из секунд в кадры
        timer.start(time * 60);
        this._timers.push(timer);
        this._skills.push(skillId);
    }
    isSkillHaveTimer(skillId) {
        return this._skills.includes(skillId);
    }
    isSkillHaveTimerToShow(skillId) {
        var _a;
        return this.isSkillHaveTimer(skillId) && ((_a = this.getTimerForSkill(skillId)) === null || _a === void 0 ? void 0 : _a.maxValue) >= 60;
    }
    // * В секундах
    getRemainTimeForSkill(skillId) {
        var _a, _b;
        if (this.isSkillHaveTimer(skillId)) {
            return (_b = (_a = this.getTimerForSkill(skillId)) === null || _a === void 0 ? void 0 : _a.getSecondsLeft()) !== null && _b !== void 0 ? _b : "0";
        }
        else {
            return "0";
        }
    }
    getTimerForSkill(skillId) {
        return this._timers.find(t => t.skillId === skillId);
    }
    update() {
        try {
            // * Опасно удалять в переборке массива
            const toDelete = [];
            for (const t of this._timers) {
                if (!t)
                    continue;
                t.update();
                if (t.isReady()) {
                    this._skills = this._skills.filter(skill => skill !== t.skillId);
                    toDelete.push(t);
                }
            }
            if (toDelete.length > 0) {
                this._timers = this._timers.filter(t => !toDelete.includes(t));
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
}


var AASpawnPointsManager;
(function (AASpawnPointsManager) {
    let _updateThread;
    var _isSpawnPointEventExistsOnMap = false;
    function onNewMapLoaded() {
        _updateThread = null;
        _isSpawnPointEventExistsOnMap = false;
    }
    AASpawnPointsManager.onNewMapLoaded = onNewMapLoaded;
    function update() {
        if (!_isSpawnPointEventExistsOnMap)
            return;
        if (_updateThread == null) {
            //@ts-ignore
            _updateThread = new KDCore.TimedUpdate(60, refreshSpawn);
        }
        _updateThread.update();
    }
    AASpawnPointsManager.update = update;
    // * Точка спавна, определяется только ID, а настройки берутся из параметров плагина
    // * <absSpawnPoint:ID>
    function extractSpawnPointConfig(ev) {
        try {
            //@ts-ignore
            let configString = KDCore.Utils.getEventCommentValue("absSpawnPoint", ev.list());
            if (!configString || configString.length == 0) {
                return null;
            }
            let parameter = AAParametersParser.extractABSParameterAny(configString);
            if (!parameter)
                return null;
            let id = parameter[1];
            //@ts-ignore
            let settings = AA.PP.getSpawnPointSettings(id);
            if (settings) {
                _isSpawnPointEventExistsOnMap = true;
                return settings;
            }
            else {
                console.warn("You trying use spawn point " + id + ", but not define setting in Plugin Parameters");
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    AASpawnPointsManager.extractSpawnPointConfig = extractSpawnPointConfig;
    function isActive() {
        //@ts-ignore
        return AA.isABSMap();
    }
    function spawnPoints() {
        //@ts-ignore
        return $gameMap.events().filter(e => e['_aaSpawnPointConfig']);
    }
    AASpawnPointsManager.spawnPoints = spawnPoints;
    function refreshSpawn() {
        if (!isActive())
            return;
        try {
            for (const sp of spawnPoints()) {
                refreshSpawnForSP(sp);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    function refreshSpawnForSP(sp) {
        //@ts-ignore
        const settings = sp['_aaSpawnPointConfig'];
        if (!settings) {
            return;
        }
        sp['_aaSpawnPointStep']++;
        try {
            workWithSpawnPoint(settings, sp);
        }
        catch (e) {
            console.warn(e);
        }
    }
    function workWithSpawnPoint(settings, event) {
        if (!isSpawnPointActive(settings.conditionSwitch))
            return;
        if (!isProperSpawnRate(settings.spawnRate, event['_aaSpawnPointStep']))
            return;
        if (!isInVisorRadius(settings.visorRadius, event))
            return;
        if (!isCanSpawnNow(settings, event))
            return;
        executeSpawnPoint(settings, event);
    }
    function isSpawnPointActive(conditionSwitch) {
        if (conditionSwitch > 0) {
            return $gameSwitches.value(conditionSwitch) === true;
        }
        else {
            return true;
        }
    }
    function isInVisorRadius(visorRadius, event) {
        if (visorRadius <= 0)
            return true;
        return AAMath.getDistanceToPlayerFrom(event) <= visorRadius;
    }
    function isProperSpawnRate(spawnRate, eventSpawnStep) {
        spawnRate = AAExtendedValues.getEValue(spawnRate);
        return eventSpawnStep >= spawnRate;
    }
    function isCanSpawnNow({ spawnMax, spawnAliveMax, endCommonEvent }, event) {
        try {
            const spawnMaxX = AAExtendedValues.getEValue(spawnMax);
            if (spawnMaxX > 0) {
                if (event['_aaSpawnPointSpawnedCount'] >= spawnMaxX) {
                    event['_aaSpawnPointConfig'] = null;
                    AAUtils.startCE(endCommonEvent);
                    return false;
                }
            }
            const spawnAliveMaxX = AAExtendedValues.getEValue(spawnAliveMax);
            if (spawnAliveMaxX > 0) {
                //@ts-ignore
                const spawnedAlive = uAPI.getSpawnPointSpawnedAlive(event.eventId());
                if (spawnedAlive >= spawnAliveMaxX) {
                    event['_aaSpawnPointStep'] = 0;
                    return false;
                }
            }
        }
        catch (e) {
            console.warn(e);
            return false;
        }
        return true;
    }
    function executeSpawnPoint({ spawnPointType, spawnRadius, spawnEnemiesId }, event) {
        event['_aaSpawnPointStep'] = 0;
        spawnRadius = AAExtendedValues.getEValue(spawnRadius);
        if (spawnPointType === 'region') {
            spawnEnemyInRegion(spawnEnemiesId, spawnRadius);
        }
        else if (spawnPointType === 'player') {
            spawnEnemyAroundPlayer(spawnEnemiesId, spawnRadius);
        }
        else {
            spawnEnemyAroundSpawnPoint(spawnEnemiesId, spawnRadius, event);
        }
        //@ts-ignore
        const spawned = uAPI.getLastSpawnedEnemy();
        if (!spawned)
            return;
        event['_aaSpawnPointSpawnedCount'] += 1;
        spawned._aaSpawnPointRelativeId = event.eventId();
    }
    function spawnEnemyInRegion(spawnEnemiesId, regionId) {
        if (!regionId || regionId <= 0)
            return;
        //@ts-ignore
        uAPI.spawnEnemy(spawnEnemiesId, regionId);
    }
    function spawnEnemyAroundPlayer(spawnEnemiesId, radius) {
        if (!radius || radius <= 0)
            radius = 1;
        //@ts-ignore
        uAPI.spawnEnemyNearPlayer(spawnEnemiesId, radius);
    }
    function spawnEnemyAroundSpawnPoint(spawnEnemiesId, radius, { x, y }) {
        if (!radius || radius <= 0)
            radius = 1;
        //@ts-ignore
        uAPI.spawnEnemyAround(spawnEnemiesId, x, y, radius);
    }
})(AASpawnPointsManager || (AASpawnPointsManager = {}));
window['AASpawnPointsManager'] = AASpawnPointsManager;


class AAState {
    constructor(id) {
        this.id = id;
        this.onStart = null;
        this.onTick = null; // * каждую секунду
        this.onEnd = null;
        this.activeSkill = null;
        this.speedMod = null;
        this._activeSkillParams = null;
    }
    static IsValid(stateIdOrStateObject) {
        let stateObject = null;
        if (typeof stateIdOrStateObject === 'number') {
            stateObject = $dataStates[stateIdOrStateObject];
        }
        else {
            stateObject = stateIdOrStateObject;
        }
        if (!stateObject)
            return false;
        if (stateObject['AAState']) {
            return true;
        }
        return false;
    }
    state() {
        return $dataStates[this.id];
    }
    // * Данное состояние надо "снять" по завершению Х действия (А)
    isActionEndState() {
        return this.state().autoRemovalTiming === 1;
    }
    // * Данное состояние надо "снять" после Х секунд
    isTimeEndState() {
        return this.state().autoRemovalTiming === 2;
    }
    // * Стоит флаг Remove at Battle End
    isRemovedAtBattleEnd() {
        return this.state().removeAtBattleEnd === true;
    }
    isHaveActiveSkill() {
        return this.activeSkill !== null;
    }
    isHaveSpeedMod() {
        return this.speedMod !== null;
    }
    // * Получить случайное значение Duration in Turns
    // * Значение между state.minTurns и state.maxTurns
    getTurnsValue() {
        const state = this.state();
        if (state.maxTurns === state.minTurns) {
            return state.maxTurns;
        }
        const variance = 1 + Math.max(state.maxTurns - state.minTurns, 0);
        //@ts-ignore
        return state.minTurns + Math.randomInt(variance);
    }
    // * Установить набор параметров из Note (принимает массив пар: имя - значение)
    setNoteParameters(params) {
        for (const p of params) {
            this[p[0]] = p[1];
        }
    }
    getActiveSkillParameters() {
        if (!this.isHaveActiveSkill())
            return null;
        try {
            // * Собираем один раз для оптимизации
            if (!this._activeSkillParams) {
                this._activeSkillParams = {
                    skillId: 0,
                    rate: 1,
                    radius: 0
                };
                // * @activeSkill = SKILL_ID [RATE] [RADIUS]
                const params = this.activeSkill.toString().split(',').map(i => parseInt(i));
                this._activeSkillParams.skillId = params[0];
                this._activeSkillParams.rate = params[1] || 1;
                this._activeSkillParams.radius = params[2];
                if (!this._activeSkillParams.radius) {
                    this._activeSkillParams.radius = 0; // * Self
                }
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this._activeSkillParams;
    }
}
window['AAState'] = AAState;


// * Данный класс хранит данные об АБС state для каждого Battler
// * Правила работы состояний
// onActionEnd - после выполнения любого АБС навыка (атаки в т.ч) Х раз (Duration in Turns)
// onBattleEnd - после отключения АБС режима (uAPI.pauseABS())
// onTurnEnd - после Х секунд (Duration in Turns)
// Каждую секунду вызывается onTick (если есть), приминимо к любому ABS состоянии
// (даже если у него нет onTurnEnd)
class AAStatesSet {
    constructor(battler) {
        //@ts-ignore
        this._packedSubject = AAEntity.Pack(battler.AACharacter());
        this._aaStateTimers = {};
        this._aaStateActionCounts = {};
        // * Таймеры для баффов (-1 значение не задано, таймер не идёт)
        this._aaBuffsTimers = [-1, -1, -1, -1, -1, -1, -1, -1];
    }
    isNotHaveBattler() {
        return !this._packedSubject;
    }
    // * Значение для вывода на UI (оставшееся время или действия)
    getDisplayValueForState(stateId) {
        if (this._aaStateActionCounts[stateId] !== undefined) {
            return this._aaStateActionCounts[stateId];
        }
        else if (this._aaStateTimers[stateId] !== undefined) {
            return this._aaStateTimers[stateId][1];
        }
        else {
            return -1; // * no value
        }
    }
    battler() {
        const subject = this.subject();
        //@ts-ignore
        return subject ? subject.AABattler() : null;
    }
    subject() {
        return AAEntity.Unpack(this._packedSubject);
    }
    // * Если система ABS была отключена
    onABSSystemStop(battler) {
        const states = battler.states().filter((s) => AAState.IsValid(s));
        const battleEndStates = states.filter((s) => s['AAState'].isRemovedAtBattleEnd());
        battleEndStates.forEach((s) => battler.removeState(s.id));
    }
    // * Когда battler выполнил какое-либо действие
    onAnyActionDone() {
        // * Изменяем счётчик действий состояний
        for (const k in this._aaStateActionCounts) {
            this._aaStateActionCounts[k]--;
            this.battler()._stateTurns[k] = this._aaStateActionCounts[k];
        }
    }
    // * battler передаётся чтобы управлять через него
    // * например удалить состояние (если время вышло)
    // * или выполнить Script Action
    // * или наложить доп. эффект (снять эффект)
    // ? Не передаётся как @, потому что класс Storable
    // * Для оптимизации передаём battler сразу, без распаковки каждый кадр
    update(battler) {
        this._updateTimers(battler);
        this._updateActionCounters(battler);
        this._updateBuffs(battler);
    }
    checkBattler(battler) {
        try {
            if (!this._packedSubject) {
                //@ts-ignore
                this._packedSubject = AAEntity.Pack(battler.AACharacter());
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    item(stateId) {
        return $dataStates[stateId]['AAState'];
    }
    add(stateId) {
        // * На battler состояние уже есть, когда этот метод вызывается
        try {
            this._pushNewState(stateId);
            this._onStateAdded(stateId);
        }
        catch (e) {
            console.warn(e);
        }
    }
    // * Все AAState объекты на персонаже
    allStates() {
        try {
            const states = this.battler().states().map((i) => this.item(i.id));
            return states.filter((s) => s);
        }
        catch (e) {
            console.warn(e);
            return [];
        }
    }
    remove(stateId) {
        // * На battler состояния уже нету когда этот метод вызывается
        try {
            this._deleteState(stateId);
            this._onStateRemoved(stateId);
        }
        catch (e) {
            console.warn(e);
        }
    }
    _pushNewState(stateId) {
        try {
            const aaState = this.item(stateId);
            // * АБС состояние с onTick всё равно имеет таймер
            if (AAScriptActions.isProper(aaState.onTick)) {
                // * [текущий таймер, кол-во секунд осталось]
                // * так надо, чтобы выполнять onTick
                this._aaStateTimers[stateId] = [0, -1]; // -1 - нет предела
            }
            if (aaState.isActionEndState()) {
                this._aaStateActionCounts[stateId] = aaState.getTurnsValue();
                if (this.battler()) {
                    this.battler()._stateTurns[stateId] = this._aaStateActionCounts[stateId];
                }
            }
            else if (aaState.isTimeEndState()) {
                // * Заменяем бесконечное время (-1) на TurnsValue
                this._aaStateTimers[stateId] = [0, aaState.getTurnsValue()];
                // * Возвращаем новое значение на Battler
                if (this.battler()) {
                    this.battler()._stateTurns[stateId] = this._aaStateTimers[stateId][1];
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deleteState(stateId) {
        delete this._aaStateTimers[stateId];
        delete this._aaStateActionCounts[stateId];
    }
    _onStateAdded(stateId) {
        try {
            const state = this.item(stateId);
            if (!state)
                return;
            this._checkStateExtraParameters(state);
            if (AAScriptActions.isProper(state.onStart)) {
                AAScriptActions.execute(state.onStart, this.subject());
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    _checkStateExtraParameters(state) {
        if (!state)
            return;
        try {
            if (state.isHaveSpeedMod() && this.battler()) {
                //@ts-ignore
                this.battler().aaSetSpeedMod(state.speedMod);
            }
            else {
                // * На всякий случай
                this._checkForSpeedMods();
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    _onStateRemoved(stateId) {
        try {
            this._checkForSpeedMods();
            const state = this.item(stateId);
            if (!state)
                return;
            if (AAScriptActions.isProper(state.onEnd)) {
                AAScriptActions.execute(state.onEnd, this.subject());
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    _checkForSpeedMods() {
        try {
            const b = this.battler();
            if (!b)
                return;
            //@ts-ignore
            b.aaSetSpeedMod(null);
            // * Возможно есть другие с мод. скорости
            const stateWithSpeed = this.allStates().find((s) => s.isHaveSpeedMod());
            if (stateWithSpeed) {
                //@ts-ignore
                b.aaSetSpeedMod(stateWithSpeed.speedMod);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    // * Battler передаётся сразу (для оптимизации)
    // * Так как onStateTick вызывается из метода _updateTimers,
    // * который уже имеет ссылку на battler
    // ? Вызывается каждую секунду действия состояния
    _onStateTick(stateId, battler) {
        const state = this.item(stateId);
        if (state.onTick) {
            battler = this.battler() || battler;
            //@ts-ignore
            AAScriptActions.execute(state.onTick, battler.AACharacter());
        }
        if (state.isHaveActiveSkill()) {
            //@ts-ignore
            this._executeStateActiveSkill(stateId, battler.AACharacter());
        }
    }
    // * Выполнить активный навык для состояния
    _executeStateActiveSkill(stateId, character) {
        try {
            const state = this.item(stateId);
            const params = state.getActiveSkillParameters();
            // * Получаем остаток от оставшихся секунд, чтобы узнать можно выполнять или нет
            // * Если остаток == 0, значит делится, т.е. можно выполнить
            if (params.rate > 1) {
                const turnsLeft = this.getDisplayValueForState(stateId);
                if (turnsLeft % params.rate !== 0)
                    return;
            }
            const skill = $dataSkills[params.skillId];
            if (!skill)
                return;
            //@ts-ignore
            const absSkill = skill.AASkill;
            if (!absSkill)
                return;
            // * Если радиус 0, то выбираем себя
            let targets;
            if (params.radius === 0) {
                targets = [character];
            }
            else {
                // * Находим все возможные цели в области действия состояния
                //@ts-ignore
                targets = AATargetsManager.getAvailableTargetsInRadius(character, params.radius);
                // * Фильтруем по дистанции и лимиту
                //@ts-ignore
                targets = AATargetsManager.applySkillTargetsLimit(character, targets, absSkill);
            }
            if (!targets || targets.length === 0)
                return;
            //@ts-ignore
            const ownerId = character.aaCharId();
            //@ts-ignore
            const teamId = character.AAEntity().teamId();
            const executeSkillDelayed = (charId) => {
                AAUtils.callDelayed(() => {
                    //@ts-ignore
                    uAPI.executeAASkillOnChar(ownerId, teamId, params.skillId, charId);
                }, Math.random() * 400);
            };
            // * Через отдельный метод, чтобы не было дублирование eventId
            targets.forEach((t) => executeSkillDelayed(t.aaCharId()));
        }
        catch (e) {
            console.warn(e);
        }
    }
    _updateTimers(battler) {
        for (const k in this._aaStateTimers) {
            this._aaStateTimers[k][0]++;
            if (this._aaStateTimers[k][0] >= 60) {
                this._aaStateTimers[k][0] = 0;
                // * Только если больше 0 (т.к. -1 - бесконечно)
                if (this._aaStateTimers[k][1] > 0) {
                    this._aaStateTimers[k][1]--;
                    // * зеркалим обратно на Battler
                    battler._stateTurns[k] = this._aaStateTimers[k][1];
                }
                // * Tick не выполняется на последней секунде
                if (this._aaStateTimers[k][1] !== 0) {
                    this._onStateTick(parseInt(k), battler);
                }
                else {
                    // * ключи хранятся как String
                    battler.removeState(parseInt(k));
                }
            }
        }
    }
    _updateActionCounters(battler) {
        for (const k in this._aaStateActionCounts) {
            if (this._aaStateActionCounts[k] === 0) {
                battler.removeState(parseInt(k));
            }
        }
    }
    // * Этот метод считает секунды на каждый бафф и уменьшает количество "ходов" для баффов
    _updateBuffs(battler) {
        for (let index = 0; index < battler._buffTurns.length; index++) {
            const turn = battler._buffTurns[index];
            if (turn > 0) { // * Есть время (т.е. бафф действует)
                if (this._aaBuffsTimers[index] < 0) {
                    this._aaBuffsTimers[index] = 60; // * один ход = 1 секунда
                }
                else if (this._aaBuffsTimers[index] === 0) { // * время вышло
                    this._aaBuffsTimers[index] = 60;
                    battler._buffTurns[index]--; // * минус один ход
                    if (battler._buffTurns[index] <= 0) {
                        battler.removeBuffsAuto();
                        continue; // * Бафф удалён, таймер считать не надо, следующий
                    }
                }
                this._aaBuffsTimers[index]--; // * считаем таймер
            }
            else {
                if (this._aaBuffsTimers[index] >= 0) {
                    // * Обнуляем таймер
                    this._aaBuffsTimers[index] = -1;
                }
            }
        }
    }
}
// ■ END AAStatesSet.ts
// ---------------------------------------------------------------------------
window['AAStatesSet'] = AAStatesSet;


// Generated by CoffeeScript 2.6.1
// * Менеджер по работе с целями (поиск целей, определение)

//$[ENCODE]
window.AATargetsManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AATargetsManager;
  // * Используется для определения цели для Instant NoProjectile Direction навыков
  // * Проверка точки на наличие целей для навыка
  //?[OUTER - used by AABattleActionsManager]
  //? Этот навык используется напрямую для выбора целей в битве
  _.getTargetInPoint = function(subject, aaSkill, point) {
    var events, targets;
    events = this._collectAllAAEntitiesInPoints([point]);
    if (events.isEmpty()) {
      return null;
    }
    // * В зависимости от Subject и в зависимости от действия навыка
    targets = this.filteredTargetsForSubject(subject, aaSkill, events);
    if ((targets != null) && targets.length > 0) {
      return targets[0];
    } else {
      return null;
    }
  };
  // * Отфильтровать цели (из найденных в точках) для Subject (навыка)
  _.filteredTargetsForSubject = function(subject, aaSkill, targets) {
    var candidates, e, entity, k, l, len, len1, t;
    try {
      entity = subject.AAEntity();
      if (entity == null) {
        return [];
      }
      candidates = [];
      if (aaSkill.isForEnemies()) {
        for (k = 0, len = targets.length; k < len; k++) {
          t = targets[k];
          if (t == null) {
            continue;
          }
          if (entity.isMyEnemy(t.AAEntity())) {
            candidates.push(t);
          }
        }
      }
      if (aaSkill.isForFriends()) {
        for (l = 0, len1 = targets.length; l < len1; l++) {
          t = targets[l];
          if (!entity.isMyEnemy(t.AAEntity())) {
            candidates.push(t);
          }
        }
      }
      return candidates;
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Собрать цели для навыка (Projectile)
  //?[OUTER - used by AABattleActionsManager]
  //? Этот навык используется напрямую для выбора целей в битве
  _.collectTargtesForSkill = function(subject, absSkill, point) {
    var chance, extraTargets, k, len, t, targets;
    targets = [];
    // * Точные цели селектора, если мнгновенный навык (только для игрока)
    if (absSkill.isInstant() && subject === $gamePlayer && ($gameTemp._aaSkillSelectorTargets != null)) {
      targets = $gameTemp._aaSkillSelectorTargets;
    } else {
      targets = this.collectTargetsForSkillInMapPoint(absSkill, point);
    }
    if (absSkill.isSwing() && (subject.direction != null)) {
      chance = absSkill.getSwingKoef();
      extraTargets = this.collectTargetsForSwingAction(subject.direction(), point);
      for (k = 0, len = extraTargets.length; k < len; k++) {
        t = extraTargets[k];
        if (KDCore.Utils.isChanceIsGood(chance)) {
          targets.push(t);
        }
      }
    }
    // * Убираем НЕ АБС события
    targets = targets.filter(function(t) {
      return t.isActive();
    });
    targets = this.filteredTargetsForSubject(subject, absSkill, targets);
    // * Сбрасываем цели селектора
    $gameTemp._aaSkillSelectorTargets = null;
    return targets;
  };
  // * Собирает все возможные цели для навыка в точке карты
  // * (Лучше использовать этот метод для определения целей)
  _.collectTargetsForSkillInMapPoint = function(aaSkill, point) {
    var kdPoint, targets;
    if (aaSkill == null) {
      return [];
    }
    if (point == null) {
      return [];
    }
    targets = [];
    if (point instanceof Game_Character && aaSkill.isSingleTargetArea() && !(point instanceof AADummyCharacter)) {
      targets = [point];
    } else {
      if (aaSkill.isSingleTargetArea()) {
        targets = this._collectAllAAEntitiesInPoints([point]);
      } else {
        kdPoint = new KDCore.Point(point.x, point.y);
        targets = this.collectTargetsForSkillInScreenPoint(aaSkill, kdPoint.convertToScreen());
      }
    }
    return targets;
  };
  // * Собрать цели для навыка с эффектом "взмаха"
  _.collectTargetsForSwingAction = function(direction, point) {
    var e, neibPoints;
    try {
      if (point == null) {
        return [];
      }
      if (direction == null) {
        return [];
      }
      neibPoints = AA.Utils.Math.getNeibPoints(point.x, point.y, direction);
      return this._collectAllAAEntitiesInPoints(neibPoints);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return [];
  };
  // * Собирает все возможные цели для навыка в точке экрана
  // * (Используется для сбора событий в радиусе)
  _.collectTargetsForSkillInScreenPoint = function(aaSkill, point) {
    var searchMapPoints, targets;
    if (aaSkill == null) {
      return [];
    }
    if (point == null) {
      return [];
    }
    targets = [];
    // * Сформировать квадрат выбора
    searchMapPoints = this._createSquarePoints(aaSkill.gRadius(), point);
    targets = this._collectAllAAEntitiesInPoints(searchMapPoints);
    return targets;
  };
  _.collectTargetsForPlayerSelector = function(aaSkill) {
    var e, targets;
    try {
      // * Проверка range, если выходит за range, то не будут цели выделяться
      if (AAMath.getDistanceToPlayerFrom(TouchInput.toMapPoint()) <= aaSkill.gRange()) {
        targets = this.collectTargetsForSkillInScreenPoint(aaSkill, TouchInput);
      } else {
        targets = [];
      }
      // * Фильтр целей сразу
      return this.filteredTargetsForSubject($gamePlayer, aaSkill, targets);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Создаём точки карты в квадратной области навыка (пиксели)
  _._createSquarePoints = function(radius, point) {
    var cellSize, cellSize2, ex, ey, i, j, k, l, points, pxRadius, ref, ref1, ref2, ref3, ref4, ref5, sx, sy;
    cellSize = $gameMap.tileWidth();
    cellSize2 = cellSize / 2;
    points = [];
    pxRadius = radius * cellSize / 2;
    sx = point.x - pxRadius;
    sy = point.y - pxRadius;
    ex = point.x + pxRadius;
    ey = point.y + pxRadius;
    for (i = k = ref = sx, ref1 = ex, ref2 = cellSize; ref2 !== 0 && (ref2 > 0 ? k < ref1 : k > ref1); i = k += ref2) {
      for (j = l = ref3 = sy, ref4 = ey, ref5 = cellSize; ref5 !== 0 && (ref5 > 0 ? l < ref4 : l > ref4); j = l += ref5) {
        points.push(new KDCore.Point(i + cellSize2 / 2, j + cellSize2).convertToMap());
      }
    }
    return points;
  };
  // * Собирает все АБС сущности (события + игрок + партия)
  _._collectAllAAEntitiesInPoints = function(points) {
    var aaEntities;
    aaEntities = [];
    aaEntities.push(...this._collectAAEventsInPoints(points));
    aaEntities.push(...this._collectPartyMembersInPoints(points));
    if (AA.Network.isNetworkGame()) {
      aaEntities.push(...this._collectNetworkCharsInPoints(points));
    }
    //TODO: collect network characters as well
    return aaEntities;
  };
  // * Собирает все АБС события (Активные) в точках карты
  _._collectAAEventsInPoints = function(points) {
    var e, events, k, len, p;
    events = [];
    try {
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        events.push(...$gameMap.eventsXyAAExt(p.x, p.y));
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return events;
  };
  _._collectPartyMembersInPoints = function(points) {
    var char, e, k, l, len, len1, members, p, partyMembers;
    members = [];
    try {
      partyMembers = $gamePlayer.aaGetABSFollowers();
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        if ($gamePlayer.posExt(p.x, p.y)) {
          members.push($gamePlayer);
        }
        for (l = 0, len1 = partyMembers.length; l < len1; l++) {
          char = partyMembers[l];
          if (char.posExt(p.x, p.y)) {
            members.push(char);
          }
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return members;
  };
  _._collectNetworkCharsInPoints = function(points) {
    var e, k, len, members, p;
    members = [];
    try {
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        members.push(...$gameMap.netChars().filter(function(c) {
          return c.posExt(p.x, p.y);
        }));
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return members;
  };
  _.collectAllABSEntitiesOnMap = function() {
    var aaEntities;
    aaEntities = [$gamePlayer];
    aaEntities.push(...$gameMap.eventsAA());
    aaEntities.push(...$gamePlayer.aaGetABSFollowers());
    if (AA.Network.isNetworkGame()) {
      aaEntities.push(...$gameMap.netChars());
    }
    return aaEntities.filter(this.isValidTarget);
  };
  // * Быстрый метод проверки, находится ли игрок в определённом радиусе
  _.isPlayerInRadius = function(point, radius) {
    var e;
    try {
      return this.isCharExtInRadius(point, radius, $gamePlayer);
    } catch (error) {
      e = error;
      AA.w(e);
      return false;
    }
  };
  //? forWho - Game_Character (with ABS)
  _.getAvailableTargetsInTriangle = function(forWho, radius, tVisorSize, tSideSize) {
    var _all, candidates, d, e, entity, k, len, p1, p2, p3, points, x, y;
    try {
      points = [];
      candidates = [];
      ({x, y} = forWho);
      d = forWho.direction();
      if (tSideSize > 0) {
        points.push(...AA.Utils.Math.getLeftAndRightPoints(x, y, d));
        candidates = this._collectAllAAEntitiesInPoints(points);
      }
      // * Получаем вершины треугольника
      [p1, p2, p3] = AA.Utils.Math.getTriangleVertixes(x, y, d, radius, tVisorSize);
      // * Проверяем на вхождение
      _all = this.getAvailableTargetsInRadius(forWho, radius);
      for (k = 0, len = _all.length; k < len; k++) {
        entity = _all[k];
        if (AA.Utils.Math.isPointInsideTriangle(p1, p2, p3, entity)) {
          candidates.push(entity);
        }
      }
      return candidates.filter(function(t) {
        return forWho.isMyEnemy(t);
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  //? forWho - Game_Character (with ABS)
  _.getAvailableTargetsInRadius = function(forWho, radius) {
    var candidates, e;
    try {
      // * forWho идёт как Point тоже
      candidates = this.collectAllABSEntitiesOnMap();
      candidates = candidates.filter(function(t) {
        return (t != null) && forWho.isMyEnemy(t);
      });
      return this.getFilteredInRadius(forWho, radius, candidates);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  //? forWho - Game_Character (with ABS)
  _.getAvailableAlliesInRadius = function(forWho, radius) {
    var candidates, e;
    try {
      // * forWho идёт как Point тоже
      candidates = this.collectAllABSEntitiesOnMap();
      candidates = candidates.filter(function(t) {
        return !forWho.isMyEnemy(t);
      });
      return this.getFilteredInRadius(forWho, radius, candidates);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  //? point - просто { x, y }
  // exceptTeamId - будут АА события с НЕ равыным данному teamId
  _.getAvailableAAEntitiesInRadius = function(point, radius, exceptTeamId) {
    var candidates, e;
    try {
      candidates = this.collectAllABSEntitiesOnMap();
      if ((exceptTeamId != null) && exceptTeamId !== -1) {
        candidates = candidates.filter(function(t) {
          return t.isABS() && t.AAEntity().teamId() !== exceptTeamId;
        });
      }
      return this.getFilteredInRadius(forWho, radius, candidates);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // * Вернёт набор возможных AA событий, которые подходят под эффект навыка
  // * ( с учётом кто его запускает userTeamId )
  _.getAAEntitiesSetDependsSkill = function(userTeamId, aaSkill) {
    var candidates, e;
    try {
      candidates = this.collectAllABSEntitiesOnMap();
      if (userTeamId === -1) { // * Все в таком случае
        return candidates;
      }
      if (aaSkill.isForEnemiesOnly()) {
        return candidates.filter(function(t) {
          return t.isABS() && t.AAEntity().teamId() !== userTeamId;
        });
      } else if (aaSkill.isForFriendsOnly()) {
        return candidates.filter(function(t) {
          return t.isABS() && t.AAEntity().teamId() === userTeamId;
        });
      } else {
        return candidates; // * Все в таком случае
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // * Получить сущности в радиусе (из набора сущностей)
  _.getFilteredInRadius = function(point, radius, candidates) {
    var c, e, k, len, members;
    members = [];
    try {
      for (k = 0, len = candidates.length; k < len; k++) {
        c = candidates[k];
        if (this.isCharExtInRadius(point, radius, c)) {
          members.push(c);
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return members;
  };
  // * Находится ли персонаж (точка) в радиусе (с учётом расширенных HitBox)
  _.isCharExtInRadius = function(point, radius, char) {
    var e, k, len, p, points;
    try {
      points = $gameMap.aaGetExtendedPointsFor(char);
      for (k = 0, len = points.length; k < len; k++) {
        p = points[k];
        if ($gameMap.distance(point.x, point.y, p.x, p.y) <= radius) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
  // * Получить дистанцию между персонажем и точкой (на экране)
  // * Учитываются расширенные HitBox
  _.getScreenExtDistance = function(char, offsetY, x2, y2) {
    var dist, e, k, l, len, len1, screenXs, screenYs, x, y;
    try {
      if (char == null) {
        return 1000;
      }
      if (char.aaIsHaveExtendedHitBoxes()) {
        screenXs = char.screenXExt();
        screenYs = char.screenYExt();
        dist = [];
        for (k = 0, len = screenXs.length; k < len; k++) {
          x = screenXs[k];
          for (l = 0, len1 = screenYs.length; l < len1; l++) {
            y = screenYs[l];
            dist.push(AAMath.distanceXY(x, y - offsetY, x2, y2));
          }
        }
        return dist.min();
      } else {
        return AAMath.distanceXY(char.screenX(), char.screenY() - offsetY, x2, y2);
      }
    } catch (error) {
      e = error;
      AA.w(e);
      return 1000;
    }
  };
  // * Цель подходящая (проверки, см. BattleManagerABS.isValidTarget)
  //TODO: isValidTarget
  _.isValidTarget = function(targetChar) {
    return (targetChar != null) && targetChar.isActive() && targetChar.AABattler().isAlive();
  };
  // * Находится ли точка (цель) в области дейтсвия навыка (range)
  _.isInSkillRange = function(char, skillId, targetPoint) {
    var dataObj, dist, e, skill;
    try {
      //TODO: ПОка просто
      dist = char.distToCol(targetPoint);
      dataObj = AASkill2.GetAASkillObject(skillId);
      skill = dataObj.AASkill;
      //console.log("D " + dist)
      //console.log("R " + skill.range)
      return dist <= skill.gRange();
    } catch (error) {
      e = error;
      AA.w(e);
      return false;
    }
  };
  // * Получить всех ботов, которые имеют игрока своей целью
  //TODO: TeamID учёт
  // * На данный момент не проверяется кто именно цель, так как нету сопартийцев и teamId
  _.getAllWhoHavePlayerAsTarget = function() {
    return $gameMap.eventsAA().filter(function(e) {
      return e.AAEntity().isHasTarget();
    });
  };
  // * Получить всех "врагов", которые имеют целью игрока с учётом радиуса
  _.getAllWhoHavePlayerAsTargetInRange = function(range) {
    var candidates;
    candidates = this.getAllWhoHavePlayerAsTarget();
    if (candidates.length > 0) {
      candidates = AATargetsManager.getFilteredInRadius($gamePlayer, range, candidates);
    }
    return candidates;
  };
  // * Применение доп. проверок и условий навыка на целях (например параметр usableIfTargetState)
  //? Вызывается на AABattleActionsManager в конце
  _.applyExtraSkillConditions = function(char, targets, absSkill) {
    var e;
    try {
      if (absSkill.isHaveTargetLimit() && targets.length > 1) {
        targets = this.applySkillTargetsLimit(subject, targets, absSkill);
      }
      if (absSkill.isRequireStateOnTarget()) {
        targets = targets.filter(function(t) {
          return (t != null) && t.AABattler().isStateAffected(absSkill.gUsableIfTargetState());
        });
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return targets;
  };
  // * Применить параметры targetLimit и targetLimitType для навыка
  //? Вызывается на AABattleActionsManager в конце
  _.applySkillTargetsLimit = function(char, targets, absSkill) {
    var e, targetLimit, targetType;
    try {
      targetLimit = absSkill.gTargetLimit();
      if (targetLimit <= 0) {
        // * Если нет лимита, то все цели и возвращаем
        return targets;
      }
      targetType = absSkill.getETargetLimitType();
      if (targetType > 0 && (char != null) && (char.x != null) && (char.y != null)) {
        // * Сортировка по возрастанию расстояния
        targets.sort(function(a, b) {
          var distA, distB, x, y;
          ({x, y} = char);
          distA = AAMath.distanceXY(a.x, a.y, x, y);
          distB = AAMath.distanceXY(b.x, b.y, x, y);
          //distA = $gameMap.distance(a.x, a.y, x, y)
          //distB = $gameMap.distance(b.x, b.y, x, y)
          return distA - distB;
        });
        // * Если надо дальнюю, то перевернём массив, так как выбираются первые цели
        if (targetType > 1) { // * far
          targets = targets.reverse();
        }
      } else {
        targets.shuffle();
      }
      return targets.slice(0, targetLimit);
    } catch (error) {
      e = error;
      AA.w(e);
      return [targets[0]];
    }
  };
  // * Найти ближайшую цель для homing projectile снаряда
  _.findCandidateForHomingProjectile = function(char, aaSkill, point) {
    var candidates, e, userTeamId, whoSuitsSkill;
    try {
      //"TRY SERACH FOR TARGETS".p()
      userTeamId = char.AAEntity().teamId();
      whoSuitsSkill = this.getAAEntitiesSetDependsSkill(userTeamId, aaSkill);
      if ((whoSuitsSkill != null) && whoSuitsSkill.length > 0) {
        candidates = this.getFilteredInRadius(point, 2, whoSuitsSkill);
        candidates.delete(char);
        if (candidates.length > 0) {
          return candidates.sample();
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------


var AATargetsManager2;
(function (AATargetsManager2) {
    let _collidersCache = {};
    function getTargetsForSkill(user, skill, initialPosition) {
        return getTargetsForSkillInRadius(user, skill, initialPosition, skill.gRadius());
    }
    AATargetsManager2.getTargetsForSkill = getTargetsForSkill;
    function getTargetsForSkillInRadius(user, skill, initialPosition, radius) {
        let targets = getTargetsInRadius(radius, initialPosition);
        targets = filterTargetsByRelationship(user, targets, skill);
        targets = filterTargetsBySkillConditions(user, targets, skill);
        return targets;
    }
    AATargetsManager2.getTargetsForSkillInRadius = getTargetsForSkillInRadius;
    function getTargetsInRadius(radius, center) {
        let collider = getHurtboxCollider(radius);
        collider.setPositionXY(center.x, center.y);
        drawColliderForDebug(collider);
        return getTargetsForCollider(collider);
    }
    AATargetsManager2.getTargetsInRadius = getTargetsInRadius;
    function getTargetsForCollider(collider) {
        let hitboxOwners = AABattleMapManager.getAllHitboxOwners(true);
        let targets = [];
        hitboxOwners.forEach(owner => {
            let hitboxes = AAHitBox.getFor(owner);
            hitboxes.forEach(hitbox => {
                if (hitbox.isCollideWith(collider)) {
                    targets.push(owner);
                    //console.log('Target found: ');
                    //console.log(owner);
                }
            });
        });
        return targets;
    }
    AATargetsManager2.getTargetsForCollider = getTargetsForCollider;
    function getHurtboxCollider(radius) {
        let collider = null;
        if (_collidersCache[radius]) {
            collider = _collidersCache[radius];
        }
        else {
            collider = new AACollider({
                radius: radius * $gameMap.tileWidth(),
                type: 'c',
                flag: 'hurtbox'
            });
            _collidersCache[radius] = collider;
        }
        return collider;
    }
    function filterTargetsByRelationship(user, targets, skill) {
        let possibleTargets = targets.filter(target => {
            return isValidTarget(target);
        });
        try {
            let userEntity = AsAAChar(user).AAEntity();
            if (!userEntity)
                return possibleTargets;
            if (skill.isForFriends() && skill.isForEnemies()) {
                return possibleTargets;
            }
            let resultTargets = [];
            if (skill.isForEnemies()) {
                let enemies = possibleTargets.filter(target => {
                    let targetEntity = AsAAChar(target).AAEntity();
                    if (!targetEntity)
                        return false;
                    return userEntity.isMyEnemy(targetEntity);
                });
                for (let i = 0; i < enemies.length; i++) {
                    resultTargets.push(enemies[i]);
                }
            }
            if (skill.isForFriends()) {
                let friends = possibleTargets.filter(target => {
                    //@ts-ignore
                    let targetEntity = target.AAEntity();
                    if (!targetEntity)
                        return false;
                    return !userEntity.isMyEnemy(targetEntity);
                });
                for (let i = 0; i < friends.length; i++) {
                    resultTargets.push(friends[i]);
                }
            }
            return resultTargets;
        }
        catch (error) {
            console.warn(error);
        }
        return [];
    }
    AATargetsManager2.filterTargetsByRelationship = filterTargetsByRelationship;
    function filterTargetsBySkillConditions(user, targets, skill) {
        try {
            targets = applySkillTargetLimitRules(user, targets, skill);
            if (skill.isRequireStateOnTarget()) {
                targets = targets.filter(target => {
                    return AsAAChar(target).AABattler().isStateAffected(skill.gUsableIfTargetState());
                });
            }
        }
        catch (error) {
            console.warn(error);
        }
        return targets;
    }
    function applySkillTargetLimitRules(user, targets, skill) {
        try {
            let targetLimit = skill.gTargetLimit();
            if (targetLimit == 0)
                return targets;
            if (targets.length <= targetLimit)
                return targets;
            // * 0 - Любая цель, 1 - Ближайшая, 2 - Дальняя
            let targetLimitType = skill.getETargetLimitType();
            if (targetLimitType > 0 && user) {
                // * Сортировка по возрастанию расстояния
                targets.sort((a, b) => {
                    let aDist = AAMath.distance(user, a);
                    let bDist = AAMath.distance(user, b);
                    return aDist - bDist;
                });
                if (targetLimitType == 2) {
                    targets.reverse();
                }
            }
            else {
                //@ts-ignore
                targets.shuffle();
            }
            return targets.slice(0, targetLimit);
        }
        catch (error) {
            console.warn(error);
        }
        return targets;
    }
    AATargetsManager2.applySkillTargetLimitRules = applySkillTargetLimitRules;
    function isValidTarget(char) {
        if (!char)
            return false;
        let aaChar = AsAAChar(char);
        return aaChar.isActive() && !aaChar.aaIsInvincible();
    }
    AATargetsManager2.isValidTarget = isValidTarget;
    function drawColliderForDebug(collider) {
        if (!Sprite_AACollisionsLayer.Instance()) {
            return;
        }
        let sprite = new Sprite_AACollider(collider, {
            color: '#ff0000',
            opacity: 100
        });
        Sprite_AACollisionsLayer.Instance().addChild(sprite);
        setTimeout(() => {
            try {
                if (sprite && KUtils.IsMapScene()) {
                    sprite.destroy();
                }
            }
            catch (error) {
                console.warn(error);
            }
        }, 2000);
    }
})(AATargetsManager2 || (AATargetsManager2 = {}));
window["AATargetsManager2"] = AATargetsManager2;


// Таймер для навыков, хранит время в кадрах (frames)
class AATimer {
    constructor(maxValue = 0, value = 0) {
        this.skillId = 0;
        this.maxValue = maxValue;
        this.value = value;
    }
    update() {
        if (!this.isReady()) {
            this.value++;
        }
    }
    isReady() {
        return this.value >= this.maxValue;
    }
    start(maxValue) {
        this.reset();
        this.maxValue = Math.abs(Math.round(maxValue));
    }
    reset() {
        this.value = 0;
    }
    getSeconds() {
        return AATimer.ConvertFramesToSeconds(this.value);
    }
    getMaxSeconds() {
        return AATimer.ConvertFramesToSeconds(this.maxValue);
    }
    getSecondsLeft() {
        return (parseFloat(this.getMaxSeconds()) - parseFloat(this.getSeconds())).toFixed(1);
    }
    static ConvertFramesToSeconds(value) {
        return (value / 60.0).toFixed(1);
    }
}
window['AATimer'] = AATimer;


var AATranslationMover;
(function (AATranslationMover) {
    function isShouldTranslate(char) {
        return getTranslationSettings(char) != null;
    }
    AATranslationMover.isShouldTranslate = isShouldTranslate;
    function getTranslationSettings(char) {
        return char['_aaTranslationConfig'];
    }
    AATranslationMover.getTranslationSettings = getTranslationSettings;
    function startTranslationMovement(char, config) {
        stopTranslationMovement(char);
        console.log('Start move by translation');
        char['_aaTranslationConfig'] = config;
    }
    AATranslationMover.startTranslationMovement = startTranslationMovement;
    function stopTranslationMovement(char) {
        if (!char['_aaTranslationConfig']) {
            return;
        }
        console.log('Stop move by translation');
        char['_aaTranslationConfig'] = null;
        AACharMovementUtils.applyLocation(char);
    }
    AATranslationMover.stopTranslationMovement = stopTranslationMovement;
    function updateTranslationMoveFor(char) {
        try {
            let config = getTranslationSettings(char);
            if (!config)
                return;
            if (config.distance <= 0) {
                stopTranslationMovement(char);
                return;
            }
            if (!config.startPoint) {
                config.startPoint = { x: char._realX, y: char._realY };
            }
            let translatedDistance = AAMath.distance(config.startPoint, { x: char._realX, y: char._realY });
            if (translatedDistance >= config.distance) {
                stopTranslationMovement(char);
                return;
            }
            AACharMovementUtils.translateCharacterInDirection(char, config.directionVector, true, config.speedModifier, true, () => {
                stopTranslationMovement(char);
            });
        }
        catch (error) {
            console.warn(error);
        }
    }
    AATranslationMover.updateTranslationMoveFor = updateTranslationMoveFor;
})(AATranslationMover || (AATranslationMover = {}));
window['AATranslationMover'] = AATranslationMover;


// Generated by CoffeeScript 2.6.1
// * Основной класс менеджер интерфейса (API)
AA.UI = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AA.UI.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UI;
  // * Методы пред подготовки (возможно uiSet ещё даже не задан)
  _.init = function() {
    return this._subscribeForEvents();
  };
  _.setUI = function(uiSet) {
    this.uiSet = uiSet;
  };
  _.isValid = function() {
    return this.uiSet != null;
  };
  // * Когда появляется окно с сообщением
  _.onGameMessageStart = function() {
    var ref;
    return (ref = this.uiSet) != null ? ref.onGameMessageStart() : void 0;
  };
  //TODO: Опция, чтобы автоматически закрывать окно выбора навыков, когда появляется сообщение

  // * Когда заканчивается окно с сообщением
  _.onGameMessageEnd = function() {
    var ref;
    return (ref = this.uiSet) != null ? ref.onGameMessageEnd() : void 0;
  };
  // * Когда было нажатие мышки на какой-либо UI элемент
  _.isUITouched = function() {
    return false;
  };
  // * Вызывается когда сцена карты заканчивается
  _.terminate = function() {
    var ref;
    return (ref = this.uiSet) != null ? ref.terminate() : void 0;
  };
  (function() {    // * Основной интерфейс Spriteset_UI
    // -----------------------------------------------------------------------
    _.refresh = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.refresh() : void 0;
    };
    _.refreshElement = function(tag) {
      var ref, ref1;
      if ((ref = this.uiSet) != null) {
        ref.refreshElement(tag);
      }
      if ((ref1 = this.uiSet) != null) {
        ref1.refreshController(tag);
      }
    };
    /*_.refreshAllElements = () ->
    return unless @uiSet?
    try
        user = $gameSystem.aaGetUserUISettings()
        for e in @uiSet.elements
            if e? and String.any(e.tag) and user.isHaveFor(e.tag)
                @refreshElement(e.tag)
    catch e
        AA.w e
    return*/
    _.hide = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.hide() : void 0;
    };
    _.show = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.show() : void 0;
    };
    // * Если какой-либо UI элемент обрабатывает нажатие курсора, то true
    _.isAnyUIElementTouchProcess = function() {
      // * Обработка окна выбора навыков
      if (this._isSkillSelectorProcessHandler()) {
        return true;
      } else {
        return false;
      }
    };
    return _.addToUI = function(element) {
      if (this.uiSet == null) {
        return;
      }
      if (element == null) {
        return;
      }
      return this.uiSet.addChild(element);
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Набор навыков
    // -----------------------------------------------------------------------
    // * Открыть окно выбора навыка для слота (символа)
    _.openSkillSelectorFor = function(symbol) {
      var cntrl, e, item;
      if (!this.isValid()) {
        return;
      }
      try {
        if (symbol == null) {
          return this.closeSkillSelector();
        } else {
          cntrl = this.uiSet.getController("skills");
          item = cntrl._getItemForSymbol(symbol);
          if (item != null) {
            return this.uiSet.fwSkillsSelector.prepareAndOpenForSlot(item);
          }
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Открыто ли окно выбора навыка
    _.isSkillSelectorOpen = function() {
      var e;
      if (!this.isValid()) {
        return;
      }
      try {
        return this.uiSet.fwSkillsSelector.isOpen();
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return false;
    };
    _.closeSkillSelector = function() {
      var e;
      if (!this.isValid()) {
        return;
      }
      try {
        this.uiSet._terminateSkillSelectorWindow();
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    // * Когда игрок нажал на кнопку какого-либо навыка на панели навыков
    _.skillPerformResult = function(skillId, result) {
      var cntrl, e;
      try {
        if (!this.isValid()) {
          return;
        }
        cntrl = this.uiSet.getController("skills");
        return cntrl != null ? cntrl.onSkillPerformResult(skillId, result) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Если открыто окно выбора навыка для слота, то оно закрывается сперва
    // * Если правой кнопкой по навыку, то открывается окно
    _._isSkillSelectorProcessHandler = function() {
      var e, ref;
      if (!this.isValid()) {
        return false;
      }
      try {
        return (ref = this.uiSet.getController("skills")) != null ? ref.handleSkillSelectorProcess() : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Символ элемента панели навыков под курсором
    // * Используется для перетаскивания предметов из инвентаря на панель навыков
    return _.getSkillSymbolUnderMouse = function() {
      var e, item, ref;
      try {
        item = (ref = this.uiSet.getController("skills")) != null ? ref.getItemUnderMouse() : void 0;
        if (item != null) {
          return item.symbol;
        }
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return null;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Выбор зоны применения навыка на карте
    // -----------------------------------------------------------------------
    // * Активировать зону поражения (показать спрайт)
    _.activateSkillImpactSelector = function(aaSkill) {
      AAEventsInteractionsManager.clearHighlightUnderCursorForAll();
      return Sprite_AAImpactZone.Create(aaSkill);
    };
    // * Эффект тряски (когда нажатие за зону поражения)
    _.shakeSkillImpactSelector = function() {
      var ref;
      return (ref = Sprite_AAImpactZone.Instance()) != null ? ref.attention() : void 0;
    };
    return _.resetSkillImpactSelector = function() {
      return Sprite_AAImpactZone.Remove();
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Обработка АБС событий
    // -----------------------------------------------------------------------
    _._subscribeForEvents = function() {
      return AA.EV.subscribeFor("PlayerSkillSelector", this.gev_onPlayerSkillSelector);
    };
    _.gev_onPlayerSkillSelector = function() {
      if ($gamePlayer.isInSkillTargetingState()) {
        return AA.UI.activateSkillImpactSelector($gamePlayer.activeAASkill());
      } else {
        return AA.UI.resetSkillImpactSelector();
      }
    };
  })();
})();

// ■ END AA.UI.coffee
//---------------------------------------------------------------------------


var AAUtils;
(function (AAUtils) {
    const SELF_SWITCHES = ["A", "B", "C", "D"];
    function isSceneMap() {
        try {
            return !SceneManager.isSceneChanging() && SceneManager._scene instanceof Scene_Map;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AAUtils.isSceneMap = isSceneMap;
    function isMZ() {
        return Utils.RPGMAKER_NAME === "MZ";
    }
    AAUtils.isMZ = isMZ;
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    AAUtils.generateUUID = generateUUID;
    function callDelayed(callback, delay) {
        if (!callback)
            return;
        return setTimeout(() => {
            try {
                callback();
            }
            catch (error) {
                console.warn(error);
            }
        }, delay);
    }
    AAUtils.callDelayed = callDelayed;
    function isSelfSwitch(value) {
        if (!value)
            return false;
        return SELF_SWITCHES.indexOf(value) >= 0;
    }
    AAUtils.isSelfSwitch = isSelfSwitch;
    function isValidCE(commonEventId) {
        return $dataCommonEvents[commonEventId] != null;
    }
    AAUtils.isValidCE = isValidCE;
    function startCE(commonEventId) {
        if (!isValidCE(commonEventId))
            return;
        $gameTemp.reserveCommonEvent(commonEventId);
    }
    AAUtils.startCE = startCE;
    function extractFramesAndSpeedValueFromImageName(imageName) {
        const result = { f: 1, s: 1 };
        if (!imageName || imageName.trim().length === 0)
            return result;
        try {
            const items = imageName.match(/\((.*)\)/i);
            if (items && items[1]) {
                const [frames, speed] = items[1].split(',').map(Number);
                result.f = frames;
                result.s = speed;
            }
        }
        catch (e) {
            console.warn(e);
        }
        return result;
    }
    AAUtils.extractFramesAndSpeedValueFromImageName = extractFramesAndSpeedValueFromImageName;
    function screenXOfMapX(mapX) {
        try {
            const tw = $gameMap.tileWidth();
            const value = $gameMap.adjustX(mapX) * tw + tw / 2;
            return value;
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    AAUtils.screenXOfMapX = screenXOfMapX;
    function screenYOfMapY(mapY) {
        try {
            const th = $gameMap.tileHeight();
            const value = $gameMap.adjustY(mapY) * th + th;
            return value;
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    AAUtils.screenYOfMapY = screenYOfMapY;
    function mapPointToScreenPoint(mapPoint) {
        return {
            x: screenXOfMapX(mapPoint.x),
            y: screenYOfMapY(mapPoint.y)
        };
    }
    AAUtils.mapPointToScreenPoint = mapPointToScreenPoint;
    function screenPointToMapPoint(screenPoint) {
        const tileWidth = $gameMap.tileWidth();
        const tileHeight = $gameMap.tileHeight();
        const originX = ($gameMap._displayX * tileWidth) - tileWidth / 2;
        const originY = $gameMap._displayY * tileHeight - tileHeight;
        let x = (originX + screenPoint.x) / tileWidth;
        let y = (originY + screenPoint.y) / tileHeight;
        return { x: x, y: y };
    }
    AAUtils.screenPointToMapPoint = screenPointToMapPoint;
    function mapPointToIndex(mapPoint) {
        return mapPoint.y * $gameMap.width() + mapPoint.x;
    }
    AAUtils.mapPointToIndex = mapPointToIndex;
    function indexToMapPoint(index) {
        const x = index % $gameMap.width();
        const y = Math.floor(index / $gameMap.width());
        return { x: x, y: y };
    }
    AAUtils.indexToMapPoint = indexToMapPoint;
    function isPointOnScreen(screenPoint) {
        let widthLimit = (Graphics.width / $gameScreen.zoomScale()) + 5;
        let heightLimit = (Graphics.height / $gameScreen.zoomScale()) + 5;
        return screenPoint.x >= 0 && screenPoint.x <= widthLimit && screenPoint.y >= 0 && screenPoint.y <= heightLimit;
    }
    AAUtils.isPointOnScreen = isPointOnScreen;
    function addToTilemap(sprite) {
        if (isSceneMap()) {
            //@ts-ignore
            SceneManager._scene._spriteset._tilemap.addChild(sprite);
        }
    }
    AAUtils.addToTilemap = addToTilemap;
    function getCharacterSprite(char) {
        if (!isSceneMap())
            return null;
        //@ts-ignore
        const spriteset = SceneManager._scene._spriteset;
        if (!spriteset)
            return null;
        //@ts-ignore
        return spriteset._characterSprites.find(s => s._character === char);
    }
    AAUtils.getCharacterSprite = getCharacterSprite;
})(AAUtils || (AAUtils = {}));
window['AAUtils'] = AAUtils;


var AAVectorMover;
(function (AAVectorMover) {
    function isShouldMoveByVector(char) {
        try {
            let vector = getMovementVector(char);
            return (vector != null) && !(vector.x == 0 && vector.y == 0);
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    AAVectorMover.isShouldMoveByVector = isShouldMoveByVector;
    function getMovementVector(char) {
        return char['_aaMovementVector'];
    }
    AAVectorMover.getMovementVector = getMovementVector;
    function isStopIfCollide(char) {
        return char['_aaStopIfCollide'] == true;
    }
    AAVectorMover.isStopIfCollide = isStopIfCollide;
    function setMovementVector(char, vector, stopIfCollide = false) {
        char['_aaMovementVector'] = vector;
        char['_aaStopIfCollide'] = stopIfCollide;
    }
    AAVectorMover.setMovementVector = setMovementVector;
    function clearMovementVector(char) {
        char['_aaMovementVector'] = null;
        char['_aaStopIfCollide'] = false;
    }
    AAVectorMover.clearMovementVector = clearMovementVector;
    function updateMoveByVectorFor(char) {
        try {
            let inputVector = getMovementVector(char);
            if (!inputVector)
                return;
            slideCharacterInDirection(char, inputVector, false, () => {
                if (AAVectorMover.isStopIfCollide(char)) {
                    setMovementVector(char, { x: 0, y: 0 });
                }
            });
        }
        catch (error) {
            console.warn(error);
        }
    }
    AAVectorMover.updateMoveByVectorFor = updateMoveByVectorFor;
    function slideCharacterInDirection(char, directionVector, keepDirection = false, collideCallback = null) {
        let currentPosition = {
            x: char._realX,
            y: char._realY
        };
        let distance = AACharMovementUtils.charSingleStepDistance(char);
        let nextPositionToCheck = AAMath.getNextPoint(currentPosition, directionVector, distance);
        if (!AACharMovementUtils.isCharCanMoveTo(char, nextPositionToCheck)) {
            nextPositionToCheck = null;
            // * If we can't move to next position, we try to move only on X or Y axis
            // * But only if input vector is diagonal
            if (directionVector.x != 0 && directionVector.y != 0) {
                // * Try Moving only on X axis
                nextPositionToCheck = AAMath.getNextPoint(currentPosition, { x: directionVector.x, y: 0 }, distance);
                if (!AACharMovementUtils.isCharCanMoveTo(char, nextPositionToCheck)) {
                    // * Try Moving only on Y axis
                    nextPositionToCheck = AAMath.getNextPoint(currentPosition, { x: 0, y: directionVector.y }, distance);
                    if (!AACharMovementUtils.isCharCanMoveTo(char, nextPositionToCheck)) {
                        nextPositionToCheck = null;
                    }
                }
            }
        }
        // * We don't check collisions here, because we already checked it
        if (nextPositionToCheck != null) {
            AACharMovementUtils.translateCharacterToPoint(char, nextPositionToCheck, keepDirection, 1, null, false, null);
        }
        else {
            if (!keepDirection) {
                let direction = AAMath.convertDirectionVectorToNumberDirection(directionVector);
                if (!AACharMovementUtils.isCharSupportDiagonalDirection(char)) {
                    direction = AAMath.convert8DirectionTo4Direction(direction);
                }
                char.setDirection(direction);
            }
            if (collideCallback) {
                collideCallback();
            }
            return;
        }
    }
    AAVectorMover.slideCharacterInDirection = slideCharacterInDirection;
})(AAVectorMover || (AAVectorMover = {}));
window['AAVectorMover'] = AAVectorMover;


// * Менеджер по работе с визорами АИ
var AAVisionManager;
(function (AAVisionManager) {
    // * Проверка видимости между визором (событием) и точкой (TRUE - видно точку)
    function isVisionLineIsFree(visor, endPoint) {
        try {
            const dist = $gameMap.distance(visor.x, visor.y, endPoint.x, endPoint.y);
            // * Если дистанция 1 (рядом), то значит на линии видимости не может быть помех
            if (dist <= 1)
                return true;
            // * Количество точек проверок на линии
            // * Хватит точности 1 к 1, поэтому количество точек = дистанции
            const allPoints = getLineBetweenTwoPoints(visor, endPoint, dist);
            const betweenPoints = [];
            // * Убираем End и Start точки с результата
            // * Нам важно проверить путь между начальной и конечной точкой
            const sP = [visor.x, visor.y];
            const eP = [endPoint.x, endPoint.y];
            for (const p of allPoints) {
                if (!isSamePoint(p, sP) && !isSamePoint(p, eP)) {
                    betweenPoints.push(p);
                }
            }
            // * Если между нет точек, то значит на линии видимости
            if (betweenPoints.length == 0)
                return true;
            for (const p of betweenPoints) {
                // * Если в точке находится объект (зона), что мешает зрению, значит false
                if (isPointIsColiderForVision(visor, p[0], p[1]))
                    return false;
            }
            return true;
        }
        catch (e) {
            console.warn(e);
        }
        return false;
    }
    AAVisionManager.isVisionLineIsFree = isVisionLineIsFree;
    // * Возвращает линию из точек между начальной и конечной точкой (включая начальную и конечную)
    function getLineBetweenTwoPoints(startPoint, endPoint, precision) {
        try {
            const tw = $gameMap.tileWidth();
            const sX = Number(startPoint.x * tw + tw / 2);
            const sY = Number(startPoint.y * tw + tw / 2);
            const eX = Number(endPoint.x * tw + tw / 2);
            const eY = Number(endPoint.y * tw + tw / 2);
            const points = [];
            for (let i = 1; i <= precision; i++) {
                const k = (i / precision);
                const px = (k * (eX - sX) + sX);
                const py = (k * (eY - sY) + sY);
                const cpx = Math.floor(px / $gameMap.tileWidth());
                const cpy = Math.floor(py / $gameMap.tileHeight());
                points.push([cpx, cpy]);
            }
            return points;
        }
        catch (e) {
            console.warn(e);
        }
        return [];
    }
    AAVisionManager.getLineBetweenTwoPoints = getLineBetweenTwoPoints;
    // * Находится ли в данной точке карты что-либо, что мешает видимости
    // * TRUE - нельзя "видеть" через эту точку
    function isPointIsColiderForVision(visor, x, y) {
        try {
            //@ts-ignore
            const model = visor.AAModel();
            //@ts-ignore
            const noVisionRegions = AA.PP.getVisionRestrictedRegions().concat(model.noPassVisionRegions);
            //@ts-ignore
            const noVisionTerrains = AA.PP.getVisionRestrictedTerrains().concat(model.noPassVisionTerrains);
            if (noVisionRegions.includes($gameMap.regionId(x, y)))
                return true;
            if (noVisionTerrains.includes($gameMap.terrainTag(x, y)))
                return true;
            // * События с расширенными HitBox участвуют в области видимости
            //@ts-ignore
            const events = $gameMap.eventsXyExt(x, y);
            if (events.length === 0)
                return false;
            // * Если хоть один блокирует, то значит заблокирована видимость
            //@ts-ignore
            return events.some((e) => e.aaIsBlockVision());
        }
        catch (e) {
            console.warn(e);
        }
        return true;
    }
    AAVisionManager.isPointIsColiderForVision = isPointIsColiderForVision;
    function isSamePoint(p1, p2) {
        return p1[0] === p2[0] && p1[1] === p2[1];
    }
})(AAVisionManager || (AAVisionManager = {}));


// Generated by CoffeeScript 2.6.1
// * Состояние боя для АИ союзника
var AllyAI_BattleFlow;

AllyAI_BattleFlow = class AllyAI_BattleFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  char() {
    return AllyAI_FlowMachine.prototype.char.call(this);
  }

  target() {
    return this.entity().getTarget();
  }

  moveType() {
    return this.model().getInBattleMoveType();
  }

  isCantMove() {
    return this.moveType() === 'stay';
  }

  isSupportMode() {
    return this._isBattleMode === false;
  }

  onStateStart() {
    "START BATTLE STATE".p();
    this.char().aaStoreHomePoint();
    // * Таймер новой проверки цели (Best)
    this._refreshTargetCheckThread = 0;
    this._canFightNow = true;
    this._isBattleMode = true;
    if (!this.char().isMyEnemy(this.target())) {
      this._isBattleMode = false;
    }
    // * Таймер следующей выборки действия
    // * Когда действие было выбранно, идёт небольшая пауза
    // * перед следующей выборкой действия
    this._nextActionCheck = 0;
    // * Сколько раз АИ не смог найти нужное действие
    this._actionMakeAttempts = 0;
    if (this.model().gNoMoveInBattle() === 1) {
      this.char().aaSetMoveTypeStayStill();
    }
    console.log(this.target());
  }

  onStateEnd() {
    this.char().aaResetHomePoint();
    this.entity().resetBattle();
  }

  exitAILogic() {
    this.onStateEnd();
    this.logic().getStateFlow(0).exitAILogic();
  }

  // * Получить "другую" лучшую цель
  tryGetAnotherBestTarget() {
    return this.logic().switchToFreeState();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AllyAI_BattleFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AllyAI_BattleFlow.prototype;
  _._updateFlow = function() {
    if (this._canFightNow === true) {
      this._updateOutOfHomeFlow();
      if (this._isBattleMode === true) {
        this._updateMainBattleFlow();
      } else {
        this._updateMainSupportFlow();
      }
      this._updateRefreshTargetThread();
    } else {
      this._updateReturnToPlayerFlow();
    }
  };
  _._setCurrentAction = function(_currentAction) {
    this._currentAction = _currentAction;
    this._resetNextActionCheck();
  };
  _._resetCurrentAction = function() {
    this._currentAction = null;
    this._resetNextActionCheck();
  };
  _._isActionIsExists = function() {
    return this._currentAction != null;
  };
  // * Находится ли цель на расстроянии применения действия
  // TODO: Это бы учитывать ещё при выборе действия
  _._isActionInDistance = function() {
    return EnemyAI_BattleFlow.prototype._isActionInDistance.call(this);
  };
  _._executeAction = function() {
    return EnemyAI_BattleFlow.prototype._executeAction.call(this);
  };
  _._isProperRangeForCloseAction = function() {
    return EnemyAI_BattleFlow.prototype._isProperRangeForCloseAction.call(this, ...arguments);
  };
  _._resetNextActionCheck = function() {
    return this._nextActionCheck = 10;
  };
  // * MOVING ======================================================================
  _._movingCloserToTarget = function() {
    this._resetNextActionCheck();
    if (!this.isSupportMode()) {
      if (this.model().gNoApproach() === 1) {
        return;
      }
    }
    if (this.model().gNoMoveInBattle() === 1) {
      return;
    }
    this.char().aaSetMoveTypeApproachTarget();
  };
  _._waitForAction = function() {
    if (!this.isSupportMode()) {
      if (!this.model().gNoMoveInBattle()) {
        this.char().aaSetMoveTypeKeepBattleDistance();
      }
    }
    this._actionMakeAttempts++;
    if (this._actionMakeAttempts > 60) {
      this.tryGetAnotherBestTarget();
    }
  };
  // * Если отошёл слишком далеко от "дома", надо вернуться
  _._updateOutOfHomeFlow = function() {
    if (this._isTooFarFromHomePoint()) {
      return this._canFightNow = false;
    }
  };
  _._isTooFarFromHomePoint = function() {
    var e;
    try {
      if (typeof $gamePlayer === "undefined" || $gamePlayer === null) {
        return false;
      }
      return this.char().distTo($gamePlayer) > (this.model().gReturnRadius());
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._updateReturnToPlayerFlow = function() {
    if (this.char().distTo($gamePlayer) <= (this.model().gViewRadius() - 1)) {
      this._canFightNow = true;
      this._nextActionCheck = 120;
    } else {
      this.char().aaSetMoveTypeReturnToHomePoint();
    }
  };
  _._updateRefreshTargetThread = function() {
    this._refreshTargetCheckThread++;
    if (this._refreshTargetCheckThread >= this.model().getRefreshBattleTargetTimeMax()) {
      this._refreshTargetCheckThread = 0;
      this.tryGetAnotherBestTarget();
    }
  };
  // * BATTLE FLOW ==============================================================
  _._updateMainBattleFlow = function() {
    if (this._isTargetValid()) {
      if (this.isSupportMode()) {
        this._selectSupportActionToUse();
      } else {
        this._selectBattleActionToUse();
      }
      if (this._isActionIsExists()) {
        this._actionMakeAttempts = 0;
        if (this._isActionInDistance()) {
          this._executeAction();
          if (this.isSupportMode()) {
            // * В режиме поддержки, после выполнения действия, надо сразу делать поиск другой цели
            return this.tryGetAnotherBestTarget();
          }
        } else {
          return this._movingCloserToTarget();
        }
      } else {
        return this._waitForAction();
      }
    } else {
      return this.tryGetAnotherBestTarget();
    }
  };
  _._isTargetValid = function() {
    return this._isTargetInViewRadius() && AATargetsManager.isValidTarget(this.target());
  };
  _._isTargetInViewRadius = function() {
    return this.char().distTo(this.target()) <= (this.model().gViewRadius() + 1);
  };
  _._selectBattleActionToUse = function() {
    var bestAction, skills;
    this._nextActionCheck--;
    if (this._nextActionCheck > 0) {
      return;
    }
    skills = this._filterBattleSkills(this.battler().getUsableAASkills());
    if (skills.length > 0) {
      if (skills.length === 1) {
        this._setCurrentAction(skills[0]);
      } else {
        bestAction = this._selectBetterBattleActionForNow(skills);
        this._setCurrentAction(bestAction);
      }
    } else {
      this._resetCurrentAction();
    }
  };
  _._filterBattleSkills = function(skills) {
    var supportSkills;
    supportSkills = this.model().getSupportSkillsList();
    skills = skills.filter(function(skill) {
      return skill.AASkill.isForEnemiesOnly();
    });
    if (supportSkills.length > 0) {
      skills = skills.filter(function(skill) {
        return !supportSkills.contains(skill.id);
      });
    }
    //TODO: PARTY UPD Навык, который атакует вокруг, надо доп. проверку делать
    return skills;
  };
  _._selectBetterBattleActionForNow = function(skills) {
    var method, priorityList;
    // * Пока что смотрим только по списку приоритетов
    priorityList = this.model().getBattleSkillsPriorityList();
    if (priorityList.length > 0) {
      method = function(a, b) {
        var indexOfSkillA, indexOfSkillB;
        indexOfSkillA = priorityList.indexOf(a.id);
        indexOfSkillB = priorityList.indexOf(b.id);
        // * Если индекса нет, то 100000 (т.е. в самый конец)
        if (indexOfSkillA < 0) {
          indexOfSkillA = 100000;
        }
        if (indexOfSkillB < 0) {
          indexOfSkillB = 100000;
        }
        return indexOfSkillA - indexOfSkillB;
      };
      skills.sort(method);
      return skills[0];
    } else {
      //TODO: PARTY UPD Более умный алгоритм?
      return skills.sample();
    }
  };
  // * SUPPORT FLOW ==============================================================
  _._updateMainSupportFlow = function() {
    return this._updateMainBattleFlow();
  };
  _._selectSupportActionToUse = function() {
    var bestAction, skills;
    this._nextActionCheck--;
    if (this._nextActionCheck > 0) {
      return;
    }
    skills = this._filterSupportSkills(this.battler().getUsableAASkills());
    if (skills.length > 0) {
      if (skills.length === 1) {
        this._setCurrentAction(skills[0]);
      } else {
        bestAction = this._selectBetterSupportActionForNow(skills);
        this._setCurrentAction(bestAction);
      }
    } else {
      this._resetCurrentAction();
    }
  };
  _._filterSupportSkills = function(skills) {
    var supportSkills;
    supportSkills = this.model().getSupportSkillsList();
    skills = skills.filter(function(skill) {
      return skill.AASkill.isForFriends();
    });
    if (supportSkills.length > 0) {
      skills = skills.filter(function(skill) {
        return supportSkills.contains(skill.id);
      });
    }
    //TODO: Навык, который лечет вокруг, надо доп. проверку делать
    return skills;
  };
  _._selectBetterSupportActionForNow = function(skills) {
    var method, priorityList;
    // * Пока что смотрим только по списку приоритетов
    priorityList = this.model().getSupportSkillsList();
    if (priorityList.length > 0) {
      method = function(a, b) {
        var indexOfSkillA, indexOfSkillB;
        indexOfSkillA = priorityList.indexOf(a.id);
        indexOfSkillB = priorityList.indexOf(b.id);
        // * Если индекса нет, то 100000 (т.е. в самый конец)
        if (indexOfSkillA < 0) {
          indexOfSkillA = 100000;
        }
        if (indexOfSkillB < 0) {
          indexOfSkillB = 100000;
        }
        return indexOfSkillA - indexOfSkillB;
      };
      skills.sort(method);
      return skills[0];
    } else {
      //TODO: PARTY UPD Более умный алгоритм? Надо учитывать параметр модели: healInPriority
      return skills.sample();
    }
  };
})();

// ■ END AllyAI_BattleFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Машина состояний для АИ союзников на карте
var AllyAI_FlowMachine;

AllyAI_FlowMachine = class AllyAI_FlowMachine extends AIFlowMachine {
  constructor() {
    super(...arguments);
    this.registerFlowForState(0, new AllyAI_FreeFlow(this.id));
    this.registerFlowForState(1, new AllyAI_BattleFlow(this.id));
    // * Начальное состояние - свободное
    this.switchToFreeState();
    return;
  }

  switchToFreeState() {
    return this.setState(0);
  }

  switchToBattleState() {
    return this.setState(1);
  }

  isFreeState() {
    return this.state === 0;
  }

  isBattleState() {
    return this.state === 1;
  }

  char() {
    return $gamePlayer.followers().aaGetFollowerByActorId(this.id);
  }

};


// Generated by CoffeeScript 2.6.1
// * Свободное состояние для АИ союзника
// * В данном состоянии АИ определяет цель (ищет её)
var AllyAI_FreeFlow;

AllyAI_FreeFlow = class AllyAI_FreeFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  char() {
    return AllyAI_FlowMachine.prototype.char.call(this);
  }

  // * Выполняется каждый раз при переходе в это состояние
  onStateStart() {
    "START FREE STATE".p();
    this._currentBestTarget = null;
    this._currentBestTargetSP = null; // * support
    this._currentTargetTypeToFind = 0; // * 0 - battle, 1 - support
    // * Общее время на поиск лучшей цели
    // * Если цель не найдена, выходим из АИ логики
    this._freeFlowCommonTimer = 0;
    this._targetSearchTimer = 0;
  }

  // * Выполняется каждый раз при выходе из этого состояния
  onStateEnd() {
    this._freeFlowCommonTimer = 0;
    return this._targetSearchTimer = 0;
  }

  isHaveBestBattleTarget() {
    return this._currentBestTarget != null;
  }

  isHaveBestSupportTarget() {
    return this._currentBestTargetSP != null;
  }

  exitAILogic() {
    this.onStateEnd();
    this.char().aaForceResetAILogicState();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ AllyAI_FreeFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AllyAI_FreeFlow.prototype;
  // * Выполняется один раз при создании объекта (в конструкторе)
  _._setup = function() {};
  //TODO: Выбор двух целей (support и battle и уже выбор одной потом)
  _._updateFlow = function() {
    if (this._targetSearchTimer === 0) {
      this._updateTargetSearchFlow();
    }
    this._targetSearchTimer++;
    if (this._freeFlowCommonTimer >= 5) {
      this._targetSearchTimer = 0;
    }
    this._freeFlowCommonTimer++;
    if (this._freeFlowCommonTimer >= 11) {
      this._freeFlowCommonTimer = 0;
      this.exitAILogic();
    }
  };
  _._updateTargetSearchFlow = function() {
    if (this._currentTargetTypeToFind === 0) {
      this._updateBattleTargetSearch();
    } else {
      this._updateSupportTargetSearch();
    }
  };
  _._onBattleTargetFound = function(t) {
    // * Если поддержка не в приоритете и есть цель для боя, сразу её выбираем
    if ((t != null) && !this.model().isSupportInPriority()) {
      this._onFinalTargetFound(t);
      return;
    }
    if (this.model().isCanSupport()) {
      // * Теперь смотрим цель для support действия
      this._currentTargetTypeToFind = 1;
    } else {
      if (t != null) {
        // * Не поддерживает поддержку, т.е.сразу одна цель (бой)
        this._onFinalTargetFound(t);
      }
    }
  };
  _._onSupportTargetFound = function(t) {
    // * Если Support в приоритете и есть цель, то Support цель
    if ((t != null) && this.model().isSupportInPriority()) {
      this._onFinalTargetFound(t);
      return;
    }
    // * Если есть боевая цель, то сразу её
    if (this.isHaveBestBattleTarget()) {
      this._onFinalTargetFound(this._currentBestTarget);
      return;
    }
    // * Если есть цель Support, то её
    if (t != null) {
      this._onFinalTargetFound(t);
      return;
    }
    // * Иначе повторный поиск
    this._currentTargetTypeToFind = 0;
  };
  _._onFinalTargetFound = function(t) {
    this.entity().setTarget(t);
    this.logic().switchToBattleState();
  };
})();

// ■ END AllyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyAI_FreeFlow.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyAI_FreeFlow.prototype;
  _._updateSupportTargetSearch = function() {
    if (this.isHaveBestSupportTarget()) {
      return this._onSupportTargetFound(this._currentBestTargetSP);
    } else {
      this._currentBestTargetSP = this._trySelectBestSupportTarget();
      if (!this.isHaveBestSupportTarget()) {
        // * Не может быть любой цели для поддержки (только по критериям!)
        "SELECT NO ANY SUPPORT TARGET (null)".p();
        this._onSupportTargetFound(null);
      } else {
        "BEST SUPPORT TARGET FOUND".p();
      }
    }
  };
  _._trySelectBestSupportTarget = function() {
    var e, target;
    try {
      target = this._trySelectBestSPTargetByCondition(1);
      if (target == null) {
        target = this._trySelectBestSPTargetByCondition(2);
      }
      if (target == null) {
        target = this._trySelectBestSPTargetByCondition(3);
      }
      return target;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _._trySelectBestSPTargetByCondition = function(index) {
    var condition, e;
    try {
      condition = this.model().getBestSupportTargetCondition(index);
      if (String.any(condition)) {
        return this._tryFindSupportTargetByCondition(condition);
      } else {
        return null;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _._tryFindSupportTargetByCondition = function(conditionString) {
    var candidates, e, filterResultString, i, len, target, targetsAround;
    console.log("CONDITION STRING RAW: " + conditionString);
    if (conditionString === "any" || !String.any(conditionString)) {
      return this._trySelectAnySupportTarget();
    } else if (conditionString === "none") {
      return null;
    } else {
      targetsAround = this._getAllTargetsForSupportAround();
      conditionString = conditionString.replaceAll('|', ' || ');
      conditionString = conditionString.replaceAll('&', ' && ');
      candidates = [];
      for (i = 0, len = targetsAround.length; i < len; i++) {
        target = targetsAround[i];
        filterResultString = this._applyFiltersToSupportTargetCandidate(target, conditionString);
        try {
          if (eval(filterResultString)) {
            candidates.push(target);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
      if (candidates.length > 0) {
        return this._tryFilterSupportTargetByGroupCondition(candidates);
      }
    }
    return null;
  };
  _._trySelectAnySupportTarget = function() {
    var availabledTargets;
    availabledTargets = this._getAllTargetsForSupportAround();
    if (availabledTargets.length > 0) {
      return this._tryFilterSupportTargetByGroupCondition(availabledTargets);
    }
    return null;
  };
  _._getAllTargetsForSupportAround = function() {
    var e, targetsAround;
    try {
      targetsAround = AATargetsManager.getAvailableAlliesInRadius(this.char(), this.model().gViewRadius());
      //  * Пропустим линию видимости пока что (не особо важно)
      //targetsAround = targetsAround.filter (t) => AAVisionManager.isVisionLineIsFree(@char(), t)
      console.log(targetsAround);
      return targetsAround;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _._applyFiltersToSupportTargetCandidate = function(target, conditionString) {
    var e, i, item, len, method, ref;
    try {
      ref = ['none', 'any', 'damaged', 'full', 'player', 'ally', 'self', 'other', 'lowHp', 'partyMember', 'condition'];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (conditionString.contains(item)) {
          method = this['_aaAIConditionForSupport_' + item];
          if (method != null) {
            conditionString = conditionString.replace(item, method.call(this, target).toString());
          } else {
            conditionString = conditionString.replace(item, 'false');
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return "false";
    }
    return conditionString;
  };
  // * Нет групповых фильтров
  _._tryFilterSupportTargetByGroupCondition = function(targets) {
    return targets.sample();
  };
})();

// ■ END AllyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyAI_FreeFlow.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyAI_FreeFlow.prototype;
  // * TARGET (SINGLE) CONDITIONS ================================================
  _._aaAICondition_any = function(t) {
    return true;
  };
  _._aaAICondition_none = function(t) {
    return false;
  };
  _._aaAICondition_condition = function(t) {
    var condition, e;
    try {
      condition = this.model().getBestTargetUserCondition();
      if (String.any(condition)) {
        condition = condition.replaceAll("a.", "this.battler().");
        condition = condition.replaceAll("b.", "$gamePlayer.AABattler().");
        condition = condition.replaceAll("t.", "t.AABattler().");
        return eval(condition);
      } else {
        // * Пустое условие всегда верно
        return true;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAICondition_full = function(t) {
    var e;
    try {
      return t.AABattler().hpRate() === 1;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._aaAICondition_damaged = function(t) {
    return !this._aaAICondition_full(t);
  };
  _._aaAICondition_playerTarget = function(t) {
    var e;
    try {
      if ((t != null) && $gameTemp._aaPartyAI_flag_playerAttackSomeone > 0) {
        return (t.eventId != null) && t.eventId() === $gameTemp._aaPartyAI_flag_playerAttackSomeone;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAICondition_playerOpponent = function(t) {
    var e;
    try {
      return (t != null) && t.AAEntity().getTarget() === $gamePlayer;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._aaAICondition_notMyOpponent = function(t) {
    var e;
    try {
      return !this._aaAICondition_myOpponent(t);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._aaAICondition_myOpponent = function(t) {
    var e;
    try {
      return (t != null) && t.AAEntity().getTarget() === this.char();
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  // * GROUP CONDITIONS ===========================================================
  // * Данные методы возвращают объект target, а не Bool!
  // * Подразумевается что массив targets уже прошёл проверку на null, 0 и 1 (count)
  _._aaAIConditionGroup_nearest = function(targets) {
    var e, method, x, y;
    try {
      ({x, y} = this.char());
      method = function(a, b) {
        var distToA, distToB;
        distToA = AAMath.distanceXY(x, y, a.x, a.y);
        distToB = AAMath.distanceXY(x, y, b.x, b.y);
        return distToA - distToB;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_further = function(targets) {
    var e, method, x, y;
    try {
      ({x, y} = this.char());
      method = function(a, b) {
        var distToA, distToB;
        distToA = AAMath.distanceXY(x, y, a.x, a.y);
        distToB = AAMath.distanceXY(x, y, b.x, b.y);
        return distToB - distToA;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_weakest = function(targets) {
    var e, method;
    try {
      method = function(a, b) {
        var valA, valB;
        valA = a.AABattler().atk;
        valB = b.AABattler().atk;
        return valA - valB;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_strongest = function(targets) {
    var e, method;
    try {
      method = function(a, b) {
        var valA, valB;
        valA = a.AABattler().atk;
        valB = b.AABattler().atk;
        return valB - valA;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_lowHp = function(targets) {
    var e, method;
    try {
      method = function(a, b) {
        var hpA, hpB;
        hpA = a.AABattler().hp;
        hpB = b.AABattler().hp;
        return hpA - hpB;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_highHp = function(targets) {
    var e, method;
    try {
      method = function(a, b) {
        var hpA, hpB;
        hpA = a.AABattler().hp;
        hpB = b.AABattler().hp;
        return hpB - hpA;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_nearestToPlayer = function(targets) {
    var e, method, x, y;
    try {
      ({x, y} = $gamePlayer);
      method = function(a, b) {
        var distToA, distToB;
        distToA = AAMath.distanceXY(x, y, a.x, a.y);
        distToB = AAMath.distanceXY(x, y, b.x, b.y);
        return distToA - distToB;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._aaAIConditionGroup_furtherFromPlayer = function(targets) {
    var e, method, x, y;
    try {
      ({x, y} = $gamePlayer);
      method = function(a, b) {
        var distToA, distToB;
        distToA = AAMath.distanceXY(x, y, a.x, a.y);
        distToB = AAMath.distanceXY(x, y, b.x, b.y);
        return distToB - distToA;
      };
      targets.sort(method);
      return targets[0];
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  
  // * TARGET (SINGLE, SUPPORT) CONDITIONS ================================================
  _._aaAIConditionForSupport_none = function(t) {
    return false;
  };
  _._aaAIConditionForSupport_any = function(t) {
    return true;
  };
  _._aaAIConditionForSupport_damaged = function(t) {
    return !this._aaAIConditionForSupport_full(t);
  };
  _._aaAIConditionForSupport_full = function(t) {
    var e;
    try {
      return t.AABattler().hpRate() === 1;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
  };
  _._aaAIConditionForSupport_player = function(t) {
    var e;
    try {
      return t === $gamePlayer;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_ally = function(t) {
    var e;
    try {
      return t !== $gamePlayer;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_self = function(t) {
    var e;
    try {
      return t === this.char();
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_other = function(t) {
    var e;
    try {
      return t !== this.char();
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_lowHp = function(t) {
    var e;
    try {
      return t.AABattler().hpRate() < 0.2;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_partyMember = function(t) {
    var e;
    try {
      return $gamePlayer.aaGetABSFollowers().contains(t);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAIConditionForSupport_condition = function(t) {
    var condition, e;
    try {
      condition = this.model().getBestSupportTargetUserCondition();
      if (String.any(condition)) {
        condition = condition.replaceAll("a.", "this.battler().");
        condition = condition.replaceAll("b.", "$gamePlayer.AABattler().");
        condition = condition.replaceAll("t.", "t.AABattler().");
        return eval(condition);
      } else {
        // * Пустое условие всегда верно
        return true;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END AllyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AllyAI_FreeFlow.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AllyAI_FreeFlow.prototype;
  _._updateBattleTargetSearch = function() {
    if (this.isHaveBestBattleTarget()) {
      return this._onBattleTargetFound(this._currentBestTarget);
    } else {
      this._currentBestTarget = this._trySelectBestTarget();
      if (!this.isHaveBestBattleTarget()) {
        this._onBattleTargetFound(null);
      } else {
        "BEST TARGET FOUND".p();
      }
    }
  };
  
  // * Смотрим три условия
  _._trySelectBestTarget = function() {
    var target;
    target = this._trySelectBestTargetByCondition(1);
    if (target == null) {
      target = this._trySelectBestTargetByCondition(2);
    }
    if (target == null) {
      target = this._trySelectBestTargetByCondition(3);
    }
    return target;
  };
  _._trySelectBestTargetByCondition = function(index) {
    var condition;
    condition = this.model().getBestTargetCondition(index);
    if (String.any(condition)) {
      return this._tryFindTargetByCondition(condition);
    } else {
      return null;
    }
  };
  _._tryFindTargetByCondition = function(conditionString) {
    var candidates, e, filterResultString, i, len, target, targetsAround;
    console.log("CONDITION STRING RAW: " + conditionString);
    if (conditionString === "any" || !String.any(conditionString)) {
      return this._trySelectAnyTarget();
    } else if (conditionString === "none") {
      return null;
    } else {
      targetsAround = this._getAllTargetsAround();
      conditionString = conditionString.replaceAll('|', ' || ');
      conditionString = conditionString.replaceAll('&', ' && ');
      candidates = [];
      for (i = 0, len = targetsAround.length; i < len; i++) {
        target = targetsAround[i];
        filterResultString = this._applyFiltersToTargetCandidate(target, conditionString);
        try {
          if (eval(filterResultString)) {
            candidates.push(target);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
      if (candidates.length > 0) {
        return this._tryFilterTargetByGroupCondition(candidates);
      }
    }
    return null;
  };
  _._applyFiltersToTargetCandidate = function(target, conditionString) {
    var e, i, item, len, method, ref;
    try {
      ref = ['any', 'none', 'condition', 'damaged', 'full', 'playerTarget', 'playerOpponent', 'notMyOpponent', 'myOpponent'];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (conditionString.contains(item)) {
          method = this['_aaAICondition_' + item];
          if (method != null) {
            conditionString = conditionString.replace(item, method.call(this, target).toString());
          } else {
            conditionString = conditionString.replace(item, 'false');
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return "false";
    }
    return conditionString;
  };
  _._tryFilterTargetByGroupCondition = function(targets) {
    var condition, e;
    try {
      condition = this.model().getBestTargetGroupCondition();
      if (targets.length === 1 || !String.any(condition)) {
        return targets.sample();
      }
      return this._applyTargetsGroupFilters(targets, condition);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _._applyTargetsGroupFilters = function(targets, conditionString) {
    var available, bestInGroup, e, method;
    try {
      bestInGroup = null;
      available = ['nearest', 'further', 'weakest', 'strongest', 'lowHp', 'highHp', 'nearestToPlayer', 'furtherFromPlayer'];
      if (available.contains(conditionString)) {
        method = this['_aaAIConditionGroup_' + conditionString];
        if (method != null) {
          bestInGroup = method.call(this, targets);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
    return bestInGroup;
  };
  _._trySelectAnyTarget = function() {
    var availabledTargets;
    availabledTargets = this._getAllTargetsAround();
    if (availabledTargets.length > 0) {
      return this._tryFilterTargetByGroupCondition(availabledTargets);
    }
    return null;
  };
  _._getAllTargetsAround = function() {
    var e, targetsAround;
    try {
      targetsAround = AATargetsManager.getAvailableTargetsInRadius(this.char(), this.model().gViewRadius());
      // * Для улучшения производительности, пропустим проверку линии обзора
      //targetsAround = targetsAround.filter (t) => AAVisionManager.isVisionLineIsFree(@char(), t)
      return targetsAround;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
})();

// ■ END AllyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AudioManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__playBgm, _;
  //@[DEFINES]
  _ = AudioManager;
  //@[ALIAS]
  ALIAS__playBgm = _.playBgm;
  _.playBgm = function(bgm, pos) {
    var e, storedOne;
    $gameSystem.aaBattleBgmStarted = false;
    storedOne = $gameSystem.aaLoadBgmState(bgm.name);
    if ((storedOne != null) && storedOne > 0 && $gameTemp.__lastSavedBgmStateName !== bgm.name) {
      pos = storedOne;
    }
    try {
      ALIAS__playBgm.call(this, bgm, pos);
    } catch (error) {
      e = error;
      AA.w(e);
      ALIAS__playBgm.call(this, bgm, 0);
      return;
    }
    if (pos > 0) {
      this._bgmBuffer.fadeIn(0.5);
    }
  };
})();

// ■ END AudioManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ AudioManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AudioManager;
  _.aaSaveBgmState = function() {
    var data;
    data = AudioManager.saveBgm();
    if ((data != null) && data.name !== '' && (typeof $gameSystem !== "undefined" && $gameSystem !== null)) {
      $gameSystem.aaSaveBgmState(data.name, data.pos);
    }
  };
  _.aaPlayBattleBgm = function(name, delay = 0) {
    var bgm, e;
    try {
      console.log("Start Battle BGM");
      AudioManager.aaSaveBgmState();
      $gameSystem.aaStoreSuspendedMapBgm();
      bgm = {
        name: name,
        pan: 0,
        pitch: 100,
        volume: 90
      };
      if (delay > 0) {
        AudioManager.fadeOutBgm(delay / 60);
        return setTimeout((function() {
          AudioManager.playBgm(bgm);
          return $gameSystem.aaBattleBgmStarted = true;
        }), delay * 10);
      } else {
        AudioManager.stopBgs();
        AudioManager.stopBgm();
        AudioManager.playBgm(bgm);
        return $gameSystem.aaBattleBgmStarted = true;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaStopBattleBgm = function(delay = 0) {
    var e;
    try {
      console.log("Stop Battle BGM");
      if (!$gameSystem.aaBattleBgmStarted) {
        return;
      }
      $gameSystem.aaBattleBgmStarted = null;
      if (delay > 0) {
        AudioManager.fadeOutBgm(delay / 60);
        return setTimeout((function() {
          $gameSystem.aaRestoreSuspendedMapBgm();
          return AudioManager.fadeInBgm(delay / 60);
        }), delay * 10);
      } else {
        return $gameSystem.aaRestoreSuspendedMapBgm();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END AudioManager.coffee
//---------------------------------------------------------------------------


class BaseState {
    constructor(packedEntity) {
        this._packedEntity = packedEntity;
    }
    name() {
        return this.constructor.name;
    }
    onEnter() { }
    onExit() { }
    update() { }
}


// Generated by CoffeeScript 2.6.1
(function() {
  var BuffIconsController;
  // * Общий контроллер для отрисовки бафов персонажа (игрока)
  //?rev 17.10.20
  BuffIconsController = class BuffIconsController extends AA.UIElementController {
    // * buffSprites - Sprite_ActorStateIcon (массив)
    constructor(buffSprites) {
      super();
      this.buffSprites = buffSprites;
      this.maxCount = Math.min(this.buffSprites.length, 8);
    }

    // * Собирает индексы существующих баффов
    collectBuffs() {
      var buffs, i, j, k;
      buffs = [];
      for (i = j = 0; j < 8; i = ++j) {
        if (this.source._buffs[i] !== 0) {
          buffs.push(i);
        }
      }
      // * Если в режиме редактора, то добавляем ещё (недостающие) как Dummy
      // * Чтобы можно было видеть
      if (AA.System.isUIEditor()) {
        for (i = k = 0; k < 8; i = ++k) {
          buffs.push(1);
        }
      }
      return buffs;
    }

    
      // * Собирает все иконки бафов
    collectIcons() {
      var i, icons, j;
      icons = this.source.buffIcons();
      if (AA.System.isUIEditor()) {
        for (i = j = 0; j < 8; i = ++j) {
          icons.push(16);
        }
      }
      return icons;
    }

    // * Получает количество ходов (секунд) баффа
    collectBuffTurn(buffIndex) {
      return this.source._buffTurns[buffIndex];
    }

  };
  AA.link(BuffIconsController);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.BuffIconsController.prototype;
  //$[OVER]
  _._setupThread = function() {
    return this.createThread(20, 4);
  };
  //$[OVER]
  _._refresh = function() {
    var buffs, i, icon, icons, j, ref, ref1, turns;
    buffs = this.collectBuffs();
    icons = this.collectIcons();
    for (i = j = 0, ref = this.maxCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      icon = icons[i];
      turns = this.collectBuffTurn(buffs[i]);
      if ((ref1 = this.buffSprites[i]) != null) {
        ref1.drawBuffInfo(icon, turns);
      }
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ConfigManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__applyData, ALIAS__makeData, _;
  //@[DEFINES]
  _ = ConfigManager;
  //@[ALIAS]
  ALIAS__makeData = _.makeData;
  _.makeData = function() {
    var config;
    config = ALIAS__makeData.call(this);
    config.aaUserUISettings = this.aaUserUISettings;
    return config;
  };
  
  //@[ALIAS]
  ALIAS__applyData = _.applyData;
  _.applyData = function(config) {
    ALIAS__applyData.call(this, config);
    this.aaUserUISettings = config.aaUserUISettings || {};
  };
})();

// ■ END ConfigManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__loadDataFile, ALIAS__loadDatabase, _;
  //@[DEFINES]
  _ = DataManager;
  DataManager._databaseFiles.push({
    name: "$aabsz_WeaponSkillExtensionSlot",
    src: "AABSZ/WeaponSkillExtensionSlot.json"
  });
  DataManager._databaseFiles.push({
    name: "$aabsz_SkillItemSelectorWindowSettings",
    src: "AABSZ/SkillItemSelectorWindowSettings.json"
  });
  // * Чтобы тест битвы из редактора работал
  //@[ALIAS]
  ALIAS__loadDataFile = _.loadDataFile;
  _.loadDataFile = function(name, src) {
    if (src.contains("AABSZ")) {
      src = src.replace("Test_", "");
    }
    return ALIAS__loadDataFile.call(this, name, src);
  };
  //@[ALIAS]
  ALIAS__loadDatabase = _.loadDatabase;
  _.loadDatabase = function() {
    ALIAS__loadDatabase.call(this);
    return this.aaLoadSpawnMap();
  };
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = DataManager;
  _.aaIsSpawnMapValid = function() {
    return typeof $dataAASpawnMap !== "undefined" && $dataAASpawnMap !== null;
  };
  _.aaLoadSpawnMap = function() {
    var filename, mapId;
    window.$dataAASpawnMap = null;
    mapId = AA.PP.getSpawnMapId();
    if (!(mapId > 0)) {
      return;
    }
    filename = 'Map%1.json'.format(mapId.padZero(3));
    this.loadDataFile('$dataAASpawnMap', filename);
  };
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------
//"SPAWN MAP LOADED".p(mapId)


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = DataManager;
  DataManager._databaseFiles.push({
    name: "$aabsz_NUI_PlayerCastingProgressBar",
    src: "AABSZ/NUI_PlayerCastingProgressBar.json"
  });
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Состояние (машина) для врага в битве
var EnemyAI_BattleFlow;

EnemyAI_BattleFlow = class EnemyAI_BattleFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  target() {
    return this.entity().getTarget();
  }

  onStateStart() {
    //"IN BATTLE STATE".p()
    // * Таймер следующей выборки действия
    // * Когда действие было выбранно, идёт небольшая пауза
    // * перед следующей выборкой действия
    this._nextActionCheck = 0;
    // *
    this._canFightNow = true;
    // * Бот отступает из боя
    this._fleeFromBattle = false;
    if (this.model().gNoMoveInBattle() === 1) {
      this.char().aaSetMoveTypeStayStill();
    }
  }

  //TODO: change move type
  //TEMP: остановлю ботика
  //@char()._moveType = 0
  //@char().aaSetMoveTypeKeepBattleDistance()
  //TODO: filter skills
  onStateEnd() {
    //on char сделать метод основной
    this.entity().resetBattle();
    return this.char().aaOnTargetChanged();
  }

};

(function() {  //TODO: clear target and other stuff (onBattleEnd for battle etc)
  //"BATTLE END".p()

  // * onStateEnd нету, так как Free состояние базовое

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ EnemyAI_BattleFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = EnemyAI_BattleFlow.prototype;
  _._setup = function() {};
  
  //TODO: ЕСТЬ БАГ, если убить одного врага, другие не хотят сражаться, остаюстя в keep
  _._updateFlow = function() {
    if (this._canFightNow === true) {
      this._updateOutOfHomeFlow();
      return this._updateBattleFlow();
    } else {
      return this._updateFleeFlow();
    }
  };
  // * Если отошёл слишком далеко от "дома", надо вернуться
  _._updateOutOfHomeFlow = function() {
    if (this._isTooFarFromHomePoint()) {
      return this._canFightNow = false;
    }
  };
  _._isTooFarFromHomePoint = function() {
    var homePoint;
    homePoint = this.char().homePoint;
    if (homePoint == null) {
      return false;
    }
    return this.char().distTo(homePoint) > (this.model().gReturnRadius());
  };
  _._updateBattleFlow = function() {
    if (this._isInCastingProcess()) {
      this._updateInCastingProcess();
      return;
    }
    if (this._isTargetValid()) {
      this._selectActionToUse();
      if (this._isActionIsExists()) {
        if (this._isActionInDistance()) {
          return this._executeAction();
        } else {
          return this._movingCloserToTarget();
        }
      } else {
        return this._waitForAction();
      }
    } else {
      return this.logic().switchToFreeState();
    }
  };
  _._isTargetValid = function() {
    return this._isTargetInViewRadius() && AATargetsManager.isValidTarget(this.target());
  };
  //TODO: Сделать параметр SeekTime - когда цель вне видимости, какой-то время (в сек) всё равно преследовать
  // * или следовать в точку где последний раз видел
  // * Можно отдельное состояние (поиск по маршруту или случайно)
  // * Объеденить с системой слышымости (по сути это и есть - движение к источнику звука и патруль)
  _._isTargetInViewRadius = function() {
    return this.char().distTo(this.target()) <= (this.model().gViewRadius() + 1);
  };
  _._selectActionToUse = function() {
    var skills;
    this._nextActionCheck--;
    if (this._nextActionCheck > 0) {
      return;
    }
    //TODO: алгоритм выбора действия для использования сейчас
    skills = this.battler().getUsableAASkills();
    if (skills.length > 0) {
      if (skills.length === 1) {
        this._setCurrentAction(skills[0]);
      } else {
        this._selectBetterActionForNow(skills);
      }
    } else {
      this._resetCurrentAction();
    }
  };
  _._setCurrentAction = function(_currentAction) {
    this._currentAction = _currentAction;
    //TODO: Надо это или нет?
    return this._nextActionCheck = 20;
  };
  _._selectBetterActionForNow = function(skills) {
    //TODO: Все навыки применить testApply и выбрать лучший + тот который
    // можно использовать без подхода к цели
    //TODO: пока просто первый возвращаем
    this._setCurrentAction(skills.first());
  };
  _._resetCurrentAction = function() {
    this._currentAction = null;
    this._nextActionCheck = 0;
  };
  _._isActionIsExists = function() {
    return this._currentAction != null;
  };
  // * Находится ли цель на расстроянии применения действия
  _._isActionInDistance = function() {
    var aaSkill, range;
    aaSkill = this._currentAction.AASkill;
    if (aaSkill.isSelfAction()) {
      // * Если для врагов, то проверим, что враг в области radius действия навыка
      if (aaSkill.isForEnemies()) {
        return AATargetsManager.isCharExtInRadius(this.char(), aaSkill.gRadius(), this.target());
      } else {
        return true;
      }
    } else {
      range = aaSkill.gRange();
      if (aaSkill.isInPoint() || this._isProperRangeForCloseAction(range)) {
        return AATargetsManager.isCharExtInRadius(this.char(), range, this.target());
      } else {
        // * Пока просто проверка расстояния
        //TODO: * Цель должна быть передо мной (на прямом направлении)
        // (см. inDirectionHard в Alpha ABS)
        return AATargetsManager.isCharExtInRadius(this.char(), range, this.target());
      }
    }
  };
  _._isProperRangeForCloseAction = function(range) {
    var e;
    try {
      if (AA.Input.IsDiagonalForAI === true) {
        // * range <= 1 тут используется, чтобы монстр мог ударить диагонально, но не больше 1 клетки
        return range <= 1;
      } else {
        return range < 1;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._executeAction = function() {
    var char, e;
    try {
      //TODO: Custom Attack Move Route
      //"EXECUTE".p()
      //TODO: EXECUTE ACITON !!!
      // * Дополнительная проверка ещё раз перед выполнением действия
      // * Это нужно, потому что АИ выбирает очередное действие после выбора через время
      // * см. @_nextActionCheck
      if (!this.battler().canUse(this._currentAction)) {
        return this._resetCurrentAction();
      } else {
        //"EEXECUTGE".p()
        char = this.char();
        char.setActiveAASkill(this._currentAction.idA);
        return char.startPerformAASkill(this.target());
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._movingCloserToTarget = function() {
    if (this.model().gNoApproach() === 1) {
      return;
    }
    if (this.model().gNoMoveInBattle() === 1) {
      return;
    }
    //"APPROACH".p()
    return this.char().aaSetMoveTypeApproachTarget();
  };
  _._waitForAction = function() {
    if (this.model().gNoMoveInBattle() === 1) {
      return;
    }
    //"KEEP ".p()
    this.char().aaSetMoveTypeKeepBattleDistance();
  };
  // * Враг возвращается (отступает) к точке дом
  // * Пока не увидит дом (в View Radius)
  // * В отличии от Free State, точка дома не меняется, поэтому враг получается
  // * всегда будет держаться своего "дома" и сражаться в определённом радиусе
  //TODO: Custom Move Route?
  // * Задать параметр, чтобы АИ выполнял в бою customMoveRoute если нет навыков
  _._updateFleeFlow = function() {
    if (this.char().distTo(this.char().homePoint) <= (this.model().gViewRadius() - 1)) {
      this._canFightNow = true;
    } else {
      this.char().aaSetMoveTypeReturnToHomePoint();
    }
  };
  _._isInCastingProcess = function() {
    return this.char().aaInSkillCastingProcess();
  };
  _._updateInCastingProcess = function() {
    var e;
    try {
      if (!this._isActionInDistance()) {
        console.log("Casting Aborted by Action Distance");
        this.char().aaAbortSkillCastingProcess();
        return;
      }
      if (!this._isTargetInViewRadius()) {
        console.log("Casting Aborted by ViewRadius");
        this.char().aaAbortSkillCastingProcess();
        return;
      }
      //console.log("casting")
      return this.char()._aaUpdateCastingProcess();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END EnemyAI_BattleFlow.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Машина состояний для АИ врагов на карте
var EnemyAI_FlowMachine;

EnemyAI_FlowMachine = class EnemyAI_FlowMachine extends AIFlowMachine {
  constructor() {
    super(...arguments);
    this.registerFlowForState(0, new EnemyAI_FreeFlow(this.id));
    this.registerFlowForState(1, new EnemyAI_BattleFlow(this.id));
    // * Начальное состояние - свободное
    this.switchToFreeState();
    return;
  }

  switchToFreeState() {
    return this.setState(0);
  }

  switchToBattleState() {
    return this.setState(1);
  }

  isFreeState() {
    return this.state === 0;
  }

  isBattleState() {
    return this.state === 1;
  }

};

(function() {  //TODO: search, return???
  //TODO: move

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ EnemyAI_FlowMachine.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = EnemyAI_FlowMachine.prototype;
})();

// ■ END EnemyAI_FlowMachine.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Свободное состояние для АИ враг
var EnemyAI_FreeFlow;

EnemyAI_FreeFlow = class EnemyAI_FreeFlow extends AIFlow {
  constructor() {
    super(...arguments);
    return;
  }

  isCanUpdateVision() {
    if (this.model().activeOutOfScreen > 0) {
      return true;
    } else {
      return !this.char().aaIsOutOfScreen();
    }
  }

  onStateStart() {
    //"IN FREE STATE".p()
    this._restoreMoveData();
    this._isTargetInViewRadius = false;
  }

  onStateEnd() {
    //"FREE END".p()
    this._storeHomePoint();
  }

  tryStartFightWithTarget(target) {
    var e, targetsAround;
    try {
      if (target == null) {
        return;
      }
      targetsAround = AATargetsManager.getAvailableTargetsInRadius(this.char(), this.model().gViewRadius());
      if (targetsAround.contains(target)) {
        return this._startFightWithTarget(target);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ EnemyAI_FreeFlow.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = EnemyAI_FreeFlow.prototype;
  _._setup = function() {
    this._checkVisionTimer = 0;
    this._checkTargetInRangeTimer = 0;
  };
  _._updateFlow = function() {
    this._updateReturnToHome();
    //TODO: Временно отключим Visor для врагов, у которых нет АБС навыков вообще
    if (!this.battler().isHaveAnyAASkill()) {
      return;
    }
    return this._updateVision();
  };
  _._updateReturnToHome = function() {
    var char, e, homePoint;
    char = this.char();
    if (char == null) {
      return;
    }
    homePoint = char.homePoint;
    if (homePoint == null) {
      return;
    }
    try {
      if (char.aaIsNearThePoint(homePoint, 1)) {
        char.aaResetHomePoint(); // * Сброс точки "дома"
        this._restoreMoveData(); // * Выход из режима движения
      } else {
        char.aaSetMoveTypeReturnToHomePoint();
      }
    } catch (error) {
      e = error;
      this._restoreMoveData();
      AA.w(e);
    }
  };
  // * Используется двойная проверка. Сперва простая проверка, что цель в радиусе видимости
  // * Уже затем, если цель в радиусе, проверяется линия видимости
  _._updateVision = function() {
    if (!this.isCanUpdateVision()) {
      return;
    }
    //console.log("UPDA")
    // * Если цель в радиусе видимости
    if (this._isTargetInViewRadius === true) {
      // * То проверяем чтобы цель была в линии видиомости (нет препятствий)
      this._updateVisionLine();
    }
    // * В любом случае, проверяем снова, что цель в радиусе видимости
    return this._updateVisionRadius();
  };
  _._updateVisionRadius = function() {
    var targetsAround;
    this._checkVisionTimer++;
    if (this._checkVisionTimer >= AA.PP.getAIVisionUpdateIntervalFR()) {
      this._checkVisionTimer = 0;
      if (this.model().isTVision()) {
        targetsAround = AATargetsManager.getAvailableTargetsInTriangle(this.char(), this.model().gViewRadius(), this.model().gTVisor(), this.model().sideVisor);
      } else {
        targetsAround = AATargetsManager.getAvailableTargetsInRadius(this.char(), this.model().gViewRadius());
      }
      this._isTargetInViewRadius = (targetsAround != null) && targetsAround.length > 0;
    }
  };
  //"TARGET IN RADIUS".p() if @_isTargetInViewRadius is true
  _._updateVisionLine = function() {
    var targetsAround;
    if (this._isTargetInViewRadius === false) {
      return;
    }
    this._checkTargetInRangeTimer++;
    if (this._checkTargetInRangeTimer >= 2) {
      this._checkTargetInRangeTimer = 0;
      // * Довольно сложный методы, можно вынести отедльно
      targetsAround = AATargetsManager.getAvailableTargetsInRadius(this.char(), this.model().gViewRadius());
      if (targetsAround.length > 0) {
        targetsAround = targetsAround.filter((t) => {
          return AAVisionManager.isVisionLineIsFree(this.char(), t);
        });
        if (targetsAround.length > 0) {
          this._onSeeTarget(targetsAround.sample());
        }
      }
    }
  };
  _._onSeeTarget = function(target) {
    //"SEE TARGET IN LINE".p()
    //TODO: if enemy have actions, then switch to battle state
    if (this.battler().isHaveAnyAASkill() && !this.model().isNotAgressive()) {
      this._startFightWithTarget(target);
    } else {

    }
  };
  //TODO: if can't fight?
  //TODO: escapeFromBattle like (Типо отходить от игрока)
  // * Тоже самое поведение, что и если не может драться (noFight)
  //TODO: noFight - такого параметра не будет, хотите чтобы не дрался, не давайте действий
  _._startFightWithTarget = function(target) {
    var e;
    try {
      this.entity().setTarget(target);
      this.char().aaOnTargetChanged();
      if (this.model().isHaveOnSeeTargetAction()) {
        AAScriptActions.execute(this.model().onSeeTarget, this.char());
      }
      return this.logic().switchToBattleState();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Восстановить настройки движения, если они были сохраненны
  _._restoreMoveData = function() {
    var e, ref;
    try {
      //"RESTORE MOVE DATA".p()
      if ((ref = this.char()) != null) {
        ref.aaRestoreMoveData();
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Сохранить позицию перед выходом из состояния
  _._storeHomePoint = function() {
    var ref;
    if ((ref = this.char()) != null) {
      ref.aaStoreHomePoint();
    }
  };
})();

// ■ END EnemyAI_FreeFlow.coffee
//---------------------------------------------------------------------------


var AAExtendedValues;
(function (AAExtendedValues) {
    // * Преобразовать расширенное значение
    // * Значение может быть X -> X
    // * "X" -> X (цифра)
    // * "X,Y,Z,..." -> [X, Y, Z]
    // * "[X, Y, Z,...]" -> [X, Y, Z]
    // * "X|V" -> из переменной X
    // * [Y] -> случайное число из массива (рекурсивно)
    function getEValue(value) {
        try {
            if (value === null || value === undefined)
                return null;
            if (typeof (value) == 'string') {
                //@ts-ignore
                if (isFinite(value)) { // * Число представленно строкой
                    return Number(value);
                }
                // Массив представлен строкой (может быть без квадратных скобок)
                if (value.indexOf(',') >= 0 || value.indexOf('[') >= 0) {
                    // Remove [ and ]
                    value = value.replace('[', '').replace(']', '');
                    let values = value.split(',').map(function (item) {
                        let singleItem = item.trim();
                        //@ts-ignore
                        if (isFinite(singleItem)) {
                            return Number(singleItem);
                        }
                        else {
                            return singleItem;
                        }
                    });
                    return getEValue(values);
                }
                if (value.includes('|V')) {
                    let varId = Number(value.replace('|V', ''));
                    return $gameVariables.value(varId);
                }
                return Number(value);
            }
            else if (Array.isArray(value)) {
                // * Get random value from array
                let randomIndex = Math.floor(Math.random() * value.length);
                let randomValue = value[randomIndex];
                return getEValue(randomValue);
            }
            else {
                return value;
            }
        }
        catch (error) {
            console.warn(error);
            return null;
        }
    }
    AAExtendedValues.getEValue = getEValue;
    function getSafeEValue(value, defaultValue = 0) {
        let result = getEValue(value);
        if (result === null || result === undefined) {
            return defaultValue;
        }
        return Number(result);
    }
    AAExtendedValues.getSafeEValue = getSafeEValue;
})(AAExtendedValues || (AAExtendedValues = {}));
window['AAExtendedValues'] = AAExtendedValues;


class FuncPredicate {
    constructor(func) {
        this.func = func;
    }
    isSatisfied() {
        return this.func();
    }
}


// Generated by CoffeeScript 2.6.1
var FWindow_SkillSelect;

FWindow_SkillSelect = class FWindow_SkillSelect extends KDCore.FloatingWindow {
  constructor() {
    super(...arguments);
  }

  getSettings() {
    return $aabsz_SkillItemSelectorWindowSettings;
  }

  // * Сдвинуть позицию окна с учётом позиции элемента Skills Panel
  moveRelativeSlotPosition(x, y) {
    var h2, m, sector, w2;
    // Screen sectors
    // 1 | 2
    // 3 | 4
    // ==============
    m = this.getSettings().windowFromEdgesMargin;
    sector = 1;
    w2 = Graphics.width / 2;
    h2 = Graphics.height / 2;
    
    // * Определяем сектор экрана, на котромнаходится элемент
    if (x < w2) {
      if (y < h2) {
        sector = 1;
      } else {
        sector = 3;
      }
    } else {
      if (y < h2) {
        sector = 2;
      } else {
        sector = 4;
      }
    }
    
    // * Настраиваем позиции в зависимости от секторов
    if (sector === 3 || sector === 1) {
      this.x = x;
    }
    if (sector === 2 || sector === 4) {
      this.x = x - this.width + m;
    }
    if (sector >= 3) {
      this.y = y - this.height;
    } else {
      this.y = y + m + 2;
    }
  }

  
    // * Подготовить окно и октрыть для элемента Skills Panel
  // * slotItem = Sprite_SKillPanelItem
  prepareAndOpenForSlot(slotItem) {
    var symbol, x, y;
    ({x, y, symbol} = slotItem);
    this.moveRelativeSlotPosition(x, y);
    // * Тут всегда категория 0 по умолчанию
    this.refreshSkillList(0, symbol);
    this.open();
  }

  // * Создание списка навыков для группы
  // * Этот метод вызывается когда окно открывается для слота
  refreshSkillList(category, symbol) {
    if (this.skillsList == null) {
      return;
    }
    // * Запоминаем символ, чтобы установить навык при выборе
    this.skillsList.setSymbol(symbol);
    // * При смене категории список формируется (т.е. refresh)
    this.changeCategory(0);
  }

  changeCategory(category) {
    var e;
    try {
      this._refreshCategoryButtons(category);
      this._refreshHeader(category);
      return this.skillsList.setCategory(category);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  // * Данное окно (выбор навыков и вещей) нельзя двигать
  //$[OVER]
  //isDraggable: -> false
  //TODO: или можно?
  update() {
    super.update();
    return this._updateSkillSelectClick();
  }

  _afterClose() {
    this.buttonCat0.visible = false;
    return this.buttonCat1.visible = false;
  }

  _afterOpen() {
    this.buttonCat0.visible = true;
    return this.buttonCat1.visible = true;
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ FWindow_SkillSelect.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = FWindow_SkillSelect.prototype;
  //$[OVER]
  _._createCustomElements = function() {
    this._createCategoriesButtons();
    this._createCategoriesHeader();
    this._refreshCategoryButtons(0);
    this._createSkillsList();
  };
  _._createCategoriesButtons = function() {
    var s, x, y;
    s = this.getSettings();
    ({x, y} = s.skillsCategoryButtonPosition);
    this.buttonCat0 = new KDCore.ButtonM("Button_SkSSkillsGroup", true, "Alpha");
    this.buttonCat0.addClickHandler(() => {
      return this.changeCategory(0);
    });
    this.buttonCat0.move(x, y);
    this.buttonCat0.visible = false;
    this.addContent(this.buttonCat0);
    ({x, y} = s.itemsCategoryButtonPosition);
    this.buttonCat1 = new KDCore.ButtonM("Button_SkSItemsGroup", true, "Alpha");
    this.buttonCat1.addClickHandler(() => {
      return this.changeCategory(1);
    });
    this.buttonCat1.move(x, y);
    this.buttonCat1.visible = false;
    this.addContent(this.buttonCat1);
  };
  _._createCategoriesHeader = function() {
    var p;
    p = this.getSettings().windowHeaderTextSettings;
    this.headerText = new KDCore.UI.Sprite_UIText(p);
    // * Добавляем на Header (поверх всего)
    this.addChild(this.headerText);
  };
  _._createSkillsList = function() {
    var height, p, position, r, size, width, x, y;
    p = this.getSettings();
    ({size, position} = p.itemsSkillsListWindow);
    ({x, y} = position);
    ({width, height} = size);
    r = new Rectangle(x, y, width, height);
    this.skillsList = new Window_SkillSelectorList(r);
    return this.addContent(this.skillsList);
  };
  _._updateSkillSelectClick = function() {
    var ref;
    if (!this.isOpen()) {
      return;
    }
    if (TouchInput.isTriggered() && this.isMouseIn()) {
      if ((ref = this.skillsList) != null) {
        ref.onClick();
      }
    }
  };
  _._refreshCategoryButtons = function(newCategory) {
    this.buttonCat0.disable();
    this.buttonCat1.disable();
    if (newCategory === 0) {
      this.buttonCat1.enable();
    } else {
      this.buttonCat0.enable();
    }
  };
  _._refreshHeader = function(category) {
    if (category === 0) {
      this.headerText.draw(this.getSettings().skillHeaderText);
    } else {
      this.headerText.draw(this.getSettings().itemsHeaderText);
    }
  };
})();

// ■ END FWindow_SkillSelect.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__clear, _;
  //@[DEFINES]
  _ = Game_ActionResult.prototype;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    this._lastAASkill = null;
  };
})();

// ■ END Game_ActionResult.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_ActionResult.prototype;
  // * Запоминаем АБС навык, который был использован
  _.setUsedAASkill = function(aaSkill) {
    return this._lastAASkill = aaSkill.idA;
  };
  _.getUsedAASkill = function() {
    if (this._lastAASkill != null) {
      return AA.Utils.unpackAASkill(this._lastAASkill);
    } else {
      return null;
    }
  };
})();

// ■ END Game_ActionResult.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__attackSkillId, ALIAS__changeEquip, ALIAS__displayLevelUp, ALIAS__forceChangeEquip, ALIAS__forgetSkill, ALIAS__learnSkill, ALIAS__performDamage, ALIAS__setup, _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function() {
    ALIAS__setup.call(this, ...arguments);
    return this.aaCheckAndParseExtendedHitBoxes();
  };
  //@[ALIAS]
  ALIAS__performDamage = _.performDamage;
  _.performDamage = function() {
    if (AA.isABSMap()) {
      if (this.isPlayer() && AA.PP.isShakeScreenWhenPlayerGetDamage()) {
        // * Стандартный метод (тряска экрана и звук)
        return ALIAS__performDamage.call(this);
      } else {
        // * Если не игрок, то нет тряски и звука
        return Game_Battler.prototype.performDamage.call(this);
      }
    } else {
      return ALIAS__performDamage.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__learnSkill = _.learnSkill;
  _.learnSkill = function(skillId) {
    var shouldAddNewSkillToPanel;
    // * Сперва флаг - что не надо добавлять
    shouldAddNewSkillToPanel = false;
    if (!this.isLearnedSkill(skillId) && AA.PP.isAddNewSkillsOnPanelOnLearning()) {
      shouldAddNewSkillToPanel = true;
    }
    ALIAS__learnSkill.call(this, skillId);
    // * Добавляем после, чтобы навык уже был у игрока
    // * Дополнительно проверяем, выучен ли он и надо ли его добавлять
    if (this.isLearnedSkill(skillId) && shouldAddNewSkillToPanel === true) {
      //#TODO: Учитывать членов группы, но пока только игрок
      // * Чтобы добавить на панель члена партии, надо ActorID менять у SkillSet
      // * И потом опять его возвращать
      if (this.isPlayer() && AASkill2.IsAAObject(skillId)) {
        uAPI.setSkillToPanel(skillId);
      }
    }
  };
  //@[ALIAS]
  ALIAS__forgetSkill = _.forgetSkill;
  _.forgetSkill = function(skillId) {
    var e, symbol;
    ALIAS__forgetSkill.call(this, skillId);
    if (!this.isLearnedSkill(skillId) && AA.PP.isAddNewSkillsOnPanelOnLearning()) {
      //TODO: Учитывать членов группы, но пока только игрок
      if (this.isPlayer() && AASkill2.IsAAObject(skillId)) {
        try {
          symbol = this.AACharacter().aaSkillsSet.getSymbolForSkill(skillId);
          if (symbol != null) {
            uAPI.setSkillToPanel(0, symbol);
          }
        } catch (error) {
          e = error;
          AA.w(e);
        }
      }
    }
  };
  
  //@[ALIAS]
  ALIAS__changeEquip = _.changeEquip;
  _.changeEquip = function() {
    ALIAS__changeEquip.call(this, ...arguments);
    this.aaOnEquipChanged();
  };
  //@[ALIAS]
  ALIAS__forceChangeEquip = _.forceChangeEquip;
  _.forceChangeEquip = function() {
    ALIAS__forceChangeEquip.call(this, ...arguments);
    this.aaOnEquipChanged();
  };
  //@[ALIAS]
  ALIAS__attackSkillId = _.attackSkillId;
  _.attackSkillId = function() {
    var e, id;
    try {
      id = this.aaGetWeaponAttackSkillId();
      if (id > 0 && ($dataSkills[id] != null)) {
        return id;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return ALIAS__attackSkillId.call(this, ...arguments);
  };
  //@[ALIAS]
  ALIAS__displayLevelUp = _.displayLevelUp;
  _.displayLevelUp = function() {
    var e;
    if (AA.PP.isUseCustomLevelUp()) {
      try {
        return this.aaDisplayCustomLevelUp();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    } else {
      return ALIAS__displayLevelUp.call(this, ...arguments);
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  // * Поддерживает ли данный персонаж управление АИ
  _.isSupportAIControl = function() {
    if (AA.Network.isNetworkGame()) {
      return false;
    } else {
      return KDCore.Utils.getValueFromMeta('ABS', this.actor()) != null;
    }
  };
  _.AACharacter = function() {
    var e, id, playerData;
    try {
      if (this.isPlayer()) {
        return $gamePlayer;
      } else {
        if (AA.Network.isNetworkGame()) {
          playerData = ANGameManager.getPlayerDataByActorId(this.actorId());
          if (playerData != null) {
            ({id} = playerData);
            return $gameMap.networkCharacterById(id);
          }
        } else {
          id = this.actorId();
          return $gamePlayer.followers().aaGetFollowerByActorId(id);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.aaNetSetupTeamId = function(teamId) {
    var e;
    try {
      if (!AA.Network.isNetworkGame()) {
        return;
      }
      this._aaNetTeamId = teamId;
      if (this.netDataObserver._fields["_aaNetTeamId"] == null) {
        return this.netDataObserver.addFields(this, "_aaNetTeamId");
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaNetGetTeamId = function() {
    return this._aaNetTeamId;
  };
  //$[OVER]
  _.isPlayer = function() {
    return AA.System.isABSActive() && this === $gameParty.leader();
  };
  //$[OVER]
  _.getAASkills = function() {
    var attackSkillId, list;
    // * Включает атаку и защиту (базовые 1 и 2)
    //TODO: навык защиты надо тоже под АБС автоматически дорабатывать при загрузке
    attackSkillId = this.attackSkillId();
    list = this.skills().concat([$dataSkills[attackSkillId]]);
    // * Включает АБС предметы (так как они по сути тоже навыки)
    // * Используется метод $gameParty.items() для быстродействия, чтобы 2 раза не проверять
    list = list.concat($gameParty.items());
    return list.filter(function(skill) {
      return skill.AASkill != null;
    });
  };
  //$[OVER]
  _.getAAItems = function() {
    return $gameParty.items().filter(function(item) {
      return AASkill2.IsAAObject(item);
    });
  };
  
  //$[OVER]
  // * По умолчанию (если тип weaponMotionType не указан анимации, то по типу оружия в руках)
  _.getDefaultWeaponMotionAnimationWeaponId = function() {
    var attackMotion, e, weapons, wtypeId;
    try {
      weapons = this.weapons();
      wtypeId = weapons[0] != null ? weapons[0].wtypeId : 0;
      attackMotion = $dataSystem.attackMotions[wtypeId];
      if (attackMotion != null) {
        return attackMotion.weaponImageId;
      }
    } catch (error) {
      e = error;
      AA.w;
    }
    return 0;
  };
  _.aaCheckAndParseExtendedHitBoxes = function() {
    var actor, e;
    try {
      actor = this.actor();
      if ((actor != null) && (actor.meta.extraHitBoxes != null)) {
        this._aaExtendedHitBox = AAParametersParser.convertArrayFromParameter(actor.meta.extraHitBoxes);
        return;
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    this._aaExtendedHitBox = null;
  };
  _.aaGetExtendedHitBoxes = function() {
    return this._aaExtendedHitBox;
  };
  _.aaOnEquipChanged = function() {
    var e;
    try {
      this._aaCachedWeaponAttackSkillId = null;
      // * Обработка смены оружия с навыком атаки только на игроке
      if (this.AACharacter() === $gamePlayer) {
        $gamePlayer.aaSkillsSet.refreshAttackSkillBinding();
      }
      uAPI.refreshSkillPanelSafe();
      return this.aaRefreshSkillExtensionItemForNewWeapon();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaGetProjectileStartOffset = function() {
    var e;
    try {
      return Number(KDCore.Utils.getValueFromMeta('vectorOffset', this.actor()));
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.aaGetWeaponAttackSkillId = function() {
    var currentWeapon, e, skillId;
    try {
      if (this._aaCachedWeaponAttackSkillId == null) {
        this._aaCachedWeaponAttackSkillId = 0;
        currentWeapon = this.weapons()[0];
        if (currentWeapon != null) {
          skillId = KDCore.Utils.getValueFromMeta('attackSkill', currentWeapon);
          if (String.any(skillId)) {
            skillId = parseInt(skillId);
            if ($dataSkills[skillId] && AASkill2.IsAASkill(skillId)) {
              this._aaCachedWeaponAttackSkillId = skillId;
            }
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaCachedWeaponAttackSkillId = 0;
    }
    return this._aaCachedWeaponAttackSkillId;
  };
  _.aaGetDefaultSecondarySkillId = function() {
    var e, isExistsAsAASkill, skillId;
    try {
      skillId = KDCore.Utils.getValueFromMeta('defaultSecondarySkill', this.actor());
      if (!String.any(skillId)) {
        return 0;
      }
      skillId = parseInt(skillId);
      isExistsAsAASkill = this.getAASkills().find(function(item) {
        return item.idA === skillId;
      });
      if (isExistsAsAASkill != null) {
        return skillId;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  };
  _.aaIsEquippedInHeavyArmor = function() {
    var e;
    try {
      return AA.Utils.isAnyItemHaveNotetag(this.equips(), 'aaHeavy');
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  // * Данные параметры добавлены для Gauge Controller Exp gauge
  Object.defineProperties(_, {
    cexp: {
      get: function() {
        return this.currentExp() - this.currentLevelExp();
      },
      configurable: true
    }
  });
  Object.defineProperties(_, {
    nexp: {
      get: function() {
        return this.nextLevelExp() - this.currentLevelExp();
      },
      configurable: true
    }
  });
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //%[I] Показывать список новых навыков через PopUp (как в оригинале)
  _.aaDisplayCustomLevelUp = function() {
    var e, p;
    try {
      p = AA.PP.getCustomLevelUpSettings();
      if (p.databaseAnimationId > 0) {
        uAPI.scriptAction("an_" + p.databaseAnimationId, this.AACharacter());
      }
      if (String.any(p.imageSeqAnimationName)) {
        this.aaLvUpPlayExtraAnimation(p.imageSeqAnimationName, p.imageSeqAnimationMargins);
      }
      if (String.any(p.extraSE)) {
        KDCore.Utils.playSE(p.extraSE);
      }
      if (p.isShowPopUp === true) {
        this.aaLvUpShowLevelUpPopUp(p.popUpText, p.popUpStyle);
      }
      if (p.commonEvent > 0) {
        AAUtils.startCE(p.commonEvent);
      }
      if (String.any(p.scriptAction)) {
        return uAPI.scriptAction(p.scriptAction, this.AACharacter());
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaLvUpPlayExtraAnimation = function(name, {x, y}) {
    var char, e;
    try {
      char = this.AACharacter();
      if (char == null) {
        return;
      }
      return uAPI.playExtraAnimation(char.x, char.y, name, "", x, y);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaLvUpShowLevelUpPopUp = function(text, style) {
    var char, e;
    try {
      if (style == null) {
        return;
      }
      if (!String.any(text)) {
        return;
      }
      text = text.replace("%1", this.level);
      char = this.AACharacter();
      if (char == null) {
        return;
      }
      return Sprite_AADamagePopUpItem.CreateOnCharacterBinded(char, style, text);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  _.aaIsCanUseWeaponWithExtension = function() {
    var def, e, extItemId;
    try {
      def = this.aaGetActiveWeaponExtensionDefinition();
      if (def == null) {
        return true;
      }
      extItemId = this.aaGetActiveSkillExtensionItemId();
      if (extItemId > 0) {
        return this.aaIsCanUseSkillDefinitionNow(def, extItemId);
      } else {
        if (def.isRequireExtensionItem()) {
          return false;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return true;
  };
  _.aaGetActiveWeaponExtensionDefinition = function() {
    var activeWeapon, def, e;
    try {
      activeWeapon = this.weapons()[0];
      if (activeWeapon != null) {
        def = activeWeapon.AAExtDefinition;
        if ((def != null) && def.isValidDefinition()) {
          return def;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.aaGetActiveSkillExtensionItemId = function() {
    var e;
    try {
      if (this._aaActiveExtensionItemId != null) {
        return this._aaActiveExtensionItemId;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  };
  _.aaSetActiveSkillExtensionItemId = function(extItemId) {
    var def, e;
    try {
      this._aaActiveExtensionItemId = 0;
      if (extItemId == null) {
        return;
      }
      if (extItemId <= 0) {
        return;
      }
      def = this.aaGetActiveWeaponExtensionDefinition();
      if ((def != null) && def.extensions.contains(extItemId)) {
        this._aaActiveExtensionItemId = extItemId;
        return;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaActiveExtensionItemId = 0;
    }
  };
  // * Когда персонаж меняет оружие, надо убрать предметы не подходящие
  _.aaRefreshSkillExtensionItemForNewWeapon = function() {
    var def, e, i, item, len, prevExtensionItemId, ref;
    try {
      prevExtensionItemId = this.aaGetActiveSkillExtensionItemId();
      this.aaSetActiveSkillExtensionItemId(0);
      def = this.aaGetActiveWeaponExtensionDefinition();
      if (def == null) {
        return;
      }
      if (def.extensions.contains(prevExtensionItemId)) {
        this.aaSetActiveSkillExtensionItemId(prevExtensionItemId);
      } else {
        // * Если нет, пытаемся поставить любую (если требуется вообще)
        if (def.isRequireExtensionItem()) {
          ref = def.extensions;
          for (i = 0, len = ref.length; i < len; i++) {
            item = ref[i];
            if ($gameParty.numItems($dataItems[item]) > 0) {
              this.aaSetActiveSkillExtensionItemId(item);
              return;
            }
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.aaSetActiveSkillExtensionItemId(0);
    }
  };
  // * Применить "расширение" оружия к (его) навыку атаки
  _.aaCheckAndApplySkillExtension = function(skill) {
    var aaSkillDataCopy, def, e, extItemId, item, skillId;
    try {
      if (skill.idA !== this.attackSkillId()) {
        return skill;
      }
      def = this.aaGetActiveWeaponExtensionDefinition(skill);
      if (def == null) {
        return skill;
      }
      extItemId = this.aaGetActiveSkillExtensionItemId();
      if (extItemId > 0) {
        if (this.aaIsCanUseSkillDefinitionNow(def, extItemId)) {
          item = $dataItems[this.aaGetActiveSkillExtensionItemId()];
          if (item == null) {
            return skill;
          }
          if (item.AAExtItem == null) {
            return skill;
          }
          skillId = skill.id;
          // * made a copy of skill data
          aaSkillDataCopy = JsonEx.parse(JsonEx.stringify(skill.AASkill));
          $dataSkills[skillId].__aaDefCopy = aaSkillDataCopy;
          $dataSkills[skillId].AASkill.setNoteParameters(item.AAExtItem.getParameters());
        } else {
          console.log("Skill extension not valid now for use (or you don't have any skill extension item)");
          return null;
        }
      } else {
        // * Если нет никаких, но необходим какой-либо
        // * то возращаем NULL, так как не можем использовать текущий навык
        if (def.isRequireExtensionItem()) {
          console.log("For use this skill " + skill.name + " you should have Skill Extension");
          return null;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return skill;
  };
  _.aaIsCanUseSkillDefinitionNow = function(def, extItemId) {
    var e;
    try {
      if ($gameParty.numItems($dataItems[extItemId]) <= 0) {
        return false;
      }
      if (!def.extensions.contains(extItemId)) {
        // * Только если этот предмет можно использовать с данным weapon
        return false;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return false;
    }
    return true;
  };
  _.consumeSkillExtension = function(skill) {
    var def, e, extItemId;
    try {
      if (skill.idA !== this.attackSkillId()) {
        return;
      }
      def = this.aaGetActiveWeaponExtensionDefinition(skill);
      if (def == null) {
        return;
      }
      extItemId = this.aaGetActiveSkillExtensionItemId();
      if (extItemId <= 0) {
        return;
      }
      if (def.isConsumeExtensionItem()) {
        return $gameParty.gainItem($dataItems[extItemId], -1, true);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startWeaponAnimation, _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  //@[ALIAS]
  ALIAS__startWeaponAnimation = _.startWeaponAnimation;
  _.startWeaponAnimation = function(weaponImageId) {
    AANetworkManager.requestWeaponAnimation(this, weaponImageId);
    ALIAS__startWeaponAnimation.call(this, ...arguments);
  };
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  // * Все ABS навыки персонажа
  // У Actor и Enemy разные источники, поэтому метод тут не имеет тела
  _.getAASkills = function() {
    return [];
  };
  // * Все ABS предметы персонажа
  _.getAAItems = function() {
    return [];
  };
  // * ABS навыки, которые можно использовать в данный момент (включая предметы)
  _.getUsableAASkills = function() {
    return this.getAASkills().filter((skill) => {
      return this.canUse(skill);
    });
  };
  // * Когда совершили какое-либо АБС действие (навык)
  // * Не используется стандартный onAllActionsEnd, так как он очищает result
  // * Данный метод выполняется только если действие было полностью законченно
  // * Некоторые AASkills прерываются, если нет цели, тогда onAAActionEnd не вызывается
  _.onAAActionComplete = function() {};
  // * Данный метод выполняется когда действие только активированно (начинается)
  _.onAAActionStart = function() {
    this.aaStates.onAnyActionDone();
  };
  // * Запросить анимацию взмаха оружия (не AnimaX, а стандартная как было в АБС)
  // * См. в редакторе System -> [SV] Attack Motions
  // * Файлы -> System\weapons
  _.aaPlayAAWeaponMotionAnimation = function(skill) {
    var e, weaponId;
    try {
      // * ID номер оружия указа в навыке
      if (skill.isHaveWeaponMotionSpecialType()) {
        this.startWeaponAnimation(skill.weaponMotionType); // * Иначе стандартная (0 или оружие в руках)
      } else {
        weaponId = this.getDefaultWeaponMotionAnimationWeaponId();
        if (weaponId > 0) {
          this.startWeaponAnimation(weaponId);
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Если параметр навыка weaponMotionType == 0, то этот метод вызывается
  // * Реализация на Actor и Enemy разная
  _.getDefaultWeaponMotionAnimationWeaponId = function() {
    return 0; // * 0 - нету
  };
  
  // * Изменение здоровье с показом PopUp
  _.aaGainHpWithPopUp = function(value, isCrit = false) {
    var e;
    try {
      this._result = new Game_ActionResult();
      this._result.used = true;
      this._result.hpDamage = value * -1;
      this._result.success = true;
      this._result.physical = true;
      this._result.critical = isCrit === true;
      this._result.hpAffected = true;
      this.startDamagePopup();
      return this.gainHp(value);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Изменение маны с показом PopUp
  _.aaGainMpWithPopUp = function(value, isCrit = false) {
    var e;
    try {
      this._result = new Game_ActionResult();
      this._result.used = true;
      this._result.mpDamage = value * -1;
      this._result.success = true;
      this._result.physical = true;
      this._result.critical = isCrit === true;
      this.startDamagePopup();
      return this.gainMp(value);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addNewState, ALIAS__canUse, ALIAS__clearStates, ALIAS__eraseState, ALIAS__initMembers, ALIAS__isAppeared, ALIAS__isOccasionOk, ALIAS__paySkillCost, _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  // * Этот метод используется в методе canMove, поэтому дополняем его
  // * В АБС бою, монстр всегда Appeared (видимый)
  //@[ALIAS]
  ALIAS__isAppeared = _.isAppeared;
  _.isAppeared = function() {
    if (AA.isABSMap()) {
      return true;
    } else {
      return ALIAS__isAppeared.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this.initAASkills();
  };
  //@[ALIAS]
  ALIAS__canUse = _.canUse;
  _.canUse = function(item) {
    if (AA.isABSMap() && (item.AASkill != null)) {
      return this.canUseABSItem(item);
    } else {
      return ALIAS__canUse.call(this, item);
    }
  };
  //@[ALIAS]
  ALIAS__paySkillCost = _.paySkillCost;
  _.paySkillCost = function(skill) {
    ALIAS__paySkillCost.call(this, skill);
    if (AA.isABSMap() && (skill.AASkill != null)) {
      return this.aaSetSkillTimer(skill);
    }
  };
  // * АБС навыки не учитывают область действия, так как их можно использовать только на карте
  //@[ALIAS]
  ALIAS__isOccasionOk = _.isOccasionOk;
  _.isOccasionOk = function(item) {
    if (AA.isABSMap() && (item.AASkill != null)) {
      return true;
    } else {
      return ALIAS__isOccasionOk.call(this, item);
    }
  };
  // * STATES =========================================

  //@[ALIAS]
  ALIAS__addNewState = _.addNewState;
  _.addNewState = function(stateId) {
    ALIAS__addNewState.call(this, stateId);
    // * Если состояние было добавленно
    if (this.isStateAffected(stateId)) {
      if (AAState.IsValid(stateId)) {
        this.addNewStateABS(stateId);
      }
    }
  };
  //@[ALIAS]
  ALIAS__clearStates = _.clearStates;
  _.clearStates = function() {
    ALIAS__clearStates.call(this);
    return this.clearStatesABS();
  };
  
  //@[ALIAS]
  ALIAS__eraseState = _.eraseState;
  _.eraseState = function(stateId) {
    var ref;
    ALIAS__eraseState.call(this, stateId);
    if (!this.isStateAffected(stateId)) {
      if (stateId === 1) { // * Death
        if ((ref = this.AACharacter()) != null) {
          ref.aaOnRevive();
        }
      }
      if (AAState.IsValid(stateId)) {
        return this.eraseStateABS(stateId);
      }
    }
  };
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  _.gev_onABSPaused = function() {
    return this.aaStates.onABSSystemStop(this);
  };
  _.AACharacter = function() {
    return null;
  };
  _.isPlayer = function() {
    return false;
  };
  _.aaUpdateABS = function() {
    // * Обновление таймеров навыков
    this.aaSkillsTimers.update();
    return this.aaUpdateABSStates();
  };
  // * Расчёт значения по формуле для текущего бойца
  // * Выполняется внутри Battler, чтобы можно было получить
  // * знаения базовых параметров
  _.aaCalculateFormula = function(formula) {
    var e;
    try {
      return eval(formula);
    } catch (error) {
      e = error;
      AA.w(e);
      return 0;
    }
  };
  _.initAASkills = function() {
    this.aaSkillsTimers = new AASkillsTimers();
  };
  // * Запустить таймер перезарядки для навыка
  _.aaSetSkillTimer = function(skill) {
    var time;
    time = skill.AASkill.getReloadTime(this);
    if (time > 0) {
      this.aaSkillsTimers.startTimerForSkill(skill.idA, time);
    }
  };
  // * Если у навыка есть таймер, значит он не готов (не важно сколько осталось времени)
  _.aaIsSkillReadyInTime = function(skill) {
    return !this.aaSkillsTimers.isSkillHaveTimer(skill.idA);
  };
  // * Получить таймер навыка (используется для панели навыков в основном)
  _.aaGetRemainTimeForSkill = function(skillId) {
    // * Если таймер меньше секунды, то будет возращён 0 (чтобы не начинать визуальный отсчёт)
    if (this.aaSkillsTimers.isSkillHaveTimerToShow(skillId)) {
      return this.aaSkillsTimers.getRemainTimeForSkill(skillId);
    } else {
      return 0;
    }
  };
  _.canUseABSItem = function(item) {
    if (item == null) {
      return false;
    }
    if (!AA.isABSActive()) {
      return false;
    }
    if (!this.canMove()) {
      return false;
    }
    if (!AASkill2.IsAAObject(item)) {
      return false;
    }
    if (!this.meetsABSExtraConditions(item)) {
      return false;
    }
    if (DataManager.isSkill(item)) {
      return this.meetsABSSkillContitions(item);
    } else if (DataManager.isItem(item)) {
      return this.meetsABSItemContitions(item);
    } else {
      return false;
    }
  };
  _.meetsABSExtraConditions = function(item) {
    var aaSkill, e;
    try {
      aaSkill = item.AASkill;
      if (aaSkill.isRequireStateOnUser()) {
        if (!this.isStateAffected(aaSkill.gUsableIfState())) {
          return false;
        }
      }
      if (aaSkill.idA === this.attackSkillId()) {
        if (!this.aaIsCanUseWeaponWithExtension()) {
          return false;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return true;
  };
  _.aaIsCanUseWeaponWithExtension = function() {
    return true;
  };
  _.meetsABSSkillContitions = function(skill) {
    return this.aaIsSkillReadyInTime(skill) && this.meetsSkillConditions(skill);
  };
  // * Вещи не имеют таймеров
  _.meetsABSItemContitions = function(item) {
    return this.meetsItemConditions(item);
  };
  
  // * Применение "расширения" навыка (работает только Game_Actor)
  _.aaCheckAndApplySkillExtension = function(skill) {
    return skill;
  };
  // * Использование предмета "расширения" навыка (работает только Game_Actor)
  _.consumeSkillExtension = function(skill) {}; // * EMPTY
  _.aaGetExtraOverlayImage = function() {
    var e, state, states;
    try {
      states = this.states();
      if (states.length > 0) {
        state = states[0];
        if (state.meta != null) {
          return state.meta.svOverlay;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  // * Добавим MaxTp чтобы Gauge контроллеры работали
  Object.defineProperties(_, {
    mtp: {
      get: function() {
        return this.maxTp();
      },
      configurable: true
    }
  });
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  //TODO: подписаться на событие по остановке ABS

  // * Для оптимизации, вынес в отдельную переменную
  _.aaSetSpeedMod = function(_aaSpeedModValue) {
    this._aaSpeedModValue = _aaSpeedModValue;
  };
  _.aaUpdateABSStates = function() {
    return this.aaStates.update(this);
  };
  _.addNewStateABS = function(stateId) {
    var stateItem;
    stateItem = AA.Utils.getAAStateObject(stateId);
    if (stateItem == null) {
      return;
    }
    //"ABS STATE ADDED".p(stateId)
    this.aaStates.checkBattler(this);
    this.aaStates.add(stateId);
  };
  _.clearStatesABS = function() {
    this.aaStates = new AAStatesSet(this);
    this.aaSetSpeedMod(null);
  };
  _.eraseStateABS = function(stateId) {
    var stateItem;
    stateItem = AA.Utils.getAAStateObject(stateId);
    if (stateItem == null) {
      return;
    }
    //"ABS STATE REMOVED".p()
    this.aaStates.remove(stateId);
  };
  _.aaSpeedMod = function() {
    if (this._aaSpeedModValue != null) {
      return this._aaSpeedModValue;
    } else {
      return 1;
    }
  };
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__searchLimit, ALIAS__turnTowardCharacter, _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  //@[ALIAS]
  ALIAS__searchLimit = _.searchLimit;
  _.searchLimit = function() {
    if (this.isABS()) {
      return 24;
    } else {
      return ALIAS__searchLimit.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__turnTowardCharacter = _.turnTowardCharacter;
  _.turnTowardCharacter = function(character) {
    ALIAS__turnTowardCharacter.call(this, character);
    // * Дополнительно синхронизируем поворот
    // * В Alpha NET Z это делается через Observer 60, что не хватает для ABS
    if (AA.Network.isNetworkGame()) {
      AANetworkManager.sendTurnTowardCharacter(this, character);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.aaIsHaveExColliders = function() {
    return (this._aaExColliders != null) && this._aaExColliders.length > 0;
  };
  _.aaGetAllExColliders = function() {
    var e;
    try {
      if (!this.aaIsHaveExColliders()) {
        return [];
      }
      this.aaRefreshAllColliders();
      return this._aaExColliders;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _.aaRefreshAllColliders = function() {
    var col, e, i, len, ref, results;
    try {
      if (!this.aaIsHaveExColliders()) {
        return;
      }
      ref = this._aaExColliders;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        col = ref[i];
        results.push(this.aaRefreshColliderData(col));
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaRefreshColliderData = function(c) {
    var e;
    try {
      if (c == null) {
        return;
      }
      return c.refreshPositionForChar(this);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaClearExCollider = function() {
    var e;
    try {
      return this._aaExColliders = [];
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaAddExCollider = function(config) {
    var c, col, e, i, len;
    try {
      if (config == null) {
        return;
      }
      if (config instanceof Array) {
        for (i = 0, len = config.length; i < len; i++) {
          c = config[i];
          this.aaAddExCollider(c);
        }
        return;
      }
      if (this._aaExColliders == null) {
        this._aaClearExCollider();
      }
      col = new AACollider(config);
      if (col != null) {
        return this._aaExColliders.push(col);
      }
    } catch (error) {
      //console.log("collider created " + config.flag)
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaIsCollideWith = function(collider) {
    var col, e, i, len, myColliders;
    try {
      myColliders = this.aaGetAllExColliders();
      for (i = 0, len = myColliders.length; i < len; i++) {
        col = myColliders[i];
        if (col.isCollideWith(collider)) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  // * Not for Events, for Player and Follower
  _._initExCollForABS = function(flag = 'player') {
    var config, e;
    try {
      if (this.AABattler() == null) {
        return;
      }
      config = this.AABattler().actor().meta.aCollider;
      if (String.any(config)) {
        if (config === "none") {
          return;
        }
        config = AACollider.ParseConfigString(config, flag);
      } else {
        config = AACollider.DefaultConfig(flag);
      }
      return this.aaAddExCollider(config);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  (function() {    // * Методы ABS (Цель)
    // -----------------------------------------------------------------------
    _.AATarget = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.getTarget() : void 0;
    };
    //TODO: Это можно удалить

    // * Попытка установить активную цель
    _.aaTrySetTarget = function(target) {
      var ref;
      if (this.aaIsValidTargetToSet(target)) {
        if ((ref = this.AAEntity()) != null) {
          ref.setTarget(target);
        }
        return true;
      }
      return false;
    };
    
    // * Этот метод лучше переопределять у Game_Event и Game_Player
    _.aaIsValidTargetToSet = function(target) {
      return false;
    };
    // * Есть ли активная цель?
    return _.aaIsHaveTarget = function() {
      return this.AATarget() != null;
    };
  })();
  (function() {    
    // * Методы ABS (Навыки)
    // -----------------------------------------------------------------------
    _.aaApplyImpulse = function(power, dir = 0, withJump = false, isReversed = false) {
      var e, lastDirectionFix;
      try {
        if (power <= 0) {
          return;
        }
        //console.log ("APPLY IMPULSE "  + power)
        // * Random direction
        if (dir <= 0) {
          dir = 2 + Math.randomInt(4) * 2;
        }
        lastDirectionFix = this.isDirectionFixed();
        this.setDirectionFix(true);
        // * Move away around
        if (dir === 100 && ($gameTemp._aaImpuleAwayFrom != null)) {
          this.aaMoveAwayByImpulse(power, withJump, isReversed);
        } else {
          if (isReversed) {
            dir = this.reverseDir(dir);
          }
          this.aaMoveInImpulseDirection(power, dir, withJump);
        }
        return this.setDirectionFix(lastDirectionFix);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaMoveAwayByImpulse = function(power, withJump, isReversed = false) {
      var e, i, j, ref;
      try {
        //"MOVE AWAY".p()
        this.aaClearMovePath();
        for (i = j = 0, ref = power; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (isReversed) {
            this.moveTowardCharacter($gameTemp._aaImpuleAwayFrom);
          } else {
            this.moveAwayFromCharacter($gameTemp._aaImpuleAwayFrom);
          }
        }
        if (withJump) {
          return this.jump(0, 0);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaMoveInImpulseDirection = function(power, dir, withJump) {
      var e, i, j, ref;
      try {
        this.aaClearMovePath();
        if (this.canPass(this._x, this._y, dir)) {
          for (i = j = 0, ref = power; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
            if (!this.aaForceMoveByImpluse(dir)) {
              break;
            }
          }
          if (withJump) {
            return this.jump(0, 0);
          }
        } else {
          return this.jump(0, 0);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.aaForceMoveByImpluse = function(direction) {
      var e;
      try {
        if (this.canPass(this._x, this._y, direction)) {
          this.moveStraight(direction);
          return true;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
  })();
  (function() {    // * Методы ABS (Движение)
    // -----------------------------------------------------------------------
    _.aaTurnTowardTouchInput = function() {
      return this.turnTowardCharacter(TouchInput.toMapPoint());
    };
    _.aaTeleport = function(point, inAnimation, outAnimation, delay = 1) {
      var e, staticPoint;
      try {
        // * Чтобы не хранить лишние данные, вдруг в качестве Point передался Game_Character
        staticPoint = {
          x: point.x,
          y: point.y
        };
        this._aaTeleportData = {
          point: staticPoint,
          inAnimation,
          outAnimation
        };
        this._aaTeleportDelay = delay;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _._aaPerformTeleport = function() {
      var e, inAnimation, outAnimation, point;
      if (this._aaTeleportData == null) {
        return;
      }
      try {
        ({point, inAnimation, outAnimation} = this._aaTeleportData);
        if ($gameMap.isValid(point.x, point.y)) {
          if (inAnimation > 0) {
            AABattleAnimationsManager.playAnimationOnMap(inAnimation, {
              x: this.x,
              y: this.y
            });
            return this.aaTeleport(point, 0, outAnimation, 10); // * Если нет анимации входа, то мнгновенно!
          } else {
            this.locate(point.x, point.y);
            if (outAnimation > 0) {
              AABattleAnimationsManager.playAnimationOnMap(outAnimation, point);
            }
            this._aaOnTeleportPerformed();
            return this._aaTeleportData = null;
          }
        } else {
          return this._aaTeleportData = null;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return this._aaTeleportData = null;
      }
    };
    return _._aaUpdateTeleportRequest = function() {
      if (this._aaTeleportData == null) {
        return;
      }
      if (this._aaTeleportDelay > 0) {
        this._aaTeleportDelay--;
        if (this._aaTeleportDelay <= 0) {
          this._aaTeleportDelay = 0;
          this._aaPerformTeleport();
        }
      }
    };
  })();
  // -----------------------------------------------------------------------
  _.aaIsOutOfScreen = function() {
    var e, limitH, limitW, margin, sx, sy;
    try {
      sx = this.screenX();
      sy = this.screenY();
      margin = 20;
      limitW = Graphics.width + margin;
      limitH = Graphics.height + margin;
      if (sx < -margin || sx > limitW || sy < -margin || sy > limitH) {
        return true;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //TODO LIST:
  // Casting Party AI members
  // Add Casting Progress Bar to UI Editor
  // Правильная остановка звука

  //@[DEFINES]
  _ = Game_Character.prototype;
  _.aaInSkillCastingProcess = function() {
    return this._aaCastingNowSkill != null;
  };
  // * Начать процесс каста навыка
  _.aaStartSkillCastingProcess = function(skill) {
    var e;
    try {
      console.log("Start Casting Skill: " + skill.name());
      this._aaCastingNowSkill = skill;
      this._aaCastingTimer = 0;
      this._aaCastingTimeMax = skill.gCastingTime() * 60;
      this._aaOnCastingStarted();
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.aaAbortSkillCastingProcess();
    }
  };
  _._aaOnCastingStarted = function() {
    var e;
    try {
      AAUtils.startCE(this._aaCastingNowSkill.onCastingStartCE);
      if (String.any(this._aaCastingNowSkill.castingSE)) {
        KDCore.Utils.playSE(this._aaCastingNowSkill.castingSE);
      }
      if (String.any(this._aaCastingNowSkill.castingAnimation)) {
        return this.startAnimaXCustomAction(this._aaCastingNowSkill.castingAnimation, true, true);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Прервать (например при движени или входа в меню)
  _.aaAbortSkillCastingProcess = function() {
    var e;
    try {
      if (!this.aaInSkillCastingProcess()) {
        return;
      }
      this._aaOnCastingAborted();
      AAUtils.startCE(this._aaCastingNowSkill.onCastingAbortedCE);
      console.log("Abort Casting Skill");
      return this.aaClearSkillCastingProcess();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaOnCastingAborted = function() {
    var e;
    try {

    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaClearSkillCastingProcess = function() {
    var e;
    try {
      this._aaCastingTimer = 0;
      this._aaCastingTimeMax = 0;
      this._aaBeforeCastingTargetPoint = null;
      this._aaOnCastingEnd();
      return this._aaCastingNowSkill = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaOnCastingEnd = function() {
    var e;
    try {
      //TODO: Not good way
      if (String.any(this._aaCastingNowSkill.castingSE)) {
        AudioManager.stopSe();
      }
      if ((this._aaCastingNowSkill != null) && String.any(this._aaCastingNowSkill.castingAnimation)) {
        return this.resetXAnima();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaFinishSkillCastingProcess = function() {
    var dbItem, e, extraCondition, skill, targetPoint;
    try {
      this._aaOnCastingFinished();
      console.log("Finish Casting Skill");
      skill = this._aaCastingNowSkill;
      targetPoint = this._aaBeforeCastingTargetPoint;
      if (this._aaBeforeCastingTargetPoint instanceof Game_Character) {

      } else {
        // * Nothing
        if (skill.isInPoint() && !skill.isNeedSelectZone()) {
          targetPoint = TouchInput.toMapPoint();
          extraCondition = skill.isInstant() || skill.isInCertainPoint();
          if (extraCondition === false) {
            targetPoint.touchXY = {
              x: TouchInput.x,
              y: TouchInput.y
            };
          }
        }
      }
      this.aaClearSkillCastingProcess();
      dbItem = skill.dbItem();
      return setTimeout((() => {
        var e;
        try {
          if (targetPoint != null) {
            return this.startPerformAASkill(targetPoint, true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }), 1);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaOnCastingFinished = function() {
    var e;
    try {
      return AAUtils.startCE(this._aaCastingNowSkill.onCastingCompletedCE);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaOnEventWhileCasting = function(eventName) {
    var e;
    try {
      if (!this.aaInSkillCastingProcess()) {
        return;
      }
      if (eventName === "hit") {
        if (this._aaCastingNowSkill.castingStopWhenHit > 0) {
          console.log("Character was hit while casting");
          this.aaAbortSkillCastingProcess();
        } else if (this._aaCastingNowSkill.castingDelayWhenHit > 0) {
          console.log("Character was hit while casting, delay casting");
          this._aaCastingTimer -= this._aaCastingNowSkill.castingDelayWhenHit * 60;
          if (this._aaCastingTimer < 0) {
            this._aaCastingTimer = 0;
          }
        }
        return;
      }
      if (eventName === "move") {
        console.log("Character is moving while casting");
        this.aaAbortSkillCastingProcess();
        return;
      }
      if (eventName === "click") {
        if (this._aaCastingNowSkill.castingRotation > 0) {
          this.aaTurnTowardTouchInput();
        }
        return;
      }
      if (eventName === "cancel" || eventName === "menu") {
        console.log("Character canceled casting (or menu)");
        this.aaAbortSkillCastingProcess();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Not used now
  //_.aaIsCantMoveWhileCasting = () ->
  //    return false unless @aaInSkillCastingProcess()
  //    return @_aaCastingNowSkill.castingStopWhenMove == 0
  _._aaUpdateCastingProcess = function() {
    var e;
    try {
      if (!this.aaInSkillCastingProcess()) {
        return;
      }
      if (this._aaCastingNowSkill.castingRotation > 0) {
        this.aaTurnTowardTouchInput();
      }
      this._aaCastingTimer += 1;
      if (this._aaCastingTimer >= this._aaCastingTimeMax) {
        return this.aaFinishSkillCastingProcess();
      } else {
        if (this.isMoving()) {
          return this.aaOnEventWhileCasting('move');
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.setActiveAASkill = function(_activeAASkillId) {
    this._activeAASkillId = _activeAASkillId;
  };
  _.activeAASkill = function() {
    if (this._activeAASkillId > 0) {
      return AASkill2.GetAASkillObject(this._activeAASkillId).AASkill;
    } else {
      return null;
    }
  };
  _.startPerformAASkill = function(point, afterCasting = false) {
    var skill;
    skill = this.activeAASkill();
    if (skill.isNeedCasting() && !afterCasting) {
      this._aaBeforeCastingTargetPoint = point;
      this.aaStartSkillCastingProcess(skill);
      return;
    }
    if (skill.isInPoint()) {
      this.turnTowardCharacter(point);
    }
    //TODO: Тут можно ещё дополнительную проверку canUse
    // так как пока шёл выборо цели (например) мана могла закончиться
    // * Анимация Motion и AnimaX могут работать вместе
    this.aaDetermineAndPlaySkillAnimation(skill);
    // * Персонаж "платит" за навык как только использует его
    this.AABattler().useItem(skill.dbItem());
    this.AABattler().consumeSkillExtension(skill);
    this.AABattler().onAAActionStart();
    // * Ограничение задержки для безопасности (было снято)
    if (skill.actionStartDelay > 0) { //and skill.actionStartDelay <= 60
      this.setupDelayedAASkill(skill, point);
    } else {
      AABattleSkillsExecutionManager.startSkill(skill, this, point);
    }
  };
  _.aaDetermineAndPlaySkillAnimation = function(skill) {
    if (skill.animaXPriority > 1) {
      if (skill.isHaveWeaponMotion()) {
        // * Анимация Motion и AnimaX могут работать вместе
        this.AABattler().aaPlayAAWeaponMotionAnimation(skill);
      }
      this.aaPlayAASkillXAnimation(skill);
    } else {
      // * Если в приоритете AnimaX
      if (skill.animaXPriority === 1) {
        // * Если есть анимация для действия, то проиграть её
        if (this.aaIsAvailableAnimaXForSkill(skill)) {
          this.aaPlayAASkillXAnimation(skill); // * Иначе анимаци Weapon Motion
        } else {
          if (skill.isHaveWeaponMotion()) { // * Если в приоритете Weapon Motion
            this.AABattler().aaPlayAAWeaponMotionAnimation(skill);
          }
        }
      } else {
        if (skill.isHaveWeaponMotion()) {
          this.AABattler().aaPlayAAWeaponMotionAnimation(skill); // * Если нет Weapon Motion, то AnimaX (если есть)
        } else {
          if (this.aaIsAvailableAnimaXForSkill(skill)) {
            this.aaPlayAASkillXAnimation(skill);
          }
        }
      }
    }
  };
  _.aaIsAvailableAnimaXForSkill = function(skill) {
    if (Imported.PKD_AnimaX !== true) {
      return false;
    }
    if (!this.isAnimX()) {
      return false;
    }
    return this.isHaveAnimaXActionWithName(skill.getAnimaXActionName());
  };
  _.aaPlayAASkillXAnimation = function(skill) {
    var e;
    try {
      if (!Imported.PKD_AnimaX) {
        return;
      }
      if (!this.isAnimX()) {
        return;
      }
      // * For AnimaX network
      // * Команда startAnimaXCustomAction отправляет
      if (this instanceof Game_Event) {
        // * по номеру события
        $gameTemp._lastAxNetworkChar = this.eventId();
      } else {
        // * 0 - значит будет по Actor ID, который отправляет
        $gameTemp._lastAxNetworkChar = 0;
      }
      this.startAnimaXCustomAction(skill.getAnimaXActionName(), false, true);
      return $gameTemp._lastAxNetworkChar = null;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.setupDelayedAASkill = function(skill, point) {
    this.aaDelayedSkillActions.push([skill.actionStartDelay, skill.idA, AA.Utils.packAAPoint(point)]);
  };
  _._aaUpdateDelayedSkillActions = function() {
    var action, i, len, point, ref, skill;
    ref = this.aaDelayedSkillActions;
    //TODO: Навык с задержкой должен иметь задержку перед использованием иначе ошибка, если спамить навык
    for (i = 0, len = ref.length; i < len; i++) {
      action = ref[i];
      if (action == null) {
        continue;
      }
      if (action[0]-- <= 0) {
        skill = AA.Utils.unpackAASkill(action[1]);
        point = AA.Utils.unpackAAPoint(action[2]);
        AABattleSkillsExecutionManager.startSkill(skill, this, point);
        this.aaDelayedSkillActions.delete(action);
      }
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Character.prototype;
  _.aaUpdateAIMovement = function() {
    this.aaUpdateSmartMovementDelay();
    if (this.isMoving()) {
      return;
    }
    if (this.aaInSkillCastingProcess()) {
      return;
    }
    switch (this._moveType) {
      case 91: // * Approach target
        this.aaMoveTypeToTarget();
        return this.aaMoveTypeTeleportToTarget();
      case 92:
        this.aaMoveTypeKeepDistance();
        return this.aaMoveTypeTeleportFromTarget();
      case 93:
        return this.aaMoveTypeReturnToHomePoint();
      case 94:
        // * СТОИТ НА МЕСТЕ И ВСЁ
        return this.aaTurnTowardTarget();
    }
  };
  // * NOTHING
  // Просто стоим
  _.aaUpdateSmartMovementDelay = function() {
    var e;
    try {
      if (this.__aaNextDirectionFindDelay > 0) {
        this.__aaNextDirectionFindDelay--;
        if (this.__aaNextDirectionFindDelay <= 0) {
          return this.__aaNextDirectionFindDelay = null;
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Эти два метода реализует Game_Event (т.к. враги поддерживают телепорт)
  // * см. файл Game_Event_AIMove_Teleport
  _.aaMoveTypeTeleportToTarget = function() {}; // * EMPTY
  _.aaMoveTypeTeleportFromTarget = function() {}; // * EMPTY
  
  // * Сохраняем базовые настройки движения события
  _.aaStoreMoveData = function() {
    var i, item, len, ref;
    // * Выполняется один раз, при первой инициализации
    if (this._storedMoveData != null) {
      return;
    }
    this._storedMoveData = {};
    ref = ["_moveSpeed", "_moveType", "_moveFrequency"];
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      this._storedMoveData[item] = this[item];
    }
  };
  // * Восстанавливаем базоыве настройки движения события
  _.aaRestoreMoveData = function() {
    var i, item, len, ref;
    this.__aaNextDirectionFindDelay = null;
    if (this._storedMoveData == null) {
      return;
    }
    ref = ["_moveSpeed", "_moveType", "_moveFrequency"];
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      this[item] = this._storedMoveData[item];
    }
  };
  
  // * Восстановить базовую скорость движения события
  _.aaResetDefaultFreqAndSpeed = function() {
    var i, item, len, ref;
    this.__aaNextDirectionFindDelay = null;
    if (this._storedMoveData == null) {
      return;
    }
    ref = ["_moveSpeed", "_moveFrequency"];
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      this[item] = this._storedMoveData[item];
    }
  };
  // * Сохранить текущую координату как точка "дом"
  _.aaStoreHomePoint = function() {
    this.homePoint = {
      x: this.x,
      y: this.y
    };
  };
  _.aaResetHomePoint = function() {
    return this.homePoint = null;
  };
  // * У событий AI Free State управляет этим процессом (начинает и завершает)
  _.aaSetMoveTypeReturnToHomePoint = function() {
    var e;
    try {
      if (this._moveType === 93) {
        return;
      }
      if (this.homePoint == null) {
        return;
      }
      return this._moveType = 93;
    } catch (error) {
      //returnMoveData[F, S]
      //TODO:
      e = error;
      return AA.w(e);
    }
  };
  _.aaSetMoveTypeApproachTarget = function() {
    var e, params;
    try {
      if (this._moveType === 91) {
        return;
      }
      // * Быстрая проверка, что есть цель
      if (!this.AAEntity().inBattle()) {
        return;
      }
      // * Approach target
      this._moveType = 91;
      // * Задержка перед следующим движением (для оптимизации)
      // * Используется, когда вокруг цели (игрока, персонажа) нет места
      this._aaLastMovingActionDelay = 0;
      params = this.AAModel().approachMoveData;
      if (this.distTo(this.AAEntity().getTarget()) >= params[0]) {
        this.setMoveFrequency(params[1]);
        return this.setMoveSpeed(params[2]);
      } else {
        return this.aaResetDefaultFreqAndSpeed();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaSetMoveTypeKeepBattleDistance = function() {
    var e, params;
    try {
      if (this._moveType === 92) {
        return;
      }
      if (!this.AAEntity().inBattle()) {
        return;
      }
      this._moveType = 92;
      params = this.AAModel().inBattleMoveData;
      this.setMoveFrequency(params[1]);
      this.setMoveSpeed(params[2]);
      this._aaMinPatrolDist = params[0];
      this._aaMaxPatrolDist = this.AAModel().gViewRadius();
      return this._aaCanMakeRandomPatrolMove = params[3];
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaMoveTypeReturnToHomePoint = function() {
    var e;
    try {
      //"HOME ".p()
      if (this.homePoint != null) {
        return this.aaMoveTypeToPoint(this.homePoint);
      } else {
        return this.aaRestoreMoveData();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaSetMoveTypeStayStill = function() {
    var e;
    try {
      if (this._moveType === 94) {
        return;
      }
      if (!this.AAEntity().inBattle()) {
        return;
      }
      return this._moveType = 94;
    } catch (error) {
      //"STAY STILL".p()
      e = error;
      return AA.w(e);
    }
  };
  // * Держать дистанцию боя
  // * Не подходить близко и не отходить далеко
  _.aaMoveTypeKeepDistance = function() {
    var distance, e, target;
    try {
      // * Если меньше 0, то ничего
      if (this._aaMinPatrolDist <= 0) {
        this.aaTurnTowardTarget();
        return;
      }
      target = this.AAEntity().getTarget();
      if (target == null) {
        return;
      }
      distance = this.distTo(target);
      if (distance >= this._aaMaxPatrolDist) {
        //"DIST > MAX".p()
        this.aaMoveTypeToTarget(target);
        return;
      }
      if (distance <= this._aaMinPatrolDist) {
        //"DIST <= MIN".p()
        this.moveAwayFromCharacter(target);
        this.aaTurnTowardTarget();
        return;
      }
      if (this._aaCanMakeRandomPatrolMove) {
        //"RAND MOVE".p()
        this.moveRandom();
        this.aaTurnTowardTarget();
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
})();

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//@[EXTENSION]
AA.extend(function() {
  var ALIAS___createXAnimaSetsForState, ALIAS__createNewAnimaXForCharacter, ALIAS__isHaveAnimaXState, ALIAS__onAnimaXActionEnd, _;
  // * Методы ниже даже не учитываются, если плагин не подключён
  if (Imported.PKD_AnimaX !== true) {
    return;
  }
  //@[DEFINES]
  _ = Game_Character.prototype;
  // * Логика состояний анимации (бой, смерть) (всегда работает)
  _.aaUpdateABSAnimaX = function() {
    var ref;
    if (!this.isAnimX()) {
      return;
    }
    if (!((ref = this.AABattler()) != null ? ref.isAlive() : void 0)) {
      return;
    }
    this.aaUpdateABSAnimaXInBattleState();
  };
  _.aaUpdateABSAnimaXInBattleState = function() {
    var e;
    if (this._aaIsInBattleAnimaXState()) {
      if (this._axState !== 'inBattle') {
        this._aaOnGoInBattleAnimaXState();
      }
      try {
        if (this === $gamePlayer) {
          this.aaStartAutoBattleBgm();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    } else {
      if (this._axState !== 'base') {
        this._aaOnOutFromInBattleAnimaXState();
      }
      try {
        if (this === $gamePlayer) {
          this.aaStopAutoBattleBgm();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }
  };
  _._aaOnGoInBattleAnimaXState = function() {
    this.switchToXAnimaState('inBattle');
    // * Только персонаж игрока сам определяет состояние "В бою"
    // * NET Character не определяет, только получает от севрера
    // * Game_Event - у него по AAEntity, target через Observer синхронизируется
    if (AA.Network.isNetworkGame() && this === $gamePlayer) {
      AANetworkManager.animaXChangeState('inBattle', this);
    }
  };
  _._aaOnOutFromInBattleAnimaXState = function() {
    this.resetXAnimaState();
    if (AA.Network.isNetworkGame() && this === $gamePlayer) {
      AANetworkManager.animaXChangeState('base', this);
    }
  };
  // * Game_Event and Game_Player имеют разную реализацию
  _._aaIsInBattleAnimaXState = function() {
    return false;
  };
  // * Из-за ALIAS пришлось выносить в Extenstion, чтобы не было зависимости от положения AnimaX плагина
  //@[ALIAS]
  ALIAS__createNewAnimaXForCharacter = _.createNewAnimaXForCharacter;
  _.createNewAnimaXForCharacter = function(animaXProfile) {
    ALIAS__createNewAnimaXForCharacter.call(this, animaXProfile);
    this.refreshAnimaXABSStates(animaXProfile);
  };
  // * Добавляем специальный флаг для Dead, чтобы не было Loop и заканчивался на последнем кадре (и с него воспроизводился снова)
  //@[ALIAS]
  ALIAS___createXAnimaSetsForState = _._createXAnimaSetsForState;
  _._createXAnimaSetsForState = function(state, moveSet, idleSet, dashSet) {
    ALIAS___createXAnimaSetsForState.call(this, ...arguments);
    if ((idleSet != null) && state === "dead") {
      idleSet.aaNoRepeatFlag = true;
    }
  };
  // * Загрузка состояний анимации
  _.refreshAnimaXABSStates = function(animaXProfile) {
    var animaXStateBattle, animaXStateDead;
    animaXStateBattle = XAnimaTools.getXAnimaParamsForState('inBattle', animaXProfile);
    this.registerAnimaXState('inBattle', animaXStateBattle);
    animaXStateDead = XAnimaTools.getXAnimaParamsForState('dead', animaXProfile);
    if (animaXStateDead != null) {
      this.registerAnimaXState('dead', animaXStateDead);
    }
  };
  _._aaOnGoInDeadAnimaXState = function() {
    var e;
    try {
      if (!this.isHaveAnimaXState('dead')) {
        return;
      }
      if (this._axState !== "dead") {
        this.switchToXAnimaState('dead');
      }
      if (AA.Network.isNetworkGame() && this === $gamePlayer) {
        AANetworkManager.animaXChangeState('dead', this);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  
  //@[ALIAS]
  ALIAS__isHaveAnimaXState = _.isHaveAnimaXState;
  _.isHaveAnimaXState = function() {
    if (this._axStates == null) {
      this._axStates = {};
    }
    return ALIAS__isHaveAnimaXState.call(this, ...arguments);
  };
  _.aaPlayAnimaXActionWithEndCallback = function(actionName, callback) {
    var e;
    try {
      if (!this.isAnimX()) {
        return;
      }
      this.__aaActionCallback = callback;
      return this.startAnimaXCustomAction(actionName, false, true);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //@[ALIAS]
  ALIAS__onAnimaXActionEnd = _.onAnimaXActionEnd;
  _.onAnimaXActionEnd = function() {
    var e;
    ALIAS__onAnimaXActionEnd.call(this, ...arguments);
    try {
      return this.aaExecuteAnimaXActionCalback();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaExecuteAnimaXActionCalback = function() {
    var e;
    try {
      if (this.__aaActionCallback == null) {
        return;
      }
      this.__aaActionCallback();
      return this.__aaActionCallback = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
});

// ■ END Game_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__attackSkillId, ALIAS__requestAnimation, _;
  if (AAUtils.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  //@[ALIAS]
  ALIAS__requestAnimation = _.requestAnimation;
  _.requestAnimation = function(animationId, isFromAA) {
    this.__aaIsRequestAnimationScale = isFromAA === true;
    ALIAS__requestAnimation.call(this, ...arguments);
  };
  
  //$[OVER]
  ALIAS__attackSkillId = _.attackSkillId;
  _.attackSkillId = function() {
    var e, set;
    try {
      set = this.traitsSet(Game_BattlerBase.TRAIT_ATTACK_SKILL);
      if (set.length > 0) {
        return Math.max(...set);
      } else {
        return ALIAS__attackSkillId.call(this, ...arguments);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return ALIAS__attackSkillId.call(this, ...arguments);
    }
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    // * Набор навыков с задержкой
    this.aaDelayedSkillActions = [];
    this.aaClearCharacterEffects();
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    this._aaUpdate();
  };
  (function() {    
    // * Диагональное движение
    // -----------------------------------------------------------------------
    var ALIAS__moveDiagonally, ALIAS__moveStraight, ALIAS__realMoveSpeed, ALIAS__setDirection;
    
    //@[ALIAS]
    ALIAS__realMoveSpeed = _.realMoveSpeed;
    _.realMoveSpeed = function() {
      var e, speed;
      speed = ALIAS__realMoveSpeed.call(this);
      try {
        if (this.isABS()) {
          speed *= this.aaSpeedMod();
        }
      } catch (error) {
        e = error;
        AA.w(e);
        speed = ALIAS__realMoveSpeed.call(this);
        this.aaSpeedMod = function() {
          return 1;
        };
      }
      if (this._diagonalDir) {
        return speed * AA.Input.diagonalSpeed;
      } else {
        return speed;
      }
    };
    //@[ALIAS]
    ALIAS__moveStraight = _.moveStraight;
    _.moveStraight = function(direction) {
      this._diagonalDir = false;
      return ALIAS__moveStraight.call(this, direction);
    };
    //@[ALIAS]
    ALIAS__setDirection = _.setDirection;
    _.setDirection = function(direction) {
      if (this._diagStraigten === true) {
        this._diagonalDir = false;
      }
      return ALIAS__setDirection.call(this, direction);
    };
    
    //@[ALIAS]
    ALIAS__moveDiagonally = _.moveDiagonally;
    _.moveDiagonally = function(horz, vert) {
      var diag, norm;
      if (this.aaIsThisCharCanUseDiagMovement()) {
        diag = this.canPassDiagonally(this._x, this._y, horz, vert);
        norm = this.canPass(this._x, this._y, horz) || this.canPass(this._x, this._y, vert);
        if (diag) {
          this._diagonalDir = AA.Utils.get4Dir(horz, vert);
          this._x = $gameMap.roundXWithDirection(this._x, horz);
          this._y = $gameMap.roundYWithDirection(this._y, vert);
          this._realX = $gameMap.xWithDirection(this._x, this.reverseDir(horz));
          this._realY = $gameMap.yWithDirection(this._y, this.reverseDir(vert));
          this.increaseSteps();
        } else if (norm) {
          this._diagonalDir = false;
          this.moveStraight(this.aaGetOtherDiagDirection(horz, vert));
        }
        this._diagStraigten = false;
        if (this._direction === this.reverseDir(horz)) {
          this.setDirection(horz);
        }
        if (this._direction === this.reverseDir(vert)) {
          this.setDirection(vert);
        }
        return this._diagStraigten = true;
      } else {
        return ALIAS__moveDiagonally.call(this, horz, vert);
      }
    };
  })();
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  _._aaUpdate = function() {
    var e;
    try {
      if (!this.isABS()) {
        return;
      }
      if (Imported.PKD_AnimaX) {
        this.aaUpdateABSAnimaX();
      }
      if (AA.isABSActive()) {
        return this.aaUpdateABS();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Для оптимизации, вынес параметр в общий метод класса
  Game_CharacterBase.aaColExt = function() {
    var e, v;
    if (Game_CharacterBase._aaColExtAA == null) {
      try {
        return 0.99;
      } catch (error) {
        e = error;
        AA.w(e);
        v = 0;
      }
      Game_CharacterBase._aaColExtAA = v;
    }
    return Game_CharacterBase._aaColExtAA;
  };
  if (!Imported.PKD_AnimaX) {
    _.isAnimX = function() {
      return false;
    };
  }
  (function() {    // * Общие методы ABS
    // -----------------------------------------------------------------------
    // * Основной метод, является ли персонаж вообще ABS объектом
    // * Тут НЕЛЬЗЯ добавлять доп. проверку на AA.isABSActive()
    _.isABS = function() {
      return this.AAEntity() != null;
    };
    _.AAEntity = function() {
      return this.aaEntity;
    };
    _.AAModel = function() {
      return null;
    };
    _.initABS = function() {
      var ref, ref1;
      if ((ref = this.aaEntity) != null) {
        ref.initABS();
      }
      if ((ref1 = this.AASprite()) != null) {
        ref1.initABS();
      }
    };
    // * Деактивировать АБС режим
    _.stopABS = function() {
      var ref;
      if ((ref = this.aaEntity) != null) {
        ref.deactivate();
      }
    };
    // * Полностью отключить (очистить) АБС режим у персонажа
    _.clearABS = function() {
      this.aaEntity = null;
      return this._aaClearExCollider();
    };
    _.AABattler = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.battler() : void 0;
    };
    _.AASprite = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.sprite() : void 0;
    };
    // * Логика АИ
    _.AALogic = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.logic() : void 0;
    };
    _.inBattle = function() {
      var ref;
      return (ref = this.AAEntity()) != null ? ref.inBattle() : void 0;
    };
    _.isActive = function() {
      var ref;
      return this.isABS() && ((ref = this.AAEntity()) != null ? ref.isActive() : void 0);
    };
    _.onTurnEnd = function() {};
    // * Данный персонаж не может принимать урон (Projectile пролетают через него)
    _.aaIsInvincible = function() {
      return false;
    };
    _.isMyEnemy = function(character) {
      if (!this.isABS()) {
        return false;
      }
      if (character == null) {
        return false;
      }
      if (!character.isABS()) {
        return false;
      }
      return this.AAEntity().isMyEnemy(character.AAEntity());
    };
    // * Логика АБС (только если АБС включена)
    _.aaUpdateABS = function() {
      var ref;
      this._aaUpdateDelayedSkillActions();
      this._aaUpdateTeleportRequest();
      if ((ref = this.AABattler()) != null) {
        ref.aaUpdateABS();
      }
      if (AA.Network.isNetworkGame()) {
        return this.aaUpdateForNetwork();
      }
    };
    _.aaUpdateForNetwork = function() {
      var ref;
      if (!ANGameManager.isMapMaster()) {
        return;
      }
      // * AABattler тут не обновляется, так как у Game_Actor он отдельно
      // * обновляется уже в Alpha NET Z по стандарту
      if ((ref = this.AAEntity()) != null) {
        ref.updateDataObserver();
      }
    };
    // * Специальный идентификатор персонажа на карте (0 - игрок, Х - номер события)
    _.aaCharId = function() {
      return -1;
    };
    _.aaDirection = function() {
      if (this._diagonalDir) {
        return this._diagonalDir;
      } else {
        return this.direction();
      }
    };
    return _.aaIsDodging = function() {
      return false;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Методы ABS (Бой и состояния)
    // -----------------------------------------------------------------------
    // * Когда какое-либо действие было выполненно на мне
    _.aaOnActionOnMe = function(action) {};
    // * Когда персонаж повержен
    // * Отличается от aaOnDeath так как тут надо давать бонусы победившему
    _.aaOnDefeat = function() {};
    // * Когда надо сменить состояние персонажа на Dead (вывести из АБС системы)
    _.aaOnDeath = function() {};
    // * Когда выходит из состояние смерти
    _.aaOnRevive = function() {};
    // * Эффект от навыка с параметром Impulse (сдвиг, толчок)
    _.aaIsCanMoveByImpulse = function() {
      return true;
    };
    _.aaApplyImpulse = function(power, dir, withJump, isReversed = false) {};
    _._aaUpdateTeleportRequest = function() {}; // * Game_Character_AA
    return _._aaOnTeleportPerformed = function() {};
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Эффекты спрайта (тряска и прочее)
    // -----------------------------------------------------------------------
    _.aaClearCharacterEffects = function() {
      // * Первое значение - время
      // * Второе значение DX (отклонение по X)
      this._aaShakeEffectData = [0, 0];
      // * [Запрос, массив данных для сохранения, флаг что надо создать части, DX, DY]
      //TODO: Сохранение не используется пока что
      this._aaShatterEffectData = [false, [], true, 0, 0];
    };
    _.aaMotionDX = function() {
      return this._aaShakeEffectData[1];
    };
    _.aaRequestShakeEffect = function(time = 10) {
      this._aaShakeEffectData[0] = time;
      return AANetworkManager.requestCharacterShakeEffect(this, time);
    };
    _.aaIsShakeRequested = function() {
      return this._aaShakeEffectData[0] > 0;
    };
    _.aaIsShatterRequested = function() {
      return this._aaShatterEffectData[0] === true;
    };
    _.aaRequestShatterEffect = function(dx = 0.5, dy = -4) {
      this._aaShatterEffectData = [true, [], true, dx, dy];
      AANetworkManager.requestCharacterShatterEffect(this, dx, dy);
    };
    _.aaOnShatterEffectCreated = function() {
      return this._aaShatterEffectData[0] = false;
    };
    _.aaIsSupportMotion = function() {
      return false;
    };
    _.aaIsMotionRequested = function() {
      return this.aaMotionType != null;
    };
    _.aaClearMotion = function() {
      this.aaMotionType = null;
      AANetworkManager.requestCharacterMotion(this, this.aaMotionType);
    };
    return _.aaRequestMotion = function(aaMotionType) {
      this.aaMotionType = aaMotionType;
      AANetworkManager.requestCharacterMotion(this, this.aaMotionType);
    };
  })();
  // -----------------------------------------------------------------------

  // * Добавляем метод canMove для всех персонажей
  // * В основном он нужен чтобы AAEntities не ходили во время XAnima
  _.canMove = function() {
    if (this.isAnimX()) {
      if (this.isAnimXIsBusy()) {
        // * Персонаж не может идти, если он выполняет действие анимации
        return false;
      }
    }
    if (AA.isABSMap()) {
      return this.AABattler().canMove();
    }
    return true;
  };
  // * Модификатор скорости движения (исп. в состояни)
  _.aaSpeedMod = function() {
    return this.AABattler().aaSpeedMod();
  };
  // * Позиция с учётом расширенных HitBox
  // * Реализован отдельный метод, так как HitBox учитывается только при поражении навыками
  _.posExt = function(x, y) {
    var d, extHitBoxes, l, r, u;
    //TODO: posExtCol не используется пока что при ExtendedHitBoxes
    if (this.aaIsHaveExtendedHitBoxes()) {
      extHitBoxes = this.aaGetExtendedHitBoxes();
      l = this.x - extHitBoxes[3];
      r = this.x + extHitBoxes[1];
      u = this.y - extHitBoxes[0];
      d = this.y + extHitBoxes[2];
      return l <= x && x <= r && u <= y && y <= d;
    } else {
      return this.posExtCol(x, y);
    }
  };
  // * Расширенная позиция, для расширения коллизий атак (прямым нажатием)
  _.posExtCol = function(x, y) {
    var isX, isY, v;
    v = Game_CharacterBase.aaColExt();
    isX = this._realX > x - v && this._realX < x + v;
    isY = this._realY > y - v && this._realY < y + v;
    return isX && isY;
  };
  // * Позиции X на экране, с учётом расширенных HitBox
  _.screenXExt = function() {
    var extHitBoxes, i, k, l, m, points, r, ref, ref1, tw, x;
    points = [this.screenX()]; // * базовая точка
    if (this.aaIsHaveExtendedHitBoxes()) {
      extHitBoxes = this.aaGetExtendedHitBoxes();
      r = extHitBoxes[1];
      l = extHitBoxes[3];
      tw = $gameMap.tileWidth();
      // * Точка права (если есть)
      if (r > 0) {
        for (i = k = 1, ref = r; (1 <= ref ? k <= ref : k >= ref); i = 1 <= ref ? ++k : --k) {
          x = $gameMap.adjustX(this._realX + i);
          x = Math.floor(x * tw + tw / 2);
          points.push(x);
        }
      }
      // * Точка слева (если есть)
      if (l > 0) {
        for (i = m = 1, ref1 = l; (1 <= ref1 ? m <= ref1 : m >= ref1); i = 1 <= ref1 ? ++m : --m) {
          x = $gameMap.adjustX(this._realX - i);
          x = Math.floor(x * tw + tw / 2);
          points.push(x);
        }
      }
    }
    return points;
  };
  // * Позиции Y на экране, с учётом расширенных HitBox
  _.screenYExt = function() {
    var d, extHitBoxes, i, k, m, points, ref, ref1, th, u, y;
    points = [this.screenY()]; // * базовая точка
    if (this.aaIsHaveExtendedHitBoxes()) {
      extHitBoxes = this.aaGetExtendedHitBoxes();
      u = extHitBoxes[0];
      d = extHitBoxes[2];
      th = $gameMap.tileHeight();
      // * Точка снизу (если есть)
      if (d > 0) {
        for (i = k = 1, ref = d; (1 <= ref ? k <= ref : k >= ref); i = 1 <= ref ? ++k : --k) {
          y = $gameMap.adjustY(this._realY + i);
          y = Math.floor(y * th + th - this.shiftY() - this.jumpHeight());
          points.push(y);
        }
      }
      // * Точка сверху (если есть)
      if (u > 0) {
        for (i = m = 1, ref1 = u; (1 <= ref1 ? m <= ref1 : m >= ref1); i = 1 <= ref1 ? ++m : --m) {
          y = $gameMap.adjustY(this._realY - i);
          y = Math.floor(y * th + th - this.shiftY() - this.jumpHeight());
          points.push(y);
        }
      }
    }
    return points;
  };
  // * Есть ли у персонажа расширенные HitBox для АБС навыков
  _.aaIsHaveExtendedHitBoxes = function() {
    return this.aaGetExtendedHitBoxes() != null;
  };
  // * У событий и персонажей своя реализация
  _.aaGetExtendedHitBoxes = function() {
    return null;
  };
  _.aaUpdateABSAnimaX = function() {}; // * EMPTY (Переопределяется в Game_Character_AnimaX)
  
  // * Дополнительный метод для сетевой игры
  // * Вызывается в AA.Network (через Alias метода Alpha NET Z)
  _.aaFillNetworkDataObserver = function() {
    var e;
    if (this.netDataObserver == null) {
      return;
    }
    try {

    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaIsThisCharCanUseDiagMovement = function() {
    return AA.Input.IsDiagonal === true;
  };
  _.distTo = function(point) {
    return $gameMap.distance(this.x, this.y, point.x, point.y);
  };
  // * Дистанция с учётом расширенной коллизии
  _.distToCol = function(point) {
    return ~~$gameMap.distance(this._realX, this._realY, point.x, point.y);
  };
  _.aaGetOtherDiagDirection = function(horz, vert) {
    if (this.canPass(this._x, this._y, horz)) {
      return horz;
    } else {
      return vert;
    }
  };
  // * Находится ли на Х расстоянии к точке
  _.aaIsNearThePoint = function(point, minDist = 1) {
    var e, sx, sy;
    try {
      sx = Math.abs(this.deltaXFrom(point.x));
      sy = Math.abs(this.deltaYFrom(point.y));
      return (sx + sy) <= minDist;
    } catch (error) {
      e = error;
      AA.w;
      return false;
    }
  };
  // * Повернуться к цели
  _.aaTurnTowardTarget = function() {
    var e, target;
    try {
      target = this.AAEntity().getTarget();
      if (target == null) {
        return;
      }
      return this.turnTowardCharacter(target);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Поиск пути (диагональное движение)
  _.aaFindDirectionToDiagonal = function(goalX, goalY) {
    var best, bestIndex, closedList, current, deltaX1, deltaX2, deltaY1, deltaY2, diag, direction, g1, g2, goaled, horz, i, index2, j, mapWidth, neighbor, node, nodeList, openList, pos1, pos2, searchLimit, start, vert, x1, x2, y1, y2;
    searchLimit = this.searchLimit();
    mapWidth = $gameMap.width();
    nodeList = [];
    openList = [];
    closedList = [];
    start = {};
    best = start;
    if (this.x === goalX && this.y === goalY) {
      return 0;
    }
    start.parent = null;
    start.x = this.x;
    start.y = this.y;
    start.g = 0;
    start.f = $gameMap.distance(start.x, start.y, goalX, goalY);
    nodeList.push(start);
    openList.push(start.y * mapWidth + start.x);
    while (nodeList.length > 0) {
      bestIndex = 0;
      i = 0;
      while (i < nodeList.length) {
        if (nodeList[i].f < nodeList[bestIndex].f) {
          bestIndex = i;
        }
        i++;
      }
      current = nodeList[bestIndex];
      x1 = current.x;
      y1 = current.y;
      pos1 = y1 * mapWidth + x1;
      g1 = current.g;
      nodeList.splice(bestIndex, 1);
      openList.splice(openList.indexOf(pos1), 1);
      closedList.push(pos1);
      if (current.x === goalX && current.y === goalY) {
        best = current;
        goaled = true;
        break;
      }
      if (g1 >= searchLimit) {
        continue;
      }
      j = 0;
      while (j < 9) {
        direction = 1 + j;
        if (direction === 5) {
          j++;
          continue;
        }
        diag = Math.abs(direction % 2) === 1;
        [horz, vert] = AA.Utils.get8Dir(direction);
        if (diag && this.canPassDiagonally(x1, y1, horz, vert) && (this.canPass(x1, y1, horz) || this.canPass(x1, y1, vert))) {
          x2 = $gameMap.roundXWithDirection(x1, horz);
          y2 = $gameMap.roundYWithDirection(y1, vert);
        } else if (this.canPass(x1, y1, direction)) {
          x2 = $gameMap.roundXWithDirection(x1, direction);
          y2 = $gameMap.roundYWithDirection(y1, direction);
        } else {
          j++;
          continue;
        }
        pos2 = y2 * mapWidth + x2;
        if (closedList.contains(pos2)) {
          j++;
          continue;
        }
        g2 = g1 + 1;
        index2 = openList.indexOf(pos2);
        if (index2 < 0 || g2 < nodeList[index2].g) {
          if (index2 >= 0) {
            neighbor = nodeList[index2];
          } else {
            neighbor = {};
            nodeList.push(neighbor);
            openList.push(pos2);
          }
          neighbor.parent = current;
          neighbor.x = x2;
          neighbor.y = y2;
          neighbor.g = g2;
          neighbor.f = g2 + $gameMap.distance(x2, y2, goalX, goalY);
          if (!best || neighbor.f - neighbor.g < best.f - best.g) {
            best = neighbor;
          }
        }
        j++;
      }
    }
    node = best;
    while (node.parent && node.parent !== start) {
      node = node.parent;
    }
    deltaX1 = $gameMap.deltaX(node.x, start.x);
    deltaY1 = $gameMap.deltaY(node.y, start.y);
    if (deltaY1 > 0 && deltaX1 > 0) {
      return 3;
    } else if (deltaY1 > 0 && deltaX1 < 0) {
      return 1;
    } else if (deltaY1 < 0 && deltaX1 < 0) {
      return 7;
    } else if (deltaY1 < 0 && deltaX1 > 0) {
      return 9;
    }
    if (deltaY1 > 0) {
      return 2;
    } else if (deltaX1 < 0) {
      return 4;
    } else if (deltaX1 > 0) {
      return 6;
    } else if (deltaY1 < 0) {
      return 8;
    }
    deltaX2 = this.deltaXFrom(goalX);
    deltaY2 = this.deltaYFrom(goalY);
    if (Math.abs(deltaX2) > Math.abs(deltaY2)) {
      if (deltaX2 > 0) {
        return 4;
      } else {
        return 6;
      }
    } else if (deltaY2 !== 0) {
      if (deltaY2 > 0) {
        return 8;
      } else {
        return 2;
      }
    }
    return 0;
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__isCollidedWithEvents, ALIAS__list, ALIAS__searchLimit, ALIAS__setPosition, ALIAS__updateSelfMovement, _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this.aaInitExtraParams();
  };
  //@[ALIAS]
  //@_aaFindDirCallCount = 0
  ALIAS__isCollidedWithEvents = _.isCollidedWithEvents;
  _.isCollidedWithEvents = function(x, y) {
    var events;
    // * АИ не учитывает события, которые выше или ниже по приоритету
    if (this.isABS()) {
      // * Собираем события в точке X, Y, которые с Normal Priority
      events = $gameMap.eventsXyNt(x, y).filter(function(ev) {
        return ev.isNormalPriority();
      });
      if (events.length <= 0) {
        // * Если таковых нет, то проходим (ниже и выше не учитываем)
        return false;
      }
      return this.isNormalPriority(); // * Если есть, то TRUE, если это событие тоже Normal Priority
    } else {
      return ALIAS__isCollidedWithEvents.call(this, x, y);
    }
  };
  
  //@[ALIAS]
  ALIAS__updateSelfMovement = _.updateSelfMovement;
  _.updateSelfMovement = function() {
    if (this.isABS() && !this.canMove()) {
      return;
    }
    if (this._moveType > 3) {
      if (!this._locked) {
        return this.aaUpdateAIMovement();
      }
    } else {
      return ALIAS__updateSelfMovement.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__searchLimit = _.searchLimit;
  _.searchLimit = function() {
    if (this.isABS() && this.aaIsNearToTarget()) {
      return 6;
    }
    return ALIAS__searchLimit.call(this, ...arguments);
  };
  //@[ALIAS]
  ALIAS__setPosition = _.setPosition;
  _.setPosition = function() {
    ALIAS__setPosition.call(this, ...arguments);
    if (this.isABS()) {
      // * Если мы перемещаем событие, то обновляем его "дом" точку
      return this.aaStoreHomePoint();
    }
  };
  (function() {})();  // * Система анимации XAnima
  // -----------------------------------------------------------------------
  (function() {    // -----------------------------------------------------------------------

    // * Система AAEntity
    // -----------------------------------------------------------------------
    var ALIAS__clearPageSettings, ALIAS__setupPage;
    //@[ALIAS]
    ALIAS__setupPage = _.setupPage;
    _.setupPage = function() {
      // * Сбрасываем профиль
      this._currentAnimaXProfile = null;
      ALIAS__setupPage.call(this);
      this.aaCheckABSEventState();
      this.aaCheckExtraParams();
    };
    //@[ALIAS]
    ALIAS__clearPageSettings = _.clearPageSettings;
    _.clearPageSettings = function() {
      ALIAS__clearPageSettings.call(this);
      if (this.isABS()) {
        return this.clearABS();
      }
    };
  })();
  // -----------------------------------------------------------------------

  //@[ALIAS]
  ALIAS__list = _.list;
  _.list = function() {
    var e, t;
    try {
      // * Вызов общего события, которое было bind к этому событию (SActions)
      if (this._aaExtraEventList != null) {
        t = this._aaExtraEventList;
        // * Один раз, поэтому зануляем
        this._aaExtraEventList = null;
        return [
          {
            // * Команда "Вызов Общего события" внутри этого события
            // * (Так можно использовать this. и есть _eventId)
            code: 117,
            indent: 0,
            parameters: [t]
          }
        ];
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return ALIAS__list.call(this);
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Game_Event.prototype;
    //@[ALIAS]
    const ALIAS__updateSelfMovement = _.updateSelfMovement;
    _.updateSelfMovement = function (...args) {
        let t = this;
        //TODO: Only if ABS and in state!!!
        /*if(AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            if(AACharMovementController.processMovementFor(this)) {
                return;
            }
        }*/
        ALIAS__updateSelfMovement.call(this, ...args);
    };
    //@[ALIAS]
    const ALIAS__erase = _.erase;
    _.erase = function (...args) {
        let t = this;
        ALIAS__erase.call(this, ...args);
        try {
            AAHitBox.clearFor(t);
            AACharCollider.clearFor(t);
            AACharInteractionArea.clearFor(t);
        }
        catch (error) {
            console.warn(error);
        }
    };
    //@[ALIAS]
    const ALIAS__setupPage = _.setupPage;
    _.setupPage = function (...args) {
        let t = this;
        ALIAS__setupPage.call(this, ...args);
        try {
            //TODO: Create common manger for events
            AAHitBox.setupForEventFromCurrentPage(t);
            AACharCollider.setupForEventFromCurrentPage(t);
            AACharInteractionArea.setupForEventFromCurrentPage(t);
            AAEventsProjectilesInteractions.setupProjectileInteractionsFor(t);
        }
        catch (error) {
            console.warn(error);
        }
    };
})();
// ■ END Game_Event.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  //@[EVENT]
  _.gev_onABSPaused = function() {
    var e, ref;
    try {
      try {
        if ((ref = this.AABattler()) != null) {
          ref.gev_onABSPaused();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      if (this.AALogic() == null) {
        return;
      }
      if (!this.AALogic().isFreeState()) {
        return this.AALogic().switchToFreeState();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  (function() {    // * Система AAEntity
    // -----------------------------------------------------------------------
    // * Когда мы переключили страницу события, надо пересоздать Battler и активировать АБС
    _.aaIsShouldBeReActivated = function() {
      return this.isABS() && (this.AABattler() == null);
    };
    _.aaCheckABSEventState = function() {
      if (this.aaIsABSEventPage()) {
        //TODO: Проверить переключение с АБС на АБС событие
        return this._initMembersABS();
      } else {
        if (this.isABS()) {
          // * Если переключили страницу, но событие было АИ, то надо отключить
          this.clearABS();
        }
      }
    };
    _.aaIsABSEventPage = function() {
      var ABSComment, e, enemyId;
      try {
        if (this.event() == null) {
          return false;
        }
        if (this.page() == null) {
          return false;
        }
        // * Для сохранения производительности, сперва просто смотрим есть ли ABS комментарий
        ABSComment = KDCore.Utils.getEventCommentValue("ABS", this.list());
        if ((ABSComment != null) && (ABSComment.match(/<ABS:\s*\d+>/) != null)) {
          // * Дополнительная проверка, что указан правильный ID
          enemyId = AAParametersParser.getABSEnemyId(ABSComment);
          if (enemyId > 0) {
            if (($dataEnemies[enemyId] != null) && String.any($dataEnemies[enemyId].name)) {
              // * Данный объект хранится даже после переключения страницы на НЕ АБС
              this.aaEventSettings = new AAEventSettingsParser(this.list());
              //console.info @aaEventSettings
              return true;
            } else {
              AA.w("Enemy ID " + enemyId + " not exists in DB or not have a name");
            }
          } else {
            AA.w("Can't read Enemy ID from <ABS> comment for event " + this.eventId());
          }
        }
        return false;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    _._initMembersABS = function() {
      this.aaEntity = new AAEnemyEntity(this.eventId());
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Основная логика АБС
    // -----------------------------------------------------------------------
    var ALIAS__aaOnActionOnMe, ALIAS__aaOnDeath, ALIAS__aaOnDefeat, ALIAS__aaOnShatterEffectCreated, ALIAS__clearABS, ALIAS__erase, ALIAS__initABS, ALIAS__isActive, ALIAS_aaUpdateABS;
    _.aaCharId = function() {
      return this.eventId();
    };
    // * Этот метод выполняется из отдельного потока для логики АИ
    //$[OUTER]
    _.aaUpdateAILogic = function() {
      var e;
      try {
        if (this.isActive()) {
          if (AA.isABSActive()) {
            return this.AALogic().update();
          }
        } else {
          return $gameTemp.aaClearAILogicThread(this.eventId());
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    //@[ALIAS]
    ALIAS__initABS = _.initABS;
    _.initABS = function() {
      ALIAS__initABS.call(this);
      this.aaStoreMoveData();
      this._aaLastMovingActionDelay = 0;
      $gameTemp.aaRegisterAILogicThread(this.eventId());
      this._aaInitParallelUserActions();
    };
    _._aaInitParallelUserActions = function() {
      var e, model;
      try {
        model = this.AAModel();
        if (AAScriptActions.isProper(this.AAModel().turnAction) || AAScriptActions.isProper(this.AAModel().turnActionInBattle)) {
          this._aaParallelActionTick = 0;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.aaClearParallelUserActions();
      }
    };
    //@[ALIAS]
    ALIAS__clearABS = _.clearABS;
    _.clearABS = function() {
      ALIAS__clearABS.call(this);
      $gameTemp.aaClearAILogicThread(this.eventId());
      this.aaClearParallelUserActions();
    };
    _.aaClearParallelUserActions = function() {
      return this._aaParallelActionTick = -1;
    };
    //@[ALIAS]
    ALIAS__isActive = _.isActive;
    _.isActive = function() {
      return ALIAS__isActive.call(this) && !this._erased;
    };
    // * Этот метод работает только когда АБС активна
    //@[ALIAS]
    ALIAS_aaUpdateABS = _.aaUpdateABS;
    _.aaUpdateABS = function() {
      ALIAS_aaUpdateABS.call(this);
      this._aaUpdateDeadState();
      if (this._aaParallelActionTick >= 0) {
        this._aaUpdateParallelUserActions();
      }
    };
    //@[ALIAS]
    ALIAS__aaOnShatterEffectCreated = _.aaOnShatterEffectCreated;
    _.aaOnShatterEffectCreated = function() {
      ALIAS__aaOnShatterEffectCreated.call(this);
      if (!this.isABS()) {
        return;
      }
      this.aaOnDefeat();
    };
    //@[ALIAS]
    ALIAS__erase = _.erase;
    _.erase = function() {
      if (this.isABS()) {
        this.setPriorityType(0); // * Below Characters
      }
      this._aaEraseAnimaXPartsForEvent();
      ALIAS__erase.call(this);
    };
    _._aaEraseAnimaXPartsForEvent = function() {
      var e, spr;
      try {
        if (Imported.PKD_AnimaX !== true) {
          return;
        }
        if (this.AASprite() == null) {
          return;
        }
        spr = this.AASprite();
        if (spr._animaXParts != null) {
          return spr._destroyAnimaXParts(); // * Если есть части
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    //@[ALIAS]
    ALIAS__aaOnDefeat = _.aaOnDefeat;
    _.aaOnDefeat = function() {
      ALIAS__aaOnDefeat.call(this);
      if (this.aaInSkillCastingProcess()) {
        this.aaAbortSkillCastingProcess();
      }
      if (this.AAModel().lootDropOnDeath === 1) {
        this.aaExecuteEnemyLootVisualDrop();
      }
      this.aaOnDeath();
    };
    // * Данный метод работает только при PKD_ExtendedLoot
    _.aaExecuteEnemyLootVisualDrop = function() {
      var e, gold, goldItem, i, item, items, len;
      try {
        if (!Imported.PKD_ExtendedLoot) {
          return;
        }
        if (!AAUtils.isSceneMap()) {
          return;
        }
        items = this.AABattler().makeDropItems();
        $gameTemp._pelLastGainEventId = this.eventId();
        if (items.length > 0) {
          for (i = 0, len = items.length; i < len; i++) {
            item = items[i];
            if (item == null) {
              continue;
            }
            //TODO: Переделать под новый метод в Extended Loot
            // * Используем другой метод, чтобы обойти, если опция VisualDrop выключена
            //$gameParty.pelMakeVisualDrop(item, 1)
            SceneManager._scene.pCreateVisualDropItem($gameTemp._pelLastGainEventId, item, 1);
          }
        }
        gold = this.AABattler().gold();
        if ($gameParty.hasGoldDouble()) {
          gold *= 2;
        }
        if (gold >= 1) {
          goldItem = $dataItems[PKD_ExtendedLoot.PP.goldItemId()];
          //$gameParty.pelMakeVisualDrop(goldItem, gold) if goldItem?
          SceneManager._scene.pCreateVisualDropItem($gameTemp._pelLastGainEventId, goldItem, gold);
        }
        // * Это обязательно, чтобы при подборе не повторился Visual Drop
        return $gameTemp._pelLastGainEventId = -1;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    //@[ALIAS]
    ALIAS__aaOnDeath = _.aaOnDeath;
    _.aaOnDeath = function() {
      var model;
      ALIAS__aaOnDeath.call(this);
      if (Imported.PKD_AnimaX === true && this.isAnimX()) {
        this.clearXAnimParts();
      }
      model = this.AAModel();
      if (model.isHaveDeadSwitch()) {
        // * Включаем self.switch
        AAScriptActions.execute("ss_" + model.deadSwitch + "_true", this);
      } else {
        if (model.eraseOnDead === 1) {
          this.erase();
          // * Только Erase синхронизируется, onDeathAction нет в данном методе
          // * SA синхронизируются отдельно
          AANetworkManager.executeEraseOnDeadAAEvent(this.eventId());
        }
      }
      if (model.isHaveOnDeathAction()) {
        AAScriptActions.execute(model.onDeath, this);
      }
      if (model.isHaveOnDeathVariable()) {
        KDCore.Utils.addToVar(model.onDeathVar, 1);
      }
    };
    //@[ALIAS]
    //TODO: Что делать с xAnimaDead ???
    ALIAS__aaOnActionOnMe = _.aaOnActionOnMe;
    _.aaOnActionOnMe = function(action) {
      var result;
      ALIAS__aaOnActionOnMe.call(this, action);
      result = this.AABattler().result();
      if (result == null) {
        return;
      }
      //TODO: model paramter or skill parameter (shake str)
      //%[I] Система смены цели в зависимости от полученного урона
      if (result.isHit() && result.hpDamage > 0) {
        if (this.aaInSkillCastingProcess()) {
          this.aaOnEventWhileCasting('hit');
        }
        this.aaRequestShakeEffect();
        AAScriptActions.execute(this.AAModel().onHit, this);
        if (this.AABattler().isAlive()) {
          if (action.isPlayerActionOwner()) {
            this.aaSetPartyAIOnPlayerAttackFlag();
          }
          this.aaCheckBattleStartInitiation(action);
        }
      }
      if (!this.AABattler().isAlive()) {
        this.aaOnKilledBy(action);
      }
    };
    // * Данный метод проверет, стоит ли врагу "агриться" на того кто ему нанёс урон
    // * Сейчас это работает для не агресивных врагов
    _.aaCheckBattleStartInitiation = function(action) {
      var char, e, subject;
      try {
        subject = action.subject();
        char = subject.AACharacter();
        if ((char != null) && this.isMyEnemy(char)) {
          //TODO: Some agro state, or check is current target is valid for now (like in AABS)
          if (this.AALogic().isBattleState()) {
            if (Math.random() > 0.55) {
              this.AAEntity().setTarget(char);
              return this.aaOnTargetChanged();
            }
          } else {
            // * We checked that we not in Battle State, so we directly use state 0
            return this.AALogic().getStateFlow(0).tryStartFightWithTarget(char);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaSetPartyAIOnPlayerAttackFlag = function() {
      if (!$gamePlayer.aaIsHaveAnyABSFollower()) {
        return;
      }
      $gameTemp._aaPartyAI_flag_playerAttackSomeone = this.eventId();
      // * Убираем флаг через время
      setTimeout((function() {
        return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._aaPartyAI_flag_playerAttackSomeone = null : void 0;
      }), 1000);
    };
    _.aaOnKilledBy = function(action) {
      var e;
      try {
        if (action.isPlayerTeamOwner()) {
          if (this.AAModel().autoExp === 1) {
            // * Если Exp Pop Up должен появляться над "дающим" опыт врагом
            $gameTemp.__aaExpGiver = this;
            $gameTemp.__aaExpReceiver = action.subject();
            uAPI.gainExpForEnemyEv(this.eventId());
            console.log($gameTemp.__aaExpReceiver);
            // * Надо обнулять сразу
            $gameTemp.__aaExpGiver = null;
            $gameTemp.__aaExpReceiver = null;
          }
          if (this.AAModel().isHaveAfterDeathBonus()) {
            return uAPI.spawnFlyingBonus(this.eventId(), this.AAModel().bonusOnDeadIds);
          }
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    _._aaUpdateDeadState = function() {
      if (this.isActive() && !this.AABattler().isAlive()) {
        // * Отключаем АБС для этого события
        this.stopABS();
        // * Если параметр включён, запускаем эффект
        if (this.AAModel().shatterEffect === 1) {
          this.aaRequestShatterEffect(); // * Иначе сразу
        } else {
          this.aaOnDefeat();
        }
      }
    };
    // * Обработка параллельный пользовательских действий (из Model)
    _._aaUpdateParallelUserActions = function() {
      var e, model;
      try {
        // * Используется обычный таймер, а не KDCore.TimedUpdate, чтобы сохранялось
        // * и загружалось
        this._aaParallelActionTick++;
        if (this._aaParallelActionTick >= 60) {
          this._aaParallelActionTick = 0;
          model = this.AAModel();
          AAScriptActions.execute(model.turnAction, this);
          if (this.inBattle()) {
            AAScriptActions.execute(model.turnActionInBattle, this);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.aaClearParallelUserActions();
      }
    };
    _._aaIsInBattleAnimaXState = function() {
      return this.AAEntity().inBattle();
    };
    _.aaIsCanMoveByImpulse = function() {
      return this.isABS() && !this.AAModel().isHeavy();
    };
    _.aaIsNearToTarget = function() {
      var dist, e, target;
      try {
        target = this.AAEntity().getTarget();
        if (target == null) {
          return false;
        }
        dist = this.distTo(target);
        if (dist >= 2) {
          return false;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnTargetChanged = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Дополнительные возможности АБС события
    // -----------------------------------------------------------------------
    // * Запускает общее события внутри данного события (т.е. внутри себя вызов общего)
    // * Это позволяет использовать this. и менять АБС параметры события
    _.aaStartCommonEvent = function(ceId) {
      var commonEvent, e;
      try {
        this._aaExtraEventList = null;
        if (ceId <= 0) {
          return;
        }
        //"Call outer CE ".p(ceId)
        commonEvent = $dataCommonEvents[ceId];
        if (commonEvent == null) {
          return;
        }
        this._aaExtraEventList = ceId;
        // * Переключаем напрямую, без метода start(), так как не нужен Lock
        this._starting = true;
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    // * Было ли данное событие добалвено на карту динамически
    _.aaIsSpawned = function() {
      return false;
    };
    _.aaIsLabeledAs = function(label) {
      var e;
      try {
        return this.AAModel().label === label;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
  })();
  // -----------------------------------------------------------------------

  // * Для оптимизации игры, алгоритмы проверки окружён ли персонаж отключены на событии
  //$[OVER]
  _.aaInitNoPassFlagThread = function() {}; //*EMPTY
  
  //$[OVER]
  _.aaGetExtendedHitBoxes = function() {
    return this._aaExtendedHitBox;
  };
  //$[OVER]
  _.aaIsThisCharCanUseDiagMovement = function() {
    return AA.Input.IsDiagonalForAI === true;
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------
//TODO: СБРОС ЦЕЛИ
//TODO: ОФФСЕТ ДЛЯ ВЫБОРА
//TODO: МИНИ ХП БАР
// Также добавить управление ним во время игры (один из трёх типов)


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _.AAModel = function() {
    return this.AAEntity().model();
  };
  _.aaSmartPathRefreshTime = function() {
    var e, model;
    try {
      if (!this.isABS()) {
        return 30;
      }
      model = this.AAModel();
      if ((model != null) && (model.smartPathRefreshTime != null)) {
        return model.smartPathRefreshTime;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 30;
  };
  // * Изменить параметр AAModel у данного события
  _.aaChangeModelParam = function(paramName, newValue) {
    var e, model;
    try {
      if (!String.any(paramName)) {
        return;
      }
      model = this.AAModel();
      if (model == null) {
        return;
      }
      //log = "Model param: " + paramName + " changed to " + newValue
      //log.p()
      return model[paramName] = newValue;
    } catch (error) {
      // * Надо может какой то метод что параметры были изменены?
      //TODO: some refresh or _convertParameters? on onParamsChanged?
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _.aaIsAICanTeleportIn = function() {
    if (this.aaInSkillCastingProcess()) {
      return false;
    }
    return this.AAModel().isCanTeleportIn() && this.aaIsAIReadyForNextTeleport() && this.aaIsAITeleportInPointExists();
  };
  _.aaIsAICanTeleportOut = function() {
    if (this.aaInSkillCastingProcess()) {
      return false;
    }
    return this.AAModel().isCanTeleportOut() && this.aaIsAIReadyForNextTeleport() && this.aaIsAITeleportOutPointExists();
  };
  _.aaIsAIReadyForNextTeleport = function() {
    if (this._aaTeleportTimer == null) {
      this._aaTeleportTimer = 0;
    }
    this._aaTeleportTimer++;
    // * Если Delay между телепортами прошёл
    if (this._aaTeleportTimer >= this.AAModel().gTeleportDelay() / 60) {
      this._aaTeleportTimer = 0;
      if (!$gameTemp._aaIsTeleportIsBusy && KDCore.Utils.isChanceIsGood(this.AAModel().gTeleportRate())) {
        return true;
      }
    }
    return false;
  };
  // * Чтобы боты не телепортировались одновременно
  _.aaPrepareSafeTeleportForAI = function() {
    $gameTemp._aaIsTeleportIsBusy = true;
    setTimeout((function() {
      var e;
      try {
        return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._aaIsTeleportIsBusy = null : void 0;
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }), 500);
  };
  //TODO: Переделать, добавить проверку поиска пути к точке телепорта
  _.aaIsAITeleportInPointExists = function() {
    var candidatePoints, dist, e, target;
    this._aaLastTeleportPoint = null;
    target = this.AAEntity().getTarget();
    if (target == null) {
      return false;
    }
    dist = this.distTo(target);
    if (dist <= 1) {
      return false;
    }
    if (dist > this.AAModel().gTeleportDistIn()) {
      return false;
    }
    try {
      candidatePoints = AA.Utils.Math.getAdjacentPoints(target.x, target.y);
      if ((candidatePoints != null) && candidatePoints.length > 0) {
        this._aaLastTeleportPoint = this.aaFilterProperTeleportPoint(candidatePoints);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaLastTeleportPoint = null;
    }
    return this._aaLastTeleportPoint != null;
  };
  _.aaFilterProperTeleportPoint = function(points) {
    var e, goodPoints, i, len, p;
    try {
      goodPoints = [];
      for (i = 0, len = points.length; i < len; i++) {
        p = points[i];
        if (this.canPass(p.x, p.y, this.direction()) && (p.x !== this.x && p.y !== this.y)) {
          goodPoints.push(p);
        }
      }
      if (goodPoints.length > 0) {
        return goodPoints.sample();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.aaIsAITeleportOutPointExists = function() {
    var candidatePoints, dist, e, outDist, target;
    this._aaLastTeleportPoint = null;
    target = this.AAEntity().getTarget();
    if (target == null) {
      return false;
    }
    dist = this.distTo(target);
    outDist = this.AAModel().gTeleportDistOut();
    if (dist > outDist) {
      return false;
    }
    try {
      candidatePoints = AA.Utils.Math.getPointsOutRadius(this.x, this.y, outDist);
      if ((candidatePoints != null) && candidatePoints.length > 0) {
        this._aaLastTeleportPoint = this.aaFilterProperTeleportPoint(candidatePoints);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaLastTeleportPoint = null;
    }
    return this._aaLastTeleportPoint != null;
  };
  _.aaMoveTypeTeleportToTarget = function() {
    var e;
    try {
      if (this.aaIsAICanTeleportIn()) {
        return this.aaPerformAITeleport();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaPerformAITeleport = function() {
    var e, teleportEndAnim, teleportStartAnim, x, y;
    try {
      if (this._aaLastTeleportPoint == null) {
        return;
      }
      this.aaPrepareSafeTeleportForAI();
      ({x, y} = this._aaLastTeleportPoint);
      ({teleportStartAnim, teleportEndAnim} = this.AAModel());
      this.aaTeleport({x, y}, teleportStartAnim, teleportEndAnim);
      return this._aaLastTeleportPoint = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaMoveTypeTeleportFromTarget = function() {
    var e;
    try {
      if (this.aaIsAICanTeleportOut()) {
        return this.aaPerformAITeleport();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  
  //$[OVER]
  _._aaOnTeleportPerformed = function() {
    var e;
    if (!this.isABS()) {
      return;
    }
    try {
      return this.aaTurnTowardTarget();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Дополнительные параметры, которые расширяют возможности взаимодействия событий в АБС
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  // * При попадании Projectile в событие
  _.aaOnVectorHit = function(skillId) {
    var action, e, i, len, ref;
    if (!this.aaIsHaveVectorHitAction(skillId)) {
      // * Если нет для skillId ничего, то смотрим общие - 0
      skillId = 0;
      if (!this.aaIsHaveVectorHitAction(0)) {
        return;
      }
    }
    try {
      ref = this._aaMapSkillVectorHitActions[skillId];
      for (i = 0, len = ref.length; i < len; i++) {
        action = ref[i];
        AAScriptActions.execute(action, this);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Блокирует ли данное событие Visor
  _.aaIsBlockVision = function() {
    return this._aaNoVisionPass === true;
  };
  // * Есть ли действие при попадании конкретного Vector?
  _.aaIsHaveVectorHitAction = function(skillId) {
    var actions;
    if (this._aaMapSkillVectorHitActions == null) {
      return false;
    }
    actions = this._aaMapSkillVectorHitActions[skillId];
    return (actions != null) && !actions.isEmpty();
  };
  // * Если ли флаг блокировки спавна у этого события
  _.aaIsHaveSpawnBlockFlag = function() {
    return this._aaBlockSpawnRadius > 0;
  };
  // * Инициализация расширенных параметров события
  _.aaInitExtraParams = function() {
    this._aaMapSkillVectorBlockList = null;
    this._aaMapSkillVectorHitActions = null;
    this._aaMapSkillVectorOffset = 0;
    this._aaExtendedHitBox = null;
    this._aaNoVisionPass = false;
    this._aaBlockSpawnRadius = 0;
    this._aaSpawnPointConfig = null;
    this._aaSpawnPointStep = 0;
    this._aaSpawnPointSpawnedCount = 0;
    this._aaLocatorConfig = null;
  };
  // * Проверка дополнительных параметров, которые могут касаться не только АА но и всех событий
  _.aaCheckExtraParams = function() {
    this.aaInitExtraParams();
    if (this.page() == null) {
      return;
    }
    this._aaExtractVectorOffsetParam();
    this._aaExtractVectorHitActions();
    this._aaExtractVectorBlockList();
    this._aaExtractExtendedHitBoxes();
    this._aaExtractNoVisionPass();
    this._aaExtractBlockSpawn();
    this._aaExtractSpawnPoint();
    this._aaExtractLocator();
  };
  // * Извлекает параметр смщенеия вектора для данного события
  // * Т.е. смещение начала графики, когда данное событие "выпускает" вектор из себя
  // * <vectorOffset:X>
  _._aaExtractVectorOffsetParam = function() {
    var e, param, svOffset;
    try {
      svOffset = KDCore.Utils.getEventCommentValue("vectorOffset", this.list());
      if (svOffset == null) {
        return;
      }
      param = AAParametersParser.extractABSParameter(svOffset);
      if (param != null) {
        return this._aaMapSkillVectorOffset = param[1];
      }
    } catch (error) {
      //console.info(@_aaMapSkillVectorOffset)
      e = error;
      return AA.warning(e);
    }
  };
  // * Извлекает все onVectorHit действия
  // * Пример: <onVectorHit_307:ss_A_true>
  // * Можно 0 - тогда будет для всех навыков (для любого) или просто onVectorHit:SA>
  _._aaExtractVectorHitActions = function() {
    var action, actionData, args, e, i, len, onHitActions, skillId;
    try {
      onHitActions = KDCore.Utils.getEventCommentValueArray("onVectorHit", this.list());
      if (onHitActions.isEmpty()) {
        return;
      }
      this._aaMapSkillVectorHitActions = {};
      for (i = 0, len = onHitActions.length; i < len; i++) {
        action = onHitActions[i];
        try {
          actionData = AAParametersParser.extractABSParameterAny(action);
          args = actionData[0].split("_");
          if (args.length > 1) {
            skillId = parseInt(args[1]);
          } else {
            skillId = 0; // * any
          }
          this._aaRegisterOnHitActionForSkill(skillId, actionData[1]);
        } catch (error) {
          e = error;
          AA.warning(e);
        }
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  // * Регестрирует SAction для навыка skillId при OnVectorHit
  _._aaRegisterOnHitActionForSkill = function(skillId, actionString) {
    var e;
    try {
      if (this._aaMapSkillVectorHitActions[skillId] == null) {
        this._aaMapSkillVectorHitActions[skillId] = [];
      }
      this._aaMapSkillVectorHitActions[skillId].push(actionString);
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  // * Извлекает список ID навыков, которые блокирет данное событие
  // * <vectorBlock:no> - ничего не блокирует
  // * <vectorBlock:all> - всё блокирует (по умолчанию)
  // * <vectorBlock: 301, 302> - НЕ блокирует 301 и 302 навыки
  _._aaExtractVectorBlockList = function() {
    var e, param, vectorBlockList;
    try {
      vectorBlockList = KDCore.Utils.getEventCommentValue("vectorBlock", this.list());
      if (vectorBlockList == null) {
        return;
      }
      param = AAParametersParser.extractABSParameterAny(vectorBlockList);
      if (param[1] === "no") {
        this._aaMapSkillVectorBlockList = [];
      } else if (param[1] === "all") {
        this._aaMapSkillVectorBlockList = null;
      } else {
        this._aaMapSkillVectorBlockList = AAParametersParser.convertArrayFromParameter(param[1]);
      }
    } catch (error) {
      e = error;
      AA.warning(e);
    }
  };
  // * Расширенные границы коллизии события (учитывается только для АБС навыков)
  // * UP, RIGHT, DOWN, LEFT (по часовой)
  // * Пример: <extraHitBoxes:1,0,0,0> - расширение на 1 клетку вверх
  _._aaExtractExtendedHitBoxes = function() {
    var e, param, values;
    try {
      values = KDCore.Utils.getEventCommentValue("extraHitBoxes", this.list());
      if (values == null) {
        return;
      }
      param = AAParametersParser.extractABSParameterAny(values);
      this._aaExtendedHitBox = AAParametersParser.convertArrayFromParameter(param[1]);
    } catch (error) {
      e = error;
      AA.w(e);
      this._aaExtendedHitBox = null;
    }
  };
  // * Если есть этот комментарий, Visor АИ не может проходить через это событие
  // * <noVisionPass>
  //TODO: Добавить except ID событий (или врагов) как с vectorBlock
  //TODO: Т.е. только определённые враги могут видеть через этот объект
  _._aaExtractNoVisionPass = function() {
    var e, value;
    try {
      value = KDCore.Utils.getEventCommentValue("noVisionPass", this.list());
      // * Не важно какое значение, если есть комментарий, значит noVisionPass есть
      this._aaNoVisionPass = value != null;
    } catch (error) {
      e = error;
      AA.w(e);
      this._aaNoVisionPass = false;
    }
  };
  _._aaExtractBlockSpawn = function() {
    var e, value;
    try {
      value = KDCore.Utils.getEventCommentValue("disableSpawn", this.list());
      if (value == null) {
        return;
      }
      value = AAParametersParser.extractABSParameterAny(value);
      if (value != null) {
        this._aaBlockSpawnRadius = parseInt(value[1]);
      }
      if (this._aaBlockSpawnRadius > 0) {
        // * Для производительности, устанавливаем флаг на карте, что существует blockSpawn
        $gameMap.aaRegisterBlockSpawnEventExist();
      }
    } catch (error) {
      e = error;
      AA.w(e);
      this._aaBlockSpawnRadius = 0;
    }
  };
  // * Точка спавна, определяется только ID, а настройки берутся из параметров плагина
  // * <absSpawnPoint:ID>
  _._aaExtractSpawnPoint = function() {
    var e;
    try {
      this._aaSpawnPointConfig = AASpawnPointsManager.extractSpawnPointConfig(this);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaSpawnPointConfig = null;
    }
  };
  // * Локатор. Ищет персонажа в радиусе и активирует действие
  // * <absLocator:RADIUS, SERACH_EVENT_TYPE, CE_ID, LOOP>
  // * SERACH_EVENT_TYPE:
  // * 0 - player
  // * X - teamId
  // * -1 - my team Id (only for AA events) OR any ABS event
  //TODO: Below is not implemented!
  // * -2 - any NOT ABS event
  // * -3 - any event (not abs || abs)
  // * -4 - all (any event + player)
  _._aaExtractLocator = function() {
    var e;
    try {
      return this._aaLocatorConfig = AAEventsLocatorsManager.extractLocatorConfig(this);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this._aaLocatorConfig = null;
    }
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__aaFillNetworkDataObserver, ALIAS__aaUpdateForNetwork, _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  //@[ALIAS]
  ALIAS__aaUpdateForNetwork = _.aaUpdateForNetwork;
  _.aaUpdateForNetwork = function() {
    var ref;
    ALIAS__aaUpdateForNetwork.call(this);
    if (!ANGameManager.isMapMaster()) {
      return;
    }
    if ((ref = this.AABattler()) != null) {
      ref._updateDataObserver();
    }
  };
  
  //@[ALIAS]
  ALIAS__aaFillNetworkDataObserver = _.aaFillNetworkDataObserver;
  _.aaFillNetworkDataObserver = function() {
    ALIAS__aaFillNetworkDataObserver.call(this);
    // * Будем хранить точку "дома", чтобы АИ
    // мог вернуться домой, даже если
    // мастер карты был сменён в бою
    this.aaResetHomePoint();
    this.netDataObserver.addFields(this, ["homePoint"]);
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------
//TODO: Помимо обновления раз в 1 секундку
// * Сделать так что когда приходит какой-либо Action
// * на событие, то ещё раз сразу обновить DataObserver 


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__chaseCharacter, ALIAS__initMembers, ALIAS__isActive, ALIAS__isGathered, ALIAS__isMoving, ALIAS__isVisible, ALIAS__moveSpeed, ALIAS__refresh, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  //@[ALIAS]
  ALIAS__isMoving = _.isMoving;
  _.isMoving = function() {
    var isMoving;
    isMoving = ALIAS__isMoving.call(this, ...arguments);
    if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
      if (AAPathMover.isHavePathFor(this)) {
        isMoving = true;
      }
      if (AAVectorMover.isShouldMoveByVector(this)) {
        isMoving = true;
      }
    }
    return isMoving;
  };
  //@[ALIAS]
  ALIAS__isGathered = _.isGathered;
  _.isGathered = function() {
    var v;
    v = ALIAS__isGathered.call(this, ...arguments);
    console.log("Game_Follower.isGathered", v);
    return v;
  };
  //@[ALIAS]
  ALIAS__isActive = _.isActive;
  _.isActive = function() {
    return ALIAS__isActive.call(this, ...arguments) && (this.actor() != null);
  };
  //@[ALIAS]
  ALIAS__isVisible = _.isVisible;
  _.isVisible = function() {
    var result;
    result = ALIAS__isVisible.call(this, ...arguments);
    if (this.isABS()) {
      return result && this.isActive() && !this.aaIsKilledNow();
    }
    return result;
  };
  
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this, ...arguments);
    this._moveType = 0;
    this._aaSetupInitialABSParameters();
  };
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this, ...arguments);
    setTimeout((() => {
      return this._aaRefreshABS();
    }), 200);
  };
  //@[ALIAS]
  ALIAS__chaseCharacter = _.chaseCharacter;
  _.chaseCharacter = function(character) {
    if (this.aaIsInBattleState() || this.aaIsInReturnState()) {

    } else {
      // * EMPTY
      if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
        this._chaseCharacterNew2(character);
      } else {
        //console.log("Game_Follower.chaseCharacter", character)
        ALIAS__chaseCharacter.call(this, ...arguments);
      }
      this._diagonalDir = false; // * Без этого персонаж дёргается при диагональном движении
    }
  };
  //TODO: Temporary solution for new chase character method
  //@[ALIAS]
  ALIAS__moveSpeed = _.moveSpeed;
  _.moveSpeed = function() {
    var x;
    x = ALIAS__moveSpeed.call(this, ...arguments);
    if (this.aaIsInBattleState() || this.aaIsInReturnState()) {
      return x;
    }
    if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
      return $gamePlayer.realMoveSpeed() - 1;
    }
    return x;
  };
  //TODO: Temporary solution for new chase character method
  _._chaseCharacterNew2 = function(character) {
    if (!this.isMoving()) {
      //this.setMoveSpeed($gamePlayer.realMoveSpeed() / 20)
      //console.log("Game_Follower.chaseCharacter", character)
      return AACharMovementController.chaseCharacter(this, character);
    }
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this, ...arguments);
    if (!this.isABS()) {
      return;
    }
    if (!AA.isABSActive()) {
      return;
    }
    if (!this.isActive()) {
      return;
    }
    if (this.aaIsKilledNow()) {
      return;
    }
    this.aaUpdateABS();
    if (this.aaIsInReturnState()) {
      this.aaUpdateReturnState();
    }
    if (this.aaIsInBattleState() || this.aaIsInReturnState()) {
      return;
    }
    if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
      if (AACharMovementController.processMovementFor(this)) {
        return;
      }
    }
  };
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__aaOnActionOnMe, ALIAS__aaOnDeath, ALIAS__aaOnDefeat, ALIAS__aaUpdateABS, ALIAS__clearABS, ALIAS__initABS, _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  _.AAModel = function() {
    return this.AAEntity().model();
  };
  _.aaCharId = function() {
    return this._memberIndex * -1;
  };
  _.actorId = function() {
    var e;
    try {
      if (this.actor() != null) {
        return this.actor().actorId();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return 0;
  };
  // * После смены сцены (если потеряли поток логики)
  _.aaIsShouldBeReActivated = function() {
    return this.isABS() && !$gameTemp.aaIsHaveAILogicThreadFor();
  };
  _.aaIsInBattleState = function() {
    return this._aaMainAIState === 1;
  };
  _.aaIsInReturnState = function() {
    return this._aaMainAIState === 2;
  };
  _.aaIsInFreeState = function() {
    return this._aaMainAIState === 0;
  };
  _.aaIsKilledNow = function() {
    return this._aaBeenKilled === true;
  };
  // * Этот метод вызывается для выхода из АИ логики и возвращения к игроку
  _.aaForceResetAILogicState = function() {
    this._aaChangeAllyAIMainStateTo(2);
  };
  // * Этот метод вызывается для выхода из АИ логики снова в обычного Follower
  _.aaForceStopAILogic = function() {
    var e;
    try {
      this._aaChangeAllyAIMainStateTo(0);
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  _.aaRefreshABSThread = function() {
    //TODO: PARTY UPD Нормельная система смерти!!!
    if (this.isABS() && this.aaIsKilledNow() === true && this.AABattler().isAlive()) {
      this.aaRevivePartyMember();
      return;
    }
    if (!$gameTemp.aaIsHaveAILogicThreadFor(this.aaCharId())) {
      $gameTemp.aaRegisterAILogicThread(this.aaCharId());
    }
  };
  _.aaRevivePartyMember = function() {
    var e;
    try {
      this._aaBeenKilled = false;
      this.initABS();
      this.AAEntity().activate();
      return this.refresh();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //@[EVENT]
  _.gev_onABSPaused = function() {
    var e, ref;
    try {
      try {
        if ((ref = this.AABattler()) != null) {
          ref.gev_onABSPaused();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      if (this.AALogic() == null) {
        return;
      }
      return this.aaForceStopAILogic();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  //@[ALIAS]
  ALIAS__initABS = _.initABS;
  _.initABS = function() {
    ALIAS__initABS.call(this);
    this._aaLastMovingActionDelay = 0;
    this.aaRefreshABSThread();
    this._aaInitParallelUserActions();
    if (AA.System.isExCollisionActive()) {
      this._initExCollForABS();
    }
  };
  _._aaInitParallelUserActions = function() {
    var e, model;
    try {
      model = this.AAModel();
      if (AAScriptActions.isProper(this.AAModel().turnAction) || AAScriptActions.isProper(this.AAModel().turnActionInBattle)) {
        this._aaParallelActionTick = 0;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.aaClearParallelUserActions();
    }
  };
  //@[ALIAS]
  ALIAS__clearABS = _.clearABS;
  _.clearABS = function() {
    ALIAS__clearABS.call(this);
    this.aaForceStopAILogic();
    $gameTemp.aaClearAILogicThread(this.aaCharId());
    this.aaClearParallelUserActions();
  };
  _.aaClearParallelUserActions = function() {
    return this._aaParallelActionTick = -1;
  };
  //@[ALIAS]
  ALIAS__aaUpdateABS = _.aaUpdateABS;
  _.aaUpdateABS = function() {
    ALIAS__aaUpdateABS.call(this, ...arguments);
    this._aaUpdateABSMoving();
    this._aaUpdateDeadState();
    if (this._aaParallelActionTick >= 0) {
      this._aaUpdateParallelUserActions();
    }
    if (!this.aaIsInBattleState()) {
      this._aaUpdateMainStateTransferThread();
    }
  };
  _._aaUpdateABSMoving = function() {
    if (!this.aaIsInBattleState()) {
      return;
    }
    if (!this.canMove()) {
      return;
    }
    this.aaUpdateAIMovement();
  };
  _._aaUpdateDeadState = function() {
    if (this.isActive() && !this.AABattler().isAlive()) {
      // * Отключаем АБС для этого события
      this.stopABS();
      this.aaOnDefeat();
    }
  };
  //@[ALIAS]
  ALIAS__aaOnDefeat = _.aaOnDefeat;
  _.aaOnDefeat = function() {
    ALIAS__aaOnDefeat.call(this, ...arguments);
    this.aaForceStopAILogic();
    this.aaOnDeath();
  };
  //@[ALIAS]
  ALIAS__aaOnDeath = _.aaOnDeath;
  _.aaOnDeath = function() {
    var model;
    ALIAS__aaOnDeath.call(this, ...arguments);
    if (Imported.PKD_AnimaX === true && this.isAnimX()) {
      this.clearXAnimParts();
    }
    model = this.AAModel();
    if (model.isHaveOnDeathAction()) {
      AAScriptActions.execute(model.onDeath, this);
    }
    if (model.isHaveOnDeathVariable()) {
      KDCore.Utils.addToVar(model.onDeathVar, 1);
    }
    //TODO: PARTY UPD Нормельная система смерти!!!
    this._aaBeenKilled = true;
    this.refresh();
    "ON DEATH AA AI".p();
  };
  // * Обработка параллельный пользовательских действий (из Model)
  _._aaUpdateParallelUserActions = function() {
    var e, model;
    try {
      // * Используется обычный таймер, а не KDCore.TimedUpdate, чтобы сохранялось
      // * и загружалось
      this._aaParallelActionTick++;
      if (this._aaParallelActionTick >= 60) {
        this._aaParallelActionTick = 0;
        model = this.AAModel();
        AAScriptActions.execute(model.turnAction, this);
        if (this.inBattle()) {
          AAScriptActions.execute(model.turnActionInBattle, this);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.aaClearParallelUserActions();
    }
  };
  //@[ALIAS]
  ALIAS__aaOnActionOnMe = _.aaOnActionOnMe;
  _.aaOnActionOnMe = function(action) {
    var result;
    ALIAS__aaOnActionOnMe.call(this, action);
    result = this.AABattler().result();
    if (result == null) {
      return;
    }
    if (result.isHit() && result.hpDamage > 0) {
      this.aaRequestShakeEffect();
      // * Если ещё живой, то будет onHit
      if (this.AABattler().isAlive()) {
        AAScriptActions.execute(this.AAModel().onHit, this);
        // * Для условия
        this._aaAllyGotDamage = true;
      }
    }
    if (!this.AABattler().isAlive()) {
      this.aaOnKilledBy(action);
    }
  };
  _._aaIsInBattleAnimaXState = function() {
    return this.AAEntity().inBattle();
  };
  _.aaIsCanMoveByImpulse = function() {
    var e;
    try {
      if (!this.isABS()) {
        return false;
      }
      if (this.AAModel().isHeavy()) {
        return false;
      }
      if (this.AABattler().aaIsEquippedInHeavyArmor()) {
        return false;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return true;
  };
  _.aaOnKilledBy = function(action) {};
  _.aaSmartPathRefreshTime = function() {
    return 10;
  };
  _._aaSetupInitialABSParameters = function() {
    // 0 - follower (ABS like OFF)
    // 1 - Battle (ABS controll)
    // 2 - Looting (not implemented)
    this._aaMainAIState = 0;
    this._aaMainStateTransferCheckTimer = 0;
  };
  _._aaUpdateMainStateTransferThread = function() {
    this._aaMainStateTransferCheckTimer++;
    if (this._aaMainStateTransferCheckTimer >= 30) {
      this._aaUpdateMainStateTransferConditions();
      this._aaMainStateTransferCheckTimer = 0;
    }
  };
  _._aaUpdateMainStateTransferConditions = function() {
    var conditions, e;
    conditions = this._aaConvertMainStateConditions(this.AAModel().getBattleStartConditions());
    this._aaClearConditionsTempFlags();
    try {
      //console.log conditions
      // * Проверяем все условия
      if (eval(conditions)) {
        this._aaChangeAllyAIMainStateTo(1);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      KDCore.warning("Check Ally AI battleConditionType");
      this.aaForceResetAILogicState();
      // * Force change to proper conditions
      this.AAModel().battleConditionType = "seeEnemy";
    }
  };
  _._aaClearConditionsTempFlags = function() {
    return this._aaAllyGotDamage = false;
  };
  _._aaConvertMainStateConditions = function(conditionString) {
    var e, i, item, len, method, ref;
    try {
      conditionString = conditionString.replaceAll('|', ' || ');
      conditionString = conditionString.replaceAll('&', ' && ');
      ref = ['seeEnemy', 'gotDamage', 'playerAction', 'playerGotDamage', 'playerInDanger', 'playerAttacksSomeone', 'condition'];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (conditionString.contains(item)) {
          method = this['_aaAICondition_' + item];
          if (method != null) {
            conditionString = conditionString.replace(item, method.call(this).toString());
          } else {
            conditionString = conditionString.replace(item, 'false');
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return "false";
    }
    return conditionString;
  };
  _._aaChangeAllyAIMainStateTo = function(newStateIndex) {
    if (this._aaMainAIState !== newStateIndex) {
      this._aaMainAIState = newStateIndex;
      this._aaOnAIMainStateChanged();
    }
  };
  _._aaOnAIMainStateChanged = function() {
    if (this.aaIsInBattleState()) {
      // * Переходим в режим поиска (выбора) цели
      this.AALogic().switchToFreeState();
    }
    console.log("STATE CHANGED to " + this._aaMainAIState);
    this.setThrough(this.aaIsInFreeState());
  };
  _._aaRefreshABS = function() {
    var e;
    try {
      //TODO: PARTY UPD Надо делать нормальную обработку ABS состояния в зависимости от Visible
      //TODO: PARTY UPD нормельная обработка смерти игрока
      if ($gamePlayer.AABattler() == null) {
        this.clearABS();
        return;
      }
      if (!$gamePlayer.AABattler().isAlive()) {
        this.clearABS();
        return;
      }
      if ((this.actor() != null) && this.actor().isSupportAIControl()) {
        if (this.aaEntity != null) {
          if (this.aaEntity.actorId !== this.actorId()) {
            return this._aaInitNewABSEntity();
          } else {

          }
        } else {
          // * NOTHING, same Actor
          return this._aaInitNewABSEntity();
        }
      } else {
        return this.clearABS();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaInitNewABSEntity = function() {
    if (this.isABS()) {
      this.clearABS();
    }
    this._aaBeenKilled = false;
    this.aaEntity = new AAAllyEntity(this.actorId());
    if (this.aaEntity.character() != null) {
      this.initABS();
    } else {
      KDCore.warning("Follower character not found on Game Map");
      this.clearABS();
    }
  };
  // * Этот метод выполняется из отдельного потока для логики АИ
  //$[OUTER]
  _.aaUpdateAILogic = function() {
    var e;
    try {
      if (!this.isVisible()) {
        return;
      }
      if (!this.aaIsInBattleState()) {
        return;
      }
      if (this.isActive()) {
        if (AA.isABSActive()) {
          return this.AALogic().update();
        }
      } else {
        return $gameTemp.aaClearAILogicThread(this.aaCharId());
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Точка (дом) союзника - это игрок
  //$[OVER]
  _.aaMoveTypeReturnToHomePoint = function() {
    var e;
    try {
      return this.aaMoveTypeToPoint($gamePlayer);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaUpdateReturnState = function() {
    if (!this.canMove()) {
      this.aaForceStopAILogic();
      return;
    }
    if (!this.isMoving()) {
      if (!this.aaIsNearThePoint($gamePlayer)) {
        this.aaMoveTypeReturnToHomePoint();
      } else {
        this.aaForceStopAILogic();
      }
    }
  };
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Follower.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Follower.prototype;
  // * Данный метод является только лишь условием, он только проверяет наличие целей, но
  // не устанавливает ни одну из них, т.к. для этого есть другие услвоия
  _._aaAICondition_seeEnemy = function() {
    var e, targetsAround;
    try {
      targetsAround = AATargetsManager.getAvailableTargetsInRadius(this, this.AAModel().gViewRadius());
      if ((targetsAround != null) && targetsAround.length > 0) {
        targetsAround = targetsAround.filter((t) => {
          return AAVisionManager.isVisionLineIsFree(this, t);
        });
        return targetsAround.length > 0;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _._aaAICondition_gotDamage = function() {
    return this._aaAllyGotDamage === true;
  };
  _._aaAICondition_playerGotDamage = function() {
    return $gameTemp._aaPartyAI_flag_playerGotDamage === true;
  };
  _._aaAICondition_playerInDanger = function() {
    return $gamePlayer._aaIsInBattleAnimaXState();
  };
  // * Алтернатива (но в методы выше этот же код, чтоыб два раза не выполнять)
  //playerEnemies =
  //    AATargetsManager.getAllWhoHavePlayerAsTargetInRange(@AAModel().gViewRadius())
  //return playerEnemies.length > 0
  _._aaAICondition_playerAttacksSomeone = function() {
    return $gameTemp._aaPartyAI_flag_playerAttackSomeone > 0;
  };
  _._aaAICondition_playerAction = function() {
    var certainId;
    certainId = this.AAModel().getCertainActionId();
    if (certainId > 0) {
      return $gameTemp._aaPartyAI_flag_playerMadeAction === certainId;
    } else {
      return $gameTemp._aaPartyAI_flag_playerMadeAction != null;
    }
  };
  _._aaAICondition_condition = function() {
    var condition, e;
    try {
      condition = this.AAModel().getBattleStartUserCondition();
      if (String.any(condition)) {
        condition = condition.replaceAll("a.", "this.AABattler().");
        condition = condition.replaceAll("b.", "$gamePlayer.AABattler().");
        return eval(condition);
      } else {
        // * Пустое условие всегда верно
        return true;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END Game_Follower.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Followers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__updateMove, _;
  //@[DEFINES]
  _ = Game_Followers.prototype;
  //@[ALIAS]
  ALIAS__updateMove = _.updateMove;
  _.updateMove = function() {
    var charToChase, i, j, ref, results;
    if ($gamePlayer.aaIsHaveAnyABSFollower()) {
      results = [];
      for (i = j = ref = this._data.length - 1; (ref <= 0 ? j <= 0 : j >= 0); i = ref <= 0 ? ++j : --j) {
        if (i > 0) {
          charToChase = this._data[i - 1];
          if ((charToChase != null) && charToChase.isABS() && charToChase.aaIsInBattleState()) {
            charToChase = $gamePlayer;
          }
        } else {
          charToChase = $gamePlayer;
        }
        results.push(this._data[i].chaseCharacter(charToChase));
      }
      return results;
    } else {
      return ALIAS__updateMove.call(this, ...arguments);
    }
  };
})();

// ■ END Game_Followers.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Followers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Followers.prototype;
  _.aaGetABSFollowers = function() {
    return this._data.filter(function(f) {
      return (f != null) && f.isABS() && f.isActive();
    });
  };
  _.aaGetABSFollowersAll = function() {
    return this._data.filter(function(f) {
      return (f != null) && f.isABS();
    });
  };
  _.aaGetABSFollowersXyAAExt = function(x, y) {
    return this.aaGetABSFollowers().filter(function(f) {
      return f.posExt(x, y);
    });
  };
  _.aaGetFollowerByActorId = function(actorId) {
    var e;
    try {
      return this._data.find(function(f) {
        return (f.actor() != null) && f.actorId() === actorId;
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.aaGetFollowerByCharId = function(charId) {
    var e;
    try {
      return this._data.find(function(f) {
        return (f.actor() != null) && f.aaCharId() === charId;
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
  _.aaRefreshABSMemebers = function() {
    var i, len, p, ref, results;
    ref = this.aaGetABSFollowersAll();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      p = ref[i];
      results.push(p.aaRefreshABSThread());
    }
    return results;
  };
  _.aaOnPlayerDeathEvent = function() {
    var e, i, len, p, ref, results;
    try {
      ref = this.aaGetABSFollowersAll();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        p = ref[i];
        results.push(p.refresh());
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaOnPlayerRevive = function() {
    var e, i, len, p, ref, results;
    try {
      ref = this._data;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        p = ref[i];
        // * We need Activate ABS again
        results.push(p.refresh());
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Followers.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__command126, ALIAS__command127, ALIAS__command128, ALIAS__command204, ALIAS__terminate, ALIAS__updateWaitMode, _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  //TODO: Вынести это в отдельный плагин
  //TODO: change GOLD and visual notify (command125)

  // * Показывает Notify только когда игрок получает предмет именно через команду, а не
  // * через игровой процесс (смена экипировки и т.д.)

  //@[ALIAS]
  ALIAS__command126 = _.command126;
  _.command126 = function() {
    var r;
    r = ALIAS__command126.call(this, ...arguments);
    $gameParty.pOnSomeItemBeenGained();
    return r;
  };
  //@[ALIAS]
  ALIAS__command127 = _.command127;
  _.command127 = function() {
    var r;
    r = ALIAS__command127.call(this, ...arguments);
    $gameParty.pOnSomeItemBeenGained();
    return r;
  };
  //@[ALIAS]
  ALIAS__command128 = _.command128;
  _.command128 = function() {
    var r;
    r = ALIAS__command128.call(this, ...arguments);
    $gameParty.pOnSomeItemBeenGained();
    return r;
  };
  //@[ALIAS]
  ALIAS__command204 = _.command204;
  _.command204 = function() {
    this.aaBlockMapMouseScroll();
    return ALIAS__command204.call(this, ...arguments);
  };
  
  //@[ALIAS]
  ALIAS__updateWaitMode = _.updateWaitMode;
  _.updateWaitMode = function() {
    this.aaCheckMapMouseScroll();
    return ALIAS__updateWaitMode.call(this, ...arguments);
  };
  
  //@[ALIAS]
  ALIAS__terminate = _.terminate;
  _.terminate = function() {
    ALIAS__terminate.call(this, ...arguments);
    this.aaResetMapMouseScrollBlock();
  };
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  (function() {    // * Управление АБС событиями
    // -----------------------------------------------------------------------
    _.aaBattler = function() {
      var e, ref;
      try {
        return (ref = this.aaEvent()) != null ? ref.AABattler() : void 0;
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return null;
    };
    _.aaEvent = function() {
      var char, e;
      try {
        if (this.eventId() <= 0) {
          return null;
        }
        char = $gameMap.event(this.eventId());
        if (char == null) {
          return null;
        }
        if (!char.isABS()) {
          return null;
        }
        return char;
      } catch (error) {
        e = error;
        AA.w(e);
        return null;
      }
    };
    // * Изменить параметр АА события (врага)
    _.aaChangeAIParam = function(paramName, newValue) {
      var char, e;
      try {
        char = this.aaEvent();
        return char != null ? char.aaChangeModelParam(paramName, newValue) : void 0;
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Выполнить SAction
    _.aaExecuteSAction = function(action) {
      var e;
      try {
        return uAPI.scriptAction(action, this, 0);
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
    // * Получить опыт с данного события "врага"
    _.aaGainExp = function() {
      var e;
      try {
        if (this.eventId() <= 0) {
          return;
        }
        uAPI.gainExpForEnemyEv(this.eventId());
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Скролл карты (решение проблем с командой события)
    // -----------------------------------------------------------------------
    _.aaBlockMapMouseScroll = function() {
      this._aaBlockScroll = true;
      $gameTemp.aaIsMapScrolledByEvent = true;
      if (KDCore.isMV() && AA.PP.getMapScrollingSettings().isEnabled === true) {
        this.setWaitMode('scroll');
      }
    };
    _.aaCheckMapMouseScroll = function() {
      if (!this._aaBlockScroll) {
        return;
      }
      if (this._waitMode === 'scroll' && !$gameMap.isScrolling()) {
        $gameTemp.aaIsMapScrolledByEvent = false;
        return this._aaBlockScroll = false;
      }
    };
    _.aaResetMapMouseScrollBlock = function() {
      if (this._aaBlockScroll === true) {
        return $gameTemp.aaIsMapScrolledByEvent = false;
      }
    };
  })();
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Game_Interpreter.prototype;
    _['setPlayerPosition'] = function (x, y) {
        try {
            $gamePlayer.setPosition(x, y);
        }
        catch (error) {
            console.warn(error);
        }
    };
    // Set Movement Route
    //@[ALIAS]
    const ALIAS__command205 = _.command205;
    //@ts-ignore
    _.command205 = function (params) {
        let charId = params[0];
        if (charId == -1 && AAMainSystem.isExtendedPlayerMovementSystemActive()) { // Player
            // * We should make sure that the player X and Y are aligned with the grid
            AACharMovementUtils.alignCharToGrid($gamePlayer, true);
        }
        return ALIAS__command205.call(this, params);
    };
})();
// ■ END Game_Interpreter.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__refresh, ALIAS__setup, _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function() {
    this.aaOnNewMapLoaded();
    ALIAS__setup.call(this, ...arguments);
    if (AA.System.isExCollisionActive()) {
      this.aaCreateColliders();
    }
  };
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    return this.initABSMembers();
  };
  
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this);
    return this.refreshABSMembers();
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Game_Map.prototype;
    //@[ALIAS]
    const ALIAS__setup = _.setup;
    _.setup = function (mapId) {
        AAMainGameLoopManager.onBeforeGameMapLeave(this._mapId);
        ALIAS__setup.call(this, mapId);
        AAMainGameLoopManager.onAfterGameMapSetup(mapId);
    };
})();
// ■ END Game_Map.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.aaEventWithColliders = function() {
    return this.events().filter(function(ev) {
      return ev.aaIsHaveExColliders();
    });
  };
  _.aaIsHaveExColliders = function() {
    return (this._aaExColliders != null) && this._aaExColliders.length > 0;
  };
  _.aaGetAllExColliders = function() {
    var e;
    try {
      if (!this.aaIsHaveExColliders()) {
        return [];
      }
      return this._aaExColliders;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _._aaClearExCollider = function() {
    var e;
    try {
      return this._aaExColliders = [];
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaCreateColliders = function() {
    var e;
    try {
      this.aaCreateTerrainTagsColliders();
      return this.aaCreateRegionColliders();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaCreateTerrainTagsColliders = function() {
    var config, configs, e, j, k, len, len1, p, ref, results, t, tag, tagsWithCollisions, terrainTagConfigs;
    try {
      terrainTagConfigs = [];
      tagsWithCollisions = terrainTagConfigs.map(function(i) {
        return i.terrainTag;
      });
      configs = {};
      for (j = 0, len = tagsWithCollisions.length; j < len; j++) {
        tag = tagsWithCollisions[j];
        config = terrainTagConfigs.getByField('terrainTag', tag);
        configs[tag] = config.colliderConfig;
        configs[tag].flag = 'terrain';
      }
      ref = this.aaGetAllPoints();
      results = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        p = ref[k];
        t = this.terrainTag(p.x, p.y);
        if (tagsWithCollisions.contains(t)) {
          results.push(this.aaAddExCollider(p, configs[t]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaCreateRegionColliders = function() {
    var config, configs, e, j, k, len, len1, p, r, ref, regionConfigs, regionId, regionsWithCollisions, results;
    try {
      regionConfigs = [];
      regionsWithCollisions = regionConfigs.map(function(i) {
        return i.regionId;
      });
      configs = {};
      for (j = 0, len = regionsWithCollisions.length; j < len; j++) {
        regionId = regionsWithCollisions[j];
        config = regionConfigs.getByField('regionId', regionId);
        configs[regionId] = config.colliderConfig;
        configs[regionId].flag = 'region';
      }
      ref = this.aaGetAllPoints();
      results = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        p = ref[k];
        r = this.regionId(p.x, p.y);
        if (regionsWithCollisions.contains(r)) {
          results.push(this.aaAddExCollider(p, configs[r]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaGetAllPoints = function() {
    var e, j, k, ref, ref1, x, y;
    try {
      if (this._aaAllMapPointsCache == null) {
        this._aaAllMapPointsCache = [];
        for (x = j = 0, ref = this.width(); (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
          for (y = k = 0, ref1 = this.height(); (0 <= ref1 ? k < ref1 : k > ref1); y = 0 <= ref1 ? ++k : --k) {
            this._aaAllMapPointsCache.push({x, y});
          }
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return this._aaAllMapPointsCache;
  };
  _.aaAddExCollider = function(point, config) {
    var col, e;
    try {
      if (config == null) {
        return;
      }
      col = new AACollider(config);
      if (col == null) {
        return;
      }
      col.setPositionXY(point.x, point.y);
      return this._aaExColliders.push(col);
    } catch (error) {
      //console.log("collider created " + config.flag)
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaGetExCollidersWithin = function(x, y, distance) {
    var candidats, col, e, j, len, ref;
    try {
      if (!this.aaIsHaveExColliders()) {
        return [];
      }
      candidats = [];
      distance *= distance;
      ref = this._aaExColliders;
      for (j = 0, len = ref.length; j < len; j++) {
        col = ref[j];
        if (AAMath.distanceQuickXY(x, y, col.x(), col.y()) <= distance) {
          candidats.push(col);
        }
      }
      return candidats;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _.aaGetEventCollidersWithin = function(x, y, distance) {
    var candidats, e, ev, j, len, ref;
    try {
      candidats = [];
      distance *= distance;
      ref = this.aaEventWithColliders();
      for (j = 0, len = ref.length; j < len; j++) {
        ev = ref[j];
        if (AAMath.distanceQuickXY(x, y, ev.x, ev.y) <= distance) {
          candidats.push(ev);
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return candidats;
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.aaIsHaveEncounters = function() {
    return this.aaEncountersData != null;
  };
  _.aaIsABSOnlyEncounters = function() {
    return this.aaIsHaveEncounters() && this.aaEncountersData.absOnly;
  };
  _.addGetEncountersRadius = function() {
    if (this.aaIsHaveEncounters()) {
      return this.aaEncountersData.radius;
    } else {
      return 2;
    }
  };
  _.addGetEncounterAnimation = function() {
    if (this.aaIsHaveEncounters()) {
      return this.aaEncountersData.animation;
    } else {
      return 0;
    }
  };
  _.aaGetEncountersCount = function() {
    if (this.aaIsHaveEncounters()) {
      return this.aaEncountersData.count;
    } else {
      return 0;
    }
  };
  _.aaInitMapEncounters = function() {
    var e, g, group, i, len, p;
    this.aaEncountersData = null;
    try {
      if (KDCore.Utils.getValueFromMeta('AAENC', $dataMap) == null) {
        return;
      }
      group = AAParametersParser.parseNoteGroup('AAENC', $dataMap.note);
      if (group == null) {
        return;
      }
      this.aaEncountersData = {};
      for (i = 0, len = group.length; i < len; i++) {
        g = group[i];
        p = AAParametersParser.extractABSParameter(g);
        this.aaEncountersData[p[0]] = p[1];
      }
      //console.info @aaEncountersData
      this.aaEncountersData.count = 0;
      return console.log("Map use ABS Encounters");
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this.aaEncountersData = null;
    }
  };
  _.aaExecuteEncounter = function(playerRegionId, encTroopId) {
    var e, regionIdForSpawnEnemy;
    try {
      regionIdForSpawnEnemy = this.aaGetRegionForEncounterEnemy(playerRegionId, encTroopId);
      if (regionIdForSpawnEnemy > 0) {
        uAPI.spawnEnemy(encTroopId, regionIdForSpawnEnemy);
      } else {
        uAPI.spawnEnemyNearPlayer(encTroopId, this.addGetEncountersRadius());
      }
      // * Учёт количества, если спавн прошёл успешно
      if ($gameTemp.aaLastSpawnedEvent != null) {
        this.aaEncountersData.count++;
        if (($gameSystem.aaEnemySpawnAnimationId == null) || $gameSystem.aaEnemySpawnAnimationId <= 0) {
          return this.aaPlaySpawnAnimation($gameTemp.aaLastSpawnedEvent, this.addGetEncounterAnimation());
        }
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaPlaySpawnAnimation = function(char, animId) {
    var e;
    try {
      if (animId <= 0) {
        return;
      }
      return AAScriptActions.execute('an_' + animId, char);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Получить номер региона в котором спавнить врага (учитывается регион игрока)
  _.aaGetRegionForEncounterEnemy = function(playerRegionId, encTroopId) {
    var candidates, e, en, i, len, ref;
    try {
      candidates = [];
      ref = this.encounterList();
      for (i = 0, len = ref.length; i < len; i++) {
        en = ref[i];
        if (en.troopId === encTroopId) {
          if (en.regionSet.contains(playerRegionId)) {
            candidates.push(...en.regionSet);
          }
        }
      }
      if (candidates.length === 0) {
        return 0;
      } else {
        return playerRegionId;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return 0; // * any point on map
    }
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  // * Инициализация переменных ABS
  _.initABSMembers = function() {
    this.aaMapAnimations = [];
    return this.aaEncountersData = null;
  };
  // * Инициализация временных данных, когда переход на новую карту
  _.aaOnNewMapLoaded = function() {
    AA.System.onNewMapLoaded();
    // * Храним все летающие бонусы на карте
    this._aaMapBonuses = [];
    // * Сбрасываем сетку навигации
    this._aaMapPathGrid = null;
    $gameTemp.aaProjYOff = $gameMap.tileWidth() * 0.25;
    // * Сохраняем состояние врагов (пока ещё прошлой карты, не новой)
    this.aaStoreEnemiesHPs();
    $gameTemp.__aaIsShouldRestoreEnemiesHp = true;
    // * Для производительности, флаг что существует хоть один Spawn Block
    this._aaIsAnySpawnBlockEvent = false;
    // * Кэш точек карты для конкретного региона (для оптимизации)
    this._aaRegionPointsCache = {};
    // * В конце вызывается оригинальный метод, это важно
    this._aaGlobalSkillsCache = {};
    // * Cache of all map points
    this._aaAllMapPointsCache = null;
    // * Remove all colliders
    this._aaClearExCollider();
    this.aaInitMapEncounters();
  };
  // * Проверка АБС событий и активация по требованию
  _.refreshABSMembers = function() {
    var e, j, len, ref;
    try {
      ref = this.eventsAA();
      for (j = 0, len = ref.length; j < len; j++) {
        e = ref[j];
        if (e.aaIsShouldBeReActivated()) {
          e.initABS();
        }
      }
      $gamePlayer.followers().aaRefreshABSMemebers();
      if (AA.Network.isNetworkGame()) {
        return AA.Network.refreshABSMembers();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Когда карта загружена, происходит активация ABS событий
  _.initABS = function() {
    var e, j, len, ref;
    try {
      ref = this.eventsAA();
      for (j = 0, len = ref.length; j < len; j++) {
        e = ref[j];
        e.initABS();
      }
      // * Чтобы АИ союзников восстановил поток после выхода из меню
      return this.refreshABSMembers();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Все ABS события на карте
  _.eventsAA = function() {
    return this.events().filter(function(e) {
      return e.isABS();
    });
  };
  // * Все АИ собзники на карте
  _.followersAA = function() {
    return $gamePlayer.followers().aaGetABSFollowers();
  };
  // * Все ABS события с меткой label
  _.eventAAWithLabel = function(label = "") {
    return this.eventsAA().filter(function(e) {
      return e.aaIsLabeledAs(label);
    });
  };
  // * ABS события в указанной точке
  _.eventsXyAA = function(x, y) {
    var e;
    try {
      return this.eventsXy(x, y).filter(function(e) {
        return e.isActive();
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * ABS события в указанной точке (с учётом Extended Hit Box)
  _.eventsXyAAExt = function(x, y) {
    var e;
    try {
      return this.eventsXyExt(x, y).filter(function(e) {
        return e.isActive();
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  _.eventsXyNoAAExt = function(x, y) {
    var e, events;
    try {
      events = this.eventsXyExt(x, y);
      return events.filter(function(ev) {
        return !ev.isABS();
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // * События в указанной точке (с учётом Extended Hit Box)
  _.eventsXyExt = function(x, y) {
    var e;
    try {
      return this.events().filter(function(event) {
        return event.posExt(x, y);
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Аналогично, только Network Characters в данной точке
  _.netCharsXyAAExt = function(x, y) {
    var e;
    try {
      if (!AA.Network.isNetworkGame()) {
        return [];
      }
      return this.netChars().filter(function(char) {
        return char.posExt(x, y);
      });
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Аналогично, только члены партии в данной точке
  _.follwersXyAAExt = function(x, y) {
    var e;
    try {
      return $gamePlayer.followers().aaGetABSFollowersXyAAExt(x, y);
    } catch (error) {
      e = error;
      AA.w(e);
      return [];
    }
  };
  // * Возвращяет спрайтсет карты (!Надо проверять сцену сперва)
  _.aaSpriteset = function() {
    return SceneManager._scene._spriteset;
  };
  // * Данный метод возвращает позиции с учётом расширенного HitBox
  _.aaGetExtendedPointsFor = function(char) {
    var d, e, extHitBoxes, i, j, k, l, m, n, positions, r, ref, ref1, ref2, ref3, u;
    try {
      positions = [
        {
          x: char.x,
          y: char.y
        }
      ];
      if (char.aaIsHaveExtendedHitBoxes()) {
        extHitBoxes = char.aaGetExtendedHitBoxes();
        l = extHitBoxes[3];
        r = extHitBoxes[1];
        u = extHitBoxes[0];
        d = extHitBoxes[2];
        if (r > 0) {
          for (i = j = 1, ref = r; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
            positions.push({
              x: char.x + i,
              y: char.y
            });
          }
        }
        if (l > 0) {
          for (i = k = 1, ref1 = l; (1 <= ref1 ? k <= ref1 : k >= ref1); i = 1 <= ref1 ? ++k : --k) {
            positions.push({
              x: char.x - i,
              y: char.y
            });
          }
        }
        if (u > 0) {
          for (i = m = 1, ref2 = u; (1 <= ref2 ? m <= ref2 : m >= ref2); i = 1 <= ref2 ? ++m : --m) {
            positions.push({
              x: char.x,
              y: char.y - i
            });
          }
        }
        if (d > 0) {
          for (i = n = 1, ref3 = d; (1 <= ref3 ? n <= ref3 : n >= ref3); i = 1 <= ref3 ? ++n : --n) {
            positions.push({
              x: char.x,
              y: char.y + i
            });
          }
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return positions;
  };
  // * Сохраняет состояния HP врагов
  _.aaStoreEnemiesHPs = function() {
    var b, dataToStore, e, ev, events, j, len;
    try {
      //"STORE ENEMIES HPS".p()
      events = this.eventsAA().filter(function(ev) {
        return ev.AAModel().saveHp > 0 && !(ev instanceof Game_AASpawnedEvent);
      });
      if (events.length === 0) {
        return;
      }
      dataToStore = {};
      for (j = 0, len = events.length; j < len; j++) {
        ev = events[j];
        try {
          b = ev.AABattler();
          if (b == null) {
            continue;
          }
          if (b.hpRate() !== 1) {
            dataToStore[ev.eventId()] = b._hp;
          }
        } catch (error) {
          //"STORED FOR".p(ev.eventId())
          e = error;
          KDCore.warning(e);
        }
      }
      return $gameSystem.aaSaveEnemiesHpDataForMap(this.mapId(), dataToStore);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Восстанавливает HP врагов из сохранённого состояния
  _.aaRestoreEnemiesHPs = function() {
    var dataToRestore, e, evId, events, hp, results, targetEvent;
    try {
      //"RESTORE ENEMIES HPS".p()
      dataToRestore = $gameSystem.aaGetEnemiesHpDataForMap(this.mapId());
      if (dataToRestore == null) {
        return;
      }
      events = this.eventsAA().filter(function(ev) {
        return ev.AAModel().saveHp > 0;
      });
      if (events.length === 0) {
        return;
      }
      results = [];
      for (evId in dataToRestore) {
        hp = dataToRestore[evId];
        try {
          targetEvent = events.find(function(ev) {
            return ev.eventId() === Number(evId);
          });
          if (targetEvent == null) {
            continue;
          }
          results.push(targetEvent.AABattler()._hp = hp);
        } catch (error) {
          //"RESTORED FOR".p(evId)
          e = error;
          results.push(KDCore.warning(e));
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaIsPointPassableForDodge = function(x, y) {
    var e;
    try {
      if (x == null) {
        return false;
      }
      if (y == null) {
        return false;
      }
      if (!this.aaIsPointInMapBorders(x, y)) {
        return false;
      }
      if (this.eventsXyNoAAExt(x, y).length > 0) {
        return false;
      }
      return this.isPassable(x, y);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaGetBattleAutoBgm = function() {
    var e;
    try {
      if (($dataMap.meta != null) && ($dataMap.meta.battleAutoBgm != null)) {
        return $dataMap.meta.battleAutoBgm;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  _.aaMapFlyBonuses = function() {
    return this._aaMapBonuses;
  };
  _.aaRequestFlyBonusSpawn = function(evId, bonusData) {
    var e, event, mapBonusObj;
    try {
      if (bonusData == null) {
        return;
      }
      //"SPAWN BONUS".p()
      event = this.event(evId);
      if (event == null) {
        return;
      }
      mapBonusObj = new AAMapFlyBonusInstance(event.x, event.y, bonusData);
      //TODO: Network code!
      KDCore.Utils.playSE(bonusData.spawnSE);
      return this._aaRegisterNewFlyBonus(mapBonusObj);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaRegisterNewFlyBonus = function(bonus) {
    var e, i, index, j, ref;
    try {
      index = 0;
      for (i = j = 0, ref = this._aaMapBonuses.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (this._aaMapBonuses[i] == null) {
          index = i;
          break;
        }
      }
      this._aaMapBonuses[index] = bonus;
      //TODO: NETWORK CODE
      if (AAUtils.isSceneMap()) {
        return $gameMap.aaSpriteset().aaCreateNewMapFlyBonus(index, bonus.delay() > 0);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  // * Работа с глобальными навыками (см. uAPI.executeAASkillOnMap)
  _.aaRegisterGlobalSkill = function(uId, aaDummyChar) {
    return this._aaGlobalSkillsCache[uId] = aaDummyChar;
  };
  _.aaDisposeGlobalSkill = function(uId) {
    this._aaGlobalSkillsCache[uId] = null;
    return delete this._aaGlobalSkillsCache[uId];
  };
  _.aaGetGlobalSkill = function(uId) {
    return this._aaGlobalSkillsCache[uId];
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  // * Спавн врага в точке карты X, Y
  // * isForce - если true, то пропускаем любые проверки
  //%[Основной метод спавна врага на карте]
  _.aaSpawnEnemyInPoint = function(refEventId, x, y, isForce = false) {
    var e;
    try {
      if (isForce === true || this.aaIsMapPointIsValidForSpawn(x, y)) {
        this._aaExecuteSpawnInPoint(refEventId, x, y);
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Спавн монстра (не безопасно вызывать этот метод сам по себе)
  _._aaExecuteSpawnInPoint = function(refEventId, x, y) {
    var e, refEvent;
    try {
      if (!DataManager.aaIsSpawnMapValid()) {
        return;
      }
      if (refEventId == null) {
        return;
      }
      if (refEventId <= 0) {
        return;
      }
      // * Проверка, что основа существует
      refEvent = $dataAASpawnMap.events[refEventId];
      if (refEvent == null) {
        return;
      }
      return $gameTemp.aaLastSpawnedEvent = new Game_AASpawnedEvent(refEventId, x, y);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaIsMapPointIsValidForSpawn = function(x, y) {
    var e;
    try {
      if (x == null) {
        return false;
      }
      if (y == null) {
        return false;
      }
      if (!this.aaIsPointInMapBorders(x, y)) {
        return false;
      }
      // * Режим Force Spawn, без каких-либо проверок
      if ($gameTemp.aaIsForceSpawn === true) {
        $gameTemp.aaIsForceSpawn = false;
        return true;
      }
      if (!AA.PP.isCanSpawnAboveEvents()) {
        if (this.eventsXyNt(x, y).length > 0) {
          // * Что нет события другого в данном месте
          return false;
        }
      }
      if ($gamePlayer.pos(x, y)) {
        // * Нельзя на игроке спавнить
        return false;
      }
      if (this.aaIsSpawnOnMapPointIsBlocked(x, y)) {
        // * Не заблокированная зона
        return false;
      }
      // * Точка проходимая
      return this.isPassable(x, y);
    } catch (error) {
      e = error;
      AA.w(e);
      return false;
    }
  };
  _.aaIsPointInMapBorders = function(x, y) {
    if (x < 0 || y < 0) {
      return false;
    }
    if (x >= $gameMap.width()) {
      return false;
    }
    if (y >= $gameMap.height()) {
      return false;
    }
    return true;
  };
  _.aaSpawnEnemyInRegion = function(refEventId, regionId, isForce = false) {
    var point, x, y;
    // Получение случайной Valid точки в регионе
    point = this.aaGetRandomSpawnPointForRegion(regionId);
    if (point == null) {
      return;
    }
    ({x, y} = point);
    this.aaSpawnEnemyInPoint(refEventId, x, y, true);
  };
  // * Возвращает случайную (доступную) точку спавна в регионе
  _.aaGetRandomSpawnPointForRegion = function(regionId) {
    var validPoints;
    if (this._aaRegionPointsCache[regionId] == null) {
      this._aaCollectAllPointsForRegion(regionId);
    }
    validPoints = this._aaRegionPointsCache[regionId].filter((p) => {
      return this.aaIsMapPointIsValidForSpawn(p.x, p.y);
    });
    // * Если опция кэширования отключена, удаляем кэш
    if (!AA.PP.isSpawnRegionCacheAllowed()) {
      this._aaRegionPointsCache[regionId] = [];
    }
    return validPoints.sample();
  };
  // * Собираем все точки на карте соответствующего региона
  _._aaCollectAllPointsForRegion = function(regionId) {
    var i, j, ref, ref1, x, y;
    this._aaRegionPointsCache[regionId] = [];
    for (x = i = 0, ref = this.width(); (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
      for (y = j = 0, ref1 = this.height(); (0 <= ref1 ? j < ref1 : j > ref1); y = 0 <= ref1 ? ++j : --j) {
        if (this.regionId(x, y) === regionId) {
          this._aaRegionPointsCache[regionId].push({x, y});
        }
      }
    }
  };
  // * Точка вокруг точки (в радиусе), Valid точка
  // * Если не найдена, возвращает NULL
  _.aaGetRandomSpawnPointInRadius = function(x, y, radius) {
    var e, isPointFinded, point, tryCount;
    if ((radius == null) || radius <= 0) {
      return {x, y};
    }
    try {
      tryCount = radius * 2;
      isPointFinded = false;
      while (!isPointFinded) {
        if (tryCount <= 0) {
          break;
        }
        tryCount--;
        point = AA.Utils.Math.getPointInRadius(x, y, radius);
        isPointFinded = this.aaIsMapPointIsValidForSpawn(point.x, point.y);
      }
      if (isPointFinded === true) {
        return point;
      } else {
        return null;
      }
    } catch (error) {
      e = error;
      AA.w(e);
      return null;
    }
  };
  
  // * SPAWN BLOCK SYSTEM =========================================
  _.aaRegisterBlockSpawnEventExist = function() {
    return this._aaIsAnySpawnBlockEvent = true;
  };
  _.aaIsSpawnBlockEventRegistred = function() {
    return this._aaIsAnySpawnBlockEvent === true;
  };
  _.aaIsSpawnOnMapPointIsBlocked = function(x, y) {
    var ev, i, len, point, spawnBlockEvents;
    if (this.aaIsSpawnBlockEventRegistred()) {
      spawnBlockEvents = this.events().filter(function(ev) {
        return ev.aaIsHaveSpawnBlockFlag();
      });
      point = {x, y};
      for (i = 0, len = spawnBlockEvents.length; i < len; i++) {
        ev = spawnBlockEvents[i];
        if (ev == null) {
          continue;
        }
        if (ev.distTo(point) < ev._aaBlockSpawnRadius) {
          console.log("Block Event disable Spawn on point " + [x, y]);
          return true;
        }
      }
    }
    return false;
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addActor, ALIAS__gainItem, ALIAS__removeActor, ALIAS__setupStartingMembers, _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  //@[ALIAS]
  ALIAS__removeActor = _.removeActor;
  _.removeActor = function() {
    ALIAS__removeActor.call(this, ...arguments);
    if ($gameParty.leader() == null) {
      AA.System.checkABSPlayerExists();
    }
  };
  //@[ALIAS]
  ALIAS__addActor = _.addActor;
  _.addActor = function() {
    ALIAS__addActor.call(this, ...arguments);
    // * Если игрока не было, но появился
    if ($gameTemp._noABSPlayer === true && ($gameParty.leader() != null)) {
      AA.System.checkABSPlayerExists();
    }
  };
  //@[ALIAS]
  ALIAS__setupStartingMembers = _.setupStartingMembers;
  _.setupStartingMembers = function() {
    ALIAS__setupStartingMembers.call(this);
    // * Игнорирование членов группы с пустыми именами (частая ошибка новичков)
    this._actors = this._actors.filter(function(actor) {
      return String.any($dataActors[actor].name);
    });
  };
  
  //@[ALIAS]
  ALIAS__gainItem = _.gainItem;
  _.gainItem = function(item, amount, includeEquip) {
    var e, ref;
    ALIAS__gainItem.call(this, item, amount, includeEquip);
    try {
      if ((ref = AA.Sprite_WeaponExtensionSlot.Instance()) != null) {
        ref.closeMenu();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    //TODO: Пока так, но вообще это будет отдельный плагин
    if (amount > 0 && (this.itemContainer(item) != null)) {
      $gameTemp._pLastItemGainedToParty = [item, amount];
    } else {
      $gameTemp._pLastItemGainedToParty = null;
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  _.aaRefreshABSStatesSet = function() {
    var actor, e, i, len, ref, results;
    try {
      ref = this.members();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        actor = ref[i];
        if (actor == null) {
          continue;
        }
        if (actor.aaStates == null) {
          continue;
        }
        if (actor.aaStates.isNotHaveBattler()) {
          results.push(actor.clearStatesABS());
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaCheckDeath = function() {
    //TODO: PARTY UPD Что делать если игрок погиб, а партия нет?
    if ($gameParty.leader() == null) {
      return;
    }
    if ($gameParty.leader().isAlive()) {
      return;
    }
    // * Пока GAME OVER если игрок погибает
    //TODO: Если будет партия по типу переключения (Genshin mode),
    //TODO: то можно переключать персонажа на живого (опция)
    $gamePlayer.aaOnDefeat();
  };
  // * Дать опыт всей группе (с учётом опций (разделение, для всех))
  // * isVisible == true -> Показать PopUp
  _.aaGainExpForParty = function(value, isVisible = true) {
    var char, charReceivers, e, expGainMode, i, j, len, len1, m, ref, ref1, valueX;
    try {
      if (value === 0) {
        return;
      }
      // * In network mode, only killer get exp (for now)
      if (AA.Network.isNetworkGame()) {
        try {
          if ($gameTemp.__aaExpReceiver != null) {
            if ($gameTemp.__aaExpReceiver === $gameParty.leader()) {
              $gameParty.leader().gainExp(value);
              if (isVisible === true) {
                this._aaShowExpPopUpVisually([$gamePlayer], value);
              }
            } else {
              if ($gameTemp.__aaExpReceiver.AACharacter() != null) {
                char = $gameTemp.__aaExpReceiver.AACharacter();
                AANetworkManager.gainExpFor(char, value, isVisible);
              }
            }
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return;
      }
      expGainMode = AA.PP.getPartyExpGainMode();
      switch (expGainMode) {
        case "party":
          charReceivers = $gameParty.members().map(function(m) {
            return m.AACharacter();
          });
          ref = $gameParty.members();
          for (i = 0, len = ref.length; i < len; i++) {
            m = ref[i];
            m.gainExp(value);
          }
          break;
        case "partyDivided":
          if (value === 0) {
            return;
          }
          charReceivers = $gameParty.members().map(function(m) {
            return m.AACharacter();
          });
          valueX = Math.round(value / $gameParty.members().length);
          if (valueX <= 0) {
            valueX = 1;
          }
          ref1 = $gameParty.members();
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            m = ref1[j];
            m.gainExp(valueX);
          }
          // * Делим, если показывать над персонажами всеми
          if (AA.PP.getExpPopUpSettings().aboveChar === true) {
            value = valueX;
          }
          break;
        case "killer":
          if ($gameTemp.__aaExpReceiver != null) {
            charReceivers = [$gameTemp.__aaExpReceiver.AACharacter()];
            $gameTemp.__aaExpReceiver.gainExp(value);
          } else {
            $gameTemp.__aaExpReceiver = $gamePlayer;
            this.leader().gainExp(value); // * player
          }
          break;
        default:
          charReceivers = [$gamePlayer];
          this.leader().gainExp(value);
      }
      // * Не показывать, если флаг отключён
      if (!isVisible) {
        return;
      }
      this._aaShowExpPopUpVisually(charReceivers, value);
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  _._aaShowExpPopUpVisually = function(charReceivers, value) {
    var char, data, e, i, len, p, results;
    try {
      if (value === 0) {
        return;
      }
      p = AA.PP.getExpPopUpSettings();
      // * Не показывать, если параметр плагина отключён
      if (!p.active) {
        return;
      }
      if (p.aboveChar === false && ($gameTemp.__aaExpGiver != null)) {
        charReceivers = [$gameTemp.__aaExpGiver];
      }
      if (charReceivers == null) {
        return;
      }
      results = [];
      for (i = 0, len = charReceivers.length; i < len; i++) {
        char = charReceivers[i];
        if (char == null) {
          continue;
        }
        data = AADamagePopUpFactory.createExpPopUpData(value, char);
        if (data == null) {
          continue;
        }
        if (p.bindToChar === true) {
          results.push(Sprite_AADamagePopUpItem.CreateOnCharacterBinded(char, data.settings, data.value));
        } else {
          results.push(Sprite_AADamagePopUpItem.CreateOnCharacter(char, data.settings, data.value));
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Дать золото всей группе (только над игроком)
  _.aaGainGoldForParty = function(value) {
    var char, data, e, p;
    try {
      this.gainGold(value);
      p = AA.PP.getGoldPopUpSettings();
      char = $gamePlayer;
      data = AADamagePopUpFactory.createGoldPopUpData(value, char);
      if (data == null) {
        return;
      }
      if (p.bindToChar === true) {
        return Sprite_AADamagePopUpItem.CreateOnCharacterBinded(char, data.settings, data.value);
      } else {
        return Sprite_AADamagePopUpItem.CreateOnCharacter(char, data.settings, data.value);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  // * Когда игрок получил какой-либо предмет
  _.pOnSomeItemBeenGained = function() {
    var e;
    try {
      // * У Extended Loot свой метод, см. pelOnSomeItemBeenGained (3_EL_Compatibility.coffee)
      if (Imported.PKD_ExtendedLoot) {
        return;
      }
      return this.pOnItemBeenGainedProcess();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Обработка полученного предмета
  _.pOnItemBeenGainedProcess = function() {
    if ($gameTemp._pLastItemGainedToParty == null) {
      return;
    }
    if ($gameTemp._pLastItemGainedToParty[0] == null) {
      return;
    }
    if ($gameTemp._pLastItemGainedToParty[1] <= 0) {
      return;
    }
    if (AA.PP.isAddNewItemOnPanelOnPickup()) {
      return this.aaAddGainedItemToPanel(...$gameTemp._pLastItemGainedToParty);
    }
  };
  _.aaAddGainedItemToPanel = function(item, count) {
    if (!AASkill2.IsAAObject(item)) {
      return;
    }
    // * Новый предмет (т.е. раньше не было)
    if (this.numItems(item) === count) {
      // * Тут надо использовать idA
      if (!$gamePlayer.aaSkillsSet.isHaveItemOnPanel(item.idA)) {
        // * Тут используется обычный ID (так как конвертируется в методе)
        uAPI.setItemToPanel(item.id);
      }
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__canMove, ALIAS__executeEncounter, ALIAS__initMembers, ALIAS__moveStraight, ALIAS__update, ALIAS__updateScroll, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this._initMembersABS();
  };
  // ======================================================================

  //@[ALIAS]
  ALIAS__updateScroll = _.updateScroll;
  _.updateScroll = function() {
    if (this.aaIsDodging()) {
      return;
    }
    return ALIAS__updateScroll.call(this, ...arguments);
  };
  //@[ALIAS]
  ALIAS__canMove = _.canMove;
  _.canMove = function() {
    var canMove;
    canMove = ALIAS__canMove.call(this);
    if (canMove && this.isABS() && AA.isABSActive() && (this.AABattler() != null)) {
      return this.AABattler().canMove();
    } else {
      return canMove;
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function(sceneActive) {
    ALIAS__update.call(this, sceneActive);
    if (AA.isABSActive()) {
      this._aaUpdatePlayerABS(sceneActive);
    }
    if (sceneActive === true) {
      this._aaUpdatePlayerABSCommon();
    }
  };
  //@[ALIAS]
  ALIAS__moveStraight = _.moveStraight;
  _.moveStraight = function() {
    ALIAS__moveStraight.call(this, ...arguments);
    $gameTemp.aaResetMapScrollOnMoving();
  };
  //@[ALIAS]
  ALIAS__executeEncounter = _.executeEncounter;
  _.executeEncounter = function() {
    if ($gameMap.aaIsHaveEncounters()) {
      if (AA.isABSActive()) {
        this.aaExecuteEncounter();
        return false; // * Always!
      } else {
        if ($gameMap.aaIsABSOnlyEncounters()) {
          return false;
        }
      }
    }
    return ALIAS__executeEncounter.call(this, ...arguments);
  };
  (function() {    // * Диагональное движение
    // -----------------------------------------------------------------------
    var ALIAS__executeMove, ALIAS__findDirectionTo, ALIAS__getInputDirection;
    //@[ALIAS]
    ALIAS__getInputDirection = _.getInputDirection;
    _.getInputDirection = function() {
      if (this.aaIsThisCharCanUseDiagMovement()) {
        return Input.dir8;
      } else {
        return ALIAS__getInputDirection.call(this);
      }
    };
    
    //@[ALIAS]
    ALIAS__executeMove = _.executeMove;
    _.executeMove = function(direction) {
      var horz, vert;
      if (this.aaIsThisCharCanUseDiagMovement()) {
        if (direction % 2 === 0) {
          return ALIAS__executeMove.call(this, direction);
        } else if (Math.abs(direction % 2) === 1) {
          [horz, vert] = AA.Utils.get8Dir(direction);
          return this.moveDiagonally(horz, vert);
        }
      } else {
        return ALIAS__executeMove.call(this, direction);
      }
    };
    
    //@[ALIAS]
    ALIAS__findDirectionTo = _.findDirectionTo;
    _.findDirectionTo = function(goalX, goalY) {
      if (this.aaIsThisCharCanUseDiagMovement()) {
        return this.aaFindDirectionToDiagonal(goalX, goalY);
      } else {
        return ALIAS__findDirectionTo.call(this, goalX, goalY);
      }
    };
  })();
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Game_Player.prototype;
    //@[ALIAS]
    const ALIAS__regionId = _.regionId;
    _.regionId = function () {
        if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            return $gameMap.regionId(Math.round(this.x), Math.round(this.y));
        }
        else {
            return ALIAS__regionId.call(this);
        }
    };
    //@[ALIAS]
    const ALIAS__triggerButtonAction = _.triggerButtonAction;
    _.triggerButtonAction = function () {
        let t = this;
        let result = ALIAS__triggerButtonAction.call(this);
        if (!result && Input.isTriggered("ok")) {
            result = startInteractionEvent([0, 1, 2]);
        }
        return result;
    };
    //@[ALIAS]
    const ALIAS__updateNonmoving = _.updateNonmoving;
    _.updateNonmoving = function (...args) {
        if (!$gameMap.isEventRunning()) {
            if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
                if (AATranslationMover.isShouldTranslate(this)) {
                    AATranslationMover.updateTranslationMoveFor(this);
                    return;
                }
            }
        }
        ALIAS__updateNonmoving.call(this, ...args);
    };
    //@[ALIAS]
    const ALIAS__triggerTouchAction = _.triggerTouchAction;
    _.triggerTouchAction = function () {
        let t = this;
        let result = ALIAS__triggerTouchAction.call(this);
        if (!result) {
            result = startInteractionEvent([1, 2]);
        }
        return result;
    };
    let startInteractionEvent = function (triggers) {
        if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            let activeInteracitonEvent = AAEventsInteractionsManager.getInteractionEvent();
            if (activeInteracitonEvent) {
                let { x, y } = activeInteracitonEvent;
                $gamePlayer.startMapEvent(x, y, triggers, activeInteracitonEvent.isNormalPriority());
                return true;
            }
        }
        return false;
    };
    //@[ALIAS]
    const ALIAS__moveByInput = _.moveByInput;
    _.moveByInput = function (...args) {
        if (!AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            ALIAS__moveByInput.call(this, ...args);
            return;
        }
        //ALIAS__moveByInput.call(this, ...args);
        if (this.canMove()) {
            //@ts-ignore
            var inputVector = { x: Input._signX(), y: Input._signY() };
            AAVectorMover.setMovementVector(this, inputVector);
            if (AAVectorMover.isShouldMoveByVector(this)) {
                $gameTemp.clearDestination();
                AAPathMover.stopMoveByPath(this);
                Sprite_AAGridMapLayer.DrawPath([]);
                //console.log("Should move by InputVector");
                //console.log(inputVector);
            }
            let direction = 0; //this.getInputDirection();
            if (direction > 0) {
                $gameTemp.clearDestination();
                AAPathMover.stopMoveByPath(this);
            }
            else if ($gameTemp.isDestinationValid()) {
                if (AAEventsInteractionsManager.isPlayerTouchInteraction()) {
                    startInteractionEvent([0, 1, 2]);
                    $gameTemp.clearDestination();
                    return;
                }
                let x = $gameTemp.destinationX();
                let y = $gameTemp.destinationY();
                let distance = $gameMap.distance(this.x, this.y, x, y);
                if (distance < 2) {
                    //console.log('try move by vector')
                    // We should move by vector
                    let mapPoint = AAUtils.screenPointToMapPoint(TouchInput);
                    let vector = { x: mapPoint.x - this.x, y: mapPoint.y - this.y };
                    AAVectorMover.setMovementVector(this, vector);
                    if (AAVectorMover.isShouldMoveByVector(this)) {
                        setTimeout(() => {
                            $gameTemp.clearDestination();
                        }, 200);
                        AAPathMover.stopMoveByPath(this);
                        Sprite_AAGridMapLayer.DrawPath([]);
                        return;
                    }
                }
                let eventUnderCursor = AAEventsInteractionsManager.getInteractionEventUnderCursor();
                if (eventUnderCursor != null && eventUnderCursor != AAEventsInteractionsManager.getInteractionEvent()) {
                    let targetX = 0;
                    let targetY = 0;
                    let x = eventUnderCursor.x;
                    let y = eventUnderCursor.y;
                    switch (this.direction()) {
                        case 2:
                            targetX = x;
                            targetY = y + 1;
                            break;
                        case 4:
                            targetX = x - 1;
                            targetY = y;
                            break;
                        case 6:
                            targetX = x + 1;
                            targetY = y;
                            break;
                        case 8:
                            targetX = x;
                            targetY = y - 1;
                            break;
                        case 1:
                            targetX = x + 1;
                            targetY = y + 1;
                            break;
                        case 3:
                            targetX = x - 1;
                            targetY = y + 1;
                            break;
                        case 7:
                            targetX = x - 1;
                            targetY = y - 1;
                            break;
                        case 9:
                            targetX = x + 1;
                            targetY = y - 1;
                            break;
                    }
                    x = targetX;
                    y = targetY;
                }
                else {
                    //direction = this.findDirectionTo(x, y);
                    if (!AAGridMapManager.isGridSize48()) {
                        let mapPoint = AAUtils.screenPointToMapPoint(TouchInput);
                        x = mapPoint.x;
                        y = mapPoint.y;
                    }
                }
                this.test(x, y);
                $gameTemp.clearDestination();
            }
            if (direction > 0) {
                this.executeMove(direction);
            }
        }
        else {
            if (this.isMoving()) {
                AAPathMover.stopMoveByPath(this);
                AAVectorMover.setMovementVector(this, { x: 0, y: 0 });
                $gameTemp.clearDestination();
            }
        }
    };
    //@[ALIAS]
    const ALIAS__isMoving = _.isMoving;
    _.isMoving = function (...args) {
        if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            if (AAPathMover.isHavePathFor(this)) {
                return true;
            }
            if (AAVectorMover.isShouldMoveByVector(this)) {
                return true;
            }
        }
        return ALIAS__isMoving.call(this, ...args);
    };
    //@ts-ignore
    _.test = function (x, y) {
        AAPathMover.stopMoveByPath(this);
        let testPath = AAGridMapManager.findPath({ x: this.x, y: this.y }, { x: x, y: y });
        if (testPath.length == 0) {
            // We should try to find path to the nearest point
            let points = AAMath.getAdjacentPointsInSquare(x, y, 1);
            //let minDistance = Number.MAX_SAFE_INTEGER;
            //let minPoint = {x: x, y: y};
            for (let point of points) {
                let path = AAGridMapManager.findPath({ x: this.x, y: this.y }, point);
                if (path.length != 0) {
                    /*let distance = AAMath.distanceQuickXY(point.x, point.y, x, y);
                    if(distance < minDistance) {
                        minDistance = distance;
                        minPoint = point;
                    }*/
                    testPath = path;
                    break;
                }
            }
            //testPath = AAGridMapManager.findPath({x: this.x, y: this.y}, minPoint);
        }
        //console.log(testPath)
        if (testPath.length != 0) {
            Sprite_AAGridMapLayer.DrawPath(testPath);
            let copyPath = testPath.map(p => AAGridMapManager.alignGridPointWithMap(p));
            AAPathMover.startMoveByPath(this, copyPath);
        }
        else {
            //console.log("EMPTY")
        }
    };
    //@[ALIAS]
    const ALIAS__updateMove = _.updateMove;
    _.updateMove = function (...args) {
        if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            if (AACharMovementController.processMovementFor(this)) {
                updateMovementProcess($gamePlayer);
                return;
            }
        }
        ALIAS__updateMove.call(this, ...args);
    };
    var _movementProcessTimeDelay = 20; // in frames
    var _movementProcessTimer = 0;
    function updateMovementProcess(player) {
        _movementProcessTimer++;
        if (_movementProcessTimer >= _movementProcessTimeDelay) {
            _movementProcessTimer = 0;
            player.updateEncounterCount();
            player.followers().updateMove();
            $gameParty.onPlayerWalk();
        }
    }
})();
// ■ END Game_Player.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.aaGetAutoBattleBgmData = function() {
    var data, defaultSettings, delay, e, mapAutoBattleBgm, name;
    try {
      defaultSettings = AA.PP.getDefaultBattleBgm();
      mapAutoBattleBgm = $gameMap.aaGetBattleAutoBgm();
      if (String.any(mapAutoBattleBgm)) {
        name = mapAutoBattleBgm;
      } else {
        if (defaultSettings != null) {
          name = defaultSettings.name;
        } else {
          name = "";
        }
      }
      if (defaultSettings != null) {
        delay = defaultSettings.delay;
      } else {
        delay = 0;
      }
      data = {name, delay};
      return data;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  };
  _.aaStartAutoBattleBgm = function() {
    var autoBattleBgmData, delay, e, name;
    try {
      if (this._aaIsAutoBattleBgmStarted === true) {
        return;
      }
      autoBattleBgmData = this.aaGetAutoBattleBgmData();
      if (autoBattleBgmData == null) {
        return;
      }
      ({name, delay} = autoBattleBgmData);
      if (String.any(name)) {
        uAPI.playBattleBgm(name, delay);
        return this._aaIsAutoBattleBgmStarted = true;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaStopAutoBattleBgm = function() {
    var autoBattleBgmData, delay, e;
    try {
      if (!this._aaIsAutoBattleBgmStarted) {
        return;
      }
      autoBattleBgmData = this.aaGetAutoBattleBgmData();
      ({delay} = autoBattleBgmData);
      if (delay == null) {
        delay = 0;
      }
      uAPI.stopBattleBgm(delay);
      return this._aaIsAutoBattleBgmStarted = false;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS___aaOnCastingAborted, ALIAS___aaOnCastingEnd, ALIAS___aaOnCastingStarted, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  //@[ALIAS]
  ALIAS___aaOnCastingEnd = _._aaOnCastingEnd;
  _._aaOnCastingEnd = function() {
    ALIAS___aaOnCastingEnd.call(this, ...arguments);
    return AA_NUI_Sprite_PlayerCastingProgressBar.Hide();
  };
  //@[ALIAS]
  ALIAS___aaOnCastingAborted = _._aaOnCastingAborted;
  _._aaOnCastingAborted = function() {
    ALIAS___aaOnCastingAborted.call(this, ...arguments);
    return AA.UI.skillPerformResult(this._aaCastingNowSkill.idA, 0);
  };
  //@[ALIAS]
  ALIAS___aaOnCastingStarted = _._aaOnCastingStarted;
  _._aaOnCastingStarted = function() {
    ALIAS___aaOnCastingStarted.call(this, ...arguments);
    return AA_NUI_Sprite_PlayerCastingProgressBar.Show();
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.aaIsInvincible = function() {
    return this.aaIsDodging() && AA.PP.getDodgeSettings().isInvincible === true;
  };
  _.aaIsDodging = function() {
    return this._aaInDodgeMovement === true;
  };
  _.aaIsCanDodgeNow = function() {
    return this.aaIsDodgeAllowedNow() && this.isABS() && this.canMove() && !this.aaIsDodging() && this.aaIsNextDodgeReady();
  };
  _.aaIsDodgeAllowedNow = function() {
    var e;
    try {
      if (!AA.PP.isAllowDodge()) {
        return false;
      }
      if (AA.PP.getDodgeSettings().dodgeSwitch > 0) {
        if ($gameSwitches.value(AA.PP.getDodgeSettings().dodgeSwitch) === true) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  _.aaIsNextDodgeReady = function() {
    return !this._aaDodgeRestTimer || this._aaDodgeRestTimer <= 0;
  };
  _.aaPerformDodge = function() {
    var dodgeMoveSpeed, dodgeSteps, dodgeStepsDelay, e, isAnimaXDodge;
    try {
      //console.log("DODGE!")
      this._aaInDodgeMovement = true;
      this.__aaPrevMoveSpeed = this.moveSpeed();
      this.setThrough(true);
      dodgeSteps = this._aaGetDodgeStepsCount();
      isAnimaXDodge = this.isAnimX() && this.isHaveAnimaXActionWithName('Dodge');
      dodgeStepsDelay = AA.PP.getDodgeSettings().delayBetweenStepMS;
      dodgeMoveSpeed = AA.PP.getDodgeSettings().dodgeMoveSpeed;
      if (isAnimaXDodge) {
        this.aaPlayAnimaXActionWithEndCallback("Dodge", this.aaOnDodgeEnds.bind(this));
      }
      if (dodgeSteps > 0) {
        if (!isAnimaXDodge) {
          setTimeout((() => {
            return this.aaOnDodgeEnds();
          }), dodgeStepsDelay + 1);
        }
        this.setMoveSpeed(dodgeMoveSpeed);
        this._aaMakeDodgeMovement();
        if (dodgeSteps > 1) {
          return setTimeout((() => {
            return this._aaMakeDodgeMovement();
          }), dodgeStepsDelay);
        }
      } else {
        return this.aaOnDodgeEnds();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaMakeDodgeMovement = function() {
    var e, h, v;
    try {
      if (this._diagonalDir) {
        [h, v] = AA.Utils.get8Dir(this._diagonalDir);
        return this.moveDiagonally(h, v);
      } else {
        return this.moveStraight(this.direction());
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaGetDodgeStepsCount = function() {
    var d, e, nextMovePoint, pointsCount;
    try {
      pointsCount = 0;
      d = this.aaDirection();
      nextMovePoint = AA.Utils.Math.getNextPointByDirection(this.x, this.y, d);
      if ($gameMap.aaIsPointPassableForDodge(nextMovePoint.x, nextMovePoint.y)) {
        pointsCount += 1;
        if (AA.PP.getDodgeSettings().stepsCount > 1) {
          nextMovePoint = AA.Utils.Math.getNextPointByDirection(nextMovePoint.x, nextMovePoint.y, d);
          if ($gameMap.aaIsPointPassableForDodge(nextMovePoint.x, nextMovePoint.y)) {
            pointsCount += 1;
          }
        }
      }
      return pointsCount;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return 0;
    }
  };
  _.aaOnDodgeEnds = function() {
    var e, time;
    try {
      //console.log("DODGE END")
      this._aaInDodgeMovement = false;
      this.setThrough(false);
      this.setMoveSpeed(this.__aaPrevMoveSpeed || 4);
      if (AA.PP.getDodgeSettings().dodgeRestVariable > 0) {
        time = KDCore.Utils.getVar(AA.PP.getDodgeSettings().dodgeRestVariable);
      } else {
        time = AA.PP.getDodgeSettings().dodgeRestTimerFrames;
      }
      return this._aaDodgeRestTimer = time;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaUpdateDodgeRestTimer = function() {
    var e;
    try {
      if (this._aaDodgeRestTimer > 0) {
        return this._aaDodgeRestTimer -= 1;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__isABS, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  // * Доп. проверка
  //@[ALIAS]
  ALIAS__isABS = _.isABS;
  _.isABS = function() {
    return ALIAS__isABS.call(this) && ($gameParty.leader() != null);
  };
  // * Когда сцена карты останавливается (сменяется другой)
  _.aaOnMapSceneEnd = function() {
    var ref;
    // * Выходим из цикла проверти Dead Timer, если разработчик забыл удалить состояние Death
    if ($gameTemp.aaDeathCEExecuted === true) {
      $gameTemp.aaDeathCEExecuted = null;
      if ((ref = this.AABattler()) != null) {
        ref.removeState(1);
      }
      this.aaClearMotion();
    }
    if (this.isInSkillTargetingState()) {
      this.onSkillTargetCancel();
    }
  };
  // * Можно ли управлять? (АБС элементы: навыки, атака и всё в этом роде)
  _.canBeControlled = function() {
    return this.isActive() && AA.isABSMap();
  };
  _.isInSkillTargetingState = function() {
    return this.aaState === 'skill';
  };
  // * Если ли у игрока АБС навык с ID
  _.aaIsHaveABSSkill = function(skillId) {
    return this.AABattler().getAASkills().getById(skillId) != null;
  };
  //TODO:?
  // * Проверка цели (см. Game_CharacterBase_AA)
  _.aaIsValidTargetToSet = function(target) {
    return true;
  };
  // * Когда игрок выбрал зону поражения навыка на карте (нажал левую кнопку мыши)
  _.onSkillTargetSelected = function() {
    var point, skill;
    //"SKILL ZONE SELECTED".p()
    //console.info $gameTemp._aaSkillSelectorTargets
    // * Проверка радиуса
    skill = this.activeAASkill();
    point = TouchInput.toMapPoint();
    if (AAMath.getDistanceToPlayerFrom(point) <= skill.gRange()) {
      this.startPerformAASkill(point);
      // * Сбрасываем состояние
      this.onSkillTargetCancel();
    } else {
      AA.UI.shakeSkillImpactSelector();
    }
  };
  //TODO: shake sprite
  _.onSkillTargetCancel = function() {
    return this._resetAAState();
  };
  //TODO: Возможно эта реализация довольно затратная по производительности
  //TODO: Сделать параметр плагина - использовать боевую стойку или нет
  _._aaIsInBattleAnimaXState = function() {
    var myEnemies;
    if (!AA.isABSActive()) {
      return false;
    }
    myEnemies = AATargetsManager.getAllWhoHavePlayerAsTargetInRange(5);
    return myEnemies.length > 0;
  };
  // * Обработка общей логики (вне зависимости Active ABS или нет)
  _._aaUpdatePlayerABSCommon = function() {
    if (this._aaOnDeathTimer != null) {
      this._aaUpdateDeathTimer();
    }
    if (this._aaDodgeRestTimer != null) {
      this._aaUpdateDodgeRestTimer();
    }
    //TODO: Можно убрать, но пока оставлю
    if (this.aaIsMotionRequested() && $gameParty.leader().isAlive()) {
      this.aaClearMotion();
    }
  };
  _._aaUpdateDeathTimer = function() {
    if (this._aaOnDeathTimer > 0) {
      this._aaOnDeathTimer--;
    } else {
      this.aaOnDeath();
    }
  };
  //@[EVENT]
  _.gev_onABSPaused = function() {
    var e;
    try {
      // * Сбрасываем состояние (выбор навыка)
      return this._resetAAState();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _.aaGetABSFollowers = function() {
    return this.followers().aaGetABSFollowers();
  };
  _.aaIsHaveAnyABSFollower = function() {
    return this.aaGetABSFollowers().length > 0;
  };
  _.aaIsCanMoveByImpulse = function() {
    var e;
    try {
      if (this.isABS() && this.AABattler().aaIsEquippedInHeavyArmor()) {
        return false;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return true;
  };
  (function() {    // * Основные (приватные) методы АБС
    // -----------------------------------------------------------------------
    var ALIAS__initABS;
    
    //TODO: Доделать поддержку техники
    // * Боты сейчас не учитывают isActive
    // * Надо там добавить isTagetValid
    //@[ALIAS]
    //ALIAS__isActive = _.isActive
    //_.isActive = ->
    //    ALIAS__isActive.call(@) && !@isInVehicle()

    // * 0 - Игрок
    _.aaCharId = function() {
      return 0;
    };
    //@[ALIAS]
    ALIAS__initABS = _.initABS;
    _.initABS = function() {
      ALIAS__initABS.call(this);
      if (AA.System.isExCollisionActive()) {
        this._initExCollForABS();
      }
      this.aaRefreshABSSkillsForPanel();
      //TODO: TEMP SOLUTION
      AACharCollider.setupForCharacter(this);
      //TODO: Temp
      AAHitBox.setupForCharacter(this);
    };
    _._initMembersABS = function() {
      this.aaEntity = new AAPlayerEntity();
      this.aaState = null; // * Свободное состояние (нулевое)
      this.aaSkillsSet = new AASkillsSet();
    };
    _._setAAStateToSelectSkillTarget = function() {
      // * Наверное должно быт в AAEntity!!! Так как у ботов тоже будет этот параметр
      this.aaState = 'skill';
      AA.EV.call("PlayerSkillSelector");
    };
    _._setAAStateToSmartSkillUse = function(skillId, point) {
      this.aaState = 'smartAttack';
      this._aaSmartSkillId = skillId;
      this._aaSmartPoint = point;
    };
    _._resetAAState = function() {
      this.aaState = null;
      AA.EV.call("PlayerSkillSelector");
    };
    _._aaUpdatePlayerABS = function(sceneActive) {
      if (sceneActive === true) {
        this._aaUpdateStates();
        this._aaUpdatePlayerInput();
        return this._aaUpdateCastingProcess();
      }
    };
    _._aaUpdateStates = function() {
      switch (this.aaState) {
        case 'skill':
          // * Обновляем цели под кругом выбора
          return $gameTemp._aaSkillSelectorTargets = AATargetsManager.collectTargetsForPlayerSelector(this.activeAASkill());
        //? Не используется пока что
        // * Работает, но проблема что надо сбрасывать во многих случаях - путаница
        case 'smartAttack':
          if (!this.isMoving()) {
            if (AATargetsManager.isInSkillRange(this, this._aaSmartSkillId, this._aaSmartPoint)) {
              this._resetAAState();
              return this.aaTryPerformSkill(this._aaSmartSkillId);
            } else {
              return this.aaMoveTypeToPoint(this._aaSmartPoint);
            }
          }
          break;
      }
    };
    _.aaIsSupportMotion = function() {
      return AA.PP.getShowDeadMotionOnDeathType() > 0;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Методы ABS (Бой и состояния)
    // -----------------------------------------------------------------------
    var ALIAS__aaOnActionOnMe;
    // * Когда какое-либо действие было выполненно на мне
    //@[ALIAS]
    ALIAS__aaOnActionOnMe = _.aaOnActionOnMe;
    _.aaOnActionOnMe = function(action) {
      var result;
      ALIAS__aaOnActionOnMe.call(this, action);
      //TODO: На будущее: тут можно определить кто именно атаковал, так как action имеет packedSubject
      // * Сброс камеры (если есть опция)
      $gameTemp.aaResetMapScrollOnAction();
      result = this.AABattler().result();
      if ((result != null) && result.isHit() && result.hpDamage > 0) {
        this.aaOnActionDamageReceived();
      }
      if (AA.Network.isNetworkPvPGame()) {
        this.aaOnActionOnMeInNetwork(action);
      }
    };
    _.aaSetPartyAIOnDamageFlag = function() {
      if (!this.aaIsHaveAnyABSFollower()) {
        return;
      }
      $gameTemp._aaPartyAI_flag_playerGotDamage = true;
      // * Убираем флаг через время
      setTimeout((function() {
        return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._aaPartyAI_flag_playerGotDamage = false : void 0;
      }), 1000);
    };
    _.aaOnActionDamageReceived = function() {
      var e;
      try {
        this.aaSetPartyAIOnDamageFlag();
        if (this.aaInSkillCastingProcess()) {
          return this.aaOnEventWhileCasting('hit');
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnActionOnMeInNetwork = function(action) {
      var e, result;
      try {
        result = this.AABattler().result();
        if (result == null) {
          return;
        }
        if (result.isHit() && result.hpDamage > 0) {
          if (!this.AABattler().isAlive()) {
            return this.aaOnKilledByNetworkChar(action);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnKilledByNetworkChar = function(action) {
      var e, owner;
      try {
        if (action == null) {
          return;
        }
        if (!action.isNetCharActionOwner()) {
          return;
        }
        owner = action.character();
        $gameTemp.aaPvPKilledBy = owner.id;
        return AAUtils.startCE(AA.PP.getCommonEventOnPlayerDeadInPvP());
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnDefeat = function() {
      var e, motionShowType;
      if (this._aaOnDeathTimer != null) {
        return;
      }
      if (this.aaInSkillCastingProcess()) {
        this.aaAbortSkillCastingProcess();
      }
      // * Если не включён Force dead motion (и подключён AnimaX)
      if (Imported.PKD_AnimaX && AA.PP.getShowDeadMotionOnDeathType() !== 1) {
        try {
          if (this.isAnimX()) {
            // * см. Game_Character_AnimaX.coffee
            this._aaOnGoInDeadAnimaXState();
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
      motionShowType = AA.PP.getShowDeadMotionOnDeathType();
      // * Показать Dead Motion
      if (Imported.PKD_AnimaX === true) {
        try {
          if (motionShowType === 1 || (motionShowType === 2 && !this.isHaveAnimaXState('dead'))) {
            this.aaRequestMotion('dead');
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      } else {
        if (motionShowType > 0) {
          this.aaRequestMotion('dead');
        }
      }
      if (AA.PP.getCommonEventOnPlayerDeath() > 0) {
        this.followers().aaOnPlayerDeathEvent();
        this._aaOnDeathTimer = 90;
      } else {
        this._aaOnDeathTimer = 10;
      }
    };
    _.aaOnDeath = function() {
      var ce;
      // * Сбрасываем таймер
      this._aaOnDeathTimer = null;
      if ($gameTemp.aaDeathCEExecuted === true) {
        return;
      }
      // * Если живой, то ничего, мало ли, вдруг воскресили
      if (this.AABattler().isAlive()) {
        return;
      }
      ce = AA.PP.getCommonEventOnPlayerDeath();
      // * Если задано общее событие, то выполнить его
      if (AAUtils.isValidCE(ce)) {
        AAUtils.startCE(ce);
        $gameTemp.aaDeathCEExecuted = true; // * Иначе Game Over Screen
      } else {
        SceneManager.goto(Scene_Gameover);
      }
    };
    //TODO: А что делать при анимации XAnima??? Надо возвращать из Dead при Revive potion
    //TODO: Сам на себе игрок не может использовать предмет Stimulant, поэтому пока пропуск
    return _.aaOnRevive = function() {
      this.aaClearMotion();
      $gameTemp.aaDeathCEExecuted = false;
      if (Imported.PKD_AnimaX) {
        this._aaAnimaXDeathPlayedFlag = false;
        this.aaUpdateABSAnimaX();
      }
      this.followers().aaOnPlayerRevive();
    };
  })();
  // * Переопределяем
  //$[OVER]
  _.aaGetExtendedHitBoxes = function() {
    if (this.isABS() && ($gameParty.leader() != null)) {
      return $gameParty.leader().aaGetExtendedHitBoxes();
    } else {
      return null;
    }
  };
  _.aaExecuteEncounter = function() {
    var e, spawnEvId;
    try {
      console.log(this._encounterCount);
      if (!$gameMap.isEventRunning() && this._encounterCount <= 0) {
        this.makeEncounterCount();
        spawnEvId = this.makeEncounterTroopId();
        if (spawnEvId <= 0) {
          return;
        }
        return $gameMap.aaExecuteEncounter(this.regionId(), spawnEvId);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //$[OVER]
  _._aaOnTeleportPerformed = function() {
    uAPI.resetMapScroll();
    return $gameTemp.clearDestination();
  };
  _.aaAfterLoad = function() {
    var e;
    try {
      if (this.aaIsDodging()) {
        return this.aaOnDodgeEnds();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startPerformAASkill, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  // * Выполнить атаку первичным навыком (в первой ячеке E)
  _.aaPerformPlayerAttack01 = function(isSmart = false) {
    //"ATTACK ONLY 01".p()
    return this.aaPerformAttack(true, isSmart);
  };
  // * Выполнить атаку вторичным навыком (во второй ячейке Q)
  _.aaPerformPlayerAttack02 = function(isSmart = false) {
    //"ATTACK ONLY 02".p()
    return this.aaPerformAttack(false, isSmart);
  };
  _.aaPerformAttack = function(isPrimary = true, isSmart = false) {
    var skillId, symbol;
    if (!$gamePlayer.canBeControlled()) {
      return;
    }
    if (isPrimary) {
      symbol = AA.Input.primarySkillSymbol();
    } else {
      symbol = AA.Input.secondarySkillSymbol();
    }
    skillId = this.aaSkillsSet.getSkillForSymbol(symbol);
    if (skillId <= 0) {
      return;
    }
    this.aaTurnTowardTouchInput();
    if (isSmart) {
      this.aaPerformSmartSkillUse(skillId, TouchInput.toMapPoint());
    } else {
      this.aaTryPerformSkill(skillId);
    }
  };
  // * Выполнить "умную" атаку (либо использовать навык, либо подойти ближе)
  _.aaPerformSmartSkillUse = function(skillId, point) {
    var e;
    try {
      if (skillId <= 0) {
        return;
      }
      //@_setAAStateToSmartSkillUse(skillId, point)
      //? Не состоянием, а просто
      if (AATargetsManager.isInSkillRange(this, skillId, point)) {
        this.aaTryPerformSkill(skillId);
      } else {
        $gameTemp.setDestination(point.x, point.y);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Главный метод по выполнению того или иного АБС навыка
  // * Навык должен быть у персонажа
  // * Чтобы выполнить навык, которого нет у персонажа, то можно поставить флаг forced = true
  _.aaTryPerformSkill = function(skillId, forced = false) {
    var e, skill;
    try {
      if (!AA.isABSActive()) {
        return;
      }
      if (skillId == null) {
        return;
      }
      if (skillId <= 0) {
        return;
      }
      if (this.aaInSkillCastingProcess()) {
        this.aaAbortSkillCastingProcess();
      }
      // * Выполняем навык в любом случае (даже если нету или не готов)
      if (forced === true) {
        skill = AASkill2.GetAASkillObject(skillId);
        if (!AASkill2.IsAAObject(skill)) {
          // * Только АБС навык можно выполнить через этот метод
          skill = null;
        }
      } else {
        // * Иначе навык должен быть готов к использованию и выучен
        skill = this.AABattler().getUsableAASkills().find(function(s) {
          return s.idA === skillId;
        });
      }
      if (skill != null) {
        // * Проверяем активный Skill Extension
        skill = this.AABattler().aaCheckAndApplySkillExtension(skill);
      }
      if (skill != null) {
        if (skill.AASkill.isNeedCasting() && this.isMoving()) {
          AA.UI.skillPerformResult(skillId, 0);
          return;
        }
        AA.UI.skillPerformResult(skillId, 1);
        //TODO: perform skill
        //"PERFROM SKILL ".p(skillId)
        //console.log(skill.name)
        //TODO: нормальный метод на баттлере (или персонаже)
        this.prepareAASkillToExecute(skill);
      } else {
        //TODO: Notify???
        AA.UI.skillPerformResult(skillId, 0);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  
  // * Подготовка навыка к выполнению (сюда передаётся базовый объект навыка)
  _.prepareAASkillToExecute = function(skill) {
    var e, point, targetPoint;
    //console.log("Use skill " + skill.name)
    //TODO: А если предмет???
    //TODO: Анимация навыка атаки
    this.onSkillTargetCancel();
    this.setActiveAASkill(skill.idA);
    skill = this.activeAASkill();
    // * Если навык работает по направлению точки (курсора)
    if (skill.isInPoint()) {
      // * Если надо выбирать зону, то выбор зоны
      if (skill.isNeedSelectZone()) {
        // * Сбор целей сразу в точке где сейчас курсор
        AATargetsManager.collectTargetsForPlayerSelector(this.activeAASkill());
        this._setAAStateToSelectSkillTarget();
      } else {
        point = TouchInput.toMapPoint();
        if (skill.isInstant() || skill.isInCertainPoint()) {
          // * Надо проверить находится ли точка в Range навыка
          if (AATargetsManager.isInSkillRange(this, this._activeAASkillId, point)) {
            this.startPerformAASkill(point);
          } else {
            // * NOTHING
            //TODO: Показать область range применения (моргнуть)
            //TODO: Написать Notify (small range)
            AA.UI.skillPerformResult(this._activeAASkillId, 0);
            this.setActiveAASkill(null);
          }
        } else {
          // * Направление по точке
          point.touchXY = {
            x: TouchInput.x,
            y: TouchInput.y
          };
          this.startPerformAASkill(point);
        }
      }
    } else {
      // * Передаём себя в качестве точки (direction == 0 - напрвление персонажа)
      targetPoint = this.toPoint();
      try {
        // * Если homing projectile, пытаемся передать цель под курсором
        if (skill.isHomingProjectile() && ($gameTemp._aaEventUnderCursor != null)) {
          targetPoint = $gameTemp._aaEventUnderCursor;
        }
        this.startPerformAASkill(targetPoint);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }
  };
  //@[ALIAS]
  ALIAS__startPerformAASkill = _.startPerformAASkill;
  _.startPerformAASkill = function() {
    ALIAS__startPerformAASkill.call(this, ...arguments);
    return this.aaSetPartyAIOnPlayerMadeActionFlag();
  };
  _.aaSetPartyAIOnPlayerMadeActionFlag = function() {
    if (!this.aaIsHaveAnyABSFollower()) {
      return;
    }
    $gameTemp._aaPartyAI_flag_playerMadeAction = this.activeAASkill().databaseId();
    // * Убираем флаг через время
    setTimeout((function() {
      return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp._aaPartyAI_flag_playerMadeAction = null : void 0;
    }), 1000);
  };
  // * Обновление навыков для панели задач (при смене лидера)
  // * Также выполняется начальная расстановка навыков
  _.aaRefreshABSSkillsForPanel = function() {
    var ref;
    if (this.AABattler() == null) {
      return;
    }
    if ((ref = this.aaSkillsSet) != null) {
      ref.setPlayerActorId();
    }
    AA.UI.refreshElement('skills');
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  // * Только атака по нажатию LMB или RMB в режиме поворота (Cntr зажата)
  //TODO: Plugin Parameter
  //TODO: Можно DYNAMIC сделать метод (т.е. если параметр отключён, занулить его)
  // см. AASystem -> applyParameters метод (в нём можно занулять)
  _.aaIsStaticAttackInRotation = function() {
    return this.aaInRotation === true && AA.Input.IsStaticAttackWhenRotating === true;
  };
  _._aaUpdatePlayerInput = function() {
    var e;
    if (!$gamePlayer.canBeControlled()) {
      return;
    }
    try {
      this._aaUpdateInput_Rotation();
      //TODO: Action Keys
      //@_aaUpdateInput_ActionKeys()
      this._aaUpdateInput_Dodge();
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  _._aaUpdateInput_Rotation = function() {
    // * Чтобы не поворачивался во время анимации, проверяем и canMove()
    this.aaInRotation = this.canMove() && Input.isPressed(AA.IKey.ROT);
    if (this.aaInRotation) {
      this.turnTowardCharacter(TouchInput.toMapPoint());
    }
  };
  _._aaUpdateInput_Dodge = function() {
    if (!AA.PP.isAllowDodge()) {
      return;
    }
    if (Input.isTriggered(AA.PP.getDodgeSettings().dodgeKey)) {
      if (this.aaIsCanDodgeNow()) {
        this.aaPerformDodge();
      }
    }
  };
  _._aaUpdateInput_ActionKeys = function() {
    if (Input.isTriggered(AA.IKey.REL)) {
      return;
    }
    //TODO: reload firearm
    if (Input.isTriggered(AA.IKey.CMD)) {

    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------
//TODO: AI command menu


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Screen.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__clear, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_Screen.prototype;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this, ...arguments);
    this.aaClearBloodSplatterEffect();
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this, ...arguments);
    this.aaUpdateBloodSplatterEffect();
  };
})();

// ■ END Game_Screen.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Screen.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Screen.prototype;
  _.aaIsNeedBSEffectShow = function() {
    return this._aaIsBSERequested === true;
  };
  _.aaClearBloodSplatterEffect = function() {
    var _aaBSSettings, e;
    try {
      if (!AA.PP.isShowBloodSplatterEffect()) {
        return;
      }
      this._aaBloodSEThread = new KDCore.TimedUpdate(30, _._aaUpdateBSEThread.bind(this));
      this._aaIsBSERequested = false;
      _aaBSSettings = AA.PP.getBloodSplatterEffectSettings();
      this._aaBSColor = KDCore.Color.FromHex(_aaBSSettings.BS_Color).ARR;
      this._aaBSColor[3] = _aaBSSettings.BS_Opacity;
      this._aaBSHPRate = _aaBSSettings.BS_HpRate / 100;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaBloodSEThread = null;
    }
  };
  _.onAfterLoad = function() {
    var e;
    try {
      return this.aaClearBloodSplatterEffect();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaOnBeforeSave = function() {
    this._aaBloodSEThread = null;
    return this._aaBloodSEThread2 = null;
  };
  _.aaUpdateBloodSplatterEffect = function() {
    var e, ref, ref1;
    if (this._aaBloodSEThread == null) {
      return;
    }
    try {
      if ((ref = this._aaBloodSEThread) != null) {
        ref.update();
      }
      return (ref1 = this._aaBloodSEThread2) != null ? ref1.update() : void 0;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this.aaClearBloodSplatterEffect();
    }
  };
  _._aaUpdateBSEThread = function() {
    var color, e;
    try {
      if (this.aaIsShouldShowBSEffectNow()) {
        this._aaRequestBloodSplatterEffect();
        if (this._aaBSColor != null) {
          if (this._aaBloodSEThread2 == null) {
            color = this._aaBSColor;
            this._aaBloodSEThread2 = new KDCore.TimedUpdate(20, function() {
              return $gameScreen.startFlash(color, 30);
            });
            this._aaBloodSEThread2.once();
          }
          if (!this._aaBloodSEThread2.isAlive()) {
            return this._aaBloodSEThread2 = null;
          }
        }
      } else {
        return this._aaStopBloodSplatterEffect();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e, 'Screen Blood Splatter - update');
      return this._aaBloodSEThread.stop();
    }
  };
  _.aaIsShouldShowBSEffectNow = function() {
    return ($gameParty.leader() != null) && $gameParty.leader().hpRate() <= this._aaBSHPRate && !$gameSystem.absBSEForceDisabled;
  };
  _._aaRequestBloodSplatterEffect = function() {
    return this._aaIsBSERequested = true;
  };
  _._aaStopBloodSplatterEffect = function() {
    return this._aaIsBSERequested = false;
  };
})();

// ■ END Game_Screen.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_System.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onAfterLoad, ALIAS__onBeforeSave, _;
  //@[DEFINES]
  _ = Game_System.prototype;
  //@[ALIAS]
  ALIAS__onBeforeSave = _.onBeforeSave;
  _.onBeforeSave = function() {
    var e;
    ALIAS__onBeforeSave.call(this, ...arguments);
    try {
      AA.System.onBeforeGameSave();
      return this.aaOnBeforeGameSaved();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  
  //@[ALIAS]
  ALIAS__onAfterLoad = _.onAfterLoad;
  _.onAfterLoad = function() {
    var e;
    ALIAS__onAfterLoad.call(this, ...arguments);
    try {
      AA.System.onGameLoaded();
      return this.aaOnGameLoaded();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_System.coffee
//---------------------------------------------------------------------------


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_System.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Game_System.prototype;
    //@[ALIAS]
    const ALIAS__onAfterLoad = _.onAfterLoad;
    _.onAfterLoad = function (...args) {
        ALIAS__onAfterLoad.call(this, ...args);
        AAMainGameLoopManager.onAfterGameLoad();
    };
    //@[ALIAS]
    const ALIAS__onBeforeSave = _.onBeforeSave;
    _.onBeforeSave = function (...args) {
        ALIAS__onBeforeSave.call(this, ...args);
        AAMainGameLoopManager.onBeforeGameSave();
    };
})();
// ■ END Game_System.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_System.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_System.prototype;
  _.aaInitSoundStore = function() {
    if (!this._aaSndStore) {
      return this._aaSndStore = {};
    }
  };
  _.aaSaveBgmState = function(name, pos) {
    $gameTemp.__lastSavedBgmStateName = name;
    this.aaInitSoundStore();
    this._aaSndStore[name] = pos;
  };
  _.aaLoadBgmState = function(name) {
    this.aaInitSoundStore();
    if (this._aaSndStore[name] != null) {
      return this._aaSndStore[name];
    }
  };
  _.aaStoreSuspendedMapBgm = function() {
    var e;
    try {
      this.__aaMapBgm = AudioManager.saveBgm();
      return this.__aaMapBgs = AudioManager.saveBgs();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.aaRestoreSuspendedMapBgm = function() {
    var e;
    try {
      if (this.__aaMapBgm != null) {
        AudioManager.replayBgm(this.__aaMapBgm);
      } else {
        AudioManager.stopBgm();
      }
      if (this.__aaMapBgs != null) {
        AudioManager.replayBgs(this.__aaMapBgs);
      }
      this.__aaMapBgs = null;
      return this.__aaMapBgm = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Game_System.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_System.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_System.prototype;
  (function() {    // * Дополнительные системы АБС (since 0.9)
    // -----------------------------------------------------------------------
    _.aaGetCustomGaugesSystem = function() {
      var e;
      try {
        if (this._aaCGS == null) {
          this._aaCGS = new AACustomGaugesSystem();
        }
        return this._aaCGS;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    _.aaUpdateSystems = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaBeforeMapLoaded = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaBeforeMapStopped = function() {
      var e;
      try {
        return this.aaGetCustomGaugesSystem().onBeforeMapStopped();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnMapLoaded = function() {
      var e;
      try {
        return this.aaGetCustomGaugesSystem().onMapLoaded();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.aaOnBeforeGameSaved = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.aaOnGameLoaded = function() {
      var e;
      try {

      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Пользовательские настройки интерфейса
    // -----------------------------------------------------------------------
    _.aaInitUserUISettings = function() {
      return this._aaUserUiSettings = new AAUserUISettings();
    };
    _.aaGetUserUISettings = function() {
      if (this._aaUserUiSettings == null) {
        this.aaInitUserUISettings();
      }
      return this._aaUserUiSettings;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * Состояние врагов (сохранение и загрузка здоровья)
    // -----------------------------------------------------------------------
    _.aaSaveEnemiesHpDataForMap = function(mapId, data) {
      if (this._aaEnemiesHPDataStored == null) {
        this._aaEnemiesHPDataStored = {};
      }
      this._aaEnemiesHPDataStored[mapId] = data;
    };
    _.aaGetEnemiesHpDataForMap = function(mapId) {
      if (this._aaEnemiesHPDataStored == null) {
        return null;
      }
      return this._aaEnemiesHPDataStored[mapId];
    };
  })();
})();

// ■ END Game_System.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setDestinationMVonly, _;
  if (AAUtils.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Game_Temp.prototype;
  // * В MV нет метода onMapTouch, делаем перехват только тут
  //@[ALIAS]
  ALIAS__setDestinationMVonly = _.setDestination;
  _.setDestination = function() {
    if ($gameTemp.__isFromMapTouchMethod === true) {
      $gameTemp.__isFromMapTouchMethod = false;
      if (AA.UI.isUITouched()) {
        return;
      }
      if (AA.isABSActive() && AAUtils.isSceneMap()) {
        SceneManager._scene.onMapTouchAA();
        return;
      }
    }
    ALIAS__setDestinationMVonly.call(this, ...arguments);
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setDestination, _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  //@[ALIAS]
  ALIAS__setDestination = _.setDestination;
  _.setDestination = function() {
    ALIAS__setDestination.call(this, ...arguments);
    // * Восстановить камеру при движении (если опция)
    this.aaResetMapScrollOnMoving();
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  (function() {    // * АИ обновление
    // -----------------------------------------------------------------------
    _._aaInitAILogicThreads = function() {
      if (this.__aaAILogicThreads == null) {
        return this.__aaAILogicThreads = {};
      }
    };
    _.aaRegisterAILogicThread = function(eventId) {
      var thread, time;
      //"THREAD REGISTERED FOR".p(eventId)
      this._aaInitAILogicThreads();
      time = AA.PP.getAIUpdateIntervalMS() || 100;
      if (time <= 0) {
        time = 1;
      }
      thread = setInterval((function() {
        var ev;
        if (!AA.isABSMap()) {
          return;
        }
        if (eventId > 0) {
          ev = $gameMap.event(eventId);
        } else {
          ev = $gamePlayer.followers().aaGetFollowerByCharId(eventId);
        }
        if (ev != null) {
          return ev.aaUpdateAILogic();
        } else {
          return $gameTemp.aaClearAILogicThread(eventId);
        }
      }), time);
      this.__aaAILogicThreads[eventId] = thread;
    };
    _.aaIsHaveAILogicThreadFor = function(eventId) {
      var e;
      try {
        this._aaInitAILogicThreads();
        return this.__aaAILogicThreads[eventId] != null;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    _.aaClearAILogicThread = function(eventId) {
      var thread;
      this._aaInitAILogicThreads();
      thread = this.__aaAILogicThreads[eventId];
      if (thread != null) {
        clearInterval(thread);
      }
      this.__aaAILogicThreads[eventId] = null;
    };
    return _.aaClearAllAILogicThreads = function() {
      var key, ref, value;
      if (this.__aaAILogicThreads == null) {
        return;
      }
      ref = this.__aaAILogicThreads;
      for (key in ref) {
        value = ref[key];
        this.aaClearAILogicThread(key);
      }
      this.__aaAILogicThreads = {};
    };
  })();
  (function() {    // * Камера
    // -----------------------------------------------------------------------
    _.aaSetMapScrolled = function(_aaIsScrollBeenApplied) {
      this._aaIsScrollBeenApplied = _aaIsScrollBeenApplied;
    };
    _.aaIsMapScrolled = function() {
      return this._aaIsScrollBeenApplied === true;
    };
    _.aaResetMapScrollOnAction = function() {
      // * Сброс камеры (если есть опция) при действии
      if ($gameTemp.aaIsMapScrolled() && AA.PP.getMapScrollingSettings().resetOnAction === true) {
        uAPI.resetMapScroll();
      }
    };
    return _.aaResetMapScrollOnMoving = function() {
      // * Восстановить камеру при движении (если опция)
      if (this.aaIsMapScrolled() && AA.PP.getMapScrollingSettings().resetOnMove === true) {
        uAPI.resetMapScroll();
      }
    };
  })();
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var GaugeController;
  // * Общий контроллер для Sprite_UIGauge (HP, MP, TP, ...)
  //?rev 03.07.21
  GaugeController = class GaugeController extends AA.UIElementController {
    constructor(gaugeSprite) {
      super();
      this.gaugeSprite = gaugeSprite;
    }

    
      // * source - Game_Battler
    // * valueFieldName - название поля (hp)
    //$[OVER]
    setup(source, valueFieldName, maxValueFieldName) {
      this.source = source;
      this.valueFieldName = valueFieldName;
      this.maxValueFieldName = maxValueFieldName;
      this.value = 0;
      this.max = 0;
      this.createThread(10, 4);
    }

    
      // * 0 - value (100), 1 - % (100%), 2 - full (100 / 100)
    setValueTextType(valueTextType) {
      switch (valueTextType) {
        case 1:
          this.getTypedText = this.getValuePercentText;
          break;
        case 2:
          this.getTypedText = this.getValueAndMaxText;
          break;
        default:
          this.getTypedText = this.getValueText;
      }
    }

    refreshGauge() {
      var e;
      if (this.gaugeSprite == null) {
        return;
      }
      try {
        this._refreshValues();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        // * Останавливаем работу метода
        this.refreshGauge = function() {};
      }
    }

    //?DYNAMIC
    // * Этот метод используется чтобы получить текст исходя из настроек контроллера
    // * По стандарту - обычное значение
    getTypedText() {
      return this.getValueText();
    }

    getValueText() {
      return this.value;
    }

    getValueAndMaxText() {
      return this.value + " / " + this.max;
    }

    getValuePercentText() {
      return Math.round((this.value / this.max) * 100) + '%';
    }

  };
  AA.link(GaugeController);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.GaugeController.prototype;
  //$[OVER]
  _._refresh = function() {
    var sourceMaxValue, sourceValue;
    sourceValue = this.source[this.valueFieldName];
    sourceMaxValue = this.source[this.maxValueFieldName];
    // * Перерисовываем только если значния изменились
    if (this.value !== sourceValue || this.max !== sourceMaxValue) {
      this.value = sourceValue;
      this.max = sourceMaxValue;
      this.refreshGauge();
    }
  };
  _._refreshValues = function() {
    this.gaugeSprite.drawGauge(this.value / this.max);
    this.gaugeSprite.drawText(this.getTypedText());
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------




// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ImageManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = ImageManager;
  _.loadAA = function(filename) {
    return this.loadBitmap('img/Alpha/', filename);
  };
  _.loadAAWeaponMotion = function(filename) {
    return this.loadBitmap('img/weaponsAA/', filename);
  };
})();

// ■ END ImageManager.coffee
//---------------------------------------------------------------------------












// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ MATH.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------

// * Вспомогательные функции математических вычислений
AA.Utils.Math = function() {};

(function() {
  var _;
  //@[DEFINES]
  _ = AA.Utils.Math;
  // * Получить дистанцию между игроком и точкой (в масштабах карты)
  _.getDistanceToPlayerFrom = function(point) {
    var e;
    try {
      return $gameMap.distance($gamePlayer.x, $gamePlayer.y, point.x, point.y);
    } catch (error) {
      e = error;
      AA.warning(e);
      return 0;
    }
  };
  _.rotateDirsRelativeTo = function(dirSet, direction) {
    var d, e, k, l, len1, len2, rotated;
    try {
      // * Initial 2 (down)
      if ([1, 2, 3].contains(direction)) {
        return dirSet;
      }
      rotated = [];
      // * Reverse
      if ([7, 8, 9].contains(direction)) {
        for (k = 0, len1 = dirSet.length; k < len1; k++) {
          d = dirSet[k];
          rotated.push(10 - d);
        }
        return rotated;
      }
      // * Matrix 90,-90 rotation
      if ([4, 6].contains(direction)) {
        for (l = 0, len2 = dirSet.length; l < len2; l++) {
          d = dirSet[l];
          rotated.push(this.rotateDirectionByDirection(d, direction));
        }
        return rotated;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return dirSet;
  };
  // * Matrix Rotation 90 or -90 degress, just write it static, without calculations
  _.rotateDirectionByDirection = function(d, byDir) {
    var e;
    try {
      switch (byDir) {
        case 6:
          switch (d) {
            case 1:
              return 3;
            case 2:
              return 6;
            case 3:
              return 9;
            case 6:
              return 8;
            case 9:
              return 7;
            case 8:
              return 4;
            case 7:
              return 1;
            case 4:
              return 2;
          }
          break;
        case 4:
          switch (d) {
            case 1:
              return 7;
            case 2:
              return 4;
            case 3:
              return 1;
            case 6:
              return 2;
            case 9:
              return 3;
            case 8:
              return 6;
            case 7:
              return 9;
            case 4:
              return 8;
          }
          break;
        default:
          return d;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return d;
  };
  _.getProjectilePointByDirection = function(startPoint, d) {
    var diagTable, e, horVer, px, py, x, y;
    try {
      //"START POINT".p()
      //console.info(startPoint)
      ({x, y} = startPoint);
      //"FACE DIRECTION".p()
      // * Диагональное направление 8
      if ([1, 3, 7, 9].contains(d)) {
        diagTable = {
          1: [4, 2],
          3: [6, 2],
          7: [4, 8],
          9: [6, 8]
        };
        horVer = diagTable[d];
        px = $gameMap.roundXWithDirection(x, horVer[0]);
        py = $gameMap.roundYWithDirection(y, horVer[1]);
      } else {
        // * Обычное направление 4
        px = $gameMap.xWithDirection(x, d);
        py = $gameMap.yWithDirection(y, d);
      }
      return new KDCore.Point(px, py);
    } catch (error) {
      e = error;
      return KDCore.Point.Empty;
    }
  };
  _.getLeftAndRightPoints = function(x, y, d) {
    var e, points;
    try {
      points = [];
      switch (d) {
        case 4:
        case 6:
          points.push({
            x,
            y: y + 1
          });
          points.push({
            x,
            y: y - 1
          });
          break;
        case 8:
        case 2:
          points.push({
            x: x - 1,
            y
          });
          points.push({
            x: x + 1,
            y
          });
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return points;
  };
  _.getNeibPoints = function(x, y, d) {
    var e, points;
    try {
      points = [];
      switch (d) {
        case 4:
        case 6:
        case 2:
        case 8:
          return this.getLeftAndRightPoints(x, y, d);
        case 7:
          points.push({
            x: x + 1,
            y
          });
          points.push({
            x,
            y: y + 1
          });
          break;
        case 9:
          points.push({
            x: x - 1,
            y
          });
          points.push({
            x,
            y: y + 1
          });
          break;
        case 1:
          points.push({
            x: x + 1,
            y
          });
          points.push({
            x,
            y: y - 1
          });
          break;
        case 3:
          points.push({
            x: x - 1,
            y
          });
          points.push({
            x,
            y: y - 1
          });
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return points;
  };
  //Функция принимает шесть аргументов: три координаты вершин треугольника (x1, y1, x2, y2, x3, y3)
  // и координату, которую нужно проверить на вхождение в треугольник (x, y).
  //Функция возвращает true, если координата находится внутри треугольника
  //@[by CHAT GPT]
  _.isPointInsideTriangle = function(p1, p2, p3, targetPoint) {
    var a, a1, a2, a3, e, x, x1, x2, x3, y, y1, y2, y3;
    try {
      x1 = p1.x;
      x2 = p2.x;
      x3 = p3.x;
      y1 = p1.y;
      y2 = p2.y;
      y3 = p3.y;
      ({x, y} = targetPoint);
      // Вычисляем площади треугольника
      a = Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);
      // Вычисляем площади треугольников, образованных с заданной координатой
      a1 = Math.abs((x * (y2 - y3) + x2 * (y3 - y) + x3 * (y - y2)) / 2);
      a2 = Math.abs((x1 * (y - y3) + x * (y3 - y1) + x3 * (y1 - y)) / 2);
      a3 = Math.abs((x1 * (y2 - y) + x2 * (y - y1) + x * (y1 - y2)) / 2);
      // Если сумма площадей равна площади треугольника, то координата находится внутри треугольника
      return (a1 + a2 + a3) === a;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
  // Возвращает координаты вершин треугольника (3 точки)
  _.getTriangleVertixes = function(x, y, d, len, triangleSize) {
    var e, points;
    try {
      points = [];
      points.push({x, y});
      switch (d) {
        case 8:
          points.push({
            x: x - triangleSize,
            y: y - len
          });
          points.push({
            x: x + triangleSize,
            y: y - len
          });
          break;
        case 4:
          points.push({
            x: x - len,
            y: y + triangleSize
          });
          points.push({
            x: x - len,
            y: y - triangleSize
          });
          break;
        case 6:
          points.push({
            x: x + len,
            y: y + triangleSize
          });
          points.push({
            x: x + len,
            y: y - triangleSize
          });
          break;
        case 2:
          points.push({
            x: x - triangleSize,
            y: y + len
          });
          points.push({
            x: x + triangleSize,
            y: y + len
          });
          break;
        default:
          return false;
      }
      return points;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _.getPointInRadius = function(x, y, radius) {
    var angle, e, newX, newY;
    try {
      if (radius == null) {
        return KDCore.Point.Empty;
      }
      if (radius <= 0) {
        return new KDCore.Point(x, y);
      }
      angle = Math.random() * 2 * Math.PI;
      radius = Math.randomInt(radius - 1) + 1;
      newX = Math.round(radius * Math.cos(angle));
      newY = Math.round(radius * Math.sin(angle));
      return new KDCore.Point(x + newX, y + newY);
    } catch (error) {
      e = error;
      KDCore.warning('Utils.Math.getPointInRadius', e);
      return KDCore.Point.Empty;
    }
  };
  // All in Radius (expect center)
  //@[by CHAT GPT]
  _.getPointsInRadius = function(x, y, radius) {
    var e, i, j, k, l, points, ref, ref1, ref2, ref3;
    try {
      if (radius == null) {
        return [];
      }
      if (radius <= 1) {
        return [];
      }
      points = [];
      for (i = k = ref = x - radius, ref1 = x + radius; (ref <= ref1 ? k <= ref1 : k >= ref1); i = ref <= ref1 ? ++k : --k) {
        for (j = l = ref2 = y - radius, ref3 = y + radius; (ref2 <= ref3 ? l <= ref3 : l >= ref3); j = ref2 <= ref3 ? ++l : --l) {
          if (Math.sqrt((i - x) ** 2 + (j - y) ** 2) <= radius) {
            points.push({
              x: i,
              y: j
            });
          }
        }
      }
      points = points.filter(function(p) {
        return p.x !== x && p.y !== y;
      });
      return points;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // * Точки на краю круга только
  _.getPointsOutRadius = function(x, y, radius) {
    var e, points;
    try {
      points = this.getPointsInRadius(x, y, radius + 1);
      return points.filter(function(p) {
        return AAMath.distanceXY(x, y, p.x, p.y) > radius;
      });
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  // Square around X,Y (8 points)
  //@[by CHAT GPT]
  _.getAdjacentPoints = function(x, y) {
    var e, i, j, k, l, points;
    try {
      points = [];
      for (i = k = -1; k <= 1; i = ++k) {
        for (j = l = -1; l <= 1; j = ++l) {
          if (i !== 0 || j !== 0) {
            points.push({
              x: x + i,
              y: y + j
            });
          }
        }
      }
      return points;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return [];
    }
  };
  _.getNextPointByDirection = function(sx, sy, d) {
    var e;
    try {
      switch (d) {
        case 1:
          sx -= 1;
          sy += 1;
          break;
        case 2:
          sy += 1;
          break;
        case 3:
          sx += 1;
          sy += 1;
          break;
        case 4:
          sx -= 1;
          break;
        case 6:
          sx += 1;
          break;
        case 7:
          sx -= 1;
          sy -= 1;
          break;
        case 8:
          sy -= 1;
          break;
        case 9:
          sx += 1;
          sy -= 1;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return {
      x: sx,
      y: sy
    };
  };
})();

// ■ END MATH.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс которые работает с параметрами плагина
(function() {
  var ParamsManager;
  ParamsManager = class ParamsManager extends KDCore.ParamLoader {
    constructor() {
      super("AABSZ");
      this._prepareParameters();
      return;
    }

    // * Данный метод надо вызывать когда игра уже загружена (доступны $gameX объекты)
    applyParameters() {
      if (this.getMapScrollingSettings().isEnabled === false) {
        // * Отключение Scroll камеры, если не задан параметр
        uAPI.disableMapScroll();
      }
    }

    // * ABS SYSETM
    // -----------------------------------------------------------------------
    fonts() {
      return this.getParam("fonts", []);
    }

    isGlobalUserUISettings() {
      return this.getParam("isSaveUIEditsGlobal", false);
    }

    uiData(tag, arg) {
      var method;
      // * Поиск соответсвующих настроек по тэгу элемента
      method = "_getDefaultVisualFor_" + tag;
      if (this[method] != null) {
        return this[method](arg);
      }
      return null;
    }

    // * POP UP
    // -----------------------------------------------------------------------
    isPopUpIsActive() {
      return this.getParam("isShowPopUp", true);
    }

    getTextForPopUpMiss() {
      return this.getParam("popUpTextForMiss", "Miss");
    }

    getExpPopUpSettings() {
      return this.getParam("popUpExpSettings", {
        active: true,
        textFormat: "+%1 exp",
        styleId: "Experience",
        aboveChar: false,
        bindToChar: false
      });
    }

    getGoldPopUpSettings() {
      return this.getParam("popUpGoldSettings", {
        textFormat: "%2%1",
        popUpStyle: {
          id: "gold",
          randDX: 15,
          randDY: 10,
          stayTime: 12,
          noFlyUp: false,
          noFadeOut: false,
          changeFontSize: 16,
          text: {
            visible: true,
            size: {
              w: 0,
              h: 0 // * not used
            },
            margins: {
              x: 0,
              y: 0
            },
            alignment: "right",
            outline: {
              color: null,
              width: 2
            },
            font: {
              face: "AABS_3",
              size: 12,
              italic: false
            },
            textColor: "#e6c42e"
          },
          image: {
            name: "goldPopUpIcon",
            margins: {
              x: 26,
              y: 0
            },
            fadeInSpeed: 20
          }
        },
        bindToChar: false
      });
    }

    //TODO: Всплывающий урон вынести в отдельный плагин
    getPopUpDamageSettings(id) {
      var data, settings;
      settings = this.getParam("popUpDamageTable", []);
      data = settings.getById(id);
      if (data != null) {
        return data;
      } else {
        // * Gold have own default settings (in other parameter)
        // * Потому что золото было позже добавлено
        if (id === 'gold') {
          return this.getGoldPopUpSettings().popUpStyle;
        } else {
          return {
            id: "default",
            randDX: 15,
            randDY: 10,
            stayTime: 12,
            noFlyUp: false,
            noFadeOut: false,
            changeFontSize: 22,
            text: {
              visible: true,
              size: {
                w: 0,
                h: 0 // * not used
              },
              margins: {
                x: 0,
                y: 0
              },
              alignment: "center",
              outline: {
                color: null,
                width: 2
              },
              font: {
                face: "AABS_3",
                size: 18,
                italic: false
              },
              textColor: "#E6E6E6".toCss()
            },
            image: null
          };
        }
      }
    }

    // * BUFFS AND STATES
    // -----------------------------------------------------------------------
    getIsBuffsVisible() {
      return this.getParam("isShowBuffsOnUI", true);
    }

    getIsStatesVisible() {
      return this.getParam("isShowStatsOnUI", true);
    }

    getUIActorBuffsIconsSet() {
      return this.getParam("buffsIconsPositions", [
        {
          x: 4,
          y: 4
        },
        {
          x: 42,
          y: 4
        },
        {
          x: 80,
          y: 4
        },
        {
          x: 118,
          y: 4
        }
      ]);
    }

    getUIActorStatesIconsSet() {
      return this.getParam("statesIconsPositions", [
        {
          x: 4,
          y: 40
        },
        {
          x: 42,
          y: 40
        },
        {
          x: 80,
          y: 40
        },
        {
          x: 118,
          y: 40
        }
      ]);
    }

    getUIEnemyStatesIconsSet() {
      return this.getParam("statesIconsPositionsForEnemy", [
        {
          x: 8,
          y: 64
        },
        {
          x: 28,
          y: 64
        },
        {
          x: 48,
          y: 64
        },
        {
          x: 68,
          y: 64
        }
      ]);
    }

    getUIEnemyStateIconOnUIScale() {
      return this.getParam("stateIconsScaleOnEnUI", 0.6);
    }

    getIsStateIconVisibleAbovePlayer() {
      return this.getParam("isShowStateIconAbvPl", false);
    }

    getIsStateIconVisibleAboveEnemy() {
      return this.getParam("isShowStateIconAbvEnms", true);
    }

    getIsStateIconVisibleAboveAlly() {
      return this.getParam("isShowStateIconAbvAls", true);
    }

    getStateIconOffsets() {
      return this.getParam("stateIconsMargins", {
        x: 0,
        y: -64
      });
    }

    getStateIconScale() {
      return this.getParam("stateIconsScale", 0.7);
    }

    // * Игрок и партия
    // -----------------------------------------------------------------------
    // * Тряска экрана когда игрок получил урон
    isShakeScreenWhenPlayerGetDamage() {
      return this.getParam("isShakeScreenWhenPlayerGetDamage", true);
    }

    // * Эффект экрана при низком значении HP
    isShowBloodSplatterEffect() {
      return this.getParam("isShowBloodSplatterEffect", true);
    }

    getBloodSplatterEffectSettings() {
      return this.getParam("boolSplatterEffectSettings", {});
    }

    // * Общее событие, когда игрок погибает
    getCommonEventOnPlayerDeath() {
      return this.getParam("commonEventOnPlayerDeath", 0);
    }

    // * Режим Dead Motion, когда игрок погибает
    // * 0 - none, 1 - always, 2 - ifNoAnimaX
    getShowDeadMotionOnDeathType() {
      return this.getParam("characterDeadMotionType", 2);
    }

    // * Использовать кастомный Level Up Notification
    isUseCustomLevelUp() {
      return this.getParam("isUseCustomLevelUp", true);
    }

    getCustomLevelUpSettings() {
      return this.getParam("customLevelUpSettings", {
        databaseAnimationId: 0,
        imageSeqAnimationName: "",
        imageSeqAnimationMargins: {
          x: 0,
          y: 0
        },
        extraSE: "",
        isShowPopUp: true,
        popUpText: "Level %1!",
        popUpStyle: {
          id: "levelUp",
          randDX: 0,
          randDY: 10,
          stayTime: 12,
          noFlyUp: false,
          noFadeOut: false,
          changeFontSize: 16,
          text: {
            visible: true,
            size: {
              w: 60,
              h: 20
            },
            margins: {
              x: 0,
              y: 0
            },
            alignment: "center",
            outline: {
              color: null,
              width: 2
            },
            font: {
              face: "AABS_3",
              size: 12,
              italic: false
            },
            textColor: "#deb521"
          },
          image: null
        },
        commonEvent: 0,
        scriptAction: "" // * Относительно персонажа
      });
    }

    // * Враги
    // -----------------------------------------------------------------------
    getSpawnMapId() {
      return this.getParam("enemies_spawn_mapId", 0);
    }

    isCanSpawnAboveEvents() {
      return this.getParam("enemies_spawn_aboveEvents", false);
    }

    isSpawnRegionCacheAllowed() {
      return this.getParam("enemies_spawn_cacheAllowed", true);
    }

    getSpawnPointSettings(id) {
      return this.getSpawnPoints().getById(id);
    }

    getSpawnPoints() {
      return this.getParam("spawn_points", []);
    }

    //getMapEncounterSpawnMode: -> #TODO:
    // * Never (using as default battle system)
    // * Only if ABS is ON
    // * Always ABS enemies
    //TODO: Map Encounters - отдельный пласт

      // * Глобальные непроходимые участки карты для визоров
    getVisionRestrictedRegions() {
      return this.getParam("enemies_noPassVision", []);
    }

    getVisionRestrictedTerrains() {
      return this.getParam("enemies_noPassVision2", []);
    }

    getAfterDeathBonuses() {
      return this.getParam("enemies_afterDeathBonuses", [
        {
          image: "bonusGreen",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "",
          hpGainE: 25,
          mpGainE: 0,
          expGainE: 0,
          goldGainE: 0
        },
        {
          image: "bonusBlue",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "", //AScript
          hpGainE: 0, //@[EVal]
          mpGainE: 25, //@[EVal]
          expGainE: 0, //@[EVal]
          goldGainE: 0 //@[EVal]
        },
        {
          image: "bonusYellow",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "", //AScript
          hpGainE: 0, //@[EVal]
          mpGainE: 0, //@[EVal]
          expGainE: 0, //@[EVal]
          goldGainE: 50 //@[EVal]
        },
        {
          image: "bonusRed",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "", //AScript
          hpGainE: 0, //@[EVal]
          mpGainE: 0, //@[EVal]
          expGainE: 10, //@[EVal]
          goldGainE: 0 //@[EVal]
        },
        {
          image: "bonusRed",
          actionSE: "",
          spawnSE: "",
          startOffsetRadiusInPx: 16,
          stayFrames: 12,
          flySpeed: 8,
          actionSA: "ba_1", //AScript
          hpGainE: 0, //@[EVal]
          mpGainE: 0, //@[EVal]
          expGainE: 0, //@[EVal]
          goldGainE: 0 //@[EVal]
        }
      ]);
    }

    getAfterDeathBonus(index) {
      var bonuses, e;
      try {
        if (index <= 0) {
          return null;
        }
        bonuses = this.getAfterDeathBonuses();
        // * Iterate from 1 in game!
        return bonuses[index - 1];
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    }

    // * Карта
    // -----------------------------------------------------------------------

      // * Настройки для скролла карты курсором
    getMapScrollingSettings() {
      return this.getParam("mapScrolling", {
        isEnabled: false
      });
    }

    getMiniHpGaugeSettings() {
      return this.getParam("miniHpGaugeSetings", {
        active: true,
        showOnlyOnHover: true,
        showOnDamage: true,
        showWhenNotFull: false
      });
    }

    getAnimationAutoScallingFactor() {
      return this.getParam("mvAnimationAutoScalling", 0.5);
    }

    // * Панель навыков
    // -----------------------------------------------------------------------

      // * Добавлять автоматически новый навык на панель навыков при изучении навыка
    isAddNewSkillsOnPanelOnLearning() {
      return this.getParam("isAddNewSkillsOnPanelOnLearning", true);
    }

    // * Добавлять автоматически АБС предметы на панель навыков
    isAddNewItemOnPanelOnPickup() {
      return this.getParam("isAddNewItemOnPanelOnPickup", true);
    }

    // * Удалять предмет из панели навыков, если количество == 0
    isRemoveItemIfZeroCount() {
      return this.getParam("isRemoveItemFromPanelIfZeroCount", false);
    }

    // * Эффект подсветки слотов навыков на панели
    isUseOutlineEffect() {
      return this.getParam("isUseOutlineEffect", true);
    }

    getSkillPanelItemVisualSettings() { //TODO:
      return {};
    }

    
      // * Все слоты панели навыков
    getUISkillsItems() {
      return this._skillPanelSlots || [];
    }

    // * Настройки слота навыка по его символу
    getUISkillItemSlotSettings(symbol) {
      var items, settings;
      items = this.getUISkillsItems();
      settings = items.getByField('symbol', symbol);
      return settings;
    }

    // * Сетевой режим
    // -----------------------------------------------------------------------
    isNetworkPvPGame() {
      return this.getParam("netGameMode", 'PvE') === 'PvP';
    }

    getCommonEventOnPlayerDeadInPvP() {
      return this.getParam("netPvPKilledCE", 0);
    }

  };
  AA.link(ParamsManager);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.ParamsManager.prototype;
  // * Данный метод вызывается при старте системы, $game объекты ещё не доступны
  // * Например для конвертирования каких-либо значений
  _._prepareParameters = function() {
    // * Если эффект отключён, заменяем класс на класс заглушку
    if (this.isUseOutlineEffect() === false) {
      AA.Sprite_SkillPanelOutline = AA.Sprite_SkillPanelOutlineDummy;
    }
    // * Собираем все слоты в один массив
    this._collectAllSkillSlots();
  };
  _._collectAllSkillSlots = function() {
    var primary, secondary, slots;
    primary = this._getPrimarySkillSlot();
    secondary = this._getSecondarySkillSlot();
    slots = this._getSkillSlots();
    this._skillPanelSlots = [primary, secondary, ...slots];
  };
  _._getPrimarySkillSlot = function() {
    return this.getParam("primaryAttackSlot", {
      position: {
        x: 218,
        y: 583
      },
      symbol: "E"
    });
  };
  _._getSecondarySkillSlot = function() {
    return this.getParam("secondaryAttackSlot", {
      position: {
        x: 255,
        y: 583
      },
      symbol: "Q"
    });
  };
  _._getSkillSlots = function() {
    return this.getParam("allSkillSlots", [
      {
        position: {
          x: 302,
          y: 583
        },
        symbol: "1"
      },
      {
        position: {
          x: 339,
          y: 583
        },
        symbol: "2"
      },
      {
        position: {
          x: 376,
          y: 583
        },
        symbol: "3"
      },
      {
        position: {
          x: 413,
          y: 583
        },
        symbol: "4"
      },
      {
        position: {
          x: 450,
          y: 583
        },
        symbol: "5"
      },
      {
        position: {
          x: 487,
          y: 583
        },
        symbol: "6"
      },
      {
        position: {
          x: 524,
          y: 583
        },
        symbol: "7"
      },
      {
        position: {
          x: 561,
          y: 583
        },
        symbol: "8"
      }
    ]);
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ParamsManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _;
  // * Базовые настройки элементов интерфейса
  // * Эти настройки используется BASIC версия плагина

  //@[DEFINES]
  _ = AA.ParamsManager.prototype;
  _.isAllowDodge = function() {
    return this.getParam("isAllowDodge", true);
  };
  _.getDodgeSettings = function() {
    return this.getParam("dodgeSettings", {
      dodgeKey: 'f',
      dodgeSwitch: 0, // * If false -> can't dodge now!
      isInvincible: true,
      stepsCount: 2, // * 1 or 2
      delayBetweenStepMS: 100,
      dodgeMoveSpeed: 5,
      dodgeRestVariable: 0,
      dodgeRestTimerFrames: 30
    });
  };
  _.getAIUpdateIntervalMS = function() {
    return this.getParam("enemyAIUpdateThreadMS", 100);
  };
  _.getAIVisionUpdateIntervalFR = function() {
    return this.getParam("enemyAIUpdateVisionIntervalFR", 4);
  };
  _.getPartyExpGainMode = function() {
    return this.getParam("partyExpGainMode", "player");
  };
  _.getDefaultBattleBgm = function() {
    return this.getParam("defaultBattleAutoBgm", {
      name: "",
      delay: 0.5
    });
  };
  _.getCustomGauges = function() {
    return this.getParam("customGaugesSet", []);
  };
  _.getCustomGaugeById = function(gaugeId) {
    var e, gaugeSettings;
    try {
      gaugeSettings = this.getCustomGauges().find(function(item) {
        return item.id === gaugeId;
      });
      if (gaugeSettings != null) {
        gaugeSettings.visible = true;
      }
      return gaugeSettings;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ParamsManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _;
  // * Базовые настройки элементов интерфейса
  // * Эти настройки используется BASIC версия плагина

  //@[DEFINES]
  _ = AA.ParamsManager.prototype;
  // * HP
  _._getDefaultVisualFor_hpGauge = function() {
    return this.getParam("playerHpGaugeVisualSettings", {
      visible: true,
      position: {
        x: 304,
        y: 560
      },
      label: "Player_HPGaugeLabel",
      labelMargins: {
        x: -33,
        y: 5
      },
      isCanBeEdited: true,
      isHideWithMessage: true,
      text: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 10,
          y: 0
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_HPGauge",
        foreground: "",
        mask: "",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      }
    });
  };
  // * MP
  _._getDefaultVisualFor_mpGauge = function() {
    return this.getParam("playerMpGaugeVisualSettings", {
      visible: true,
      position: {
        x: 454,
        y: 560
      },
      label: "Player_MPGaugeLabel",
      labelMargins: {
        x: -37,
        y: 5
      },
      isCanBeEdited: true,
      isHideWithMessage: true,
      text: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 10,
          y: 0
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_MPGauge",
        foreground: "",
        mask: "",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      }
    });
  };
  // * TP
  _._getDefaultVisualFor_tpGauge = function() {
    return this.getParam("playerTpGaugeVisualSettings", {
      visible: false,
      position: {
        x: 454,
        y: 560
      },
      label: "Player_TPGaugeLabel",
      labelMargins: {
        x: -37,
        y: 5
      },
      isCanBeEdited: true,
      isHideWithMessage: true,
      text: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 10,
          y: 0
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_TPGauge",
        foreground: "",
        mask: "",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      }
    });
  };
  // * EXP
  _._getDefaultVisualFor_expGauge = function() {
    return this.getParam("playerExpGaugeVisualSettings", {
      visible: true,
      position: {
        x: 273,
        y: 528
      },
      label: "",
      labelMargins: {
        x: 0,
        y: 0
      },
      isCanBeEdited: true,
      isHideWithMessage: true,
      text: {
        visible: false,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 10,
          y: 0
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_ExpGauge",
        foreground: "Player_EXPGaugeForeground",
        mask: "Player_EXPGaugeMask",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      }
    });
  };
  // * ENEMY MINI HP
  // * Враги имееют параметр miniHpGaugeStyle, поэтому поддерживается выбор из массива настроек
  _._getDefaultVisualFor_enemyMiniHp = function(styleId) {
    var data, item;
    if ((styleId != null) && String.any(styleId) && AA.isPro()) {
      data = this.getParam("enemyMiniHpGaugesCustoms", []);
      item = data.getById(styleId);
      if (item != null) {
        return item.gauge; // * Стандартный
      } else {
        AA.w("Enemy Mini HP gauge style ID " + styleId + " not defined in Plugin Parameters");
        return this._getDefaultVisualFor_enemyMiniHp(null);
      }
    } else {
      // * Стандартная настройка
      return this.getParam("enemyMiniHpGaugeSettings", {
        visible: true,
        position: {
          x: -19,
          y: -56
        },
        label: null,
        labelMargins: {
          x: 0,
          y: 0
        },
        // * TEXT не используется в этой реализации
        text: {
          visible: false,
          size: {
            w: 100,
            h: 20
          },
          alignment: "left",
          font: {
            face: "AABS_0",
            size: 13,
            italic: false
          },
          margins: {
            x: 10,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#edead8".toCss()
        },
        gauge: {
          visible: true,
          fill: "Event_HPGauge2",
          foreground: "",
          mask: "",
          backColor: "#000000".toCss(),
          backOpacity: 160,
          vertical: false
        }
      });
    }
  };
  // * Иконка для бафов
  _._getDefaultVisualFor_actorBuffIcon = function() {
    return this.getParam("buffIconSettings", {
      visible: true,
      position: {
        x: 0,
        y: 0
      },
      isCanBeEdited: true,
      textFormat: "%1", //%1 меняется на количество секунд
      textFormatA: "A:%1", //%1 меняется на количество действия до завершения состояния
      text: {
        visible: true,
        size: {
          w: 38,
          h: 14
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 16,
          italic: false
        },
        margins: {
          x: -2,
          y: -4
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#fafdec".toCss()
      },
      icon: {
        visible: true,
        index: 0,
        size: 32
      }
    });
  };
  // * Иконка для состояний (настройки аналогичные)
  _._getDefaultVisualFor_actorStateIcon = function() {
    return this.getParam("statsIconSettings", {
      visible: true,
      position: {
        x: 0,
        y: 0
      },
      isCanBeEdited: true,
      textFormat: "%1", //%1 меняется на количество секунд
      textFormatA: "A:%1", //%1 меняется на количество действия до завершения состояния
      text: {
        visible: true,
        size: {
          w: 38,
          h: 14
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 16,
          italic: false
        },
        margins: {
          x: -2,
          y: -4
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#fafdec".toCss()
      },
      icon: {
        visible: true,
        index: 0,
        size: 32
      }
    });
  };
  // * Слот навыка
  _._getDefaultVisualFor_skillSlot = function() {
    return this.getParam("skillSlotVisualSettings", {
      visible: true,
      isCanBeEdited: true,
      isHideWithMessage: true,
      outlineMargins: {
        x: -2,
        y: -2
      },
      iconMargins: {
        x: 2,
        y: 2
      },
      outlinePulseSpeed: 40,
      selectedOutlineColor: "#fcba03",
      clickedOutlineColor: "#0b03fc",
      readyOutlineColor: "#21b53c",
      badOutlineColor: "#d61a1a",
      icon: {
        visible: true,
        size: 32,
        index: 0
      },
      symbolText: {
        visible: true,
        size: {
          w: 20,
          h: 20
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 14,
          italic: false
        },
        margins: {
          x: 18,
          y: 22
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#e0cfbf".toCss()
      },
      timeText: {
        visible: true,
        size: {
          w: 32,
          h: 32
        },
        alignment: "center",
        font: {
          face: "AABS_1",
          size: 12,
          italic: false
        },
        margins: {
          x: 2,
          y: 2
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#fcba03".toCss()
      },
      countText: {
        visible: true,
        size: {
          w: 32,
          h: 32
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 12,
          italic: false
        },
        margins: {
          x: 0,
          y: -6
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#eb852d".toCss()
      }
    });
  };
  _._getDefaultVisualFor_enemyInfo = function() {
    return this.getParam("enemyInfoVisualSettings", {
      visible: true,
      position: {
        x: 640,
        y: 66
      },
      image: "Enemy_Background",
      isCanBeEdited: true,
      isHideWithMessage: true,
      nameFormat: "%1",
      levelFormat: "Lv. %1",
      hpTextFormat: "%1 / %2", // * %3 - Для процента, %1 - текущее, %2 - максимум
      nameText: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_2",
          size: 16,
          italic: false
        },
        margins: {
          x: 10,
          y: 6
        },
        outline: {
          color: null,
          width: 3
        },
        textColor: "#d05816".toCss()
      },
      hpText: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "left",
        font: {
          face: "AABS_0",
          size: 13,
          italic: false
        },
        margins: {
          x: 12,
          y: 28
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edead8".toCss()
      },
      levelText: {
        visible: true,
        size: {
          w: 100,
          h: 20
        },
        alignment: "right",
        font: {
          face: "AABS_1",
          size: 12,
          italic: false
        },
        margins: {
          x: 60,
          y: 4
        },
        outline: {
          color: null,
          width: 2
        },
        textColor: "#edeb6a".toCss()
      },
      gauge: {
        visible: true,
        fill: "Player_HPGauge",
        foreground: "",
        mask: "",
        backColor: "#000000".toCss(),
        backOpacity: 160,
        vertical: false
      },
      gaugeMargins: {
        x: 6,
        y: 28
      },
      face: {
        visible: true,
        faceName: "",
        faceIndex: 0,
        mirror: false,
        size: 74,
        margins: {
          x: 92,
          y: 10
        }
      },
      battleState: {
        visible: true,
        image: "Enemy_BattleState_Free",
        margins: {
          x: 142,
          y: 60
        }
      },
      foregroundImage: {
        visible: false,
        image: "",
        margins: {
          x: 0,
          y: 0
        }
      }
    });
  };
})();

// ■ END ParamsManager.coffee
//---------------------------------------------------------------------------




//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Boot.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Scene_Boot.prototype;
    //@[ALIAS]
    const ALIAS__start = _.start;
    _.start = function () {
        ALIAS__start.call(this);
        AAMainGameLoopManager.onAfterSceneBoot();
    };
})();
// ■ END Scene_Boot.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Boot.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__loadGameFonts, ALIAS__start, _;
  //@[DEFINES]
  _ = Scene_Boot.prototype;
  // * Загружаем и инициализируем систему АБС
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    AA.System.initSystem();
    if (KDCore.isMV()) {
      // * В MV нету метода loadGameFonts
      AA.System.loadFonts();
    }
  };
  //?MZ only
  // * Загрузка шрифтов системы АБС
  //@[ALIAS]
  ALIAS__loadGameFonts = _.loadGameFonts;
  _.loadGameFonts = function() {
    ALIAS__loadGameFonts.call(this);
    AA.System.loadFonts();
  };
  // * Начальная настройка (и сброс) системы АБС
  //@[ALIAS]
  ALIAS__start = _.start;
  _.start = function() {
    ALIAS__start.call(this);
    AA.System.onGameDataLoaded();
  };
})();

// ■ END Scene_Boot.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__processMapTouch, _;
  if (AAUtils.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Scene_Map.prototype;
  //@[ALIAS]
  ALIAS__processMapTouch = _.processMapTouch;
  _.processMapTouch = function() {
    $gameTemp.__isFromMapTouchMethod = true;
    ALIAS__processMapTouch.call(this, ...arguments);
    $gameTemp.__isFromMapTouchMethod = false;
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__checkGameover, ALIAS__create, ALIAS__createSpriteset, ALIAS__onMapLoaded, ALIAS__onMapTouch, ALIAS__stop, ALIAS__update, ALIAS__updateCallMenu, _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.test = function() {
    var i, j;
    console.log("Scene_Map");
    for (i = j = 5; j <= 44; i = ++j) {
      //$gameMap.event(i)?.aaMakePathToCharacter($gamePlayer)
      $gameMap.event(i)._testSmartPath = true;
    }
  };
  //@[ALIAS]
  ALIAS__create = _.create;
  _.create = function() {
    ALIAS__create.call(this);
    AA.EV.subscribeFor("ABSPartyLeaderReady", this.gev_onABSPartyLeaderReady.bind(this));
    AA.EV.subscribeFor("ABSPartyLeaderNone", this.removeABSUI.bind(this));
  };
  //@[ALIAS]
  ALIAS__onMapLoaded = _.onMapLoaded;
  _.onMapLoaded = function() {
    ALIAS__onMapLoaded.call(this);
    AA.System.onMapSceneLoaded();
    this.aaCreateMouseDetectionThread();
    this.aaInitMapScrollSystem();
    this.aaRestoreEnemiesHp();
    this.aaRefreshPartyABSMembers();
    // * Небольшая задержка на приём визуальных эффектов от сервера
    AAUtils.callDelayed(function() {
      return $gameTemp._aaCanReceiveVisualFromServer = true;
    }, 100);
  };
  //@[ALIAS]
  // * Создаём интерфейс боевой системы
  ALIAS__createSpriteset = _.createSpriteset;
  _.createSpriteset = function() {
    ALIAS__createSpriteset.call(this);
    this._aaUILayer = new Sprite();
    this.addChild(this._aaUILayer);
  };
  //@[ALIAS]
  ALIAS__stop = _.stop;
  _.stop = function() {
    $gameTemp._aaCanReceiveVisualFromServer = false;
    if ($gamePlayer.aaInSkillCastingProcess()) {
      $gamePlayer.aaOnEventWhileCasting('menu');
    }
    ALIAS__stop.call(this);
    AA.System.onMapSceneStopped();
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    $gameSystem.aaUpdateSystems();
    if (AA.isABSActive()) {
      this.updateABS();
    }
  };
  //@[ALIAS]
  ALIAS__onMapTouch = _.onMapTouch;
  // * Сохранение алиаса, чтобы использовать в другом файле
  _.ALIAS__onMapTouch = ALIAS__onMapTouch;
  _.onMapTouch = function() {
    if (AA.UI.isUITouched()) {
      return;
    }
    if (AA.isABSActive()) {
      return this.onMapTouchAA();
    } else {
      return ALIAS__onMapTouch.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__updateCallMenu = _.updateCallMenu;
  _.updateCallMenu = function() {
    if (TouchInput.isCancelled()) {
      //if AA.UI.performCancelActionOnMap()
      if (this.onMapCancelTouchAA()) {
        return;
      }
    }
    //TODO: Меню не вызывается если isMoving, также сделать если игрок в действии (анимация, удар)
    // * Если действие выполненно, то не надо вызывать меню
    return ALIAS__updateCallMenu.call(this);
  };
  //@[ALIAS]
  //$[OVER]
  ALIAS__checkGameover = _.checkGameover;
  _.checkGameover = function() {
    return $gameParty.aaCheckDeath(); // * Другой метод
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------
//ALIAS__checkGameover.call(@, ...arguments)


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Scene_Map.prototype;
    let connectedGamepad;
    //@[ALIAS]
    const ALIAS__onMapLoaded = _.onMapLoaded;
    _.onMapLoaded = function (...args) {
        ALIAS__onMapLoaded.call(this, ...args);
        AAMainGameLoopManager.onMapAfterSceneLoaded();
        /*pGameController.on('connect', gamepad => {
            console.log('A new gamepad was connected!');
            console.log(gamepad)
            connectedGamepad = gamepad;

            gamepad.on('button0',     () => { console.log('Button 0 still pressed...'); })
                .before('button0', () => { console.log('Button 0 pressed...');       })
                .after('button0',  () => { console.log('Button 0 was released');      });
        });*/
    };
    //@[ALIAS]
    const ALIAS__update = _.update;
    _.update = function (...args) {
        ALIAS__update.call(this, ...args);
        AAMainGameLoopManager.onMapSceneUpdate();
        if (connectedGamepad) {
            //console.log(connectedGamepad.axeValues[0])
            //console.log(connectedGamepad.axeValues[1])
        }
    };
    //@[ALIAS]
    const ALIAS__stop = _.stop;
    _.stop = function (...args) {
        let t = this;
        ALIAS__stop.call(this, ...args);
        AAMainGameLoopManager.onBeforeMapSceneStop();
    };
    //@[ALIAS]
    const ALIAS__start = _.start;
    _.start = function (...args) {
        let t = this;
        ALIAS__start.call(this, ...args);
        AAMainGameLoopManager.onMapAfterSceneStart();
    };
})();
// ■ END Scene_Map.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  if (AAUtils.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Scene_Map.prototype;
  // * Method From MZ
  _.onMapTouchAA = function() {
    var x, y;
    x = $gameMap.canvasToMapX(TouchInput.x);
    y = $gameMap.canvasToMapY(TouchInput.y);
    $gameTemp.setDestination(x, y);
  };
  _.ALIAS__onMapTouch = _.onMapTouchAA;
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.aaUpdateExtraControllers = function() {
    if (AA.Network.isNetworkGame() && !ANGameManager.isMapMaster()) {
      return;
    }
    AAEventsLocatorsManager.update();
    return AASpawnPointsManager.update();
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  (function() {    // * Обработка нажатия мыши (Touch) на карте (Левой)
    // -----------------------------------------------------------------------
    // * ТОЛЬКО левая кнопка мыши
    _.onMapTouchAA = function() {
      //TODO: $gamePlayer.canBeControlled() ??? Надо или нет???
      // * Если игрок в режиме выбора зоны навыка, то активация навыка
      if ($gamePlayer.isInSkillTargetingState()) {
        $gamePlayer.onSkillTargetSelected();
      } else if ($gamePlayer.aaInSkillCastingProcess()) {
        $gamePlayer.aaOnEventWhileCasting('click');
      } else {
        // * Новая система (без выбора целей)
        // * Обновим поиск цели под курсором
        this.aaRefreshMouseDetection();
        // * Статичная атака при повороте
        if ($gamePlayer.aaIsStaticAttackInRotation()) {
          $gamePlayer.aaPerformPlayerAttack01(false);
          return;
        }
        if ($gameTemp._aaEventUnderCursor != null) {
          // * Нажатие по цели
          // * (это используется чтобы не атаковать дружественные цели)
          if (this._aaIsTargetUnserCursorIsAlied()) {
            _.ALIAS__onMapTouch.call(this);
          } else {
            this._aaOnTouchOnTarget();
          }
        } else {
          // * Нажатие по карте (просто)
          this._aaOnTouchOnMapBasic();
        }
      }
    };
    // * Эта проверка предотвращает атаку по дружественной цели
    // * Доп. опции нету, т.к. с зажатым Cntrl можно атаковать и дружественную цель
    _._aaIsTargetUnserCursorIsAlied = function() {
      return !$gamePlayer.AAEntity().isMyEnemy($gameTemp._aaEventUnderCursor.AAEntity());
    };
    _._aaOnTouchOnTarget = function() {
      var char, mode;
      if (AA.isDEV()) {
        char = $gameTemp._aaEventUnderCursor;
        window.__selected = char;
        if (char != null) {
          "SELECTED ON MAP".p(char.AABattler().name());
        }
      }
      mode = AA.Input.LMBTargetTouchMode;
      switch (mode) {
        case 0: // * ATTACK ONLY
          $gamePlayer.aaPerformPlayerAttack01(false);
          break;
        case 1: // * DEFAULT (move)
          _.ALIAS__onMapTouch.call(this);
          break;
        case 2: // * SMART ATTACK
          $gamePlayer.aaPerformPlayerAttack01(true); // * 3, TURN
          break;
        default:
          $gamePlayer.turnTowardCharacter($gameTemp._aaEventUnderCursor);
      }
    };
    _._aaOnTouchOnMapBasic = function() {
      var mode;
      mode = AA.Input.LMBMapTouchMode;
      if (mode === 0) { // * ATTACK ONLY
        $gamePlayer.aaPerformPlayerAttack01(false);
      } else if (mode === 1) { // * DEFAULT (move)
        _.ALIAS__onMapTouch.call(this); // mode == 2
      } else {

      }
    };
    // * NOTHING, ничего
    _.aaGetABSEntityInPosition = function(point) {
      var candidates, chars, e, events, partyMembers;
      try {
        events = $gameMap.eventsXyAAExt(point.x, point.y);
        if (events.length > 0) {
          return events.first();
        }
        partyMembers = $gameMap.follwersXyAAExt(point.x, point.y);
        if (partyMembers.length > 0) {
          return partyMembers.first();
        }
        if (AA.Network.isNetworkPvPGame()) {
          candidates = $gameMap.netCharsXyAAExt(point.x, point.y);
          chars = candidates.filter(function(char) {
            return char.AAEntity().isMyEnemy($gamePlayer.AAEntity());
          });
          if (chars.length > 0) {
            return chars.first();
          }
        }
      } catch (error) {
        e = error;
        AA.w(e);
      }
      return null;
    };
    return _.aaOnClickOnABSCharacter = function(char) {
      var e;
      try {
        $gamePlayer.aaTrySetTarget(char);
        //? DEBUG ONLY
        if (AA.isDEV()) {
          window.__selected = char;
          if (char != null) {
            return "SELECTED ON MAP".p(char.AABattler().name());
          }
        }
      } catch (error) {
        e = error;
        return AA.w(e);
      }
    };
  })();
  (function() {    // * Обработка нажатия мыши (Touch) на карте (Правой)
    // -----------------------------------------------------------------------
    // * Если вернуть true - то меню НЕ будет показано
    _.onMapCancelTouchAA = function() {
      var isNotShowMenu;
      if (AA.UI.isAnyUIElementTouchProcess()) {
        // * инвернтарь, Hot бар и т.д.
        return true;
      }
      // * Отмена выбора зоны поражения навыка
      if ($gamePlayer.isInSkillTargetingState()) {
        $gamePlayer.onSkillTargetCancel();
        return true;
      }
      if ($gamePlayer.aaInSkillCastingProcess()) {
        $gamePlayer.aaOnEventWhileCasting('cancel');
        return true;
      }
      // * Новая система (без выбора целей)
      // * Обновим поиск цели под курсором
      this.aaRefreshMouseDetection();
      // * Статичная атака при повороте
      if ($gamePlayer.aaIsStaticAttackInRotation()) {
        $gamePlayer.aaPerformPlayerAttack02(false);
        return true;
      }
      if ($gameTemp._aaEventUnderCursor != null) {
        // * Нажатие по цели
        // * (это используется чтобы не атаковать дружественные цели)
        if (this._aaIsTargetUnserCursorIsAlied()) {
          isNotShowMenu = this._aaOnCancelTouchOnAllyTarget();
        } else {
          isNotShowMenu = this._aaOnCancelTouchOnTarget();
        }
      } else {
        // * Нажатие по карте (просто)
        isNotShowMenu = this._aaOnCancelTouchBasic();
      }
      return isNotShowMenu;
    };
    _._aaOnCancelTouchOnAllyTarget = function() {
      var mode;
      mode = AA.Input.RMBTargetTouchMode;
      switch (mode) {
        case 0: // * ATTACK ONLY
          // * NOTHING
          return true;
        case 1: // * Move
          _.ALIAS__onMapTouch.call(this);
          return true;
        case 2: // * SMART ATTACK
          // * NOTHING
          return true;
        case 3: // TURN
          $gamePlayer.turnTowardCharacter($gameTemp._aaEventUnderCursor);
          return true; // * 4, MENU
        default:
          return false;
      }
    };
    _._aaOnCancelTouchOnTarget = function() {
      var mode;
      mode = AA.Input.RMBTargetTouchMode;
      switch (mode) {
        case 0: // * ATTACK ONLY
          $gamePlayer.aaPerformPlayerAttack02(false);
          return true;
        case 1: // * Move
          _.ALIAS__onMapTouch.call(this);
          return true;
        case 2: // * SMART ATTACK
          $gamePlayer.aaPerformPlayerAttack02(true);
          return true;
        case 3: // TURN
          $gamePlayer.turnTowardCharacter($gameTemp._aaEventUnderCursor);
          return true; // * 4, MENU
        default:
          return false;
      }
    };
    return _._aaOnCancelTouchBasic = function() {
      var mode;
      mode = AA.Input.RMBMapTouchMode;
      switch (mode) {
        case 0: // * Menu
          return false; // * false - значит меню будет открыто
        case 1: // * Attack Secondary
          $gamePlayer.aaPerformPlayerAttack02(false);
          return true;
        case 2: // * Move
          _.ALIAS__onMapTouch.call(this);
          return true;
        case 3: // * Turn
          $gamePlayer.turnTowardCharacter(TouchInput.toMapPoint());
          return true; // * Nothing
        default:
          return true;
      }
    };
  })();
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.aaCreateMouseDetectionThread = function() {
    $gameTemp._aaEventUnderCursor = null;
    return this._aaMouseDetectThread = new KDCore.TimedUpdate(2, this.aaRefreshMouseDetection.bind(this));
  };
  _.aaUpdateMouseDetection = function() {
    return this._aaMouseDetectThread.update();
  };
  // * Этот метод отвечает за "сбор" событий и объектов под курсором
  _.aaRefreshMouseDetection = function() {
    var eventUnderCursor;
    eventUnderCursor = this.aaGetABSEntityInPosition(TouchInput.toMapPoint());
    if (eventUnderCursor != null) {
      if ($gameTemp._aaEventUnderCursor !== eventUnderCursor) {
        $gameTemp._aaEventUnderCursor = eventUnderCursor;
        AA.EV.call("UnderMouseEventChanged");
      }
    } else {
      if ($gameTemp._aaEventUnderCursor != null) {
        $gameTemp._aaEventUnderCursor = null;
        AA.EV.call("UnderMouseEventChanged");
      }
    }
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.aaInitMapScrollSystem = function() {
    $gameTemp.aaIsMapScrolledByEvent = false;
    this.aaScrollTimer = 0;
    this.aaIsNeedScroll = false;
    this.aaScrollParams = AA.PP.getMapScrollingSettings();
  };
  //@[DYNAMIC]
  _.aaUpdateMapScrlByMouse = function() {
    if ($gameTemp.aaIsMapScrolledByEvent === true) {
      return;
    }
    // * По умолчанию скролл включён
    this.aaUpdateMapScrlByMouseBody();
  };
  _.aaUpdateMapScrlByMouseBody = function() {
    var p, zone;
    if ($gamePlayer.isMoving() || $gameTemp.isDestinationValid()) {
      return;
    }
    // * Когда мышка у края экрана, тогда будет scroll карты
    this.aaIsNeedScroll = false;
    zone = this.aaScrollParams.scrollZone;
    p = TouchInput;
    if (p.y > Graphics.height - zone && p.y <= Graphics.height - 2) {
      this.aaMakeScroll(2);
    } else {

    }
    if (p.y >= 2 && p.y < zone) {
      this.aaMakeScroll(8);
    } else {

    }
    if (p.x >= 2 && p.x < zone) {
      this.aaMakeScroll(4);
    } else {

    }
    if (p.x > Graphics.width - zone && p.x <= Graphics.width - 2) {
      this.aaMakeScroll(6);
    }
    if (!this.aaIsNeedScroll) {
      // * Не применяем, например delay ещё не прошёл
      $gameMap.startScroll(0, 0, 0);
      if (this.aaScrollTimer >= this.aaScrollParams.delay) {
        // * Сброс таймера
        this.aaScrollTimer = 0;
      }
    }
    if (this.aaIsNeedScroll === true) {
      
      // * Было ли движение камеры? (Тут только true может быть)
      $gameTemp.aaSetMapScrolled(true);
    }
  };
  _.aaMakeScroll = function(d) {
    $gameMap.startScroll(d, 1, this.aaScrollParams.speed);
    this.aaScrollTimer++;
    this.aaIsNeedScroll = this.aaScrollTimer >= this.aaScrollParams.delay;
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  _.addABSUI = function() {
    if (this._aaUI != null) {
      return;
    }
    this._aaUI = new AA.Spriteset_UI();
    this._aaUILayer.addChild(this._aaUI);
  };
  _.removeABSUI = function() {
    if (this._aaUI != null) {
      this._aaUILayer.removeChild(this._aaUI);
    }
    this._aaUI = null;
  };
  _.updateABS = function() {
    this.aaUpdateMouseDetection();
    this.aaUpdateMapScrlByMouse();
    this.aaUpdateExtraControllers();
  };
  _.aaRestoreEnemiesHp = function() {
    var e;
    if ($gameTemp.__aaIsShouldRestoreEnemiesHp == null) {
      return;
    }
    $gameTemp.__aaIsShouldRestoreEnemiesHp = null;
    try {
      return $gameMap.aaRestoreEnemiesHPs();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Т.к. АИ союзников постоянны (создаются один раз), то надо обновлять их после загрузки карты
  _.aaRefreshPartyABSMembers = function() {
    var e;
    try {
      $gamePlayer.followers().aaRefreshABSMemebers();
      return $gameParty.aaRefreshABSStatesSet();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //@[EVENT]
  _.gev_onABSPartyLeaderReady = function() {
    var e;
    try {
      this.addABSUI();
      return $gamePlayer.initABS();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Title.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Scene_Title.prototype;
    //@[ALIAS]
    const ALIAS__start = _.start;
    _.start = function (...args) {
        ALIAS__start.call(this, ...args);
        AAMainGameLoopManager.onSceneTitleStart();
    };
})();
// ■ END Scene_Title.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Сцена игрового визуального редактора интерфейса
(function() {
  var Scene_UIEditor;
  Scene_UIEditor = class Scene_UIEditor extends Scene_Base {
    constructor() {
      super();
      this.elementUnderMouse = null;
      this.isDrag = false;
      this.preEditElementsStates = [];
      return;
    }

    create() {
      super.create();
      // * Запоминаем состояние АБС, так как надо его ставить на паузу
      $gameTemp._needRestoreABSSystemAfterUIEdit = AA.isABSActive();
      AA.System.pauseABS();
      this.createMain(); //# -> 0
      //TODO: Добавить опцию (Показывать ли скрытые в редактре...)
      this.showNotVisibleElements();
      //TODO: Добавить опцию (параметр  Показывать ли..)
      return this.showNotEditableElements();
    }

    // * Элементы, которые нельзя редактировать, мы отмечаем (блюр)
    showNotEditableElements() {
      var e, i, len, ref;
      ref = this.elements();
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (!e.isCanBeEdited()) {
          this.deactivateElement(e);
        }
      }
    }

    // * Элемнты, которые скрыты, мы показываем прозрачными
    showNotVisibleElements() {
      var e, i, len, ref;
      ref = this.elements();
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (!e.visible) {
          // * Тут проверяется по флагу visible, а не isActive
          this.transparentElement(e);
        }
      }
    }

    deactivateElement(element) {
      // * Сохраняем значения перед редактированием
      this.preEditElementsStates.push([element, element.visible, element.opacity]);
      element.opacity = 150;
      element.desaturate();
    }

    transparentElement(element) {
      this.preEditElementsStates.push([element, element.visible, element.opacity]);
      element.visible = true;
      element.opacity = 120;
    }

    // * Сбросить значения по умолчанию
    resetElement(element) {
      var user;
      element.reset("position");
      user = $gameSystem.aaGetUserUISettings();
      return user.set(element.tag, "resetPosition");
    }

    // * Сохранить позицию элемента
    saveElementPosition(element) {
      var user, x, y;
      user = $gameSystem.aaGetUserUISettings();
      ({x, y} = element);
      user.set(element.tag, "setPosition", [x, y]);
    }

    elements() {
      return this.uiSpriteset.elements;
    }

    //TODO: Добавить кнопка H - скрыть\показать или скрыть \ показать последний (если не на элементе курсор)
    // Например стоит опция не показывать скрытые

      //TODO: Параметр плагина - OFF, Всегда, Только в режиме разработки

      //TODO: Кнопка - Сбросить до последний позиции???
    update() {
      super.update();
      this.updateMain(); //# -> Mouse
      this.updateExit();
      if (!this.isDrag) {
        // * Обновляем пользовательское управление (если не Drag)
        return this.updateInput();
      }
    }

    updateExit() {
      if (Input.isCancel()) {
        return this.popScene();
      }
    }

    updateInput() {
      // * Сброс позиции по умолчанию
      if (Input.isTriggered('r')) {
        if (this.elementUnderMouse != null) {
          this.resetElement(this.elementUnderMouse);
        }
      }
    }

    stop() {
      var elementData, i, len, ref;
      super.stop();
      if ($gameTemp._needRestoreABSSystemAfterUIEdit === true) {
        AA.System.resumeABS();
      }
      ref = this.preEditElementsStates;
      // * Восстанавливаем прозрачность и видимость которые были перед редактированием
      for (i = 0, len = ref.length; i < len; i++) {
        elementData = ref[i];
        elementData[0].visible = elementData[1];
        elementData[0].opacity = elementData[2];
      }
    }

  };
  AA.link(Scene_UIEditor);
})();


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_UIEditor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Scene_UIEditor.prototype;
  _.createMain = function() {
    this.createBackground();
    // * Показать что в редакторе находимся
    this.createEditorMark();
    // * Сетки
    this.createGrids();
    this.createUI();
    this.createXYHelpText();
    return this.createTagHelpText();
  };
  // * За заднем плане карта
  _.createBackground = function() {
    this._backgroundSprite = new Sprite(SceneManager.backgroundBitmap());
    this.addChild(this._backgroundSprite);
    return this._backgroundSprite.opacity = 250;
  };
  _.createEditorMark = function() {
    var eLayer, eText, p;
    eLayer = KDCore.Sprite.FromBitmap(Graphics.width, Graphics.height);
    eLayer.fillAll("#C0C0C0".toCss());
    eLayer.opacity = 75;
    p = KDCore.UI.Sprite_UIText.prototype.defaultParams();
    p.size = {
      w: Graphics.width,
      h: 200
    };
    p.font.size = 72;
    eText = new KDCore.UI.Sprite_UIText(p);
    eText.drawText('UI Editor');
    eText.y = Graphics.height / 2 - 100;
    eLayer.addChild(eText);
    return this.addChild(eLayer);
  };
  // * Сетка для визуальной привязки (для шага 10)
  _.createGrids = function() {
    this.xGrid = this.createGridSprite(10);
    return this.addChild(this.xGrid);
  };
  _.createGridSprite = function(size) {
    var drawLineHor, drawLineVert, grid, i, j, k, l, ref, ref1;
    grid = KDCore.Sprite.FromBitmap(Graphics.width, Graphics.height);
    drawLineVert = function(b, i) {
      return b.fillRect(0, i * size, b.width, 1, 'rgba(0, 0, 0, 1)');
    };
    drawLineHor = function(b, i) {
      return b.fillRect(i * size, 0, 1, b.height, 'rgba(0, 0, 0, 1)');
    };
    for (i = k = 0, ref = grid.b().height / size; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      drawLineVert(grid.bitmap, i);
    }
    for (j = l = 0, ref1 = grid.b().width / size; (0 <= ref1 ? l < ref1 : l > ref1); j = 0 <= ref1 ? ++l : --l) {
      drawLineHor(grid.bitmap, j);
    }
    grid.visible = false;
    grid.opacity = 75;
    return grid;
  };
  // * В этом методе создаётся AA UI (не обновляемый)
  _.createUI = function() {
    this.uiSpriteset = new AA.Spriteset_UI();
    this.uiSpriteset.show(); // * Всегда видимый в редакторе
    this.addChild(this.uiSpriteset);
  };
  _.createXYHelpText = function() {
    var p;
    p = KDCore.UI.Sprite_UITextWithBack.prototype.defaultParams();
    p.text.size.w = 80;
    p.rect.size.w = 80;
    p.rect.borderColor = "";
    p.text.textColor = "#FFFFFF".toCss();
    this.xyText = new KDCore.UI.Sprite_UITextWithBack(p);
    this.xyText.fill("#C0C0C0".toCss());
    return this.addChild(this.xyText);
  };
  _.createTagHelpText = function() {
    var p;
    p = KDCore.UI.Sprite_UITextWithBack.prototype.defaultParams();
    p.text.size.w = 120;
    p.rect.size.w = 120;
    p.rect.borderColor = "";
    p.text.textColor = "#FFFFFF".toCss();
    this.tagText = new KDCore.UI.Sprite_UITextWithBack(p);
    this.tagText.fill("#808080".toCss());
    return this.addChild(this.tagText);
  };
})();

// ■ END Scene_UIEditor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_UIEditor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Scene_UIEditor.prototype;
  _.updateMain = function() {
    this.updateMouse();
    return this.updateXYText();
  };
  _.updateMouse = function() {
    this.xGrid.visible = false;
    if (this.isDrag === true) {
      this.updateDragEnd();
      return this.updateMouseDrag();
    } else {
      this.updateMouseHover();
      return this.updateDragStart();
    }
  };
  _.updateMouseHover = function() {
    var underMouse;
    this.elementUnderMouse = null;
    underMouse = this.elements().filter(function(e) {
      return e.isUnderMouse();
    });
    if (underMouse.isEmpty()) {
      return;
    }
    return this.elementUnderMouse = underMouse.last();
  };
  _.updateDragStart = function() {
    if (this.elementUnderMouse == null) {
      return;
    }
    if (!this.elementUnderMouse.isCanBeEdited()) {
      return;
    }
    if (TouchInput.isPressed()) {
      this.isDrag = true;
      this._lastElementPosition = this.elementUnderMouse.toPoint();
      // * Разница в координатах курсора и объекта, чтобы убрать эффект "прыжка"
      this._deltaXY = this.getDeltaXY();
    }
  };
  _.getDeltaXY = function() {
    var dx, dy, x, y;
    ({x, y} = this.elementUnderMouse);
    dx = TouchInput.x - x;
    dy = TouchInput.y - y;
    return new KDCore.Point(dx, dy);
  };
  _.updateMouseDrag = function() {
    // * Проверка, есть ли элемент
    this.elementUnderMouse.move(TouchInput.x - this._deltaXY.x, TouchInput.y - this._deltaXY.y);
    if (Input.isPressed('shift')) {
      this.applyMargin(2);
    } else if (Input.isPressed('control')) {
      this.applyMargin(10);
      this.xGrid.visible = true;
    }
    if (TouchInput.isCancelled()) {
      this.resetAfterDrag();
    }
  };
  // * Применить "привязывание" к координатам
  _.applyMargin = function(delta) {
    var x, y;
    ({x, y} = this.elementUnderMouse);
    while (x % delta !== 0) {
      x += 1;
    }
    while (y % delta !== 0) {
      y += 1;
    }
    return this.elementUnderMouse.move(x, y);
  };
  _.resetAfterDrag = function() {
    this.isDrag = false;
    TouchInput.clear();
    return this.elementUnderMouse.move(this._lastElementPosition);
  };
  _.updateDragEnd = function() {
    if (TouchInput.isReleased()) {
      this.isDrag = false;
      this.saveElementPosition(this.elementUnderMouse); //# -> @
    }
  };
  _.updateXYText = function() {
    var fillColor, t;
    fillColor = "#C0C0C0".toCss();
    this.tagText.visible = false;
    if (this.elementUnderMouse != null) {
      // * Показываем координаты элемента
      t = this.getXYTextFormat(this.elementUnderMouse);
      if (this.isDrag === true) {
        fillColor = "#008040".toCss();
      } else {
        if (this.elementUnderMouse.isCanBeEdited()) {
          fillColor = "#008080".toCss();
        } else {
          fillColor = "#FF8080".toCss();
        }
        this.tagText.draw(this.elementUnderMouse.tag);
        this.tagText.visible = true;
      }
    } else {
      t = this.getXYTextFormat(TouchInput);
    }
    this.xyText.fill(fillColor);
    this.xyText.draw(t);
    return this.moveXYTextHelp();
  };
  _.moveXYTextHelp = function() {
    this.xyText.move(TouchInput.x + 16, TouchInput.y + 16);
    this.tagText.move(this.xyText.x - 20, this.xyText.y + this.xyText.realHeight());
    // * Если слишком низки (за экран выходит)
    if (this.tagText.y + this.tagText.realHeight() > Graphics.height) {
      this.xyText.y = TouchInput.y - 16 - this.xyText.realHeight();
      this.tagText.y = this.xyText.y + this.xyText.realHeight();
    }
  };
  _.getXYTextFormat = function(point) {
    var x, y;
    ({x, y} = point);
    return "X:" + x + " ; Y:" + y;
  };
})();

// ■ END Scene_UIEditor.coffee
//---------------------------------------------------------------------------


class Sprite_AAAnimatedImage extends Sprite {
    constructor(imageName) {
        super();
        this._framesCount = 0;
        this._delay = 0;
        this._currentFrame = 0;
        this._frameWidth = 0;
        this._frameHeight = 0;
        this._frameTimer = 0;
        this._isLooping = true;
        let data = AAUtils.extractFramesAndSpeedValueFromImageName(imageName);
        this._framesCount = data.f;
        this._delay = data.s;
        //@ts-ignore
        KDCore.Utils.loadImageAsync('pictures', imageName).then(this._onImageLoaded.bind(this));
    }
    setLooping(value) {
        this._isLooping = value;
    }
    _onImageLoaded(loadedBitmap) {
        this.bitmap = loadedBitmap;
        this._frameWidth = this.bitmap.width / this._framesCount;
        this._frameHeight = this.bitmap.height;
        this._refreshCurrentFrame();
        /*if (this.onLoaded) {
            this.onLoaded();
        }*/
    }
    /**
     * Updates the animation.
     */
    update() {
        super.update();
        this._updateFramesAnimation();
    }
    _updateFramesAnimation() {
        if (this._framesCount <= 1)
            return;
        this._frameTimer++;
        if (this._frameTimer >= this._delay) {
            this._frameTimer = 0;
            this._currentFrame++;
            if (this._currentFrame >= this._framesCount) {
                if (this._isLooping) {
                    this._currentFrame = 0;
                }
                else {
                    this._currentFrame = this._framesCount - 1;
                    this._framesCount = 1; // Stop the animation
                    if (this.onEnd) {
                        this.onEnd();
                    }
                }
            }
            this._refreshCurrentFrame();
        }
    }
    _refreshCurrentFrame() {
        const sx = this._frameWidth * this._currentFrame;
        this.setFrame(sx, 0, this._frameWidth, this._frameHeight);
    }
}
window['Sprite_AAAnimatedImage'] = Sprite_AAAnimatedImage;


class Sprite_AACollider extends Sprite {
    /**
     * Creates an instance of COE_Sprite_Collider.
     * @param collider - The collider object.
     * @param config - Configuration object for the sprite collider.
     */
    constructor(collider, config = null) {
        super();
        this.collider = collider;
        if (!config) {
            this.config = this.getConfigForFlag(collider.flag);
        }
        else {
            this.config = config;
        }
        this._create();
    }
    getConfigForFlag(flag) {
        switch (flag) {
            case 'char':
                return {
                    color: '#ffd257',
                    opacity: 180
                };
            case 'hitbox':
                return {
                    color: '#ff0000',
                    opacity: 160
                };
            case 'event':
                return {
                    color: '#00ff00',
                    opacity: 180
                };
            case 'tilemap':
                return {
                    color: '#ffff00',
                    opacity: 100
                };
            case 'projectile':
                return {
                    color: '#ff00ff',
                    opacity: 180
                };
            case 'interaction':
                return {
                    color: '#0000ff',
                    opacity: 120
                };
            case 'projectileCollision':
                return {
                    color: '#61ffca',
                    opacity: 140
                };
            default:
                return {
                    color: '#cccccc',
                    opacity: 150
                };
        }
    }
    /**
     * Checks if the collider is valid.
     */
    isValid() {
        return !!this.collider;
    }
    /**
     * Checks if the collider is a circle.
     */
    isCircle() {
        return this.isValid() && this.collider.isCircle();
    }
    /**
     * Checks if the collider is a box.
     */
    isBox() {
        return this.isValid() && this.collider.isBox();
    }
    /**
     * Disposes of the collider.
     */
    dispose() {
        this.collider = null;
    }
    /**
     * Updates the sprite collider.
     */
    update() {
        super.update();
        if (this.isValid()) {
            this.visible = true;
        }
        else {
            this.visible = false;
            return;
        }
        try {
            this.move(this.collider.px(), this.collider.py());
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the sprite collider.
     */
    _create() {
        try {
            if (!this.isValid())
                return;
            if (this.isCircle()) {
                this._createCircleColliderSpr();
            }
            else {
                this._createBoxColliderSpr();
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates a circle collider sprite.
     */
    _createCircleColliderSpr() {
        try {
            const colConfig = this.collider.config;
            const { color, opacity } = this.config;
            const { radius } = colConfig;
            const scaledRadius = radius * $gameMap.tileWidth();
            const width = scaledRadius * 2;
            const colliderSpr = new Sprite(new Bitmap(width, width));
            colliderSpr.bitmap.drawCircle(scaledRadius, scaledRadius, scaledRadius, color);
            colliderSpr.opacity = opacity;
            this.addChild(colliderSpr);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates a box collider sprite.
     */
    _createBoxColliderSpr() {
        try {
            const colConfig = this.collider.config;
            const { width, height } = colConfig;
            const { color, opacity } = this.config;
            const colliderSpr = new Sprite(new Bitmap(width * $gameMap.tileWidth(), height * $gameMap.tileHeight()));
            colliderSpr.bitmap.fillAll(color);
            colliderSpr.opacity = opacity;
            this.addChild(colliderSpr);
        }
        catch (e) {
            console.warn(e);
        }
    }
}
window["Sprite_AACollider"] = Sprite_AACollider;


class Sprite_AACollisionsLayer extends Sprite {
    constructor() {
        super();
        this._create();
        /*@ts-ignore*/
        this.z = 999;
    }
    static Instance() {
        return this._currentLayer;
    }
    static CreateLayer() {
        if (!this._currentLayer) {
            this._currentLayer = new Sprite_AACollisionsLayer();
            /*@ts-ignore*/
            SceneManager._scene._spriteset._tilemap.addChild(this._currentLayer);
        }
    }
    static DestroyLayer() {
        if (this._currentLayer) {
            //@ts-ignore
            this._currentLayer.removeFromParent();
            this._currentLayer.visible = false;
            this._currentLayer = null;
        }
    }
    static updateTool() {
        //TODO: Only in DevMode
        if (Input.isTriggered(AAPluginParams.getShowCollisionLayerKey())) {
            if (Sprite_AACollisionsLayer._currentLayer) {
                Sprite_AACollisionsLayer.DestroyLayer();
            }
            else {
                Sprite_AACollisionsLayer.CreateLayer();
            }
            Input.clear();
        }
    }
    update() {
        super.update();
        if (!this.visible)
            return;
        this._updateCharCollidersPosition();
    }
    _create() {
        if (AAMainSystem.isExtendedPlayerMovementSystemActive()) {
            this._createMapCollisions();
            this._createCharCollisions();
        }
    }
    _createMapCollisions() {
        let mapColliders = AAMapCollisionsManager.getTilemapColliders();
        this._mapCollisions = [];
        mapColliders.forEach(collider => {
            this._mapCollisions.push(this._addColliderSprite(collider));
        });
    }
    _addColliderSprite(collider) {
        let sprite = new Sprite_AACollider(collider);
        this.addChild(sprite);
        return sprite;
    }
    _createCharCollisions() {
        this._charCollisions = [];
        this._createEventsInteractions();
        this._createEventsCollisions();
        this._createPartyCollisions();
    }
    _createEventsInteractions() {
        this._charInteractions = [];
        let events = AAEventsInteractionsManager.getEventsWithInteractionArea();
        events.forEach(event => {
            let collider = AACharInteractionArea.getFor(event);
            if (collider) {
                this._charInteractions.push(this._addColliderSprite(collider));
            }
        });
    }
    _createEventsCollisions() {
        let events = AAMapCollisionsManager.getEventsWithColliders();
        events.forEach(event => {
            let collider = AACharCollider.getFor(event);
            if (collider) {
                this._charCollisions.push(this._addColliderSprite(collider));
            }
        });
    }
    _createPartyCollisions() {
        let playerCollider = AACharCollider.getFor($gamePlayer);
        if (playerCollider) {
            this._charCollisions.push(this._addColliderSprite(playerCollider));
        }
        //let follwers = $gamePlayer.followers().visibleFollowers();
    }
    _updateCharCollidersPosition() {
        AACharCollider.getFor($gamePlayer);
        let events = AAMapCollisionsManager.getEventsWithColliders();
        events.forEach(event => {
            AACharCollider.getFor(event);
        });
        let eventsWithInteractions = AAEventsInteractionsManager.getEventsWithInteractionArea();
        eventsWithInteractions.forEach(event => {
            AACharInteractionArea.getFor(event);
        });
    }
}
window["Sprite_AACollisionsLayer"] = Sprite_AACollisionsLayer;


// Generated by CoffeeScript 2.6.1
var Sprite_AACustomGauge;

Sprite_AACustomGauge = class Sprite_AACustomGauge extends KDCore.Sprite {
  constructor(id) {
    var refreshTime;
    super();
    this.id = id;
    this.gauge = this.getGauge();
    if (this.gauge == null) {
      return;
    }
    if (this.gauge.isDisposed()) {
      return;
    }
    this._create();
    if (this.gauge.isEnemyHpGauge()) {
      refreshTime = 4;
    } else {
      refreshTime = 20;
    }
    this._refreshThread = new KDCore.TimedUpdate(refreshTime, this.refresh.bind(this));
    this.refresh();
    return;
  }

  update() {
    super.update();
    if (this.__disposed != null) {
      return;
    }
    if (this._gaugeSpr == null) {
      return;
    }
    this._updatePosition();
    this._refreshThread.update();
  }

  getGauge() {
    return AACustomGaugesSystem.Instance().getGaugeDataById(this.id);
  }

  _create() {
    var e, text, textFormat;
    try {
      this._createGauge(this.gauge.gaugeParams);
      ({text, textFormat} = this.gauge.gaugeParams);
      if ((text != null) && text.visible === true) {
        this._captionTextFormat = textFormat;
        return this._createGaugeCaptionText(text);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  refresh() {
    var currentValue, e, maxValue, rate, text;
    try {
      if (this._gaugeSpr == null) {
        return;
      }
      if (this.gauge != null) {
        rate = this.gauge.getCurrentRate();
        this._gaugeSpr.draw(rate);
        if (rate === 0 && this.gauge.isEnemyHpGauge()) {
          AACustomGaugesSystem.Instance().removeGauge(this.id);
        }
      } else {
        this._gaugeSpr.draw(0);
      }
      if ((this._textSpr != null) && (this._captionTextFormat != null)) {
        rate = this.gauge.getCurrentRate();
        currentValue = this.gauge.getCurrentValue();
        maxValue = this.gauge.getMaxValue();
        text = this._captionTextFormat.replace("$1", currentValue);
        text = text.replace("$2", maxValue);
        text = text.replace("$3", Math.round(rate * 100));
        this._textSpr.draw(text);
      }
      if (this.gauge.isDisposed()) {
        this.visible = false;
        this.removeFromParent();
        return this.__disposed = true;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _updatePosition() {
    var e, x, y;
    try {
      if (this._gaugeSpr == null) {
        return;
      }
      ({x, y} = this.gauge.getScreenPos());
      return this.move(x, y);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createGauge(p) {
    var e;
    try {
      if (p == null) {
        p = {
          visible: true,
          fill: "Player_HPGauge",
          foreground: "",
          mask: "",
          backColor: "#000000",
          backOpacity: 255,
          vertical: false,
          rootImageFolder: "Alpha"
        };
        AA.w("Parameters for Gauge not found! Used default one");
      }
      this._gaugeSpr = new KDCore.UI.Sprite_UIGauge(p);
      return this.addChild(this._gaugeSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  _createGaugeCaptionText(p) {
    var e;
    try {
      if (p == null) {
        return;
      }
      this._textSpr = new KDCore.UI.Sprite_UIText(p);
      return this.addChild(this._textSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

};


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_AADamagePopUpItem.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var Sprite_AADamagePopUpItem;

Sprite_AADamagePopUpItem = class Sprite_AADamagePopUpItem extends KDCore.Sprite {
  constructor(settings1, value1) {
    super();
    this.settings = settings1;
    this.value = value1;
    this._init();
    this._createSprites();
    this._start();
  }

  dispose() {
    var ref;
    this.disposed = true;
    this.visible = false;
    this._removeDynamic();
    if ((ref = this.parent) != null) {
      ref.removeChild(this);
    }
  }

  update() {
    super.update();
    if (this.disposed === true) {
      return;
    }
    if (SceneManager.isSceneChanging()) {
      return;
    }
    this.thread.update();
    this._updateZoom();
    this._updateImageFadeIn();
  }

  // * Установить позицию и применить случайный сдвиг координат
  setStartPoint(x, y) {
    this.move(x, y);
    if (this.settings.randDX > 0) {
      this.x = this.x + Math.randomInt(this.settings.randDX) - Math.randomInt(this.settings.randDX * 2);
    }
    if (this.settings.randDY > 0) {
      this.y = this.y + Math.randomInt(this.settings.randDY);
    }
  }

  // * Привязан, надо удалять себя (aaRemoveDynamicSprite)
  setDynamic() {
    return this._isDynamic = true;
  }

  // * Общие методы создания Pop объекта
  // * Находяться прямо в классе, чтобы не создавать доп. менеджер

    // * Двигается вместе с персонажем (а не экраном)
  static CreateOnCharacterBinded(char, settings, value) {
    var charSprite, dy, e, ph, popDynamicParentSpr, popItem, spriteset, x, y;
    try {
      if (!AAUtils.isSceneMap()) {
        return;
      }
      if (char == null) {
        return;
      }
      if (settings == null) {
        return;
      }
      spriteset = $gameMap.aaSpriteset();
      charSprite = spriteset.findTargetSprite(char);
      if (charSprite == null) {
        return;
      }
      ({x, y} = charSprite);
      // * Создаётся спрайт "оболочка", которая будет привязана к координатам персонажа
      popDynamicParentSpr = new Sprite();
      popDynamicParentSpr.anchor.set(0.5);
      popItem = new Sprite_AADamagePopUpItem(settings, value);
      ph = charSprite.patternHeight();
      dy = -(ph - $gameMap.tileWidth() / 2);
      try {
        if ((char.AAModel() != null) && char.AAModel().damagePopUpYOffset !== 0) {
          dy = char.AAModel().damagePopUpYOffset;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        dy = 0;
      }
      popItem.setStartPoint(0, dy);
      // * Устанавливаем флаг, чтобы при Dispose удалять себя
      popItem.setDynamic();
      popDynamicParentSpr.addChild(popItem);
      // * Регестрируем как динамический спрайт
      spriteset.aaRegisterDynamicSprite(popDynamicParentSpr, char, 0, dy);
      // * Добавляем на слой PopUp
      return spriteset.aaGetDamagePopUpLayer().addChild(popDynamicParentSpr);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  static CreateOnCharacter(char, settings, value) {
    var charSprite, e, spriteset, x, y;
    try {
      if (!AAUtils.isSceneMap()) {
        return;
      }
      if (char == null) {
        return;
      }
      spriteset = $gameMap.aaSpriteset();
      charSprite = spriteset.findTargetSprite(char);
      if (charSprite == null) {
        return;
      }
      ({x, y} = charSprite);
      y = y - charSprite.patternHeight() - $gameMap.tileWidth() / 2;
      return Sprite_AADamagePopUpItem.CreateOnScreen(x, y, settings, value);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  static CreateOnMap(x, y, settings, value) {
    var e, screenX, screenY, tempChar;
    try {
      if (!AAUtils.isSceneMap()) {
        return;
      }
      tempChar = new Game_Character();
      tempChar.setPosition(x, y);
      screenX = tempChar.screenX();
      screenY = tempChar.screenY() - $gameMap.tileWidth();
      return Sprite_AADamagePopUpItem.CreateOnScreen(screenX, screenY, settings, value);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  static CreateOnScreen(x, y, settings, value) {
    var e, popItem, spriteset;
    try {
      if (settings == null) {
        return;
      }
      if (!AAUtils.isSceneMap()) {
        return;
      }
      popItem = new Sprite_AADamagePopUpItem(settings, value);
      popItem.setStartPoint(x, y);
      spriteset = $gameMap.aaSpriteset();
      return spriteset.aaGetDamagePopUpLayer().addChild(popItem);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

};

(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_AADamagePopUpItem.prototype;
  _._init = function() {
    this.disposed = false;
    this.isNeedZoom = true;
    this.stayTime = 0;
    this.maxStayTime = this.settings.stayTime; // * 60
  };
  _._createSprites = function() {
    var e;
    if (this.settings == null) {
      return;
    }
    // * Используется для расчёта размера текста
    this.bitmap = new Bitmap(50, 50);
    this.anchor.set(0.5);
    try {
      this.bitmap.fontSize = Math.max(this.settings.text.font.size, this.settings.changeFontSize);
      this._createValueText();
      if ((this.settings.image != null) && String.any(this.settings.image.name)) {
        return this._createImage();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._createValueText = function() {
    var e, h, w;
    try {
      w = this.bitmap.measureTextWidth(this.value) + 4;
      h = this.settings.text.font.size + 10;
      // * Присваеваем новые значение (посчитанные)
      this.settings.text.size.w = w;
      this.settings.text.size.h = h;
      this.valueSprite = KDCore.Sprite.FromParams(this.settings.text);
      this.valueSprite.anchor.set(0.5);
      this.valueSprite.onReady(this._drawValue.bind(this));
      return this.add(this.valueSprite);
    } catch (error) {
      e = error;
      AA.w(e);
      return this.valueSprite = new Sprite();
    }
  };
  _._drawValue = function() {
    this.valueSprite.clear();
    return this.valueSprite.drawTextFull(this.value, this.settings.text.alignment);
  };
  _._createImage = function() {
    var e, settings;
    try {
      settings = this.settings.image;
      this.imageSprite = KDCore.Sprite.FromImg(settings.name);
      this.imageSprite.x = settings.margins.x || 0;
      this.imageSprite.y = settings.margins.y || 0;
      this.imageSprite.anchor.set(0.5);
      this.imageSprite.opacity = 0;
      return this.add(this.imageSprite);
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._start = function() {
    this.thread = new KDCore.TimedUpdate(2, this._updateLife.bind(this));
  };
  _._updateLife = function() {
    // * Сперва идёт анимация увеличения, затемм только отсчёт таймера
    if (this.isNeedZoom === true) {
      return;
    }
    if (this.disposed === true) {
      return;
    }
    if (SceneManager.isSceneChanging()) {
      return;
    }
    if (this.maxStayTime <= 0) {
      this.dispose();
    } else {
      if (this.stayTime++ < this.maxStayTime) {
        return;
      }
    }
    this._updateOpacity();
    this._updateMoveUp();
    if (this.opacity <= 0) {
      this.dispose();
    }
  };
  _._updateOpacity = function() {
    var e;
    try {
      // * Если не надо, то сразу исчезает
      if (this.settings.noFadeOut === true) {
        this.opacity = 0;
      } else {
        this.opacity -= 25;
      }
    } catch (error) {
      e = error;
    }
  };
  _._updateMoveUp = function() {
    var e;
    if (this.settings.noFlyUp === true) {
      return;
    }
    try {
      this.move(this.x, this.y - 1);
    } catch (error) {
      e = error;
    }
  };
  _._updateZoom = function() {
    var b, e;
    if (!this.isNeedZoom) {
      return;
    }
    try {
      b = this.valueSprite.bitmap;
      if (b.fontSize === this.settings.changeFontSize) {
        this.isNeedZoom = false;
        return;
      }
      if (b.fontSize < this.settings.changeFontSize) {
        b.fontSize = b.fontSize + 1;
      } else if (b.fontSize > this.settings.changeFontSize) {
        b.fontSize = b.fontSize - 1;
      }
      this._drawValue();
    } catch (error) {
      e = error;
    }
  };
  _._updateImageFadeIn = function() {
    var e;
    try {
      if (this.imageSprite == null) {
        return;
      }
      if (this.imageSprite.opacity >= 255) {
        return;
      }
      this.imageSprite.opacity += this.settings.image.fadeInSpeed;
    } catch (error) {
      e = error;
    }
  };
  _._removeDynamic = function() {
    var e, spriteset;
    if (this._isDynamic !== true) {
      return;
    }
    try {
      spriteset = $gameMap.aaSpriteset();
      spriteset.aaRemoveDynamicSprite(this);
      if (this.parent != null) {
        return spriteset.aaRemoveDynamicSprite(this.parent);
      }
    } catch (error) {
      e = error;
      return AA.warning(e);
    }
  };
})();

// ■ END Sprite_AADamagePopUpItem.coffee
//---------------------------------------------------------------------------


class Sprite_AAExtraSkillAnimation extends Sprite {
    static Create(mapPosition, config) {
        if (!AAUtils.isSceneMap())
            return;
        try {
            let animation = new Sprite_AAExtraSkillAnimation(config.extraAnimation, mapPosition, config.extraAnimationSE);
            animation.setupOffset({ x: config.extraAnimationOX, y: config.extraAnimationOY });
            AAUtils.addToTilemap(animation);
        }
        catch (error) {
            console.warn(error);
        }
    }
    constructor(_imageName, _mapPosition, _startSound = '') {
        super();
        this._imageName = _imageName;
        this._mapPosition = _mapPosition;
        this._offset = { x: 0, y: 0 };
        this._create();
        //@ts-ignore
        KDCore.Utils.playSE(_startSound);
    }
    setupOffset(offset) {
        this._offset = offset;
    }
    _create() {
        this._image = new Sprite_AAAnimatedImage(this._imageName);
        this._image.setLooping(false);
        this._image.onEnd = this._dispose.bind(this);
        this._image.anchor.x = 0.5;
        this._image.anchor.y = 1;
        this.addChild(this._image);
        this['z'] = 4; // Above characters
    }
    update() {
        super.update();
        this._updatePosition();
    }
    _dispose() {
        this.visible = false;
        if (this.parent) {
            this.parent.removeChild(this);
        }
    }
    _updatePosition() {
        if (!this.visible)
            return;
        let screenPosition = AAUtils.mapPointToScreenPoint(this._mapPosition);
        this.x = screenPosition.x + this._offset.x;
        this.y = screenPosition.y + this._offset.y;
    }
}
window['Sprite_AAExtraSkillAnimation'] = Sprite_AAExtraSkillAnimation;


class Sprite_AAGridMapLayer extends Sprite {
    constructor() {
        super();
        this._create();
        /*@ts-ignore*/
        this.z = 999;
    }
    static CreateLayer() {
        if (!this._currentGrid) {
            this._currentGrid = new Sprite_AAGridMapLayer();
            /*@ts-ignore*/
            SceneManager._scene._spriteset._tilemap.addChild(this._currentGrid);
        }
    }
    static DrawPath(path, clear = true) {
        try {
            if (this._currentGrid) {
                this._currentGrid.drawPath(path, clear);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    static DestroyLayer() {
        if (this._currentGrid) {
            //@ts-ignore
            this._currentGrid.removeFromParent();
            this._currentGrid.visible = false;
            this._currentGrid = null;
            this._currentGrid = null;
        }
    }
    static RefreshGrid() {
        if (this._currentGrid) {
            this._currentGrid._refreshGridPassage();
        }
    }
    static updateTool() {
        //TODO: Only in DevMode
        if (Input.isTriggered(AAPluginParams.getShowPathfindingGridKey())) {
            if (Sprite_AAGridMapLayer._currentGrid) {
                Sprite_AAGridMapLayer.DestroyLayer();
            }
            else {
                Sprite_AAGridMapLayer.CreateLayer();
            }
            Input.clear();
        }
    }
    update() {
        super.update();
        if (this.visible) {
            this._updatePosition();
        }
    }
    drawPath(path, clear = true) {
        if (clear) {
            this._clearPathLayer();
        }
        let color = "rgba(0, 255, 0, 0.5)";
        for (let node of path) {
            this._addPassCell(node.x * 48, node.y * 48, null, color, this._pathLayer);
        }
    }
    _updatePosition() {
        let x = $gameMap.displayX() * $gameMap.tileWidth();
        let y = $gameMap.displayY() * $gameMap.tileHeight();
        this.x = -x;
        this.y = -y;
    }
    _create() {
        let width = $gameMap.width() * $gameMap.tileWidth();
        let height = $gameMap.height() * $gameMap.tileHeight();
        this.bitmap = new Bitmap(width, height);
        this._drawBaseGrid();
        this._createCollisionsLayer();
        this._createGridPathLayer();
        this._refreshGridPassage();
    }
    _createCollisionsLayer() {
        this._passageLayer = new Sprite();
        this.addChild(this._passageLayer);
    }
    _createGridPathLayer() {
        this._pathLayer = new Sprite();
        this.addChild(this._pathLayer);
    }
    _refreshGridPassage() {
        this._passageLayer.removeChildren();
        this._drawGridPassage();
    }
    _clearPathLayer() {
        this._pathLayer.removeChildren();
    }
    _drawGridPassage() {
        let grid = AAGridMapManager.getMapGrid();
        let tw = AAGridMapManager.gridSize();
        let th = AAGridMapManager.gridSize();
        for (let x = 0; x < AAGridMapManager.mapGridWidth(); x++) {
            for (let y = 0; y < AAGridMapManager.mapGridHeight(); y++) {
                let isPassable = grid.isWalkableAt(x, y);
                if (!isPassable) {
                    let cx = x * tw;
                    let cy = y * th;
                    this._addPassCell(cx, cy, null, "rgba(255, 72, 0, 0.5)", this._passageLayer);
                }
            }
        }
    }
    _drawBaseGrid() {
        let bitmap = this.bitmap;
        bitmap.clear();
        let tw = AAGridMapManager.gridSize();
        let th = tw;
        let w = AAGridMapManager.mapGridWidth();
        let h = AAGridMapManager.mapGridHeight();
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                bitmap.fillRect(x * tw, y * th, tw, 2, "rgba(255, 255, 255, 0.5)");
                bitmap.fillRect(x * tw, y * th, 2, th, "rgba(255, 255, 255, 0.5)");
            }
        }
    }
    _addPassCell(x, y, outerColor, innerColor, layer) {
        let tw = AAGridMapManager.gridSize();
        let th = tw;
        let cell = new Bitmap(tw, th);
        if (outerColor) {
            cell.fillRect(0, 0, tw, 2, outerColor);
            cell.fillRect(0, 0, 2, th, outerColor);
            cell.fillRect(0, th - 2, tw, 2, outerColor);
            cell.fillRect(tw - 2, 0, 2, th, outerColor);
        }
        if (innerColor) {
            cell.fillRect(0, 0, tw, th, innerColor);
        }
        let sprite = new Sprite();
        sprite.bitmap = cell;
        sprite.x = x;
        sprite.y = y;
        layer.addChild(sprite);
    }
}


// * Показывает область поражения скилла на карте
// * Может двигаться как за курсором, так и при помощи стиков геймпада
class Sprite_AAImpactZone extends Sprite {
    //TODO: If gamepad, then position automatically below player, else TouchInput?
    static Create(skill) {
        if (!AAUtils.isSceneMap())
            return;
        try {
            Sprite_AAImpactZone.Remove();
            let sprite = new Sprite_AAImpactZone(skill, TouchInput);
            AAUtils.addToTilemap(sprite);
            Sprite_AAImpactZone._current = sprite;
        }
        catch (error) {
            console.warn(error);
        }
    }
    static Remove() {
        if (Sprite_AAImpactZone._current) {
            Sprite_AAImpactZone._current._dispose();
            Sprite_AAImpactZone._current = null;
        }
    }
    static Instance() {
        return Sprite_AAImpactZone._current;
    }
    constructor(skill, startScreenPosition) {
        super();
        this._isFollowCursor = true;
        this._isHighlightTargets = true;
        this._targetsRefreshThread = null;
        this._highlightedTargets = [];
        this._effectOffThread = null;
        this._shakeDuration = 0;
        this._skill = skill;
        this._skillPosition = startScreenPosition;
        this.anchor.x = 0.5;
        this.anchor.y = 0.5;
        this['z'] = 1; // Below characters
        this._create();
        if (this._isHighlightTargets) {
            this._targetsRefreshThread = new KDX.TimedUpdate(10, this._refreshHighlightTargets.bind(this));
        }
    }
    attention() {
        try {
            this.highlight();
            this.shake();
        }
        catch (error) {
            console.warn(error);
        }
    }
    highlight() {
        try {
            let settings = {
                color: 0xFF0000,
                innerStrength: 0.5,
                outerStrength: 1,
                quality: 0.5
            };
            let effect = {
                type: "glow",
                settings: settings
            };
            this._impactZoneVisual.addEffect(effect);
            this._effectOffThread = new KDX.TimedUpdate(10, () => {
                try {
                    if (this._impactZoneVisual) {
                        this._impactZoneVisual.removeEffect("glow");
                    }
                }
                catch (error) {
                    console.warn(error);
                }
            });
            this._effectOffThread.once();
        }
        catch (error) {
            console.warn(error);
        }
    }
    shake() {
        this._shakeDuration = 20;
    }
    setFollowCursor(value) {
        this._isFollowCursor = value;
    }
    _create() {
        if (this._skill.selectorImg && this._skill.selectorImg != '') {
            let imageSize = this._skill.gRadius() * 2 * $gameMap.tileWidth();
            //TODO: Settings for user
            this._impactZoneVisual = new KNSprite_Image({
                width: imageSize,
                height: imageSize,
                imageName: this._skill.selectorImg,
                folderName: "pictures"
            });
            this._impactZoneVisual.setCommonAnchor(0.5, 0.5);
        }
        else {
            this._impactZoneVisual = KDNUI.FromScheme(this._selectorScheme());
        }
        this.addChild(this._impactZoneVisual);
    }
    _selectorScheme() {
        let skillDiameter = this._skill.gRadius() * 2;
        let fillColor = this._skill.selectorColor;
        let fillAlpha = this._skill.selectorOpacity / 255.0;
        //TODO: Settings for user
        return {
            "type": "circle",
            "parameters": {
                "width": skillDiameter * $gameMap.tileWidth(),
                "height": skillDiameter * $gameMap.tileWidth(),
                "fillColor": fillColor,
                "fillAlpha": fillAlpha,
                "strokeWidth": 2,
                "strokeColor": fillColor,
                "strokeAlpha": 1
            },
            "bindings": {
                "position": {
                    "x": "-width/2",
                    "y": "-height/2"
                }
            }
        };
    }
    _dispose() {
        this._targetsRefreshThread = null;
        this._unhighlightTargets();
        this.visible = false;
        if (this.parent) {
            this.parent.removeChild(this);
        }
    }
    update() {
        var _a, _b;
        super.update();
        if (!this.visible)
            return;
        this._updatePosition();
        this._updateShake();
        (_a = this._effectOffThread) === null || _a === void 0 ? void 0 : _a.update();
        (_b = this._targetsRefreshThread) === null || _b === void 0 ? void 0 : _b.update();
    }
    _updatePosition() {
        if (this._isFollowCursor) {
            this._skillPosition = TouchInput;
        }
        else {
            //TODO: Gamepad stick movement?
        }
        this.move(this._skillPosition.x, this._skillPosition.y);
    }
    _updateShake() {
        if (this._shakeDuration > 0) {
            this._shakeDuration--;
            this._impactZoneVisual.x += Math.round(this._shakeDuration * 0.2 * Math.cos(this._shakeDuration));
            if (this._shakeDuration <= 0) {
                this._impactZoneVisual.x = 0;
                this._impactZoneVisual.refreshBindings();
            }
        }
    }
    _refreshHighlightTargets() {
        let mapPosition = AAUtils.screenPointToMapPoint(this._skillPosition);
        let targets = AATargetsManager2.getTargetsForSkill($gamePlayer, this._skill, mapPosition);
        for (let i = 0; i < this._highlightedTargets.length; i++) {
            let target = this._highlightedTargets[i];
            if (!targets.includes(target)) {
                AACharHighlightEffect.unhighlight(target);
            }
        }
        for (let i = 0; i < targets.length; i++) {
            let target = targets[i];
            if (!this._highlightedTargets.includes(target)) {
                AACharHighlightEffect.highlightForSkillImpact(target);
            }
        }
        this._highlightedTargets = targets;
    }
    _unhighlightTargets() {
        for (let i = 0; i < this._highlightedTargets.length; i++) {
            let target = this._highlightedTargets[i];
            AACharHighlightEffect.unhighlight(target);
        }
        this._highlightedTargets = [];
    }
}
window['Sprite_AAImpactZone'] = Sprite_AAImpactZone;


class Sprite_AAMapFlyBonus extends Sprite {
    constructor(mapIndex, isAppear) {
        super();
        this.mapIndex = mapIndex;
        //@ts-ignore
        this.obj = $gameMap.aaMapFlyBonuses()[this.mapIndex];
        this._ended = false;
        this._isShouldAppear = isAppear;
        this._initParams();
        this._setupImage();
        this._updatePosition();
        if (this._frames)
            this._updateFrame();
        if (this._isShouldAppear)
            this._setupAppear();
    }
    // * Завёршён (достиг игрока)
    isEnd() {
        return this._ended === true;
    }
    update() {
        super.update();
        if (this._frames)
            this._updateFrame();
        this._updatePosition();
        if (!this._isShouldAppear) {
            this._updateDirection();
            if (!this.isEnd())
                this._updateHit();
        }
        else {
            this._updateAppear();
        }
        this._updateMove();
        if (this.isEnd())
            this._updateEnd();
    }
    _initParams() {
        this.anchor.x = 0.5;
        this.anchor.y = 0.5;
        this['z'] = 9;
    }
    _setupImage() {
        this._setupAnimatedImg();
        this.bitmap = ImageManager.loadPicture(this.obj.image());
    }
    _setupAnimatedImg() {
        this._curFrame = 0;
        this._frameTimer = 0;
        const data = AAUtils.extractFramesAndSpeedValueFromImageName(this.obj.image());
        this._frames = data.f;
        this._frameSpeed = data.s;
    }
    _updateDirection() {
        const { x, y } = this.obj.getTargetPoint();
        const eX = x;
        const eY = y;
        const sX = this.obj.x;
        const sY = this.obj.y;
        this._angle = Math.atan2(eY - sY, eX - sX) * 180 / Math.PI;
        this.dx = this.obj.speed() * Math.cos(this._angle * Math.PI / 180);
        this.dy = this.obj.speed() * Math.sin(this._angle * Math.PI / 180);
    }
    _updatePosition() {
        this.x = this.obj.x - $gameMap.displayX() * $gameMap.tileWidth();
        this.y = this.obj.y - $gameMap.displayY() * $gameMap.tileWidth();
    }
    _updateMove() {
        this.obj.x += this.dx;
        this.obj.y += this.dy;
    }
    _updateFrame() {
        const pw = this.bitmap.width / this._frames;
        const ph = this.bitmap.height;
        const sx = this._curFrame * pw;
        const sy = 0;
        if (this._frameTimer >= this._frameSpeed) {
            this._frameTimer = 0;
            this._curFrame = this._curFrame >= this._frames - 1 ? 0 : this._curFrame + 1;
        }
        this.setFrame(sx, sy, pw, ph);
        this._frameTimer += 1;
    }
    _updateHit() {
        if (this.obj.isPhantom())
            return;
        const playerHit = this._checkHitPlayer();
        if (playerHit)
            this.onHit();
    }
    _updateEnd() {
        this.opacity -= 36;
        if (this.opacity < 50) {
            this.onEnd();
        }
    }
    onEnd() {
        this.opacity = 0;
        // * Using the same Event as Skills
        //@ts-ignore
        AA.EV.call("MapSkillsRequestsClean");
    }
    _updateAppear() {
        if (this._yUpStep >= 12) {
            this.dy = 0; // * stop moving up
            this._delay++; // * wait a little
            this._updateHit(); // * can check Hit
            if (this._delay > this._delayMax) {
                this._isShouldAppear = false; // * fly to Player
            }
        }
        else {
            this._yUpStep += 1;
            this.opacity += 20;
        }
    }
    _setupAppear() {
        this._delay = 0;
        //@ts-ignore
        this._delayMax = this.obj.delay() / 2 + Math.randomInt(this.obj.delay() + this.obj.delay() / 2);
        this._yUpStep = 0;
        this.dy = -1;
        this.opacity = 0;
        this.dx = 0;
    }
    // * Когда достиг игрока
    _checkHitPlayer() {
        //@ts-ignore
        const dist = AATargetsManager.getScreenExtDistance($gamePlayer, 0, this.x, this.y);
        return dist < 26;
    }
    onHit() {
        this._ended = true;
        this._isShouldAppear = false;
        this.obj.onHit();
    }
}
window['Sprite_AAMapFlyBonus'] = Sprite_AAMapFlyBonus;


class Sprite_AAProjectile extends Sprite {
    static CreateFor(projectile) {
        try {
            let sprite = new Sprite_AAProjectile(projectile);
            AAUtils.addToTilemap(sprite);
        }
        catch (error) {
            console.warn(error);
        }
    }
    constructor(_projectile) {
        super();
        this._projectile = _projectile;
        this._projectileHead = null;
        this._fadeTween = null;
        this._isCanRotate = true;
        if (this._projectile) {
            this._create();
            this._isCanRotate = this._projectile.isCanRotate();
            this['z'] = this._projectile.zLevel();
        }
    }
    _create() {
        this._createGraphics();
        this._createFadeOutAnimation();
    }
    _createGraphics() {
        //this.bitmap = new Bitmap(16, 16);
        //this.bitmap.fillAll('red');
        this.anchor.x = 0.5;
        this.anchor.y = 0.5;
        this._projectileHead = new Sprite_AAProjectileHead(this._projectile.projectileHeadImage());
        this.addChild(this._projectileHead);
    }
    _createFadeOutAnimation() {
        try {
            let fadeOutTime = this._projectile.fadeOutTime();
            if (fadeOutTime <= 0)
                return;
            this._fadeTween = AASimpleTween.CreateAuto(this, {
                fieldName: "opacity",
                startValue: 0,
                endValue: 255,
                delay: 0.25,
                duration: fadeOutTime,
            });
            this.opacity = 0;
        }
        catch (error) {
            console.warn(error);
        }
    }
    update() {
        super.update();
        if (!this._projectile) {
            return;
        }
        if (this._projectile.isDisposed()) {
            this.visible = false;
            this._projectile = null;
            return;
        }
        this._projectile.update();
        if (this._fadeTween) {
            this._fadeTween.update();
        }
        let currentScreenPosition = this._projectile.currentPositionOnScreen();
        this.x = currentScreenPosition.x;
        this.y = currentScreenPosition.y;
        if (this._isCanRotate) {
            this._lookAtTargetPosition();
        }
    }
    // We rotate the projectile itself to look at the target position
    _lookAtTargetPosition() {
        var angle = AAMath.getFacingAngleFromTo(this, this._projectile.targetPositionOnScreen(), true);
        // Image looking to the up, so we need to add 90 degrees (in radians) to the angle
        angle += Sprite_AAProjectileHead.ANGLE90;
        this.rotation = angle;
        // We should also flip the image if the angle is greater than 90 degrees
        this.scale.x = angle > Math.PI ? -1 : 1;
    }
}
window['Sprite_AAProjectile'] = Sprite_AAProjectile;


class Sprite_AAProjectileHead extends Sprite {
    constructor(imageName) {
        super();
        this._create(imageName);
    }
    _create(imageName = "") {
        if (imageName === "") {
            AALog.warn("Projectile: No image name provided");
            return;
        }
        this._image = new Sprite_AAAnimatedImage(imageName);
        this._image.anchor.x = 0.5;
        this._image.anchor.y = 0;
        this.addChild(this._image);
    }
    lookAtMapPoint(mapPoint) {
        var screenPoint = AAUtils.mapPointToScreenPoint(mapPoint);
        this.lookAtScreenPoint(screenPoint);
    }
    lookAtScreenPoint(screenPoint) {
        var angle = AAMath.getFacingAngleFromTo(this, screenPoint, true);
        // Image looking to the up, so we need to add 90 degrees (in radians) to the angle
        angle += Sprite_AAProjectileHead.ANGLE90;
        this.rotation = angle;
        // We should also flip the image if the angle is greater than 90 degrees
        this._image.scale.x = angle > Math.PI ? -1 : 1;
    }
}
Sprite_AAProjectileHead.ANGLE90 = Math.PI / 2;


class Sprite_AAProjectilesCollisionsLayer extends Sprite {
    constructor() {
        super();
        this._projectileCollisions = {};
        this._create();
        /*@ts-ignore*/
        this.z = 999;
    }
    static Instance() {
        return this._currentLayer;
    }
    static CreateLayer() {
        if (!this._currentLayer) {
            this._currentLayer = new Sprite_AAProjectilesCollisionsLayer();
            /*@ts-ignore*/
            SceneManager._scene._spriteset._tilemap.addChild(this._currentLayer);
        }
    }
    static DestroyLayer() {
        if (this._currentLayer) {
            //@ts-ignore
            this._currentLayer.removeFromParent();
            this._currentLayer.visible = false;
            this._currentLayer = null;
        }
    }
    static updateTool() {
        //TODO: Only in DevMode
        if (Input.isTriggered(AAPluginParams.getShowProjectilesCollisionLayerKey())) {
            if (Sprite_AAProjectilesCollisionsLayer._currentLayer) {
                Sprite_AAProjectilesCollisionsLayer.DestroyLayer();
            }
            else {
                Sprite_AAProjectilesCollisionsLayer.CreateLayer();
            }
            Input.clear();
        }
    }
    update() {
        super.update();
        if (!this.visible)
            return;
        this._updateCharCollidersPosition();
        this._updateProjectileColliders();
    }
    _create() {
        this._createHitboxes();
        this._createMapProjectilesCollisions();
    }
    _createMapProjectilesCollisions() {
        let mapColliders = AAMapCollisionsManager.getTilemapCollidersForProjectiles();
        this._mapProjectilesCollisions = [];
        mapColliders.forEach(collider => {
            this._mapProjectilesCollisions.push(this._addColliderSprite(collider));
        });
    }
    _addColliderSprite(collider) {
        let sprite = new Sprite_AACollider(collider);
        this.addChild(sprite);
        return sprite;
    }
    _createHitboxes() {
        let hitboxOwners = AABattleMapManager.getAllHitboxOwners(false);
        this._hitboxes = [];
        hitboxOwners.forEach(owner => {
            let hitboxes = AAHitBox.getFor(owner);
            hitboxes.forEach(hitbox => {
                this._hitboxes.push(this._addColliderSprite(hitbox));
            });
        });
    }
    _updateCharCollidersPosition() {
        AACharCollider.getFor($gamePlayer);
        let hitboxOwners = AABattleMapManager.getAllHitboxOwners(false);
        hitboxOwners.forEach(owner => {
            AAHitBox.getFor(owner);
        });
        let events = AAMapCollisionsManager.getEventsWithColliders();
        events.forEach(event => {
            AACharCollider.getFor(event);
        });
        let eventsWithInteractions = AAEventsInteractionsManager.getEventsWithInteractionArea();
        eventsWithInteractions.forEach(event => {
            AACharInteractionArea.getFor(event);
        });
    }
    _updateProjectileColliders() {
        let projectilesIds = AAProjectileManager.getAllProjectiles().map(p => p.uniqueId);
        let keys = Object.keys(this._projectileCollisions);
        keys.forEach(key => {
            if (!projectilesIds.includes(key)) {
                this._projectileCollisions[key].destroy();
                delete this._projectileCollisions[key];
            }
        });
        AAProjectileManager.getAllProjectiles().forEach(p => {
            if (!this._projectileCollisions[p.uniqueId]) {
                this._projectileCollisions[p.uniqueId] = this._addColliderSprite(p.getCollider());
            }
        });
    }
}
window["Sprite_AAProjectilesCollisionsLayer"] = Sprite_AAProjectilesCollisionsLayer;


// Generated by CoffeeScript 2.6.1
// * Класс для показа базовых параметров игрока HP, MP, TP
(function() {
  var Sprite_ActorStateGauge;
  Sprite_ActorStateGauge = class Sprite_ActorStateGauge extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
    }

    //%[I] Переделать вывод значения как у Enemy Mini HP
    defaultParams() {
      return AA.PP._getDefaultVisualFor_hpGauge();
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

    //$[OVER]
    isHaveHideWithMessageFlag() {
      return this.params.isHideWithMessage === true;
    }

    drawGauge(percent) {
      return this.gauge.draw(percent);
    }

    drawText(text) {
      return this.text.draw(text);
    }

  };
  AA.link(Sprite_ActorStateGauge);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_ActorStateGauge.prototype;
  //$[OVER]
  _._createContent = function() {
    this._createGauge();
    this._createText();
    this._createLabel();
    //%[I] Делать eval для позиции
    return this.move(this.params.position);
  };
  _._createGauge = function() {
    this.gauge = new KDCore.UI.Sprite_UIGauge(this.params.gauge);
    return this.add(this.gauge);
  };
  _._createText = function() {
    this.text = new KDCore.UI.Sprite_UIText(this.params.text);
    return this.add(this.text);
  };
  _._createLabel = function() {
    var label;
    if (String.isNullOrEmpty(this.params.label)) {
      return;
    }
    label = new KDCore.UI.Sprite_UIImage();
    label.draw(this.params.label);
    label.move(this.params.labelMargins);
    return this.add(label);
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс для показа иконки состояния или баффа игрока
(function() {
  var Sprite_ActorStateIcon;
  //%[I] Улучшенные настройки, чтобы можно было разным цветом рисовать цифры
  // * Можно было у состояния прописать стиль (было в AABS)
  Sprite_ActorStateIcon = class Sprite_ActorStateIcon extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
    }

    //@_lastIconIndex = 0
    //@_lastTextValue = null

      //defaultParams: -> AA.PP._getDefaultActorBuffIcon()
    drawBuffInfo(iconIndex, text) {
      this._drawStateIcon(iconIndex);
      this._drawBuffText(text);
    }

    drawStateInfo(iconIndex, text, isActionCounted = false) {
      this.drawBuffInfo(iconIndex, text); // * same
      if (isActionCounted === true) {
        this._drawStateActText(text); // * overwrite time text to action count text
      }
    }

    drawIcon(index) {
      return this.icon.draw(index);
    }

    drawText(text) {
      return this.text.draw(text);
    }

    clear() {
      this.drawIcon(0);
      return this.drawText("");
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

  };
  AA.link(Sprite_ActorStateIcon);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_ActorStateIcon.prototype;
  //$[OVER]
  _._createContent = function() {
    this._createIcon();
    this._createText();
    return this.move(this.params.position);
  };
  _._createIcon = function() {
    this.icon = new KDCore.UI.Sprite_UIIcon(this.params.icon);
    return this.add(this.icon);
  };
  _._createText = function() {
    this.text = new KDCore.UI.Sprite_UIText(this.params.text);
    return this.add(this.text);
  };
  _._drawStateIcon = function(iconIndex) {
    //return if @_lastIconIndex == iconIndex
    this.drawIcon(iconIndex);
  };
  //@_lastIconIndex = iconIndex
  _._drawBuffText = function(text) {
    var e, time;
    try {
      //return if @_lastTextValue == text
      if ((text != null) && isFinite(text)) {
        time = KDCore.Utils.convertTimeShort(text);
        return this.drawText(this.params.textFormat.replace("%1", time));
      } else {
        return this.drawText(text);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  //@_lastTextValue = text
  _._drawStateActText = function(text) {
    var e;
    try {
      //return if @_lastTextValueA == text
      if ((text != null) && isFinite(text)) {
        return this.drawText(this.params.textFormatA.replace("%1", text));
      } else {
        return this.drawText(text);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------
//@_lastTextValueA = text


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Animation.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__targetSpritePosition, _;
  // * MZ only
  if (KDCore.isMV()) {
    return;
  }
  //@[DEFINES]
  _ = Sprite_Animation.prototype;
  //@[ALIAS]
  ALIAS__targetSpritePosition = _.targetSpritePosition;
  _.targetSpritePosition = function(sprite) {
    var e;
    try {
      if (sprite instanceof Sprite_Character && (sprite.parent == null)) {
        AALog.warn("Sprite_Character not added to parent");
        if (AAUtils.isSceneMap()) {
          SceneManager._scene._spriteset._tilemap.addChild(sprite);
        } else {
          return {
            x: 0,
            y: 0
          };
        }
      }
      return ALIAS__targetSpritePosition.call(this, sprite);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return {
        x: 0,
        y: 0
      };
    }
  };
})();

// ■ END Sprite_Animation.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Animation.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  if (AAUtils.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Sprite_Animation.prototype;
  _.aaApplyMapScale = function() {
    var scallingFactor;
    scallingFactor = AA.PP.getAnimationAutoScallingFactor();
    if (scallingFactor <= 0) {
      return;
    }
    this.scale.x = scallingFactor;
    this.scale.y = scallingFactor;
  };
})();

// ■ END Sprite_Animation.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startAnimation, _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  if (AAUtils.isMZ()) {
    return;
  }
  //@[ALIAS]
  ALIAS__startAnimation = _.startAnimation;
  _.startAnimation = function() {
    var e, ref;
    ALIAS__startAnimation.call(this, ...arguments);
    // * Применяем масштабирование анимации
    if ((this._character != null) && this._character.__aaIsRequestAnimationScale === true) {
      try {
        this._character.__aaIsRequestAnimationScale = false;
        if ((ref = this._animationSprites.last()) != null) {
          ref.aaApplyMapScale();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__setCharacter, ALIAS__update, _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    this._aaIsShouldCheckVisionDraw = false;
    AA.EV.subscribeFor("UnderMouseEventChanged", this.gev_onUnderMouseEventChanged.bind(this));
  };
  
  //@[ALIAS]
  ALIAS__setCharacter = _.setCharacter;
  _.setCharacter = function() {
    ALIAS__setCharacter.call(this, ...arguments);
    this._aaPrepareMotion();
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    // * Если в зоне навыка, подсвечиваться
    this._aaUpdate();
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  // * Создать дополнительные спрайты для ABS системы
  _.initABS = function() {
    this._aaSetupExtraInfo();
    this._aaSetupWeaponMotionSprite();
    this._aaSetupStateOverlaySprite();
    this._aaSetupStateIcon();
  };
  _.isPlayer = function() {
    return this._character === $gamePlayer;
  };
  _.isABSEntity = function() {
    return (this._character != null) && this._character.isABS() && (this._character.AABattler() != null);
  };
  _.isAllyParty = function() {
    return this.isABSEntity() && this._character.AAEntity().isAlly();
  };
  _.isEnemy = function() {
    return this.isABSEntity() && this._character.AAEntity().isEnemy();
  };
  _._aaUpdate = function() {
    this._aaUpdateDamagePopUps();
    this._aaUpdateSpriteEffects();
    this._aaUpdateWeaponMotion();
    this._aaUpdateStateOverlay();
    this._aaUpdateStateIcon();
    this._aaUpdateMotion();
    this._aaUpdateExtraInfo();
  };
  _._aaUpdateDamagePopUps = function() {
    var b, data;
    if (!this.isABSEntity()) {
      return;
    }
    b = this._character.AABattler();
    if (!b.isDamagePopupRequested()) {
      return;
    }
    data = AADamagePopUpFactory.createDamagePopUpData(b);
    if (data != null) {
      Sprite_AADamagePopUpItem.CreateOnCharacterBinded(this._character, data.settings, data.value);
      AANetworkManager.showDamagePopUpOnCharacter(this._character, data);
    }
    this._aaRefreshExtraInfoOnDamage();
    b.clearDamagePopup();
    b.clearResult();
  };
  _.gev_onUnderMouseEventChanged = function() {
    var e;
    try {
      return this._aaRefreshExtraInfoState();
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _._aaPrepareMotion = function() {
    if ((this._character != null) && this._character.aaIsSupportMotion()) {
      return this._aaUpdateMotion = this._aaUpdateMotionBody;
    } else {
      return this._aaUpdateMotion = function() {}; // * EMPTY
    }
  };
  
  //?DYNAMIC
  _._aaUpdateMotion = function() {};
  _._aaUpdateMotionBody = function() {
    var motion;
    if (!this.isABSEntity()) {
      return;
    }
    if (this._character.aaIsMotionRequested()) {
      motion = Sprite_Actor.MOTIONS[this._character.aaMotionType];
      if (motion !== this._aaCurrentMotionType) {
        if (this._aaMotionSprite != null) {
          this._aaClearMotion();
        }
        this._aaSetupMotion(motion);
      }
    } else {
      if (this._aaMotionSprite != null) {
        this._aaClearMotion();
      }
    }
    if (this._aaMotionSprite != null) {
      this._aaUpdateMotionAnimation();
    }
  };
  _._aaSetupMotion = function(motion) {
    var e;
    if (motion == null) {
      return;
    }
    if (this._aaCurrentMotionType === motion) {
      return;
    }
    try {
      // * Sprite creation
      this._aaMotionSprite = new Sprite();
      this._aaMotionSprite.x = 0.5;
      this._aaMotionSprite.y = 1;
      this._aaMotionSprite.bitmap = ImageManager.loadSvActor(this._character.AABattler().battlerName());
      this._aaMotionSprite.scale.set(0.8);
      // * По стандарту, спрайт смотрит влево, перевернём его, если  персонаж смотрел вправо
      if (this._character.direction() === 6) {
        this._aaMotionSprite.scale.x *= -1;
        // * Нужно добавить также сдвиг самого спрайта
        this._aaMotionDX = this.patternWidth();
      } else {
        this._aaMotionDX = 0;
      }
      this.parent.addChild(this._aaMotionSprite);
      // * Motion setup
      this._aaCurrentMotionType = motion;
      this._aaMotionCount = 0;
      this._aaMotionPattern = 0;
      this._character.setTransparent(true);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaMotionSprite = null;
      this._character.aaClearMotion();
    }
  };
  _._aaClearMotion = function() {
    this._aaCurrentMotionType = null;
    this._aaMotionSprite.removeFromParent();
    this._aaMotionSprite.visible = false;
    this._aaMotionSprite = null;
    this._character.setTransparent(false);
  };
  _._aaUpdateMotionAnimation = function() {
    var b, ch, cw, cx, cy, motionIndex;
    b = this._aaMotionSprite.bitmap;
    motionIndex = this._aaCurrentMotionType.index;
    cw = b.width / 9;
    ch = b.height / 6;
    cx = Math.floor(motionIndex / 6) * 3 + this._aaMotionPattern;
    cy = motionIndex % 6;
    this._aaMotionSprite.setFrame(cx * cw, cy * ch, cw, ch);
    this._aaMotionSprite.x = this._character.screenX() + this._aaMotionDX - this.patternWidth() / 2;
    this._aaMotionSprite.y = this._character.screenY() - this.patternHeight();
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------
//TODO: animation with delay
//@_aaMotionPattern++
//@_aaMotionPattern = 1 if @_aaMotionPattern > 3
//console.log(@_aaMotionPattern)


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _._aaUpdateSpriteEffects = function() {
    this._aaUpdateSpriteEffectValues();
    if (this._character.aaIsShakeRequested()) {
      this._aaUpdateSpriteShakeEffect();
    }
    if (this._character.aaIsShatterRequested()) {
      this._aaStartSpriteShatterEffect();
    }
  };
  // * Применение дополнительных значений к базовым
  _._aaUpdateSpriteEffectValues = function() {
    this.x += this._character.aaMotionDX();
  };
  _._aaUpdateSpriteShakeEffect = function() {
    var remainingTime;
    this._character._aaShakeEffectData[0] -= 1;
    remainingTime = this._character._aaShakeEffectData[0];
    this._character._aaShakeEffectData[1] += Math.round(remainingTime * 0.4 * Math.cos(remainingTime));
    if (this._character._aaShakeEffectData[0] <= 0) {
      // * Возвращаем на 0, когда время вышло
      this._character._aaShakeEffectData[1] = 0;
    }
  };
  _._aaStartSpriteShatterEffect = function() {
    $gameMap.aaSpriteset().aaCreateShatterEffect(this);
    this._character.aaOnShatterEffectCreated();
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //TODO: Тут стоит условие return unless @isABSEntity(), возможно если сначала событие было
  // * не АБС, а потом станет АБС, то не будет MiniHP Bar видно, проверить и исправить!
  _._aaSetupExtraInfo = function() {
    if (!this.isABSEntity()) {
      return;
    }
    // * Игрок не имеет дополнительной информации
    if (this.isPlayer()) {
      return;
    }
    this._characterAASettings = this._character.AAEntity().model();
    if (this._characterAASettings == null) {
      return;
    }
    // * Дальше код выполняется только для Enemies Events
    this._aaSetupMiniHpGauge();
    if (this.isEnemy()) {
      this._aaSetupVisionDrawCheck();
    }
  };
  _._aaSetupMiniHpGauge = function() {
    var e, params;
    //TODO: PARTY UPD Другой стиль для союзников???
    if (!AA.PP.getMiniHpGaugeSettings().active) {
      return;
    }
    params = AA.PP.uiData("enemyMiniHp", this._characterAASettings.miniHpGaugeStyle);
    this.aaMiniHPGauge = new AA.Sprite_CharacterMiniGauge(params);
    try {
      //console.log @_characterAASettings.miniHPGaugeOffset
      if ((this._characterAASettings.miniHPGaugeOffset != null) && this._characterAASettings.miniHPGaugeOffset instanceof Array) {
        this.aaMiniHPGauge.setExtraMargins(...this._characterAASettings.miniHPGaugeOffset);
      }
      this.aaMiniHPGauge.refreshPosition(0, 0); // * чтобы Margins применились безопасно
    } catch (error) {
      e = error;
      AA.w(e);
      this.aaMiniHPGauge.setExtraMargins(0, 0);
    }
    this.aaMiniHPGauge.setupController(this._character.AABattler(), "hpRate");
    if (AA.PP.getMiniHpGaugeSettings().showOnlyOnHover === true) {
      this._aaMiniHpShowHideOnHover = true;
      this.aaMiniHPGauge.hideInstant();
    }
    if (AA.PP.getMiniHpGaugeSettings().showWhenNotFull === true) {
      this._aaMiniHpShowWhenNotFull = true;
      // * Эти два параметра не совместимы
      this._aaMiniHpShowHideOnHover = false;
      this.aaMiniHPGauge.hideInstant();
      this._aaMiniHpBattlerHpRateThread = new KDCore.TimedUpdate(10, this._aaCheckBattlerHpRate.bind(this));
    }
    return this.addChild(this.aaMiniHPGauge);
  };
  _._aaRefreshExtraInfoState = function() {
    // * Использую как флаг, что у спрайта есть АБС персонаж
    if (this._characterAASettings == null) {
      return;
    }
    if (!this._aaMiniHpShowHideOnHover) {
      return;
    }
    if ($gameTemp._aaEventUnderCursor != null) {
      if ($gameTemp._aaEventUnderCursor === this._character) {
        this.aaMiniHPGauge.showSlow();
      } else {
        this.aaMiniHPGauge.hideSlow();
      }
    } else {
      this.aaMiniHPGauge.hideSlow();
    }
  };
  _._aaRefreshExtraInfoOnDamage = function() {
    if (this.aaMiniHPGauge == null) {
      return;
    }
    this.aaMiniHPGauge.refreshValues();
    // * Если всегда видно, то нет смысла
    if (AA.PP.getMiniHpGaugeSettings().showOnlyOnHover === false) {
      return;
    }
    // * Если контроллируется по не полному ХП, то тоже нет смысла
    if (this._aaMiniHpShowWhenNotFull === true) {
      return;
    }
    // * Только если опция включена
    if (!AA.PP.getMiniHpGaugeSettings().showOnDamage) {
      return;
    }
    this.aaMiniHPGauge.showAndHide();
  };
  _._aaUpdateExtraInfo = function() {
    this._aaUpdateVisionDraw();
    if (!this.isABSEntity()) {
      return;
    }
    if (!this._aaMiniHpShowWhenNotFull) {
      return;
    }
    return this._aaMiniHpBattlerHpRateThread.update();
  };
  _._aaCheckBattlerHpRate = function() {
    var e;
    if ((this._character == null) || (this._character.AABattler() == null)) {
      this.aaMiniHPGauge.hideInstant();
      return;
    }
    try {
      if (this._character.AABattler().hpRate() !== 1) {
        if (!this.aaMiniHPGauge.isVisible()) {
          this.aaMiniHPGauge.showSlow();
        }
      } else {
        if (!this.aaMiniHPGauge.isVisible()) {
          this.aaMiniHPGauge.hideInstant();
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //TODO: НЕ РАБОТАЕТ ПО СЕТИ, двигается вместе со своим персонажем
  _._aaSetupStateOverlaySprite = function() {
    this._aaStateOverlaySprite = new Sprite_StateOverlay();
    this._aaStateOverlaySprite.scale.set(0.8);
    this._aaStateOverlaySprite.z = 3;
    this._aaStateOverlaySprite.setup(this._character.AABattler());
    return this.parent.addChild(this._aaStateOverlaySprite);
  };
  _._aaUpdateStateOverlay = function() {
    if (this._aaStateOverlaySprite == null) {
      return;
    }
    return this._aaStateOverlaySprite.move(this.x, this.y + 12);
  };
  _._aaSetupStateIcon = function() {
    var e, x, y;
    try {
      if (this.isEnemy() && !AA.PP.getIsStateIconVisibleAboveEnemy()) {
        return;
      }
      if (this.isPlayer() && !AA.PP.getIsStateIconVisibleAbovePlayer()) {
        return;
      }
      if (this.isAllyParty() && !AA.PP.getIsStateIconVisibleAboveAlly()) {
        return;
      }
      this._aaStateIcon = new Sprite_StateIcon();
      this._aaStateIcon.setup(this._character.AABattler());
      this._aaStateIcon.scale.set(AA.PP.getStateIconScale());
      ({x, y} = AA.PP.getStateIconOffsets());
      this._aaStateIcon.x = x;
      this._aaStateIcon.y = y;
      this.addChild(this._aaStateIcon);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this._aaStateIcon = null;
    }
  };
  _._aaUpdateStateIcon = function() {}; // * EMPTY
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------
//return unless @_aaStateIcon?


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _._aaSetupVisionDrawCheck = function() {
    this._aaIsShouldCheckVisionDraw = true;
  };
  _._aaIsDrawVision = function() {
    return this._aaIsShouldCheckVisionDraw === true && ($gameSystem.aaDrawEnemyVision != null) && this._character.isABS();
  };
  _._aaUpdateVisionDraw = function() {
    var e;
    if (this._aaIsDrawVision()) {
      try {
        if (this._aaVisionSpr == null) {
          this._aaCreateVisionSprite();
        }
        return this._aaRefreshVisionSprite();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return $gameSystem.aaDrawEnemyVision = null;
      }
    } else {
      if (this._aaVisionSpr != null) {
        this._aaDestroyVisionSprite();
        return this._aaIsShouldCheckVisionDraw = false;
      }
    }
  };
  _._aaDestroyVisionSprite = function() {
    var e;
    if (this._aaVisionSpr == null) {
      return;
    }
    try {
      this._aaVisionSpr.visible = false;
      this._aaVisionSpr.removeFromParent();
      return this._aaVisionSpr = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaCreateVisionSprite = function() {
    var e;
    try {
      this._aaIsVisionIsTriangle = this._characterAASettings.isTVision();
      if (this._aaIsVisionIsTriangle === true) {
        this._aaCreateVisionTriangle();
      } else {
        this._aaCreateVisionCircle();
      }
      this._aaVisionSpr.opacity = $gameSystem.aaDrawEnemyVision.opacity;
      this._aaVisionSpr.z = 0;
      return this.parent.addChild(this._aaVisionSpr);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaCreateVisionTriangle = function() {
    var color, th, tw;
    tw = this._characterAASettings.gViewRadius() * $gameMap.tileWidth();
    th = this._characterAASettings.gTVisor() * $gameMap.tileWidth();
    this._aaVisionSpr = KDCore.Sprite.FromBitmap(tw, th * 4);
    color = $gameSystem.aaDrawEnemyVision.color;
    this._aaVisionSpr.b().drawTriangle(tw, th, color);
    this._aaDrawExtraSideVisors(this._characterAASettings.sideVisor);
  };
  _._aaDrawExtraSideVisors = function(size) {
    var b, color, h, mod, th, tw, w;
    if (size <= 0) {
      return;
    }
    if (size > 1) {
      //TODO: more then 1 not supported
      size = 1;
    }
    color = $gameSystem.aaDrawEnemyVision.color;
    tw = $gameMap.tileWidth();
    th = $gameMap.tileHeight();
    h = th * size;
    w = tw;
    b = this._aaVisionSpr.b();
    b.fillRect(0, (b.width / 2) + tw * 1.5, tw, tw * size, color);
    if (size === 1) {
      mod = 0; // * Not supported by AI logic yet
    } else {
      mod = ((size - 1) * tw) * -1;
    }
    b.fillRect(0, ((b.width / 2) + tw * 0.5) + mod, tw, tw * size, color);
  };
  _._aaCreateVisionCircle = function() {
    var bs, color, cr, cx, r;
    r = this._characterAASettings.gViewRadius();
    bs = (r + 4) * $gameMap.tileWidth();
    cx = bs / 2;
    cr = r * $gameMap.tileWidth();
    color = $gameSystem.aaDrawEnemyVision.color;
    this._aaVisionSpr = KDCore.Sprite.FromBitmap(bs, bs);
    this._aaVisionSpr.b().drawCircle(cx, cx, cr, color);
    this._aaVisionSpr.anchor.set(0.5, 0.5);
  };
  _._aaRefreshVisionSprite = function() {
    var e;
    try {
      this._aaVisionSpr.move(this.x, this.y - this.height / 2);
      if (this._aaIsVisionIsTriangle === true) {
        return this._aaRefershVisionTriangle();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaRefershVisionTriangle = function() {
    var dir, e;
    try {
      dir = this._character.direction();
      this._aaVisionSpr.visible = true;
      if (dir === 4) {
        this._aaVisionSpr.anchor.set(0, 0.5);
        this._aaVisionSpr.scale.x = -1;
        return this._aaVisionSpr.rotation = 0;
      } else if (dir === 6) {
        this._aaVisionSpr.anchor.set(0, 0.5);
        this._aaVisionSpr.scale.x = 1;
        return this._aaVisionSpr.rotation = 0;
      } else if (dir === 8) {
        this._aaVisionSpr.anchor.set(0, 0.5);
        this._aaVisionSpr.scale.x = -1;
        return this._aaVisionSpr.rotation = 1.57;
      } else if (dir === 2) {
        this._aaVisionSpr.anchor.set(0, 0.5);
        this._aaVisionSpr.scale.x = 1;
        return this._aaVisionSpr.rotation = 1.57;
      } else {
        return this._aaVisionSpr.visible = false;
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  _._aaSetupWeaponMotionSprite = function() {
    this._aaSprWeapMotionHolder = new Sprite();
    // * Новый класс используется, он внутри себя содержит и старую и новую реализацию
    this._aaSprWeapon = new AA.Sprite_WeaponMotionSelector();
    this._aaSprWeapMotionHolder.addChild(this._aaSprWeapon);
  };
  _._aaUpdateWeaponMotion = function() {
    var b, direction, e;
    if (!this.isABSEntity()) {
      return;
    }
    if (this._aaSprWeapMotionHolder == null) {
      this._aaSetupWeaponMotionSprite();
    }
    this._aaSprWeapMotionHolder.move(this.x, this.y);
    b = this._character.AABattler();
    if (!b.isWeaponAnimationRequested()) {
      return;
    }
    if (this._aaSprWeapon == null) {
      return;
    }
    try {
      this._aaSprWeapon.setup(b.weaponImageId());
      //@_aaSprWeapon.setup("Motion_Sword(3,12)")
      direction = this._character.direction();
      this._aaSprWeapon.aaSetDirection(direction);
      if (direction === 8) { // * UP
        // * Ниже персонажа, так как персонаж спиной к нам
        this.parent.addChildAt(this._aaSprWeapMotionHolder, 1);
      } else {
        // * Выше персонажа
        this.parent.addChild(this._aaSprWeapMotionHolder);
      }
    } catch (error) {
      e = error;
      AA.w(e);
    } finally {
      b.clearWeaponAnimation();
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс для показа полоски здоровья над персонажами на карте
// * Имеет свой встроенный контроллер
(function() {
  var Sprite_CharacterMiniGauge;
  //rev 30.06.2021
  Sprite_CharacterMiniGauge = class Sprite_CharacterMiniGauge extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
      // * По умолчанию нету доп. смещения
      // * (у каждого события может быть своё, это см. в Model)
      this.setExtraMargins(0, 0);
      return;
    }

    setupController(battler, rateGetter) {
      this.battler = battler;
      this.rateGetter = rateGetter;
      // * Если изначально в параметрах visible == false, то ничего
      if (!this.isActive()) {
        return;
      }
      this.visible = this.battler != null;
      this.controllerThread = new KDCore.TimedUpdate(10, this.refreshValues.bind(this));
    }

    defaultParams() {
      return AA.PP._getDefaultVisualFor_enemyMiniHp();
    }

    setExtraMargins(dx, dy) {
      this.dx = dx;
      this.dy = dy;
    }

    refreshPosition(x, y) {
      // * Настройки сперва (смещение)
      this._resetPosition();
      // * Затем координаты на экране
      this.x += x;
      this.y += y;
      // * Теперь дополнительные настройки
      this.x += this.dx;
      this.y += this.dy;
    }

    showInstant() {
      this.visible = true;
      return this.opacity = 255;
    }

    isVisible() {
      return this.visible === true;
    }

    showSlow() {
      if (this.visible === true && this.opacity >= 255) {
        return;
      }
      this.refreshValues();
      this.visible = true;
      this.changer = new KDCore.Changer(this);
      this.changer.change('opacity').from(0).to(255).step(35).start();
      this.showHideThread = null;
    }

    hideInstant() {
      return this.visible = false;
    }

    hideSlow() {
      if (this.visible === false) {
        return;
      }
      if (this.showHideThread != null) {
        return;
      }
      if (this.opacity <= 0) {
        return;
      }
      this.changer = new KDCore.Changer(this);
      this.changer.change('opacity').from(this.opacity).to(0).step(45).start().done(() => {
        return this.visible = false;
      });
    }

    showAndHide() {
      if (this.visible === true) {
        return;
      }
      if (this.showHideThread != null) {
        return;
      }
      this.showSlow();
      this.showHideThread = new KDCore.TimedUpdate(60, this._hideAfterTime.bind(this));
      this._updateShowHide = this._updateShowHideBody;
    }

    drawGauge(percent) {
      return this.gauge.draw(percent);
    }

    drawText(text) {
      return this.text.draw(text);
    }

    //TODO: Динамическую смену
    refreshValues() {
      var newRate;
      if (this.__prevRate == null) {
        this.__prevRate = this.battler[this.rateGetter]();
        this.drawGauge(this.__prevRate);
      } else {
        newRate = this.battler[this.rateGetter]();
        //TODO: animated?
        //if newRate < @__prevRate
        //    diff = @__prevRate - newRate
        if (newRate !== this.__prevRate) {
          this.__prevRate = newRate;
          this.drawGauge(newRate);
        }
      }
    }

    update() {
      var ref;
      super.update();
      this._updateController();
      this._updateShowHide();
      if ((ref = this.changer) != null) {
        ref.update();
      }
    }

  };
  AA.link(Sprite_CharacterMiniGauge);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_CharacterMiniGauge.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_CharacterMiniGauge.prototype;
  //$[OVER]
  _._createContent = function() {
    this._createGauge();
    this._createText();
    this._createLabel();
    return this.move(this.params.position);
  };
  _._createGauge = function() {
    this.gauge = new KDCore.UI.Sprite_UIGauge(this.params.gauge);
    return this.add(this.gauge);
  };
  _._createText = function() {
    this.text = new KDCore.UI.Sprite_UIText(this.params.text);
    return this.add(this.text);
  };
  _._createLabel = function() {
    var label;
    if (String.isNullOrEmpty(this.params.label)) {
      return;
    }
    label = new KDCore.UI.Sprite_UIImage();
    label.draw(this.params.label);
    label.move(this.params.labelMargins);
    return this.add(label);
  };
  _._updateController = function() {
    if (!this.isActive()) {
      return;
    }
    if (this.battler == null) {
      return;
    }
    return this.controllerThread.update();
  };
  _._hideAfterTime = function() {
    this.showHideThread = null;
    return this.hideSlow();
  };
  //?DYNAMIC
  _._updateShowHide = function() {}; // * EMPTY
  _._updateShowHideBody = function() {
    var ref;
    return (ref = this.showHideThread) != null ? ref.update() : void 0;
  };
})();

// ■ END Sprite_CharacterMiniGauge.coffee
//---------------------------------------------------------------------------


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Destination.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Sprite_Destination.prototype;
    //@[ALIAS]
    const ALIAS__update = _.update;
    _.update = function (...args) {
        let previousFrameCount = this._frameCount;
        ALIAS__update.call(this, ...args);
        try {
            if (AAPathMover.isHavePathFor($gamePlayer)) {
                let path = AAPathMover.getMovePathFor($gamePlayer);
                if (path) {
                    this._frameCount = previousFrameCount;
                    let goal = path.getGoalPoint();
                    const tileWidth = $gameMap.tileWidth();
                    const tileHeight = $gameMap.tileHeight();
                    const x = goal.x;
                    const y = goal.y;
                    this.x = ($gameMap.adjustX(x) + 0.5) * tileWidth;
                    this.y = ($gameMap.adjustY(y) + 0.5) * tileHeight;
                    this.updateAnimation();
                    this.visible = true;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    };
})();
// ■ END Sprite_Destination.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс для отображения информации о враге на экране (портрет, здоровье и т.д.)
(function() {
  var Sprite_EnemyInfo;
  Sprite_EnemyInfo = class Sprite_EnemyInfo extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
    }

    defaultParams() {
      return AA.PP._getDefaultVisualFor_enemyInfo();
    }

    //TODO: Уже есть в двух классах, может вынести на UIElement ???
    //(Sprite_CharacterMiniGauge)
    showSlow() {
      if (this.visible === true && this.opacity >= 255) {
        return;
      }
      this.visible = true;
      this.changer = new KDCore.Changer(this);
      this.changer.change('opacity').from(0).to(255).step(35).start();
    }

    hideSlow() {
      if (this.visible === false) {
        return;
      }
      if (this.opacity <= 0) {
        return;
      }
      this.changer = new KDCore.Changer(this);
      this.changer.change('opacity').from(this.opacity).to(0).step(45).start().done(() => {
        return this.visible = false;
      });
    }

    drawStates(iconsArray) {
      var e, i, iconIndex, index, len, results, stateIcon, statesIcons;
      try {
        if (iconsArray == null) {
          iconsArray = [];
        }
        if (this.stateIconsGroup == null) {
          return;
        }
        statesIcons = this.stateIconsGroup.children;
        results = [];
        for (index = i = 0, len = statesIcons.length; i < len; index = ++i) {
          stateIcon = statesIcons[index];
          iconIndex = iconsArray[index];
          if (iconIndex == null) {
            results.push(stateIcon.draw(0));
          } else {
            results.push(stateIcon.draw(iconIndex));
          }
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

    //$[OVER]
    isHaveHideWithMessageFlag() {
      return this.params.isHideWithMessage === true;
    }

    // * Value: level
    drawLevelWithFormat(value) {
      var e, ref, ref1;
      try {
        if (this.params.levelFormat == null) {
          return (ref = this.levelText) != null ? ref.draw(value) : void 0;
        } else {
          return (ref1 = this.levelText) != null ? ref1.draw(this.params.levelFormat.replace("%1", value)) : void 0;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Values: current, max, rate
    drawHpWithFormat(value1, value2, value3) {
      var e, text;
      if (this.hpText == null) {
        return;
      }
      try {
        if (this.params.hpTextFormat == null) {
          this.params.hpTextFormat = "%1";
        }
        text = this.params.hpTextFormat.replace("%1", value1);
        if (value2 != null) {
          text = text.replace("%2", value2);
        }
        if (value3 != null) {
          text = text.replace("%3", value3);
        }
        return this.hpText.draw(text);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Value: name
    drawNameWithFormat(value) {
      var e, ref, ref1;
      try {
        if (this.params.levelFormat == null) {
          return (ref = this.nameText) != null ? ref.draw(value) : void 0;
        } else {
          return (ref1 = this.nameText) != null ? ref1.draw(this.params.nameFormat.replace("%1", value)) : void 0;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    drawFace(faceName, faceIndex) {
      var ref;
      return (ref = this.face) != null ? ref.draw(...arguments) : void 0;
    }

    //TODO: Отрисовка пользовательских картинок цели
    drawCustomImages() {}

    // * удаляются и отрисовываются заного
    update() {
      var ref;
      super.update();
      return (ref = this.changer) != null ? ref.update() : void 0;
    }

  };
  AA.link(Sprite_EnemyInfo);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_EnemyInfo.prototype;
  //$[OVER]
  _._createContent = function() {
    if (!this.isActive()) {
      return;
    }
    this._createBase();
    this._createGauge();
    this._createHpText();
    this._createFaceImage();
    this._createNameText();
    this._createLevelText();
    this._createBattleState();
    this._createStatesIcons();
    // * Слой для статусов и бафов
    this._statesLayer = new Sprite();
    this.addChild(this._statesLayer);
    // * Для пользовательских картинок из параметров конкретного монстра
    this._customImagesLayer = new Sprite();
    this.addChild(this._customImagesLayer);
    this._createForegroundImage();
    return this.move(this.params.position);
  };
  _._createBase = function() {
    this.base = new KDCore.UI.Sprite_UIImage(this.params);
    this.add(this.base);
  };
  _._createGauge = function() {
    this.gauge = new KDCore.UI.Sprite_UIGauge(this.params.gauge);
    this.gauge.move(this.params.gaugeMargins);
    return this.add(this.gauge);
  };
  _._createHpText = function() {
    this.hpText = new KDCore.UI.Sprite_UIText(this.params.hpText);
    return this.add(this.hpText);
  };
  _._createFaceImage = function() {
    this.face = new KDCore.UI.Sprite_UIFace(this.params.face);
    this.face.move(this.params.face.margins);
    return this.add(this.face);
  };
  _._createNameText = function() {
    var e;
    try {
      this.nameText = new KDCore.UI.Sprite_UIText(this.params.nameText);
      return this.add(this.nameText);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createLevelText = function() {
    var e;
    try {
      this.levelText = new KDCore.UI.Sprite_UIText(this.params.levelText);
      return this.add(this.levelText);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createBattleState = function() {
    this.battleState = new KDCore.UI.Sprite_UIImage(this.params.battleState);
    this.battleState.move(this.params.battleState.margins);
    return this.add(this.battleState);
  };
  _._createStatesIcons = function() {
    var e, i, len, p, ref, stateIcon;
    this.stateIconsGroup = new Sprite();
    ref = AA.PP.getUIEnemyStatesIconsSet();
    for (i = 0, len = ref.length; i < len; i++) {
      p = ref[i];
      try {
        stateIcon = this._createStateIcon(p.x, p.y);
        this.stateIconsGroup.addChild(stateIcon);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }
    this.add(this.stateIconsGroup);
  };
  _._createStateIcon = function(x, y) {
    var icon, p;
    p = {
      visible: true,
      index: 0,
      size: 32
    };
    icon = new KDCore.UI.Sprite_UIIcon(p);
    icon.move(x, y);
    icon.scale.set(AA.PP.getUIEnemyStateIconOnUIScale());
    return icon;
  };
  // * Для пользователя, по умолчанию не используется
  _._createForegroundImage = function() {
    var foregroundImage;
    foregroundImage = new KDCore.UI.Sprite_UIImage(this.params.foregroundImage);
    foregroundImage.move(this.params.foregroundImage.margins);
    return this.add(foregroundImage);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс ячейки быстрого доступа для АБС навыка (предмета)
//rev 07.07.21
(function() {
  var Sprite_SKillPanelItem;
  Sprite_SKillPanelItem = class Sprite_SKillPanelItem extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
    }

    // * Позиция не определяется, так как каждый элемент имеет свою позицию
    defaultParams() {
      return AA.PP._getDefaultVisualFor_skillSlot();
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

    //$[OVER]
    isHaveHideWithMessageFlag() {
      return this.params.isHideWithMessage === true;
    }

    //$[OVER]
    isUnderMouse() {
      return this.icon.isUnderMouse() && this.isFullVisible();
    }

    pulseClick() {
      return this.notifyOutline.pulse(this._clickedColor, this.params.outlinePulseSpeed);
    }

    pulseReady() {
      return this.notifyOutline.pulse(this._readyColor, this.params.outlinePulseSpeed);
    }

    pulseAlert() {
      return this.notifyOutline.pulse(this._badColor, this.params.outlinePulseSpeed);
    }

    hideOutline() {
      return this.notifyOutline.hide();
    }

    select() {
      return this.selectionOutline.show(this._selectionColor);
    }

    deselect() {
      return this.selectionOutline.hide();
    }

    clear() {
      this.enable();
      this.drawIcon(0);
      this.drawCount("");
      return this.drawTime("");
    }

    //@disable() #??? or @enable()
    //TODO: hide if option
    drawIcon() {
      return this.icon.draw(...arguments);
    }

    drawSymbol() {
      return this.text.draw(...arguments);
    }

    drawCount(a) {
      return this.countText.draw(...arguments);
    }

    drawTime() {
      return this.timeText.draw(...arguments);
    }

    disable() {
      this.button.disable();
      this.state.visible = true;
    }

    enable() {
      this.button.enable();
      this.state.visible = false;
    }

    switchState(isEnabled) {
      if (isEnabled === true) {
        if (this.isDisabled()) {
          this.enable();
          return true; // * Вновь доступна
        }
      } else {
        if (!this.isDisabled()) {
          this.disable();
        }
      }
      return false;
    }

    isDisabled() {
      return this.state.visible === true;
    }

  };
  AA.link(Sprite_SKillPanelItem);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_SKillPanelItem.prototype;
  _._createContent = function() {
    this._initColors();
    this._createOutline();
    this._createMain();
    this._createIcon();
    //@_createImage() #TODO: if item have image instead icon
    // * Disabled darker hover image
    this._createState();
    this._createInfo();
  };
  _._initColors = function() {
    this._tryConvertColor("_selectionColor", "selectedOutlineColor");
    this._tryConvertColor("_clickedColor", "clickedOutlineColor");
    this._tryConvertColor("_readyColor", "readyOutlineColor");
    this._tryConvertColor("_badColor", "badOutlineColor");
  };
  _._tryConvertColor = function(colorFieldName, paramName) {
    var e;
    try {
      this[colorFieldName] = KDCore.Color.FromHex(this.params[paramName]).ARR;
    } catch (error) {
      e = error;
      AA.w(e);
      this[colorFieldName] = [0, 0, 0, 1];
    }
  };
  _._createOutline = function() {
    this.notifyOutline = new AA.Sprite_SkillPanelOutline();
    this.notifyOutline.move(this.params.outlineMargins);
    this.add(this.notifyOutline);
    this.selectionOutline = new AA.Sprite_SkillPanelOutline();
    this.selectionOutline.move(this.params.outlineMargins);
    this.add(this.selectionOutline);
  };
  _._createMain = function() {
    this.button = new KDCore.ButtonM("SkillSlot", false, "Alpha");
    this.button.addClickHandler(() => {
      if (this.isFullVisible()) {
        return $gamePlayer.aaTryPerformSkill(this.skillId);
      }
    });
    return this.add(this.button);
  };
  _._createIcon = function() {
    this.icon = new KDCore.UI.Sprite_UIIcon(this.params.icon);
    this.icon.move(this.params.iconMargins);
    this.add(this.icon);
  };
  /*
  size = @params.icon.size
  if size > 32
      icon_x = @icon
      @button.isUnderMouse = -> icon_x.isUnderMouse()
  */
  _._createState = function() {
    this.state = new KDCore.UI.Sprite_UIImage();
    this.state.draw("SkillSlot_Disabled");
    this.state.visible = false;
    return this.add(this.state);
  };
  _._createInfo = function() {
    this._createTimer();
    this._createCountText();
    return this._createSymbolText();
  };
  _._createTimer = function() {
    this.timeText = new KDCore.UI.Sprite_UIText(this.params.timeText);
    return this.add(this.timeText);
  };
  _._createCountText = function() {
    this.countText = new KDCore.UI.Sprite_UIText(this.params.countText);
    return this.add(this.countText);
  };
  _._createSymbolText = function() {
    this.text = new KDCore.UI.Sprite_UIText(this.params.symbolText);
    return this.add(this.text);
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс подсветки (вокруг) ячейки быстрого доступа
//rev 07.07.21
(function() {
  var Sprite_SkillPanelOutline;
  Sprite_SkillPanelOutline = class Sprite_SkillPanelOutline extends KDCore.UI.Sprite_UIImage {
    constructor() {
      super(...arguments);
      this.visible = false;
    }

    defaultParams() {
      return {
        visible: true,
        image: "SkillSlot_Outline"
      };
    }

    show(colorArr) {
      this.visible = true;
      if (this._changer != null) {
        this._changer = null;
      }
      this.setBlendColor(colorArr);
      this.opacity = 255;
    }

    hide() {
      if (this._changer != null) {
        this._changer = null;
      }
      return this.visible = false;
    }

    pulse(colorArr, speed) {
      this.show(colorArr);
      this.opacity = 0;
      this._changer = new KDCore.Changer(this);
      this._changer.change('opacity').from(0).to(255).step(speed).repeat(2).reverse();
      this._changer.start().done(() => {
        return this.hide();
      });
    }

    update() {
      var ref;
      super.update();
      return (ref = this._changer) != null ? ref.update() : void 0;
    }

  };
  AA.link(Sprite_SkillPanelOutline);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_SkillPanelOutline.prototype;
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс заглушка для подсветки (вокруг) ячейки быстрого доступа
// * Используется если отключён параметр плагина
// * Все методы данного класса ПУСТЫЕ
(function() {
  var Sprite_SkillPanelOutlineDummy;
  Sprite_SkillPanelOutlineDummy = class Sprite_SkillPanelOutlineDummy extends Sprite {
    constructor() {
      super();
    }

    defaultParams() {
      return {};
    }

    show(colorArr) {}

    hide() {}

    pulse(colorArr, speed) {}

  };
  AA.link(Sprite_SkillPanelOutlineDummy);
})();


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_StateOverlay.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__updateFrame, ALIAS__updatePattern, _;
  //@[DEFINES]
  _ = Sprite_StateOverlay.prototype;
  //@[ALIAS]
  ALIAS__updatePattern = _.updatePattern;
  _.updatePattern = function() {
    if (this._battler != null) {
      this._overlayExtraImage = this._battler.aaGetExtraOverlayImage();
      if (String.any(this._overlayExtraImage)) {
        if (this.__lastOverlayBitmapName !== this._overlayExtraImage) {
          this._aaLoadExtraBitmap();
          this.__lastOverlayBitmapName = this._overlayExtraImage;
        }
      } else {
        this._aaResetExtraBitmap();
      }
    } else {
      if (String.any(this.__lastOverlayBitmapName) || String.any(this._overlayExtraImage)) {
        this._aaResetExtraBitmap();
      }
    }
    ALIAS__updatePattern.call(this, ...arguments);
  };
  
  //@[ALIAS]
  ALIAS__updateFrame = _.updateFrame;
  _.updateFrame = function() {
    if (String.any(this._overlayExtraImage)) {
      return this._aaUpdateExtraOverlayFrame();
    } else {
      return ALIAS__updateFrame.call(this, ...arguments);
    }
  };
})();

// ■ END Sprite_StateOverlay.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_StateOverlay.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_StateOverlay.prototype;
  _._aaLoadExtraBitmap = function() {
    this.bitmap = ImageManager.loadPicture(this._overlayExtraImage);
    return this._aaUpdateExtraOverlayFrame();
  };
  _._aaResetExtraBitmap = function() {
    this._overlayExtraImage = null;
    this.__lastOverlayBitmapName = null;
    return this.loadBitmap();
  };
  _._aaUpdateExtraOverlayFrame = function() {
    var e, h, sx, sy, w;
    try {
      w = 96;
      h = 96;
      sx = this._pattern * w;
      sy = 0;
      return this.setFrame(sx, sy, w, h);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Sprite_StateOverlay.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Weapon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__update, _;
  //@[DEFINES]
  _ = Sprite_Weapon.prototype;
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    var ref;
    ALIAS__update.call(this);
    if ((ref = this._aaOpChanger) != null) {
      ref.update();
    }
  };
  //$[OVER]
  //TODO: setting for user
  _.animationWait = function() {
    return 6;
  };
})();

// ■ END Sprite_Weapon.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Weapon.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Weapon.prototype;
  // * Настройки анимации оружия для ABS карты
  //TODO: settings to user for each type (scale, dx, dy)
  _.aaSetDirection = function(direction) {
    this._aaApplyScaleAndDir(direction);
    // * Начало в прозрачности (небольшой эффект)
    this._aaPlayOpChanger();
  };
  _._aaApplyScaleAndDir = function(direction) {
    this.scale.x = 0.7;
    this.scale.y = this.scale.x;
    this.x = this.y = 0;
    switch (direction) {
      case 6:
        this.x = 12;
        this.scale.x *= -1;
        break;
      case 4:
        this.x = -12;
        break;
      case 2:
        this.y = 0;
        break;
      default:
        this.y = -10;
    }
  };
  _._aaPlayOpChanger = function() {
    //TODO: тоже опция
    this._aaOpChanger = new KDCore.Changer(this);
    this._aaOpChanger.change('opacity').from(60).to(255).step(20).speed(1);
    this._aaOpChanger.start().done(() => {
      return this._aaOpChanger = null;
    });
  };
})();

// ■ END Sprite_Weapon.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс ячейки для расширения навыка оружия (аммуниция)
(function() {
  var Sprite_WeaponExtensionSlot;
  Sprite_WeaponExtensionSlot = class Sprite_WeaponExtensionSlot extends KDCore.UI.Sprite_UIElement {
    constructor() {
      super(...arguments);
      this.reset("position");
      this.refreshActiveExtItem();
      this.tag = "skillExtensionIcon";
      return;
    }

    defaultParams() {
      return $aabsz_WeaponSkillExtensionSlot;
    }

    static Instance() {
      var e;
      try {
        if (AA.UI.isValid()) {
          return AA.UI.uiSet.sActorSkillExtIcon;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    }

    //$[OVER]
    isActive() {
      if (this.params.isVisibleOnlyWhenWeaponHaveExtensionsSupport) {
        if (this.isDisabled()) {
          return false;
        }
      } else {
        return true;
      }
    }

    refresh() {
      return this.refreshActiveExtItem();
    }

    actor() {
      return $gameParty.leader();
    }

    isEnabled() {
      return this._mainButton.isEnabled();
    }

    isDisabled() {
      return this._mainButton.isDisabled();
    }

    disable() {
      if (this.isDisabled()) {
        return;
      }
      return this._mainButton.disable();
    }

    enable() {
      if (this.isEnabled()) {
        return;
      }
      this.visible = true;
      return this._mainButton.enable();
    }

    //$[OVER]
    isCanBeEdited() {
      return this.params.isCanBeEdited === true;
    }

    //$[OVER]
    isHaveHideWithMessageFlag() {
      return this.params.isHideWithMessage === true;
    }

    isMenuIsOpened() {
      return this._isMenuIsOpen === true;
    }

    isValidActiveWeaponExtension() {
      var ref;
      return (this.actor() != null) && ((ref = this.getActiveWeaponExtensionDefinition()) != null ? ref.isValidDefinition() : void 0);
    }

    getActiveWeaponExtensionDefinition() {
      var ref;
      return (ref = this.actor()) != null ? ref.aaGetActiveWeaponExtensionDefinition() : void 0;
    }

    getActiveSkillExtensionItemId() {
      return this.actor().aaGetActiveSkillExtensionItemId();
    }

    refreshActiveExtItem() {
      var def, e, extItemId, item, j, len, ref;
      try {
        if (this.isValidActiveWeaponExtension()) {
          def = this.actor().aaGetActiveWeaponExtensionDefinition();
          this.enable();
          extItemId = this.getActiveSkillExtensionItemId();
          if ((extItemId != null) && extItemId > 0) {
            this.setActiveItem($dataItems[extItemId], def);
          } else {
            this.setActiveItem(0);
          }
        } else {
          this.disable();
          this.setActiveItem(0);
          if (this.params.isVisibleOnlyWhenWeaponHaveExtensionsSupport) {
            this.visible = false;
          }
        }
        if (this.isMenuIsOpened()) {
          ref = this.getAllMenuElements();
          for (j = 0, len = ref.length; j < len; j++) {
            item = ref[j];
            item.refreshItem();
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.disable();
        this.setActiveItem(0);
      }
    }

    getAllMenuElements() {
      if (this._extItemsMenu != null) {
        return this._extItemsMenu.children.filter(function(i) {
          return (i != null) && (i.refreshItem != null);
        });
      } else {
        return [];
      }
    }

    closeMenu() {
      var e;
      if (!this.isMenuIsOpened()) {
        return;
      }
      try {
        this._isMenuIsOpen = false;
        this.selectionOutline.hide();
        this._destroyExtItemsMenu();
        return this.refreshActiveExtItem();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    openMenu() {
      var e;
      if (this.isMenuIsOpened()) {
        return;
      }
      try {
        this._isMenuIsOpen = true;
        this.selectionOutline.show(this._pressedColor);
        this._createExtItemsMenu();
        return this.refreshActiveExtItem();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setActiveItem(item, definition) {
      var count, e;
      try {
        if (item == null) {
          return this._clearActiveItem();
        } else {
          this._drawActiveExtItemIcon(item.iconIndex);
          if ((definition != null) && definition.isConsumeExtensionItem()) {
            count = $gameParty.numItems(item);
            return this.countText.draw(count);
          } else {
            return this.countText.draw("");
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    update() {
      super.update();
      return this._refreshThread.update();
    }

    _prepare() {
      super._prepare();
      this._isMenuIsOpen = false;
      this._initColors();
      this._refreshThread = new KDCore.TimedUpdate(30, this.refreshActiveExtItem.bind(this));
    }

  };
  AA.link(Sprite_WeaponExtensionSlot);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_WeaponExtensionSlot.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_WeaponExtensionSlot.prototype;
  _._initColors = function() {
    return AA.Sprite_SKillPanelItem.prototype._tryConvertColor.call(this, "_pressedColor", "pressedOutlineColor");
  };
  _._createContent = function() {
    var e;
    try {
      this._createActiveItemButton();
      this._createActiveItemIcon();
      this._createActiveItemCountText();
      return this._createSelectionOutline();
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createActiveItemButton = function() {
    var e;
    try {
      this._mainButton = new KDCore.ButtonMU(this.params.buttonImages, true, "Alpha");
      this._mainButton.addClickHandler(this._onMainButtonClick.bind(this));
      return this.add(this._mainButton);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._onMainButtonClick = function() {
    var e;
    try {
      if (this.isMenuIsOpened()) {
        return this.closeMenu();
      } else {
        return this.openMenu();
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createActiveItemIcon = function() {
    var e;
    try {
      this.icon = new KDCore.UI.Sprite_UIIcon(this.params.icon);
      this._mainButton.addChild(this.icon);
      return this.icon.move(this.params.icon.marings);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createActiveItemCountText = function() {
    var e;
    try {
      this.countText = new KDCore.UI.Sprite_UIText(this.params.countText);
      return this._mainButton.addChild(this.countText);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createSelectionOutline = function() {
    this.selectionOutline = new AA.Sprite_SkillPanelOutline();
    this.selectionOutline.move(this.params.outlineMargins);
    this.add(this.selectionOutline);
  };
  _._clearActiveItem = function() {
    var e;
    try {
      this.icon.draw(0);
      return this.countText.draw("");
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._drawActiveExtItemIcon = function(iconIndex) {
    var e;
    try {
      return this.icon.draw(iconIndex);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._destroyExtItemsMenu = function() {
    var e, element, j, len, ref;
    try {
      if (this._extItemsMenu == null) {
        return;
      }
      ref = this.getAllMenuElements();
      for (j = 0, len = ref.length; j < len; j++) {
        element = ref[j];
        element.visible = false;
        element.destroyMenuItem();
      }
      this._extItemsMenu.removeFromParent();
      this._extItemsMenu.visible = false;
      return this._extItemsMenu = null;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createExtItemsMenu = function() {
    var activeItemId, def, e, index, itemId, itemsCandidates, j, len;
    try {
      activeItemId = this.getActiveSkillExtensionItemId();
      this._extItemsMenu = new Sprite();
      this._extItemsMenu.move(this.params.menuItem.xMarginFromParent, this.params.menuItem.yMarginFromParent);
      this._createMenuItemFor(null, 0); // * Nothing
      def = this.getActiveWeaponExtensionDefinition();
      if (def == null) {
        return;
      }
      itemsCandidates = def.extensions;
      index = 1;
      for (j = 0, len = itemsCandidates.length; j < len; j++) {
        itemId = itemsCandidates[j];
        if ($gameParty.numItems($dataItems[itemId]) > 0) {
          // * Not show active item in Menu
          if (itemId !== activeItemId) {
            this._createMenuItemFor($dataItems[itemId], index, def.isConsumeExtensionItem());
            index++;
          }
        }
      }
      return this.add(this._extItemsMenu);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._createMenuItemFor = function(item, index, isConsumed) {
    var e;
    try {
      item = new AA.Sprite_WeaponExtensionSlotMenuItem(item, index, this.closeMenu.bind(this), isConsumed);
      return this._extItemsMenu.addChild(item);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Sprite_WeaponExtensionSlot.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
(function() {
  var Sprite_WeaponExtensionSlotMenuItem;
  Sprite_WeaponExtensionSlotMenuItem = class Sprite_WeaponExtensionSlotMenuItem extends KDCore.Sprite {
    constructor(item, index, onClickHandler, isCounted = true) {
      super();
      this.item = item;
      this.index = index;
      this.onClickHandler = onClickHandler;
      this.isCounted = isCounted;
      this.params = this.defaultParams();
      this._create();
      this.refreshItem();
      this.show();
      return;
    }

    defaultParams() {
      return $aabsz_WeaponSkillExtensionSlot.menuItem;
    }

    isEditorMode() {
      return SceneManager._scene instanceof AA.Scene_UIEditor;
    }

    destroyMenuItem() {
      var e;
      try {
        if ($gameTemp.kdButtonUnderMouse === this._mainButton) {
          $gameTemp.kdButtonUnderMouse = null;
        }
        this._mainButton.visible = false;
        return this._mainButton._updateMain();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    show() {
      var destX, destY, e;
      try {
        destX = this.params.xMarginFromParent * this.index;
        destY = this.params.yMarginFromParent * this.index;
        if (!this.params.isAnimated || this.index === 0) {
          this.move(destX, destY);
        } else {
          this.moveWithAnimation(destX, destY, this.params.animationDurationInFrames);
        }
        this.appear(this.params.fadeInSpeedOf255PerFrame);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.move(0, 0);
      }
    }

    refreshItem() {
      var e, numItems, ref, ref1, ref2, ref3;
      try {
        if (this.item == null) {
          return this._drawEmptyItem();
        } else {
          if ((ref = this.icon) != null) {
            ref.draw(this.item.iconIndex);
          }
          if ((ref1 = this.nameText) != null) {
            ref1.draw(this.item.name);
          }
          numItems = $gameParty.numItems(this.item);
          if (this.isCounted) {
            return (ref2 = this.countText) != null ? ref2.draw(numItems) : void 0;
          } else {
            return (ref3 = this.countText) != null ? ref3.draw("") : void 0;
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawEmptyItem() {
      var e, ref, ref1, ref2;
      try {
        if ((ref = this.icon) != null) {
          ref.draw(this.params.nothingItemIconIndex);
        }
        if ((ref1 = this.countText) != null) {
          ref1.draw("");
        }
        return (ref2 = this.nameText) != null ? ref2.draw(this.params.emptyItemText) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      this._createMainButton();
      this._createIcon();
      this._createNameText();
      if (this.item != null) {
        return this._createCountText();
      }
    }

    _createMainButton() {
      this._mainButton = new KDCore.ButtonMU(this.params.buttonImages, true, "Alpha");
      this._mainButton.addClickHandler(this._onMainButtonClick.bind(this));
      return this.add(this._mainButton);
    }

    _onMainButtonClick() {
      var e, itemId, ref;
      try {
        if (this.isEditorMode()) {
          return;
        }
        itemId = 0;
        if (this.item != null) {
          itemId = this.item.id;
        }
        if ((ref = $gameParty.leader()) != null) {
          ref.aaSetActiveSkillExtensionItemId(itemId);
        }
        return setTimeout((() => {
          if (this.onClickHandler != null) {
            return this.onClickHandler();
          }
        }), 50);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createIcon() {
      var e;
      try {
        this.icon = new KDCore.UI.Sprite_UIIcon(this.params.icon);
        this._mainButton.addChild(this.icon);
        return this.icon.move(this.params.icon.marings);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createCountText() {
      var e;
      try {
        this.countText = new KDCore.UI.Sprite_UIText(this.params.countText);
        return this._mainButton.addChild(this.countText);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createNameText() {
      var e;
      try {
        this.nameText = new KDCore.UI.Sprite_UIText(this.params.nameText);
        return this._mainButton.addChild(this.nameText);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  AA.link(Sprite_WeaponExtensionSlotMenuItem);
})();


// Generated by CoffeeScript 2.6.1
// * Новый класс для воспроизведения анимации взмаха оружием, показывает
// * оригинальный Sprite_Weapon или новый Sprite_WeaponMotion в зависимости от типа
(function() {
  var Sprite_WeaponMotionSelector;
  Sprite_WeaponMotionSelector = class Sprite_WeaponMotionSelector extends Sprite {
    constructor() {
      super();
      this._lastMotionSpr = null; // * ссылка на класс, который будет использован
      this._originalSprWeapon = new Sprite_Weapon();
      this.addChild(this._originalSprWeapon);
      this._newSprWeapon = new AA.Sprite_WeaponMotion();
      this.addChild(this._newSprWeapon);
      return;
    }

    setup(motionNameOrWeaponId) {
      // * скрыть предыдущие
      this._newSprWeapon.setup(null);
      this._originalSprWeapon.setup(0);
      // * задать новый класс
      if (!KDCore.SDK.isString(motionNameOrWeaponId)) {
        this._lastMotionSpr = this._originalSprWeapon;
      } else {
        this._lastMotionSpr = this._newSprWeapon;
      }
      this._lastMotionSpr.setup(motionNameOrWeaponId);
    }

    aaSetDirection(d) {
      if (this._lastMotionSpr == null) {
        return;
      }
      this._lastMotionSpr.aaSetDirection(d);
    }

  };
  AA.link(Sprite_WeaponMotionSelector);
})();

(function() {
  var Sprite_WeaponMotion;
  //TODO: Tut ostanovilsia, sm class Sprite_Weapon и менять методы чтобы со своим работать

    // * Новый класс для отдельных файлов анимации оружия
  Sprite_WeaponMotion = class Sprite_WeaponMotion extends Sprite {
    constructor() {
      super();
      this.initMembers();
    }

    initMembers() {
      this._animationWaitTime = 12;
      this._weaponImage = null;
      this._animationCount = 0;
      this._pattern = 0;
      this.anchor.x = 0.5;
      this.anchor.y = 1;
    }

    update() {
      super.update();
      if (!this.isValid()) {
        return;
      }
      this._animationCount++;
      if (this._animationCount >= this.animationWait()) {
        this.updatePattern();
        this.updateFrame();
        this._animationCount = 0;
      }
    }

    isValid() {
      return this._bitmapLoaded === true && this._direction !== -1;
    }

    // * Главный метод
    //%[PREPARE]
    setup(_weaponImage) {
      this._weaponImage = _weaponImage;
      this._animationCount = 0;
      this._bitmapLoaded = false;
      this._direction = -1;
      this._pattern = 0;
      this.loadBitmap();
      this.updateFrame();
    }

    //%[START]
    // * Данный метод запускает саму анимацию
    aaSetDirection(d) {
      switch (d) {
        case 8:
          this._direction = 3;
          break;
        case 2:
          this._direction = 0;
          break;
        case 4:
          this._direction = 1;
          break;
        case 6:
          this._direction = 2;
      }
      this.updateFrame();
    }

    animationWait() {
      return this._animationWaitTime || 12;
    }

    isPlaying() {
      return this._weaponImage != null;
    }

    loadBitmap() {
      var frameData;
      if (String.any(this._weaponImage)) {
        frameData = AAUtils.extractFramesAndSpeedValueFromImageName(this._weaponImage);
        this._maxPatternFrames = frameData.f;
        this._animationWaitTime = frameData.s;
        this.bitmap = ImageManager.loadAAWeaponMotion(this._weaponImage);
        this.bitmap.addLoadListener(() => {
          this._wFrameWidth = this.bitmap.width / this._maxPatternFrames;
          this._wFrameHeight = this.bitmap.height / 4;
          return this._bitmapLoaded = true;
        });
      } else {
        this.bitmap = ImageManager.loadSystem("");
      }
    }

    updatePattern() {
      this._pattern++;
      if (this._pattern >= this._maxPatternFrames) {
        this._weaponImage = null;
        this._direction = -1;
      }
    }

    updateFrame() {
      var h, sx, sy, w;
      if (this.isValid()) {
        w = this._wFrameWidth;
        h = this._wFrameHeight;
        sx = this._wFrameWidth * this._pattern;
        sy = h * this._direction;
        return this.setFrame(sx, sy, w, h);
      } else {
        return this.setFrame(0, 0, 0, 0);
      }
    }

  };
  AA.link(Sprite_WeaponMotion);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Sprite_WeaponMotion.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Sprite_WeaponMotion.prototype;
})();

// ■ END Sprite_WeaponMotion.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__createUpperLayer, ALIAS__update, _;
  //@[DEFINES]
  _ = Spriteset_Base.prototype;
  //@[ALIAS]
  ALIAS__createUpperLayer = _.createUpperLayer;
  _.createUpperLayer = function() {
    ALIAS__createUpperLayer.call(this, ...arguments);
    if (AA.PP.isShowBloodSplatterEffect()) {
      this.aaCreateBloodSplatterEffectLayer();
    }
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this, ...arguments);
    return this.aaUpdateBloodSplatterEffectSprite();
  };
})();

// ■ END Spriteset_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Base.prototype;
  _.aaCreateBloodSplatterEffectLayer = function() {
    this._aaBloodSplatterSpriteBase = new Sprite();
    this._aaBloodSplatterSpriteBase.z = 9;
    return this.addChild(this._aaBloodSplatterSpriteBase);
  };
  _.aaCreateBloodSplatterEffectSprite = function() {
    var BS_Picture, pic, ref;
    ({BS_Picture} = AA.PP.getBloodSplatterEffectSettings());
    if ((BS_Picture != null) && String.any(BS_Picture)) {
      pic = ImageManager.loadPicture(BS_Picture);
    } else {
      pic = ImageManager.loadEmptyBitmap();
    }
    this._aaBloodSplatterEffectSpr = new KDCore.Sprite(pic);
    this._aaBloodSplatterEffectSpr.appear(20);
    if ((ref = this._aaBloodSplatterSpriteBase) != null) {
      ref.addChild(this._aaBloodSplatterEffectSpr);
    }
  };
  _.aaRemoveBloodSplatterEffectSprite = function() {
    var ref;
    if ((ref = this._aaBloodSplatterSpriteBase) != null) {
      ref.removeChild(this._aaBloodSplatterEffectSpr);
    }
    this._aaBloodSplatterEffectSpr.visible = false;
    this._aaBloodSplatterEffectSpr = null;
  };
  _.aaUpdateBloodSplatterEffectSprite = function() {
    var e;
    if (this._aaBloodSplatterSpriteBase == null) {
      return;
    }
    try {
      if ($gameScreen.aaIsNeedBSEffectShow()) {
        if (this._aaBloodSplatterEffectSpr == null) {
          return this.aaCreateBloodSplatterEffectSprite();
        }
      } else {
        if (this._aaBloodSplatterEffectSpr != null) {
          return this.aaRemoveBloodSplatterEffectSprite();
        }
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this._aaBloodSplatterSpriteBase = null;
    }
  };
})();

// ■ END Spriteset_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__createCharacters, ALIAS__createUpperLayer, ALIAS__initialize, ALIAS__update, _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    this._aaMapAnimationSprites = [];
    this._aaMapSpriteEffects = [];
    this._aaMapDynamicSprites = [];
    ALIAS__initialize.call(this);
  };
  //@[ALIAS]
  ALIAS__createUpperLayer = _.createUpperLayer;
  _.createUpperLayer = function() {
    this.aaCreateExtraMapUpLayer();
    this.aaCreateDamagePopUpLayer();
    return ALIAS__createUpperLayer.call(this);
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    this.aaUpdateShatterEffect();
    return this.aaUpdateDynamicSprites();
  };
  
  //@[ALIAS]
  ALIAS__createCharacters = _.createCharacters;
  _.createCharacters = function() {
    ALIAS__createCharacters.call(this);
    this.aaCreateMapFlyBonus();
    // * Одно событие для Skills и Бонусов
    AA.EV.subscribeFor("MapSkillsRequestsClean", this._aaClearMapFlyBonuses.bind(this));
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  (function() {    // * Дополнительные слои (под и над персонажами, но на карте)
    // -----------------------------------------------------------------------
    // * Над персонажами
    _.aaCreateExtraMapUpLayer = function() {
      this._aaLayer02 = new Sprite();
      this._aaLayer02.z = 4;
      this.addChild(this._aaLayer02);
    };
    _.aaCreateDamagePopUpLayer = function() {
      this._aaPopUpLayer = new Sprite();
      this._aaLayer02.addChild(this._aaPopUpLayer);
    };
    _.aaGetDamagePopUpLayer = function() {
      return this._aaPopUpLayer;
    };
  })();
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  (function() {    
    // * Эффект Shatter на карте
    // -----------------------------------------------------------------------
    _.aaCreateShatterEffect = function(characterSprite) {
      var char, effectBase, i, j, k, l, len, maxw, pSize, part, ph, pw, ref, shatterEffectsSet, sx, sx2, sy, sy2, x, y, y3, y_perc;
      char = characterSprite._character;
      effectBase = new Sprite();
      if (characterSprite._character != null) {
        effectBase.z = characterSprite._character.screenZ();
      } else {
        effectBase.z = 1;
      }
      this._tilemap.addChild(effectBase);
      this.aaRegisterDynamicSprite(effectBase, char, -characterSprite.width / 2, -characterSprite.height);
      x = char._aaShatterEffectData[3];
      y = char._aaShatterEffectData[4];
      shatterEffectsSet = [];
      pSize = 8;
      pw = characterSprite.patternWidth();
      ph = characterSprite.patternHeight();
      maxw = Math.floor((pw / pSize) * (ph / pSize));
      if (characterSprite._tileId > 0) {
        sx = (Math.floor(characterSprite._tileId / 128) % 2 * 8 + characterSprite._tileId % 8) * pw;
        sy = Math.floor(characterSprite._tileId % 256 / 8) % 16 * ph;
      } else {
        sx = (characterSprite.characterBlockX() + characterSprite.characterPatternX()) * pw;
        sy = (characterSprite.characterBlockY() + characterSprite.characterPatternY()) * ph;
      }
      for (i = j = 0, ref = maxw; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        shatterEffectsSet[i] = new Sprite(characterSprite.bitmap);
        shatterEffectsSet[i].anchor.set(0.5);
        l = Math.floor(pSize * i / pw);
        x = pSize * i - (l * pw);
        y = Math.floor(l * pSize);
        y_perc = pSize * (i + 1) / Math.floor(pw / pSize) / ph;
        y3 = Math.floor(l * pSize);
        if (y >= ph - pSize) {
          y = ph - pSize;
        }
        sx2 = sx + x;
        sy2 = Math.floor(sy + y);
        shatterEffectsSet[i].x = x;
        shatterEffectsSet[i].y = y;
        shatterEffectsSet[i].y_perc = y_perc;
        shatterEffectsSet[i].setFrame(sx2, sy2, pSize, pSize);
        effectBase.addChild(shatterEffectsSet[i]);
        this._aaCreateShatterPartAnimation(shatterEffectsSet[i], char._aaShatterEffectData[3], char._aaShatterEffectData[4]);
      }
      for (k = 0, len = shatterEffectsSet.length; k < len; k++) {
        part = shatterEffectsSet[k];
        this._aaMapSpriteEffects.push(part);
      }
    };
    _._aaCreateShatterPartAnimation = function(sprite, x, y) {
      var r, sx, sy;
      sx = Math.random() * x + 0.1;
      sy = (Math.random() * 0.3) + 0.7 * y;
      r = Math.randomInt(2);
      if (r !== 0) {
        sx *= -1;
      }
      sprite.sx = sx;
      sprite.sy = sy;
      sprite.op = (Math.random() * 2) + 2.0;
      sprite.sc = 0;
      sprite.rt = (Math.random() + 0.5) * 0.1;
    };
    _._aaUpdateShatterEffectPartSprite = function(part) {
      var g, ground;
      if (part == null) {
        return;
      }
      g = 0.16;
      ground = 24 * (1 - part.y_perc) + 72 * part.y_perc;
      if (part.y < ground) {
        part.sy += g;
        part.rt = (Math.random() + 0.5) * 0.1;
      } else {
        part.sy = Math.min(-2, part.sy * (-0.5));
      }
      part.y += part.sy;
      part.x += part.sx;
      part.opacity -= part.op;
      part.scale.x += part.sc;
      part.scale.y += part.sc;
      part.rotation += part.rt;
    };
    _.aaUpdateShatterEffect = function() {
      var j, len, part, ref;
      ref = this._aaMapSpriteEffects;
      for (j = 0, len = ref.length; j < len; j++) {
        part = ref[j];
        this._aaUpdateShatterEffectPartSprite(part);
        if (part.opacity <= 0) {
          this._aaDeleteShatterEffectPartSprite(part);
          return;
        }
      }
    };
    // * Выход из цикла, так как удалили элемент
    _._aaDeleteShatterEffectPartSprite = function(part) {
      var parent;
      // * Смотрим родителя
      parent = part.parent;
      parent.removeChild(part);
      // * Если у него больше нет частей
      if (parent.children.length === 0) {
        // * Удаляем его из динамических спрайтов
        this._aaMapDynamicSprites.delete(parent);
      }
      this._aaMapSpriteEffects.delete(part);
    };
  })();
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  // * Добавить спрайт нового события
  _.aaAddSpawnedEvent = function(event) {
    var charSpr, e;
    try {
      charSpr = new Sprite_Character(event);
      this._characterSprites.push(charSpr);
      this._tilemap.addChild(charSpr);
      charSpr.update();
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  // * Регестрирует спрайт как статический на карте (не движется с экраном)
  // * Требует привязки к персонажу на карте, позволяет задать смещение
  _.aaRegisterDynamicSprite = function(sprite, character, dx = 0, dy = 0) {
    this._aaMapDynamicSprites.push(sprite);
    sprite._aaDynamicParent = character;
    sprite._aaDynX = dx;
    sprite._aaDynY = dy;
  };
  // * Удалить динамический спрайт
  // * Используется также для PopUp, они сами себя удаляют
  _.aaRemoveDynamicSprite = function(sprite) {
    if (this._aaMapDynamicSprites.contains(sprite)) {
      this._aaMapDynamicSprites.delete(sprite);
    }
  };
  // * Обновление динамических спрайтов (обновление позиции относительно камеры)
  _.aaUpdateDynamicSprites = function() {
    var dx, dy, i, len, p, ref, sprite;
    ref = this._aaMapDynamicSprites;
    for (i = 0, len = ref.length; i < len; i++) {
      sprite = ref[i];
      if ((sprite != null) && (sprite._aaDynamicParent != null)) {
        p = sprite._aaDynamicParent;
        dx = sprite._aaDynX;
        dy = sprite._aaDynY;
        sprite.move(p.screenX() + dx, p.screenY() + dy);
      } else {
        this.aaRemoveDynamicSprite(sprite);
      }
    }
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  // * Данные методы аналогичны методам обработки Projectile Skills
  // (см. Spriteset_Map_AASkills)

  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  _.aaCreateMapFlyBonus = function() {
    var i, j, ref;
    this._aaMapFlyBonuses = [];
// * Создаём уже существующие (зарегестрированные) на карте
    for (i = j = 0, ref = $gameMap.aaMapFlyBonuses().length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      this.aaCreateNewMapFlyBonus(i, false);
    }
  };
  _.aaCreateNewMapFlyBonus = function(index, isAppear = true) {
    var bonus, sprite;
    bonus = $gameMap.aaMapFlyBonuses()[index];
    if (bonus == null) {
      return;
    }
    sprite = new Sprite_AAMapFlyBonus(index, isAppear);
    this._aaMapFlyBonuses[index] = sprite;
    this._tilemap.addChild(sprite);
  };
  _._aaClearMapFlyBonuses = function() {
    var e, i, j, ref, results;
    try {
      results = [];
      for (i = j = 0, ref = $gameMap.aaMapFlyBonuses().length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (!this._aaMapFlyBonuses[i] || this._aaMapFlyBonuses[i].isEnd()) {
          this._tilemap.removeChild(this._aaMapFlyBonuses[i]);
          this._aaMapFlyBonuses[i] = null;
          results.push($gameMap.aaMapFlyBonuses()[i] = null);
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Интерфейс AABS на карте
(function() {
  var Spriteset_UI;
  Spriteset_UI = class Spriteset_UI extends Sprite {
    constructor() {
      super();
      this._init(); //#Spriteset_UI_0
      this.applyUserSettings(); // * Применить настройки игрока
    }

    static Instance() {
      var e;
      try {
        if (AAUtils.isSceneMap()) {
          return SceneManager._scene._aaUI;
        } else if (SceneManager._scene instanceof AA.Scene_UIEditor) {
          return SceneManager._scene.uiSpriteset;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    }

    isActive() {
      return this.visible === true;
    }

    show() {
      return this.visible = true;
    }

    hide() {
      return this.visible = false;
    }

    terminate() {
      this._terminateElements(); //#Spriteset_UI_0
      this.visible = false;
    }

    // * Обновить все контроллеры и элементы
    refresh() {
      var controller, i, len, ref;
      ref = this.controllers;
      for (i = 0, len = ref.length; i < len; i++) {
        controller = ref[i];
        controller.refresh();
      }
    }

    onGameMessageStart() {
      return this.getElementsWithMessageFlag().forEach(function(e) {
        return e.opacity = 50;
      });
    }

    onGameMessageEnd() {
      return this.getElementsWithMessageFlag().forEach(function(e) {
        return e.opacity = 255;
      });
    }

    // * Применить пользовательские настройки ко всем элементам
    applyUserSettings() {
      var e, i, len, ref, user;
      user = $gameSystem.aaGetUserUISettings();
      this._applyVisibility(user);
      ref = this.elements;
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        if (user.isHaveFor(e.tag)) {
          //#Spriteset_UI_0
          this._applyUserSettingsFor(e, user);
        }
      }
    }

    // * Обновить элемент (применить настройки)
    refreshElement(tag) {
      var e, element;
      element = this.getElement(tag);
      if (element == null) {
        return;
      }
      try {
        if (element.refresh != null) {
          element.refresh();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      try {
        this._applyUserSettingsFor(element, $gameSystem.aaGetUserUISettings()); //#Spriteset_UI_0
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }

    // * Обновить контроллер элемента
    refreshController(tag) {
      var controller, e;
      try {
        controller = this.getController(tag);
        if (controller == null) {
          return;
        }
        controller.refresh();
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    }

    // * Восстановить настройки элемента
    resetElement(tag) {
      var element;
      element = this.getElement(tag);
      if (element == null) {
        return;
      }
      element.reset("position");
      element.reset("visible");
    }

    getElement(tag) {
      return this.elements.find(function(e) {
        return e.tag === tag;
      });
    }

    getController(tag) {
      return this.controllers.find(function(c) {
        return c.tag === tag;
      });
    }

    // * Данный метод "собирает" один раз
    getElementsWithMessageFlag() {
      if (this._elementsWithMessageFlag == null) {
        this._elementsWithMessageFlag = this.elements.filter(function(e) {
          return e.isHaveHideWithMessageFlag();
        });
      }
      return this._elementsWithMessageFlag;
    }

  };
  AA.link(Spriteset_UI);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_UI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
  _._init = function() {
    // * Регестрирует себя в менеджере
    AA.UI.setUI(this);
    // * Набор всех элементов
    this.elements = [];
    // * Набор всех контроллеров
    this.controllers = [];
    // * Набор всех компонентов
    this.uiSets = [];
    //TODO: Загрузка всех компонентов из параметров и подготовка
    return this._create();
  };
  // * Дополнительное закрытие элементов (перед закрытием всего UI)
  _._terminateElements = function() {
    return this._terminateSkillSelectorWindow(); //#Spriteset_UI_SkillsSet
  };
  
  // * Получить все элементы
  // * Обновить элемент по тэгу
  // * (возможно) Обновить все элементы
  // * Получить элемент по тэгу
  _._create = function() {
    this._createLowerUILayer();
    this._createNormalUILayer();
    return this._createElements();
  };
  // * Нижний слой нужен для пользовательских UI элементов, которые должны быть ниже UI
  _._createLowerUILayer = function() {
    this.lowerLayer = new Sprite();
    return this.addChild(this.lowerLayer);
  };
  _._createNormalUILayer = function() {
    this.layer = new Sprite();
    return this.addChild(this.layer);
  };
  _._createElements = function() {
    return this._createDefaultElements();
  };
  //@_createUserElements()
  _._createDefaultElements = function() {
    this._createSkillsSet(); //#Spriteset_UI_SkillsSet
    this._createSkillSelectorWindow(); //#Spriteset_UI_SkillsSet
    this._createActorUI(); //#Spriteset_UI_ActorUI
    return this._createTargetUI(); //#Spriteset_UI_Target
  };
  
  // * Добавить набор и зарегестрировать все элементы и контроллеры из набора
  _._registerUISet = function(uiSet) {
    this.elements.push(...uiSet.elements);
    this.controllers.push(...uiSet.controllers);
    this.uiSets.push(uiSet);
    this._addElementToUI(uiSet);
  };
  // * Добавит и зарегестрировать элемент (чтобы можно было управлять через команды)
  _._registerUIElement = function(sprite) {
    var e;
    try {
      if (sprite == null) {
        return;
      }
      if (sprite.tag == null) {
        console.warn("You try register UI element without TAG");
      }
      this._addElementToUI(sprite);
      return this.elements.push(sprite);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  // * Добавить элемент на обычный слой (выше пользовательских)
  _._addElementToUI = function(sprite) {
    return this.layer.addChild(sprite);
  };
  // * Применить пользовательские настройки к элементу
  _._applyUserSettingsFor = function(element, settings) {
    var key, pos, visible;
    key = element.tag;
    pos = settings.getPositionFor(key);
    if (pos != null) {
      element.move(pos.x, pos.y);
    } else {
      element.reset("position");
    }
    visible = settings.getVisibleFor(key);
    if (visible != null) {
      element.visible = visible;
    } else {
      element.reset("visible");
    }
  };
  
  // * Обновить видимость всего UI
  _._applyVisibility = function(settings) {
    var visible;
    if (!settings.isHaveFor("main")) {
      this.show(); // * По стандарту, всегда видно
      return;
    }
    visible = settings.getVisibleFor("main");
    if (visible != null) {
      if (visible === true) {
        return this.show();
      } else {
        return this.hide();
      }
    } else {
      return this.show(); // * По стандарту, всегда видно
    }
  };
})();

// ■ END Spriteset_UI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_UI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
  _._createActorUI = function() {
    this._createActorGauges();
    this._createActorBuffsIcons();
    this._createActorStatesIcons();
    return this._createActorSkillExtensionMenu();
  };
  _._createActorGauges = function() {
    this.sActorGauges = new AA.UISet_ActorGauges(this);
    return this._registerUISet(this.sActorGauges); //# Spriteset_UI_0
  };
  _._createActorBuffsIcons = function() {
    if (!AA.PP.getIsBuffsVisible()) {
      return;
    }
    this.sActorBuffs = new AA.UISet_ActorBuffsIcons(this);
    return this._registerUISet(this.sActorBuffs); //# Spriteset_UI_0
  };
  _._createActorStatesIcons = function() {
    if (!AA.PP.getIsStatesVisible()) {
      return;
    }
    this.sActorStates = new AA.UISet_ActorStatesIcons(this);
    return this._registerUISet(this.sActorStates); //# Spriteset_UI_0
  };
  _._createActorSkillExtensionMenu = function() {
    this.sActorSkillExtIcon = new AA.Sprite_WeaponExtensionSlot();
    this._registerUIElement(this.sActorSkillExtIcon);
  };
})();

// ■ END Spriteset_UI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_UI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
  _._createSkillsSet = function() {
    this.sSkills = new AA.UISet_Skills(this);
    return this._registerUISet(this.sSkills); //# Spriteset_UI_0
  };
  _._createSkillSelectorWindow = function() {
    var e, h, p, w;
    try {
      p = $aabsz_SkillItemSelectorWindowSettings.windowSize;
      w = p.width || 160;
      h = p.height || 360;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      w = 160;
      h = 360;
    }
    this.fwSkillsSelector = new FWindow_SkillSelect(this, w, h);
    return this._addElementToUI(this.fwSkillsSelector);
  };
  _._terminateSkillSelectorWindow = function() {
    var ref;
    return (ref = this.fwSkillsSelector) != null ? ref.close() : void 0;
  };
})();

// ■ END Spriteset_UI.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_UI.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = AA.Spriteset_UI.prototype;
  _._createTargetUI = function() {
    //TODO: А если не активен?
    this.sTargetInfo = new AA.UISet_TargetInfo(this);
    return this._registerUISet(this.sTargetInfo); //# Spriteset_UI_0
  };
})();

// ■ END Spriteset_UI.coffee
//---------------------------------------------------------------------------


class StateMachine {
    constructor() {
        this._current = null;
        this._nodes = [];
        this._anyTransitions = [];
    }
    update() {
        try {
            var transition = this.getTransition();
            if (transition) {
                this.changeState(transition.to());
            }
            if (this._current) {
                this._current.state().update();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    currentStateName() {
        if (!this._current) {
            return "";
        }
        return this._current.state().name();
    }
    setState(state) {
        try {
            var newNode = this.getOrAddNode(state);
            if (this._current) {
                this.changeState(state);
            }
            else {
                this._current = newNode;
                this._current.state().onEnter();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    addTransition(from, to, condition) {
        try {
            let fromNode = this.getOrAddNode(from);
            fromNode.addTransition(this.getOrAddNode(to).state(), condition);
        }
        catch (error) {
            console.warn(error);
        }
    }
    addAnyTransition(to, condition) {
        try {
            this._anyTransitions.push(new Transition(this.getOrAddNode(to).state(), condition));
        }
        catch (error) {
            console.warn(error);
        }
    }
    getOrAddNode(state) {
        if (!this._nodes[state.name()]) {
            this._nodes[state.name()] = new StateNode(state);
        }
        return this._nodes[state.name()];
    }
    changeState(state) {
        if (state == this._current.state()) {
            return;
        }
        let previous = this._current.state();
        let nextState = this._nodes[state.name()].state();
        if (previous) {
            previous.onExit();
        }
        if (nextState) {
            nextState.onEnter();
        }
        this._current = this._nodes[state.name()];
    }
    getTransition() {
        for (let transition of this._anyTransitions) {
            if (transition.condition().isSatisfied()) {
                return transition;
            }
        }
        if (this._current) {
            for (let transition of this._current.transitions()) {
                if (transition.condition().isSatisfied()) {
                    return transition;
                }
            }
        }
        return null;
    }
}


class StateNode {
    constructor(state) {
        this._state = state;
        this._transitions = [];
    }
    state() {
        return this._state;
    }
    transitions() {
        return this._transitions;
    }
    addTransition(to, condition) {
        this._transitions.push(new Transition(to, condition));
    }
}


// Generated by CoffeeScript 2.6.1
(function() {
  var StatesIconsController;
  
    //%[I] Опция (параметр плагина), чтобы можно было выбрать какие состояния показывать (все или только АБС)

    //%[I] Показывать и количество шагов и количество урона до снятия состояния (разными цветами)

    //%[I] Показывать подсказки при наведении мыши на иконку состояния

    // * Общий контроллер для отрисовки состояний (states) персонажа (игрока)
  //?rev 25.02.22
  StatesIconsController = class StatesIconsController extends AA.BuffIconsController {
    constructor() {
      super(...arguments);
      // * Нет ограничения (8)
      this.maxCount = this.buffSprites.length;
      return;
    }

    collectStates() {
      var i, j, ref, states;
      states = this.source._states.map(function(s) {
        return $dataStates[s];
      });
      // * Отсортировать по Priority
      states.sort(function(a, b) {
        if (a.priority > b.priority) {
          return -1;
        } else {
          return 1;
        }
      });
      // * Режиме редактора, мы дополним состоянием 1, чтобы визуально было видно
      if (AA.System.isUIEditor() && states.length < this.maxCount) {
        for (i = j = 0, ref = this.maxCount - states.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          states.push($dataStates[1]);
        }
      }
      return states;
    }

    getStateObj(stateId) {
      return $dataStates[stateId];
    }

    collectStateTurns(stateId) {
      return this.source.aaStates.getDisplayValueForState(stateId);
    }

    isAAState(state) {
      return AAState.IsValid(state);
    }

    isAAStateIsActionBased(state) {
      return this.isAAState(state) && state.AAState.isActionEndState();
    }

    isAAStateHaveAnyTurns(state) {
      return this.isAAState(state) && (this.isAAStateIsActionBased(state) || state.AAState.isTimeEndState());
    }

  };
  AA.link(StatesIconsController);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.StatesIconsController.prototype;
  //$[OVER]
  _._refresh = function() {
    var e, i, j, ref, ref1, state, states;
    states = this.collectStates();
    if (states.isEmpty()) {
      this._clearAll();
    } else {
      for (i = j = 0, ref = this.maxCount; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        state = states[i];
        if (state != null) {
          try {
            this._drawStateInfo(state, i);
          } catch (error) {
            e = error;
            AA.w(e);
          }
        } else {
          if ((ref1 = this.buffSprites[i]) != null) {
            ref1.clear();
          }
        }
      }
    }
  };
  _._drawStateInfo = function(state, i) {
    var icon, isAction, isShouldHaveText, ref, text, turns;
    icon = state.iconIndex;
    isAction = false;
    text = "";
    if (this.isAAState(state)) {
      isShouldHaveText = this.isAAStateHaveAnyTurns(state);
      if (isShouldHaveText === true) {
        isAction = this.isAAStateIsActionBased(state);
        turns = this.collectStateTurns(state.id);
        if (turns > 0) {
          text = turns;
        }
      }
    }
    return (ref = this.buffSprites[i]) != null ? ref.drawStateInfo(icon, text, isAction) : void 0;
  };
  _._clearAll = function() {
    var e, j, len, ref, results, spr;
    try {
      ref = this.buffSprites;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        spr = ref[j];
        results.push(spr != null ? spr.clear() : void 0);
      }
      return results;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


class Transition {
    constructor(to, condition) {
        this._condition = condition;
        this._to = to;
    }
    condition() {
        return this._condition;
    }
    to() {
        return this._to;
    }
}


// Generated by CoffeeScript 2.6.1
// * Глабольный набор вспомогательных функций для пользователя
var uAPI;

uAPI = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = uAPI;
  (function() {    // * Панель навыков
    // -----------------------------------------------------------------------
    // * Добавить навык на панель навыков
    // * 0 - убрать из слота
    // * slotSymbol == null - в любое не занятое место
    _.setSkillToPanel = function(skillId, slotSymbol) {
      var e, ref, ref1, ref2;
      try {
        if (slotSymbol != null) {
          slotSymbol = slotSymbol.toString();
        }
        if (skillId <= 0) { // * Удаляем навык из панели
          if (AA.Utils.isSkillPanelSymbol(slotSymbol)) {
            if ((ref = $gamePlayer.aaSkillsSet) != null) {
              ref.setSymbolForSkill(0, slotSymbol, null); // * Устанавливаем навык на панель
            }
          }
        } else {
          // * Если НАВЫК, то должен быть изучен
          if (AASkill2.IsAASkill(skillId)) {
            if (!$gamePlayer.aaIsHaveABSSkill(skillId)) {
              return;
            }
          }
          // * Предметы можно устанавливать, даже если нет в инвентаре (будет 0)
          if (AA.Utils.isSkillPanelSymbol(slotSymbol)) {
            if ((ref1 = $gamePlayer.aaSkillsSet) != null) {
              ref1.setSymbolForSkill(skillId, slotSymbol, null); // * Если символ не указан (или указан неверно, то устанавливаем в свободное место)
            }
          } else {
            if ((ref2 = $gamePlayer.aaSkillsSet) != null) {
              ref2.setSkillInEmptySlot(skillId);
            }
          }
        }
        AA.UI.refreshElement('skills');
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Добавить предмет на панель навыков, поддерживает как обычные ID, так и idA
    _.setItemToPanel = function(itemId, slotSymbol) {
      var e;
      try {
        // * Автоматическое преобразование в ID предмета
        if (itemId > 0 && !AASkill2.IsAAItem(itemId)) {
          itemId += AAITEMS_ID_START;
        }
        this.setSkillToPanel(itemId, slotSymbol);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Если навыка нет или неверно указан slotSymbol - будет возвращён 0
    _.getSkillIdFromPanel = function(slotSymbol) {
      var ref;
      if (slotSymbol != null) {
        slotSymbol = slotSymbol.toString();
      }
      return (ref = $gamePlayer.aaSkillsSet) != null ? ref.getSkillForSymbol(slotSymbol) : void 0;
    };
    // * Безопасно обновить панель навыков
    return _.refreshSkillPanelSafe = function() {
      setTimeout((function() {
        var e;
        try {
          if (AAUtils.isSceneMap() && !SceneManager.isSceneChanging()) {
            AA.UI.refreshElement('skills');
            return AA.UI.refreshElement('skillExtensionIcon');
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }), 1);
    };
  })();
  (function() {    // * Система АБС (Общее)
    // -----------------------------------------------------------------------
    _.pauseABS = function() {
      return AA.System.pauseABS();
    };
    _.resumeABS = function() {
      return AA.System.resumeABS();
    };
    // * Вызвать Script Action
    _.scriptAction = function(scriptAction, char = null, delay = 0) {
      var e;
      try {
        if (!String.any(scriptAction)) {
          return;
        }
        // * Это будет вызываться из событий скорее всего, поэтому преобразуем в Event
        // * Преобразуем наперёд, чтобы delayed можно было вызвать
        if (char instanceof Game_Interpreter) {
          if (char.eventId() > 0) {
            char = $gameMap.event(char.eventId());
          } else {
            char = null;
          }
        }
        if (delay <= 0) {
          return AAScriptActions.execute(scriptAction, char);
        } else {
          return AAUtils.callDelayed(function() {
            return AAScriptActions.execute(scriptAction, char);
          }, delay);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Последний Game_Character, которого нашёл локатор
    _.lastLocatorTarget = function() {
      return AAEventsLocatorsManager.lastLocatorTarget;
    };
    // * Последнее событие локатор, которое было активированно
    _.lastActivatedLocator = function() {
      return AAEventsLocatorsManager.lastActivatedLocator;
    };
    // * Воспроизвести доп. анимацию навыка
    _.playExtraAnimation = function(x, y, extraAnimation, seName = "", ox = 0, oy = 0) {
      var e;
      try {
        return Sprite_AAExtraSkillAnimation.Create({x, y}, {
          extraAnimation,
          extraAnimationOX: ox,
          extraAnimationOY: oy,
          extraAnimationSE: seName
        });
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Рисовать область видимости врагов
    _.drawEnemyVisors = function(isDraw, opacity = 100, color = "#d14532") {
      var e;
      try {
        if (isDraw === true) {
          return $gameSystem.aaDrawEnemyVision = {opacity, color};
        } else {
          return $gameSystem.aaDrawEnemyVision = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Музыка для битвы (или другая), с задержкой в секундах!
    _.playBattleBgm = function(name, delay = 0) {
      var e;
      try {
        return AudioManager.aaPlayBattleBgm(name, delay * 60);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.stopBattleBgm = function(delay) {
      var e;
      try {
        return AudioManager.aaStopBattleBgm(delay * 60);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Действия игрока
    // -----------------------------------------------------------------------
    return _.makePlayerDodge = function(isForce = false) {
      var e;
      try {
        if (isForce === true) {
          return $gamePlayer.aaPerformDodge();
        } else {
          if (!AA.PP.isAllowDodge()) {
            return;
          }
          if ($gamePlayer.aaIsCanDodgeNow()) {
            return $gamePlayer.aaPerformDodge();
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Интерфейс АБС
    // -----------------------------------------------------------------------
    _.editUI = function() {
      var e;
      try {
        if (!AA.isPro()) {
          window.alert("UI Editor available only in [PRO] version of plugin");
          return;
        }
        if (AA.isMap()) {
          return SceneManager.push(AA.Scene_UIEditor);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.controlUIElement = function() {
      var e, user;
      try {
        user = $gameSystem.aaGetUserUISettings();
        user.set(...arguments);
        return AA.UI.refreshElement(arguments[0]);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.showUI = function() {
      var e, user;
      try {
        user = $gameSystem.aaGetUserUISettings();
        // * Просто удаляем настройки, так как по умолчанию интерфейс всегда видно
        // * других настроек у интерфейса нету
        user.set("main", "clear");
        return AA.UI.show();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //TODO: Кнопки нажимаются напанели, даже если скрытый интерфейс
    //TODO: Надо метод isValid дополнить (который в AA.UI) и делать проверки
    _.hideUI = function() {
      var e, user;
      try {
        user = $gameSystem.aaGetUserUISettings();
        user.set("main", "setVisible", false);
        return AA.UI.hide();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //TODO: Этот метод добавить в SActions !!!
    _.showPopUpOnChar = function(charId, styleId, value, isForceString = false) {
      var char, e;
      try {
        if (!AAUtils.isSceneMap()) {
          return;
        }
        charId = AAExtendedValues.getEValue(charId);
        if (!isForceString) {
          value = AAExtendedValues.getEValue(value);
        }
        if (charId === 0) {
          char = $gamePlayer;
        } else {
          char = $gameMap.event(charId);
        }
        return uAPI._showPopUpGlobal("char", char, styleId, value);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._showPopUpGlobal = function(type, charOrPos, styleId, value) {
      var e, settings;
      try {
        if (!AAUtils.isSceneMap()) {
          return;
        }
        settings = AA.PP.getPopUpDamageSettings(styleId);
        if (settings == null) {
          AA.w("PopUp settings with ID " + styleId + " not found!");
          settings = AA.PP.getPopUpDamageSettings("default");
        }
        if (settings == null) {
          return;
        }
        switch (type) {
          case "char":
            return Sprite_AADamagePopUpItem.CreateOnCharacterBinded(charOrPos, settings, value);
          case "map":
            return Sprite_AADamagePopUpItem.CreateOnMap(charOrPos.x, charOrPos.y, settings, value);
          case "screen":
            return Sprite_AADamagePopUpItem.CreateOnScreen(charOrPos.x, charOrPos.y, settings, value);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.showPopUpOnMap = function(x, y, styleId, value, isForceString = false) {
      var e;
      try {
        if (!AAUtils.isSceneMap()) {
          return;
        }
        if (!isForceString) {
          value = AAExtendedValues.getEValue(value);
        }
        x = AAExtendedValues.getEValue(x);
        y = AAExtendedValues.getEValue(y);
        return uAPI._showPopUpGlobal("map", {x, y}, styleId, value);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.showPopUpOnScreen = function(x, y, styleId, value, isForceString = false) {
      var e;
      try {
        if (!AAUtils.isSceneMap()) {
          return;
        }
        if (!isForceString) {
          value = AAExtendedValues.getEValue(value);
        }
        x = AAExtendedValues.getEValue(x);
        y = AAExtendedValues.getEValue(y);
        return uAPI._showPopUpGlobal("screen", {x, y}, styleId, value);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.resetUserUISettings = function() {
      var user;
      user = $gameSystem.aaGetUserUISettings();
      user.settings = {}; // * reset all
      user.saveGlobalSettings();
    };
    //#AA.UI.refreshAllElements()
    return _.setBloodSplatterEffectVisible = function(isEnabled = true) {
      var e;
      try {
        if (isEnabled === true) {
          return $gameSystem.absBSEForceDisabled = null;
        } else {
          return $gameSystem.absBSEForceDisabled = true;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Камера
    // -----------------------------------------------------------------------
    // * Активировать скролл камеры
    _.enableMapScroll = function() {
      var e;
      try {
        Scene_Map.prototype.aaUpdateMapScrlByMouse = Scene_Map.prototype.aaUpdateMapScrlByMouseBody;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Отключить скролл камеры
    _.disableMapScroll = function() {
      var e;
      try {
        if ((typeof $gameTemp !== "undefined" && $gameTemp !== null) && $gameTemp.aaIsMapScrolled()) {
          this.resetMapScroll();
        }
        Scene_Map.prototype.aaUpdateMapScrlByMouse = function() {}; // * EMPTY
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Сбросить скролл камеры (на центр - игрок)
    return _.resetMapScroll = function() {
      var e;
      try {
        $gamePlayer.center($gamePlayer.x, $gamePlayer.y);
        $gameTemp.aaSetMapScrolled(false);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Управление объектами
    // -----------------------------------------------------------------------
    // * Получить опыт за врага по номеру в БД (isVisible == true -> PopUp)
    _.gainExpForEnemyDb = function(enemyId, isVisible = true) {
      var e, enemy, expValue;
      try {
        enemy = $dataEnemies[enemyId];
        if (enemy == null) {
          return;
        }
        expValue = AA.Utils.getExpFromAAEnemy(enemy);
        $gameParty.aaGainExpForParty(expValue, isVisible);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Получить опыт за врага по номеру события
    _.gainExpForEnemyEv = function(eventId, isVisible = true) {
      var e, event, expValue, expVarId;
      try {
        event = $gameMap.event(eventId);
        if (event == null) {
          return;
        }
        // * Событие не АБС и не было АБС ранее
        if (event.aaEventSettings == null) {
          return;
        }
        // * Если есть специальная переменная для опыта, сразу из неё
        expVarId = event.aaEventSettings.getExpVarId();
        if (expVarId > 0) {
          expValue = $gameVariables.value(expVarId);
          $gameParty.aaGainExpForParty(expValue, isVisible);
        } else {
          this.gainExpForEnemyDb(event.aaEventSettings.getEnemyId());
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Изменить (дать) здоровье напрямую (с вспылвающим PopUp)
    _.gainHpForBattler = function(charId, value, isCrit = false) {
      var e;
      try {
        uAPI._gainHpOrMpForBattler(charId, value, 'hp', isCrit);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Изменить (дать) ману напрямую (с вспылвающим PopUp)
    _.gainMpForBattler = function(charId, value, isCrit = false) {
      var e;
      try {
        uAPI._gainHpOrMpForBattler(charId, value, 'mp', isCrit);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _._gainHpOrMpForBattler = function(charId, value, type, isCrit) {
      var battler, e, event;
      try {
        //TODO: Получение по charId вынести в Utils (много где используется)
        if (charId > 0) {
          event = $gameMap.event(charId);
          if (event == null) {
            return;
          }
          if (!event.isABS()) {
            return;
          }
          battler = event.AABattler();
        } else {
          battler = $gameParty.leader();
        }
        if (battler == null) {
          return;
        }
        if (type === 'hp') {
          return battler.aaGainHpWithPopUp(value, isCrit);
        } else {
          return battler.aaGainMpWithPopUp(value, isCrit);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Дать опыт (с PopUp)
    _.gainExpForParty = function(value) {
      var e;
      try {
        if (value == null) {
          return;
        }
        if (value <= 0) {
          return;
        }
        return $gameParty.aaGainExpForParty(value, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Дать золото (с PopUp)
    _.gainGoldForParty = function(value) {
      var e;
      try {
        if (value == null) {
          return;
        }
        return $gameParty.aaGainGoldForParty(value);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Получить одного врага по метке (первый)
    //?Может вернуть NULL
    _.getEnemyByLabel = function(label = "") {
      var e;
      try {
        return this.getEnemiesByLabel(label).first();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    // * Получить всех врагов по метке (массив)
    _.getEnemiesByLabel = function(label = "") {
      var e;
      try {
        return $gameMap.eventAAWithLabel(label);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    // * Сбросить сохранённое состояние здоровья врага (врагов, всей карты, вообще)
    _.resetHpForEnemy = function(mapId, eventId = 0) {
      var e;
      try {
        if ($gameSystem._aaEnemiesHPDataStored == null) {
          return;
        }
        if ((mapId == null) || mapId === 0) {
          $gameSystem._aaEnemiesHPDataStored = null;
          return;
        }
        if ((eventId == null) || eventId <= 0) {
          $gameSystem._aaEnemiesHPDataStored[mapId] = null;
          delete $gameSystem._aaEnemiesHPDataStored[mapId];
          return;
        }
        return delete $gameSystem._aaEnemiesHPDataStored[mapId][eventId];
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Спавн "летающего" бонуса (от события) до игрока
    // * bonusIds - array
    //TODO: Добавить SAction
    _.spawnFlyingBonus = function(eventId, bonusIds) {
      var bonusData, e, event, i, id, len, results;
      try {
        if (bonusIds == null) {
          return;
        }
        if (bonusIds.length === 0) {
          return;
        }
        // * Проверка, что событие существует
        event = $gameMap.event(eventId);
        if (event == null) {
          return;
        }
        results = [];
        for (i = 0, len = bonusIds.length; i < len; i++) {
          id = bonusIds[i];
          bonusData = AA.PP.getAfterDeathBonus(id);
          if (bonusData == null) {
            continue;
          }
          results.push($gameMap.aaRequestFlyBonusSpawn(eventId, bonusData));
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addCustomGaugeForVariable = function(parametersId, variableId, bindedEventId, x, y, isGlobal) {
      var e, parameters, system;
      try {
        system = AACustomGaugesSystem.Instance();
        if (system == null) {
          return;
        }
        // * Не стал убирать возможность создавать много gauge для одной переменной
        //if system.isExistsGaugeForVariable()
        //    @removeVariableCustomGauge(variableId)
        parameters = AA.PP.getCustomGaugeById(parametersId);
        return system.addGauge(variableId, parameters, x, y, bindedEventId, 0, isGlobal);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addCustomGaugeForEnemy = function(parametersId, enemyEventId, bindedEventId, x, y) {
      var e, parameters, system;
      try {
        system = AACustomGaugesSystem.Instance();
        if (system == null) {
          return;
        }
        parameters = AA.PP.getCustomGaugeById(parametersId);
        return system.addGauge(0, parameters, x, y, bindedEventId, enemyEventId, false);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.removeVariableCustomGauge = function(variableId) {
      var e, ref;
      try {
        return (ref = AACustomGaugesSystem.Instance()) != null ? ref.removeGaugeByVarId(variableId) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    return _.removeEnemyCustomGauge = function(enemyEventId) {
      var e, ref;
      try {
        return (ref = AACustomGaugesSystem.Instance()) != null ? ref.removeGaugeByEnemyId(enemyEventId) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Спавн врагов
    // -----------------------------------------------------------------------
    // * Спавн врага в точке {X, Y} или в случайной точке в регионе Х
    //?Все аргументы - Extended Values
    _.spawnEnemy = function(id, xOrRegion, y) {
      var e, e2;
      $gameTemp.aaLastSpawnedEvent = null;
      if (!DataManager.aaIsSpawnMapValid()) {
        console.warn("You try spawn Enemy, but not setup Spawn Map ID in Plugin Parameters");
      } else {
        try {
          id = AAExtendedValues.getEValue(id);
          xOrRegion = AAExtendedValues.getEValue(xOrRegion);
          y = AAExtendedValues.getEValue(y);
          if (y != null) {
            $gameMap.aaSpawnEnemyInPoint(id, xOrRegion, y);
          } else {
            $gameMap.aaSpawnEnemyInRegion(id, xOrRegion);
          }
          try {
            // * Spawn Animation
            if ($gameSystem.aaEnemySpawnAnimationId > 0 && this.isEnemyBeenSpawned()) {
              $gameMap.aaPlaySpawnAnimation(this.getLastSpawnedEnemy(), $gameSystem.aaEnemySpawnAnimationId);
            }
          } catch (error) {
            e2 = error;
            KDCore.warning(e2);
          }
          AANetworkManager.spawnEnemy(id, xOrRegion, y);
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
    };
    // * Спавн врага (без проверок)
    _.spawnEnemyForced = function() {
      $gameTemp.aaIsForceSpawn = true;
      uAPI.spawnEnemy(...arguments);
    };
    // * Возвращает событие, которое было отспавнено последним
    //?Может вернуть NULL
    _.getLastSpawnedEnemy = function() {
      return $gameTemp.aaLastSpawnedEvent;
    };
    // * Был ли отспавнен враг после последней команды спавна?
    _.isEnemyBeenSpawned = function() {
      return uAPI.getLastSpawnedEnemy() != null;
    };
    // * Спавн врага в случайном месте вокруг точки {X, Y} (в пределах радиуса)
    _.spawnEnemyAround = function(id, x, y, radius) {
      var e, p;
      $gameTemp.aaLastSpawnedEvent = null;
      if (!DataManager.aaIsSpawnMapValid()) {
        console.warn("You try spawn Enemy, but not setup Spawn Map ID in Plugin Parameters");
      } else {
        try {
          // * ID не надо, так как идёт вызов spawnEnemy, где преобразование
          //id = AAExtendedValues.getEValue(id)
          x = AAExtendedValues.getEValue(x);
          y = AAExtendedValues.getEValue(y);
          radius = AAExtendedValues.getEValue(radius);
          if ((id != null) && (x != null) && (y != null) && (radius != null) && radius > 0) {
            p = $gameMap.aaGetRandomSpawnPointInRadius(x, y, radius);
            if (p != null) {
              uAPI.spawnEnemy(id, p.x, p.y);
            }
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }
    };
    // * Спавн врага вокруг игрока (на максимальном расстоянии maxDistance)
    _.spawnEnemyNearPlayer = function(id, maxDistance = 2) {
      var e;
      try {
        return uAPI.spawnEnemyAround(id, $gamePlayer.x, $gamePlayer.y, maxDistance);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.spawnEnemyAroundForced = function() {
      $gameTemp.aaIsForceSpawn = true;
      uAPI.spawnEnemyAround(...arguments);
    };
    // * Вернуть всех отспавненных врагов (объекты)
    _.getSpawnPointSpawnedEnemies = function(spawnPointId) {
      var e;
      try {
        return $gameMap.eventsAA().filter(function(ev) {
          return ev instanceof Game_AASpawnedEvent && ev._aaSpawnPointRelativeId === spawnPointId;
        });
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    // * Вернуть число (общее) отспавненных врагов точкой спавна
    _.getSpawnPointSpawnedTotal = function(spawnPointId) {
      var e;
      try {
        return $gameMap.event(spawnPointId)._aaSpawnPointSpawnedCount;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return 0;
      }
    };
    // * Вернуть число (общее) живых на данных момент отспавленных врагов точкой спавна
    _.getSpawnPointSpawnedAlive = function(spawnPointId) {
      var e, spawnedAlive;
      try {
        spawnedAlive = this.getSpawnPointSpawnedEnemies(spawnPointId).filter(function(ev) {
          return ev.AABattler().isAlive();
        });
        return spawnedAlive.length;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return 0;
      }
    };
    
    // * Вернуть общее число живых врагов (которые были отспавнены)
    _.getSpawnEnemiesAlive = function() {
      var e, events;
      try {
        events = $gameMap.eventsAA().filter(function(ev) {
          return ev instanceof Game_AASpawnedEvent && ev.isABS() && ev.AABattler().isAlive();
        });
        if (events != null) {
          return events.length;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    // * Вернуть количество отспавненных врагов по Map Encounters (для текущей карты)
    _.getSpawnedByEncountersCount = function() {
      var e;
      try {
        return $gameMap.aaGetEncountersCount();
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    // * Установить анимацию спавна для след. спавн врага
    // * 0 или null - очистить
    return _.setSpawnEnemyAnimation = function(animationId = 0) {
      var e;
      try {
        $gameSystem.aaEnemySpawnAnimationId = 0;
        if (animationId == null) {
          animationId = 0;
        }
        if (animationId <= 0) {
          return;
        }
        if ($dataAnimations[animationId] == null) {
          return;
        }
        return $gameSystem.aaEnemySpawnAnimationId = animationId;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  (function() {    // * Навыки
    // -----------------------------------------------------------------------
    //ownerId, skillId, x, y - EValues
    _.executeAASkillOnMap = function(ownerId, teamId, skillId, x, y) {
      var aaSkill, e, subject;
      try {
        if (!AA.Utils.isValidGlobalSkillForExecute(skillId, 'OnMap')) {
          return;
        }
        aaSkill = $dataSkills[skillId].AASkill;
        subject = AA.Utils.createDummyCharacterByParameters(ownerId, teamId, x, y);
        if (subject == null) {
          return;
        }
        AABattleSkillsExecutionManager.startSkill(aaSkill, subject, {x, y});
        subject.dispose(); // * Сразу Dispose, чтобы память не отнимал
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    //Projectile из точки по направлению
    //Projectile из точки в точку
    // * xOrD - направление или X цели
    // * tY - Y цели, если не указывать, то будет по направлению только
    _.executeAASkillOnMapProjFromPoint = function(ownerId, teamId, skillId, x, y, xOrD, tY = null) {
      var aaSkill, direction, e, subject, targetPoint;
      try {
        if (!AA.Utils.isValidGlobalSkillForExecute(skillId, 'ByDirection')) {
          return;
        }
        aaSkill = $dataSkills[skillId].AASkill;
        if (aaSkill == null) {
          return;
        }
        if ((xOrD != null) && (tY == null)) {
          direction = xOrD;
        } else {
          direction = null;
        }
        subject = AA.Utils.createDummyCharacterByParameters(ownerId, teamId, x, y, direction);
        if (subject == null) {
          return;
        }
        targetPoint = subject;
        if ((xOrD != null) && (tY != null)) {
          targetPoint = {
            x: xOrD,
            y: tY
          };
        }
        return AABattleSkillsExecutionManager.startSkill(aaSkill, subject, targetPoint);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.executeAASkillOnChar = function(ownerId, teamId, skillId, charId) {
      var char, e;
      try {
        charId = AAExtendedValues.getEValue(charId);
        if (charId === 0) {
          char = $gamePlayer;
        } else {
          char = $gameMap.event(charId);
        }
        if (char == null) {
          return;
        }
        uAPI.executeAASkillOnMap(ownerId, teamId, skillId, char.x, char.y);
      } catch (error) {
        e = error;
        AA.w(e);
      }
    };
    //Projectile из СОБЫТИЯ по ЕГО направлению
    //Projectile из  СОБЫТИЯ в точку [(tX, tY)]
    _.executeAASkillOnMapProjFromChar = function(ownerId, teamId, skillId, charId, tX, tY) {
      var aaSkill, char, e, subject, targetPoint;
      try {
        if (!AA.Utils.isValidGlobalSkillForExecute(skillId, 'ByDirection')) {
          return;
        }
        aaSkill = $dataSkills[skillId].AASkill;
        if (aaSkill == null) {
          return;
        }
        charId = AAExtendedValues.getEValue(charId);
        if (charId === 0) {
          char = $gamePlayer;
        } else {
          char = $gameMap.event(charId);
        }
        if (char == null) {
          return;
        }
        if ((tX != null) && (tY != null)) {
          targetPoint = {
            x: tX,
            y: tY
          };
        } else {
          targetPoint = char;
        }
        if (char.isABS()) {
          subject = char;
        } else {
          subject = AA.Utils.createDummyCharacterByParameters(ownerId, teamId, char.x, char.y, char.direction());
        }
        if (subject == null) {
          return;
        }
        AABattleSkillsExecutionManager.startSkill(aaSkill, subject, targetPoint);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    // * Последний использованный навык
    _.lastUsedSkill = function() {
      var e;
      try {
        if ($gameTemp.aaLastUsedAction != null) {
          return $gameTemp.aaLastUsedAction.item();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    // * Последняя цель на который был использован навык
    _.lastUsedSkillTarget = function() {
      return $gameTemp.aaLastUsedActionTarget;
    };
    // * Кто использовал последний навык
    return _.lastSkillUser = function() {
      var e, ref;
      try {
        if ($gameTemp.aaLastUsedAction != null) {
          return (ref = $gameTemp.aaLastUsedAction.subject()) != null ? ref.AACharacter() : void 0;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
  })();
  (function() {    // * Для сетевого режима
    // -----------------------------------------------------------------------
    //? byWhat: actor, actorId, netId, actorName, playerName, playerIndex, info
    // * IS OUTER used for server synchronization
    _.setTeamIdFor = function(byWhat, value, teamId, isOuter = false) {
      var actor, e;
      try {
        if (!AA.Network.isNetworkGame()) {
          return;
        }
        actor = nAPI.getPlayerInfo('actor', byWhat, value);
        if (actor == null) {
          return console.warn("Actor by " + byWhat + " with value " + value + " not found");
        } else {
          actor.aaNetSetupTeamId(teamId);
          if (!isOuter) {
            return AANetworkManager.setActorNetworkTeamId(actor.actorId(), teamId);
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.setPvPMode = function() {
      var e;
      try {
        AA.Network.setPvPMode();
        return AANetworkManager.refreshPvPGameModeState();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.setPvEMode = function() {
      var e;
      try {
        AA.Network.setPvEMode();
        return AANetworkManager.refreshPvPGameModeState();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * what can be: actor, actorId, netId, actorName, playerName, playerIndex, info
    return _.getWhoKillMeInPvP = function(what = "actorId") {
      var e;
      if (!AA.Network.isNetworkPvPGame()) {
        return null;
      }
      if ($gameTemp.aaPvPKilledBy == null) {
        return null;
      }
      try {
        return nAPI.getPlayerInfo(what, 'netId', $gameTemp.aaPvPKilledBy);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------
window['uAPI'] = uAPI;


// Generated by CoffeeScript 2.6.1
// * Класс хранит все иконки баффов игрока
(function() {
  var UISet_ActorBuffsIcons;
  UISet_ActorBuffsIcons = class UISet_ActorBuffsIcons extends Sprite {
    constructor() {
      super();
      this.controllers = [];
      this.elements = [];
      this._create();
      this.refresh();
    }

    refresh() {
      var e, ref;
      try {
        return (ref = this.controllers[0]) != null ? ref.setup($gameParty.leader()) : void 0;
      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    update() {
      var c, i, len, ref, results;
      super.update();
      ref = this.controllers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.update());
      }
      return results;
    }

  };
  AA.link(UISet_ActorBuffsIcons);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_ActorBuffsIcons.prototype;
  _._create = function() {
    var data, i, icons, index, len;
    icons = AA.PP.getUIActorBuffsIconsSet();
    for (index = i = 0, len = icons.length; i < len; index = ++i) {
      data = icons[index];
      this._createBuffIcon(data, index);
    }
    return this._createControllers();
  };
  _._createBuffIcon = function(data, index) {
    var buffItem, e, p;
    try {
      p = AA.PP.uiData("actorBuffIcon");
      buffItem = new AA.Sprite_ActorStateIcon(p);
      buffItem.tag = "buffItem_" + index;
      buffItem.move(data.x, data.y);
    } catch (error) {
      e = error;
      AA.w(e);
      buffItem = null;
    }
    if (buffItem == null) {
      return;
    }
    this.addChild(buffItem);
    this.elements.push(buffItem);
  };
  _._createControllers = function() {
    var buffsCnt;
    buffsCnt = new AA.BuffIconsController(this.elements);
    buffsCnt.tag = "buffs";
    this.controllers.push(buffsCnt);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит все gauge игрока, отвечает за их работу
(function() {
  var UISet_ActorGauges;
  // * В качестве аргумента получает класс интерфейса
  UISet_ActorGauges = class UISet_ActorGauges extends Sprite {
    constructor() {
      super();
      this.controllers = [];
      this.elements = [];
      this._create();
      this.refresh();
    }

    refresh() {
      var e, ref, ref1, ref2, ref3;
      try {
        if ((ref = this.hpGauge) != null) {
          ref.setup($gameParty.leader(), 'hp', 'mhp');
        }
        if ((ref1 = this.mpGauge) != null) {
          ref1.setup($gameParty.leader(), 'mp', 'mmp');
        }
        if ((ref2 = this.tpGauge) != null) {
          ref2.setup($gameParty.leader(), 'tp', 'mtp');
        }
        return (ref3 = this.expGauge) != null ? ref3.setup($gameParty.leader(), 'cexp', 'nexp') : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    update() {
      var c, i, len, ref, results;
      super.update();
      ref = this.controllers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.update());
      }
      return results;
    }

  };
  AA.link(UISet_ActorGauges);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_ActorGauges.prototype;
  _._create = function() {
    this.hpGauge = this._createGauge("hpGauge");
    this.tpGauge = this._createGauge("tpGauge");
    this.mpGauge = this._createGauge("mpGauge");
    return this.expGauge = this._createGauge("expGauge");
  };
  _._createGauge = function(tag) {
    var e, gauge, gaugeCnt, p;
    try {
      p = AA.PP.uiData(tag);
      gauge = new AA.Sprite_ActorStateGauge(p);
      gauge.tag = tag;
      gaugeCnt = new AA.GaugeController(gauge);
      gaugeCnt.tag = tag;
      this.controllers.push(gaugeCnt);
      this.elements.push(gauge);
      this.addChild(gauge);
      return gaugeCnt;
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return null;
    }
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит все иконки состояний игрока
(function() {
  var UISet_ActorStatesIcons;
  UISet_ActorStatesIcons = class UISet_ActorStatesIcons extends AA.UISet_ActorBuffsIcons {
    constructor() {
      super();
    }

  };
  AA.link(UISet_ActorStatesIcons);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_ActorStatesIcons.prototype;
  //$[OVER]
  _._create = function() {
    var data, i, icons, index, len;
    icons = AA.PP.getUIActorStatesIconsSet();
    for (index = i = 0, len = icons.length; i < len; index = ++i) {
      data = icons[index];
      this._createStateIcon(data, index);
    }
    return this._createControllers();
  };
  _._createStateIcon = function(data, index) {
    var e, p, stateItem;
    try {
      p = AA.PP.uiData("actorStateIcon");
      stateItem = new AA.Sprite_ActorStateIcon(p);
      stateItem.tag = "stateItem_" + index;
      stateItem.move(data.x, data.y);
    } catch (error) {
      e = error;
      AA.w(e);
      stateItem = null;
    }
    if (stateItem == null) {
      return;
    }
    this.addChild(stateItem);
    this.elements.push(stateItem);
  };
  //$[OVER]
  _._createControllers = function() {
    var statesCnt;
    statesCnt = new AA.StatesIconsController(this.elements);
    statesCnt.tag = "states";
    this.controllers.push(statesCnt);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс хранит все ячейки навыков (предметов) на интерфейсе
(function() {
  var UISet_Skills;
  // * В качестве аргумента получает класс интерфейса
  UISet_Skills = class UISet_Skills extends Sprite {
    constructor() {
      super();
      this.controllers = [];
      this.elements = [];
      this._create();
      this.refresh();
    }

    // * Этот метод нужен обязательно
    refresh() {
      var e;
      try {

      } catch (error) {
        e = error;
        return AA.warning(e);
      }
    }

    update() {
      var c, i, len, ref, results;
      super.update();
      ref = this.controllers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.update());
      }
      return results;
    }

  };
  AA.link(UISet_Skills);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_Skills.prototype;
  _._create = function() {
    var i, item, len, ref;
    ref = AA.PP.getUISkillsItems();
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (item != null) {
        this._createSkillItem(item);
      }
    }
    this._createController();
  };
  _._createSkillItem = function(itemSettings) {
    var def, e, p, skillItem;
    try {
      def = AA.PP.uiData("skillSlot");
      if ((itemSettings.style != null) && itemSettings.style !== "") {
        p = itemSettings.style;
      } else {
        p = def;
      }
      try {
        skillItem = new AA.Sprite_SKillPanelItem(p);
      } catch (error) {
        e = error;
        AA.w(e);
        skillItem = new AA.Sprite_SKillPanelItem(def);
      }
      skillItem.tag = "skillItem_" + itemSettings.symbol;
      skillItem.move(itemSettings.position);
      skillItem.drawSymbol(itemSettings.symbol);
      skillItem.symbol = itemSettings.symbol;
    } catch (error) {
      e = error;
      AA.w(e);
      skillItem = null;
    }
    if (skillItem == null) {
      return;
    }
    this.addChild(skillItem);
    this.elements.push(skillItem);
  };
  _._createController = function() {
    var skillsCnt;
    skillsCnt = new UISkillsItemsController(this.elements);
    skillsCnt.tag = "skills";
    this.controllers.push(skillsCnt);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Класс харинт UI выбранной (под курсором) цели и контроллеры
(function() {
  var UISet_TargetInfo;
  UISet_TargetInfo = class UISet_TargetInfo extends Sprite {
    constructor() {
      super();
      // * Эти два поля обязательные для набора элементов интерфейса
      // * Они используются в методе _registerUISet в Spriteset UI
      this.controllers = [];
      this.elements = [];
      //TODO: register global event
      this._create();
      return;
    }

    refresh() {}

    update() {
      var c, i, len, ref, results;
      super.update();
      ref = this.controllers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.update());
      }
      return results;
    }

  };
  AA.link(UISet_TargetInfo);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ UISet_TargetInfo.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = AA.UISet_TargetInfo.prototype;
  _._create = function() {
    this.infoSpr = new AA.Sprite_EnemyInfo();
    this.infoSpr.tag = "targetInfo"; // * Это надо для управленя элементов через uAPI и редактор
    this.infoSprCnt = new UITargetInfoController(this.infoSpr);
    this.infoSprCnt.tag = "targetInfo";
    this.controllers.push(this.infoSprCnt);
    this.elements.push(this.infoSpr);
    return this.addChild(this.infoSpr);
  };
})();

// ■ END UISet_TargetInfo.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
// * Данный класс работает только на Game_Player
var UISkillsItemsController;

UISkillsItemsController = class UISkillsItemsController {
  constructor(skillItems) {
    this.skillItems = skillItems;
    // * Очищаем тело метода, если отключён соответствующий параметр плагина
    // (для экономии производительности)
    if (!AA.PP.isRemoveItemIfZeroCount()) {
      this._checkResetItemFromPanel = function() {}; // * EMPTY
    }
    this.setup();
    return;
  }

  setup() {
    this.battler = $gamePlayer.AABattler();
    this.skillSet = $gamePlayer.aaSkillsSet;
    this._updThread = new KDCore.TimedUpdate(20, this._updateItemsStates.bind(this));
    this._updThreadItemCount = new KDCore.TimedUpdate(30, this._updateItemsCount.bind(this));
    this._updThreadTimers = new KDCore.TimedUpdate(2, this._updateItemsTimers.bind(this));
    this.refresh();
  }

  onSkillPerformResult(skillId, result) {
    var e, item;
    try {
      item = this._getItemForSkillId(skillId);
      if (item == null) {
        return;
      }
      if (result === 0) {
        return item.pulseAlert();
      } else {
        return item.pulseClick();
      }
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  }

  refresh() {
    var i, item, j, len, len1, panelItems, ref, skill;
    this._clearItems();
    if (this.battler == null) {
      return;
    }
    ref = this.battler.getAASkills();
    for (i = 0, len = ref.length; i < len; i++) {
      skill = ref[i];
      this._setupItem(skill);
    }
    // * Предметы отдельно, так как могут быть не в наличии
    panelItems = this.skillSet.getAllItemsFromPanel().map(function(id) {
      return AASkill2.GetAASkillObject(id);
    });
    for (j = 0, len1 = panelItems.length; j < len1; j++) {
      item = panelItems[j];
      this._setupItem(item);
    }
    // * Все слоты у которых нет навыка, очищаем уже
    this._checkAndClearEmptyItems();
    this._updateItemsCount(); // * Сразу обновим количество
  }

  update() {
    var ref, ref1, ref2;
    if ((ref = this._updThread) != null) {
      ref.update();
    }
    if ((ref1 = this._updThreadTimers) != null) {
      ref1.update();
    }
    if ((ref2 = this._updThreadItemCount) != null) {
      ref2.update();
    }
    this._updateInput();
  }

  getItemUnderMouse() {
    return this.skillItems.find(function(item) {
      return item.isUnderMouse();
    });
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = UISkillsItemsController.prototype;
  _._updateItemsStates = function() {
    var e, i, item, len, ref, results;
    try {
      ref = this.skillItems;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(this._updateItemState(item));
      }
      return results;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._updateItemsTimers = function() {
    var e, i, item, len, ref, results;
    try {
      ref = this.skillItems;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(this._updateItemTimer(item));
      }
      return results;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  _._updateItemsCount = function() {
    var e, i, item, len, ref, results;
    try {
      ref = this.skillItems;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push(this._updateItemCount(item));
      }
      return results;
    } catch (error) {
      e = error;
      return AA.w(e);
    }
  };
  // * Обновить состояние (таймер, доступность)
  _._updateItemState = function(item) {
    var e, useCases;
    try {
      if (AA.isABSActive()) {
        useCases = this.battler.getUsableAASkills().map(function(skill) {
          return skill.idA;
        });
      } else {
        useCases = [];
      }
      this._updateItemUseState(item, useCases);
    } catch (error) {
      e = error;
      AA.w(e);
      this._updThread = null;
    }
  };
  // * Обновить таймер для навыка
  _._updateItemTimer = function(item) {
    var parts, tStr, time;
    if (item.isDisabled() && item.skillId > 0) {
      time = $gamePlayer.AABattler().aaGetRemainTimeForSkill(item.skillId);
      if (time > 0) {
        //TODO: BAD performance, BAD BAD BAD way
        tStr = "" + time;
        if (tStr.contains(".")) {
          parts = tStr.split(".");
          if (parts[1].length > 0) {
            tStr = parts[0] + "." + parts[1][0];
          }
        }
        return item.drawTime(tStr);
      } else {
        return item.drawTime("");
      }
    } else {
      return item.drawTime("");
    }
  };
  // * Обновить количество (для предметов)
  _._updateItemCount = function(item) {
    var count;
    // * Навыки пропускаем
    if (AASkill2.IsAASkill(item.skillId)) {
      return;
    }
    count = $gameParty.numItems(AASkill2.GetAASkillObject(item.skillId));
    item.drawCount(count);
    this._checkResetItemFromPanel(item, count);
  };
  //@[DYNAMIC]
  _._checkResetItemFromPanel = function(item, count) {
    var e;
    try {
      if (count <= 0) {
        uAPI.setItemToPanel(0, item.symbol);
      }
    } catch (error) {
      e = error;
      this._checkResetItemFromPanel = function() {}; // * EMPTY
      AA.w(e);
    }
  };
  _._updateItemUseState = function(item, useable) {
    if (item.skillId === 0) {
      if (item.isDisabled()) {
        // * Доп. проверочка isDisabled, а то мерцает
        item.enable();
      }
    } else {
      // * Если состояние было включено на Enabled, значит даём сигнал
      if (item.switchState(useable.contains(item.skillId))) {
        item.pulseReady();
      }
    }
  };
  _._clearItems = function() {
    var i, item, len, ref;
    ref = this.skillItems;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      //item.clear() # * Не очищаем, чтобы не было мерцания картинки (если используется)
      item.skillId = 0;
    }
  };
  _._checkAndClearEmptyItems = function() {
    var e, i, item, len, ref;
    try {
      ref = this.skillItems;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.skillId <= 0) {
          item.clear();
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  };
  
  // * Задать навык в ячейку
  _._setupItem = function(skill) {
    var iconIndex, item, symb;
    if (skill == null) {
      return;
    }
    symb = this.skillSet.getSymbolForSkill(skill.idA);
    // * Нету символа для навыка (т.е. навык не находится в ячейках)
    if (symb == null) {
      return;
    }
    item = this._getItemForSymbol(symb);
    if (item == null) {
      return;
    }
    item.skillId = skill.idA;
    if (item.skillId === this.battler.attackSkillId()) {
      iconIndex = AA.Utils.getAttackSkillWeaponIconIndex(item, this.battler);
      item.drawIcon(iconIndex);
    } else {
      iconIndex = AA.Utils.getSkillSlotImgOrIcon(skill);
      item.drawIcon(iconIndex);
    }
    // * Сразу обновляем состояние
    this._updateItemState(item);
  };
  // * symbol назначается при создании в UISet_Skills из параметров
  _._getItemForSymbol = function(symb) {
    return this.skillItems.find(function(item) {
      return item.symbol === symb;
    });
  };
  // * Получить ячейку по ID навыка (устанавливается в методе _setupItem)
  _._getItemForSkillId = function(id) {
    return this.skillItems.find(function(item) {
      return item.skillId === id;
    });
  };
  // * Этот метод работает с клавиатуры, а не при клике мышкой
  _._updateInput = function() {
    var inputSymbol, item;
    inputSymbol = AA.Input.getTriggeredSkillSymbol();
    if (inputSymbol != null) {
      item = this._getItemForSymbol(inputSymbol);
      if (item != null) {
        $gamePlayer.aaTryPerformSkill(item.skillId);
      }
    }
  };
  // * Обработка нажатия правкой кнопкой мыши по слоту (вызывается из AA.UI)
  _.handleSkillSelectorProcess = function() {
    var symbol;
    if (AA.UI.isSkillSelectorOpen()) {
      AA.UI.closeSkillSelector();
      // * Если было нажатие на другой слот, то сразу открываем его
      symbol = this._getSkillSymbolSelectorHandled();
      if ((symbol != null) && $gameTemp.__aaLastSkillSelectorSymbol !== symbol) {
        return this.handleSkillSelectorProcess(); // * Если было нажатие на слот, но этот же, закрываем его
      } else {
        $gameTemp.__aaLastSkillSelectorSymbol = null;
        return true;
      }
    } else {
      symbol = this._getSkillSymbolSelectorHandled();
      if ((symbol != null) && AA.Input.isEditableSymbol(symbol)) {
        AA.UI.openSkillSelectorFor(symbol);
        $gameTemp.__aaLastSkillSelectorSymbol = symbol;
        return true;
      }
    }
    return false;
  };
  // * Возвращает symbol слота, если было открыто меню выбора навыка (правой кнопкой по слоту)
  _._getSkillSymbolSelectorHandled = function() {
    var item;
    // * Только по правой кнопке мыши (всегда)
    if (TouchInput.isCancelled()) {
      item = this._getItemUnderCursor();
      if (item != null) {
        return item.symbol;
      }
    }
    return null;
  };
  
  // * Получить Skill Item под курсором
  _._getItemUnderCursor = function() {
    return this.skillItems.find(function(item) {
      return item.isUnderMouse();
    });
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//TODO: Систематизация класса
var UITargetInfoController;

UITargetInfoController = class UITargetInfoController {
  constructor(targetInfoSpr) {
    this.targetInfoSpr = targetInfoSpr;
    AA.EV.subscribeFor("UnderMouseEventChanged", this.gev_onUnderMouseEventChanged.bind(this));
    this._createSoControllers();
    this.targetInfoSpr.visible = false;
    return;
  }

  refresh() {
    return this.gev_onUnderMouseEventChanged();
  }

  setup(target1) {
    this.target = target1;
    if (this.target == null) {
      this.hideTargetInfo();
    }
    this.gaugeCnt.setup(this.target.AABattler(), "hp", "mhp");
    this.showTargetInfo();
  }

  hideTargetInfo() {
    this.targetInfoSpr.hideSlow();
    this.target = null;
    this.statesRefreshThread = null;
  }

  showTargetInfo() {
    var battler, e, model;
    try {
      model = this.target.AAEntity().model();
      if (model == null) {
        return;
      }
      if (model.UIInfo === 0) {
        return;
      }
      battler = this.target.AABattler();
      //TODO: Values from enemy
      this.targetInfoSpr.drawNameWithFormat(battler.name());
      //TODO: level from what?
      this.targetInfoSpr.drawLevelWithFormat(1);
      this.targetInfoSpr.drawFace(model.faceName, model.faceIndex);
      //TODO: battle state show and refresh by AI state
      this.targetInfoSpr.showSlow();
      this.statesRefreshThread = new KDCore.TimedUpdate(40, this.refreshTargetStates.bind(this));
      this.refreshTargetStates();
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.hideTargetInfo();
    }
  }

  refreshTargetStates() {
    var battler, e;
    if (this.target == null) {
      return;
    }
    try {
      battler = this.target.AABattler();
      if (battler == null) {
        this.targetInfoSpr.drawStates(null);
        return;
      }
      if (battler.isAlive()) {
        this.targetInfoSpr.drawStates(battler.allIcons());
      } else {
        this.targetInfoSpr.drawStates(null);
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  }

  update() {
    var ref;
    if (!this.targetInfoSpr.visible) {
      return;
    }
    this.gaugeCnt.update();
    if ((ref = this.statesRefreshThread) != null) {
      ref.update();
    }
  }

  gev_onUnderMouseEventChanged() {
    if (this.isValidTargetToShow($gameTemp._aaEventUnderCursor)) {
      if (this.target !== $gameTemp._aaEventUnderCursor) {
        this.setup($gameTemp._aaEventUnderCursor);
      }
    } else {
      this.hideTargetInfo();
    }
  }

  isValidTargetToShow(target) {
    var e;
    if (target == null) {
      return false;
    }
    try {
      if (target instanceof Game_Event) {
        return target.isABS();
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  }

  _createSoControllers() {
    this.gaugeCnt = new AA.GaugeController(this.targetInfoSpr.gauge);
    // * Используется свой метод для отрисовки значения (с форматом)
    this.gaugeCnt.targetInfoSpr = this.targetInfoSpr;
    this.gaugeCnt._refreshValues = function() {
      var rate;
      rate = this.value / this.max;
      this.gaugeSprite.drawGauge(rate);
      return this.targetInfoSpr.drawHpWithFormat(this.value, this.max, rate);
    };
  }

};


// Generated by CoffeeScript 2.6.1
// * Данный класс содержит пользовательские (временные) настройки UI элементов

//@[GLOBAL]
//@[STORABLE]
var AAUserUISettings;

AAUserUISettings = class AAUserUISettings {
  constructor() {
    if (this.isGlobalUsage()) {
      this.settings = ConfigManager.aaUserUISettings || {};
    } else {
      this.settings = {};
    }
    return;
  }

  // * Сохранять (загружать) изменения в Config Manager (глобально)
  isGlobalUsage() {
    return AA.PP.isGlobalUserUISettings();
  }

  isHaveFor(key) {
    return this.settings[key] != null;
  }

  createFor(key) {
    return this.settings[key] = {};
  }

  //?[UNSAFE]
  //? Cперва надо сделать проверку isHaveFor
  // * Если поля нету, возращают null, значит вообще не учитывать пользовательскую настройку
  // * return KDCore.Point
  getPositionFor(key) {
    var e, ref;
    try {
      return (ref = this.settings[key]) != null ? ref.position : void 0;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  }

  //?[UNSAFE]
  getVisibleFor(key) {
    var e, state;
    try {
      if (this.settings[key] == null) {
        return null;
      }
      state = this.settings[key].visible;
      if (state != null) {
        return state;
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return null;
  }

  set(key, command, value) {
    var e;
    if (!this.isHaveFor(key)) {
      // * Создаём для элемента данные, если нету ещё
      this.createFor(key);
    }
    try {
      switch (command) {
        case "setPosition":
          // * Значние должно быть массивом
          this.settings[key].position = KDCore.Utils.jsonPos(value).simple();
          break;
        case "setVisible":
          // * Значение должно быть bool
          this.settings[key].visible = value;
          break;
        case "resetPosition":
          // * Нет значения, просто сброс
          this.settings[key].position = null;
          break;
        case "clear":
          // * Нет значения, удаление всех настроек
          delete this.settings[key];
          break;
        default:
          KDCore.warning('Unknown command ' + command);
      }
      this.saveGlobalSettings();
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  }

  saveGlobalSettings() {
    var e;
    try {
      if (!this.isGlobalUsage()) {
        return;
      }
      // * Не обязательно, но лучше переопределить
      ConfigManager.aaUserUISettings = this.settings;
      ConfigManager.save();
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

};


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Window_Base.prototype;
  _.aaDrawAnyIcon = function(imageOrIcon, x, y, size) {
    var e;
    try {
      if (imageOrIcon == null) {
        return;
      }
      if (imageOrIcon === 0) {
        return;
      }
      if (!String.any(imageOrIcon)) {
        return;
      }
      if (isFinite(imageOrIcon)) {
        return this.drawIcon(imageOrIcon, x, y);
      } else {
        return this._aaDrawAsyncImage(x, y, imageOrIcon, size);
      }
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
  _._aaDrawAsyncImage = function(x, y, imageName, size = 0) {
    var drawAsyncImageBody, e;
    try {
      drawAsyncImageBody = (x1, y1, size1, b) => {
        var e;
        try {
          if (size1 === 0) {
            size1 = b.width;
          }
          return this.contents.drawIcon(x1, y1, b, size1, false);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      };
      return KDCore.Utils.loadImageAsync("Alpha", imageName).then(drawAsyncImageBody.bind(this, x, y, size));
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  };
})();

// ■ END Window_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_BattleSkill.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__includes, _;
  //@[DEFINES]
  _ = Window_BattleSkill.prototype;
  // * Прячем ABS навыки из битвы со специальным флагом hideOutsideABS == 1
  //@[ALIAS]
  ALIAS__includes = _.includes;
  _.includes = function(item) {
    var isInclude;
    isInclude = ALIAS__includes.call(this, item);
    if (isInclude === true) {
      if (AASkill2.IsAAObject(item)) {
        if (item.AASkill.hideOutsideABS === 1) {
          return false;
        }
      }
    }
    return isInclude;
  };
})();

// ■ END Window_BattleSkill.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Message.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startMessage, ALIAS__terminateMessage, _;
  //@[DEFINES]
  _ = Window_Message.prototype;
  //@[ALIAS]
  ALIAS__startMessage = _.startMessage;
  _.startMessage = function() {
    ALIAS__startMessage.call(this);
    return AA.UI.onGameMessageStart();
  };
  
  //TODO: Тут мерцание происходит. Как быть? Timeout?
  //@[ALIAS]
  ALIAS__terminateMessage = _.terminateMessage;
  _.terminateMessage = function() {
    ALIAS__terminateMessage.call(this);
    return AA.UI.onGameMessageEnd();
  };
})();

// ■ END Window_Message.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
//TODO: Добавить настройки, чтобы и размер иконок и текста можно было менять
var Window_SkillSelectorList;

Window_SkillSelectorList = class Window_SkillSelectorList extends Window_Selectable {
  constructor(rect) {
    super(...arguments);
    this.setBackgroundType(2);
    this.catIndex = -1;
    this.skillSymbol = null;
    return;
  }

  getSettings() {
    return $aabsz_SkillItemSelectorWindowSettings.itemsSkillsListWindow;
  }

  // * При нажатии на окно выбора навыков
  onClick() {
    var e, hitIndex, skillId, x, y;
    if (this.skillSymbol == null) {
      return;
    }
    if (this.catIndex < 0) {
      return;
    }
    if (AAUtils.isMZ()) {
      hitIndex = this.hitIndex();
    } else {
      x = this.canvasToLocalX(TouchInput.x);
      y = this.canvasToLocalY(TouchInput.y);
      hitIndex = this.hitTest(x, y);
    }
    if (hitIndex < 0) {
      return;
    }
    try {
      skillId = this._skills[hitIndex].id;
      if (this.catIndex === 0) {
        uAPI.setSkillToPanel(skillId, this.skillSymbol);
      } else {
        uAPI.setItemToPanel(skillId, this.skillSymbol);
      }
      if (skillId > 0) {
        SoundManager.playEquip();
        // * Если навык был установлен (а не удалён)
        AA.UI.closeSkillSelector();
        // * Чтобы персонаж не пошёл к точку карты после закрытия окна
        TouchInput.clear();
      } else {
        SoundManager.playCursor();
        this.refresh();
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

  // * 0 - Skills
  // * 1 - Items
  setCategory(catIndex) {
    this.catIndex = catIndex;
    this.refresh();
    if (AAUtils.isMZ()) {
      this.scrollTo(0, 0);
    }
  }

  // * Символ навыка, чтобы установить (убрать) на панель
  setSymbol(skillSymbol) {
    this.skillSymbol = skillSymbol;
  }

  // * Всегда можно прокручивать, так как окно не будет Active
  //$[OVER]
  isScrollEnabled() {
    return true;
  }

  maxCols() {
    return this.getSettings().maxCols;
  }

  lineHeight() {
    return this.getSettings().lineHeight;
  }

  maxItems() {
    if (this._skills != null) {
      return this._skills.length;
    } else {
      return 0;
    }
  }

  refresh() {
    this._prepareSkillsList();
    Window_Selectable.prototype.refresh.call(this);
  }

  drawItem(index) {
    var e, iconIndex, item, rect;
    this.__drawIndex = index;
    item = this._skills[index];
    if (item == null) {
      return;
    }
    rect = this.itemLineRect(index);
    try {
      // * Тут TryCatch так как есть системный placeholder вместо Item
      // * и модифицированный другими плагинами метод drawItemName
      // * может не найти поле необходимое, которое есть у Game_Items
      iconIndex = AA.Utils.getSkillSlotImgOrIcon(item);
      // * Если навык атаки, то надо рисовать иконку оружия
      if (this._isAttackSkill(index)) {
        iconIndex = AA.Utils.getAttackSkillWeaponIconIndex(item, $gameParty.leader());
      }
      this.aaDrawAnyIcon(iconIndex, rect.x, rect.y, this.getSettings().iconSize);
      this.__aaDrawItemName(item, rect);
    } catch (error) {
      e = error;
      AA.w(e);
    }
  }

  __aaDrawItemName(item, rect) {
    var e, iconY, itemWidth, size, textMargin, width, x, y;
    try {
      size = this.getSettings().iconSize;
      ({x, y, width} = rect);
      iconY = y + (this.lineHeight() - size) / 2;
      textMargin = size + 4;
      itemWidth = Math.max(0, width - textMargin);
      this.resetTextColor();
      return this.drawText(item.name, x + textMargin, y, itemWidth);
    } catch (error) {
      e = error;
      return KDCore.warning(e);
    }
  }

  //$[OVER]
  resetFontSettings() {
    var p;
    p = this.getSettings().itemNameTextSettings;
    if (KDCore.isMV()) {
      this.contents.fontFace = p.font || this.standardFontFace();
      this.contents.fontSize = p.size;
    } else {
      this.contents.fontFace = p.font || $gameSystem.mainFontFace();
      this.contents.fontSize = p.size;
    }
    this.resetTextColor();
  }

  resetTextColor() {
    var p;
    super.resetTextColor();
    if (this.catIndex < 0) {
      return;
    }
    p = this.getSettings();
    if (this.__drawIndex === 0) {
      return this.changeTextColor(p.removeCommand.textColor); // * [Remove]
    // * Атака может быть только в категории навыков
    // * А может и не быть (если установлена)
    } else if (this._isAttackSkill(this.__drawIndex)) {
      return this.changeTextColor(p.attackSkillTextColor); // * Attack
    } else {
      //TODO: Items name color plugin compatability
      if (this.catIndex === 0) {
        return this.changeTextColor(p.skillsNamesTextColor);
      } else {
        return this.changeTextColor(p.itemsNamesTextColor);
      }
    }
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Window_SkillSelectorList.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = Window_SkillSelectorList.prototype;
  _._prepareSkillsList = function() {
    var e, skills;
    this._skills = [];
    // * ID навыка атаки в списке, если == 0 - нет навыка
    this._attackSkillId = 0;
    if (this.catIndex < 0) {
      return;
    }
    try {
      if (this.catIndex === 0) { // * Skills only
        skills = $gameParty.leader().getAASkills();
        // * Так как метод getAASkills возвращает все навыки (включая предметы)
        // * то дополнительный фильтр от предметов
        skills = skills.filter(function(s) {
          return AASkill2.IsAASkill(s.idA); // * Items only
        });
      } else {
        skills = $gameParty.leader().getAAItems();
      }
      this._skills = skills;
      this._removeAlreadyInPanelSkills();
    } catch (error) {
      e = error;
      AA.w(e);
      this._skills = [];
    }
    if (this.catIndex === 0) {
      this._checkAttackSkillInList();
    }
    this._skills.unshift(this._removeCommandItem());
  };
  _._removeCommandItem = function() {
    var p;
    p = this.getSettings().removeCommand;
    return {
      id: 0,
      idA: 0,
      iconIndex: p.iconIndex,
      name: p.title
    };
  };
  // * Удаляет из списка навыков те, что уже установленны на панель навыков
  _._removeAlreadyInPanelSkills = function() {
    var e, i, len, notInPanelSkills, ref, s, skillPanel;
    try {
      notInPanelSkills = [];
      skillPanel = $gamePlayer.aaSkillsSet;
      if (skillPanel == null) {
        return;
      }
      ref = this._skills;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        if (skillPanel.getSymbolForSkill(s.idA) == null) {
          notInPanelSkills.push(s);
        }
      }
      this._skills = notInPanelSkills;
    } catch (error) {
      e = error;
      AA.w(e);
      this._skills = [];
    }
  };
  _._checkAttackSkillInList = function() {
    var attackSkill, attackSkillId, e;
    try {
      attackSkillId = $gameParty.leader().attackSkillId();
      attackSkill = this._skills.find(function(s) {
        return s.id === attackSkillId;
      });
      if (attackSkill != null) {
        this._skills.delete(attackSkill);
        // * Запоминаем ID (значит есть в списке)
        this._attackSkillId = attackSkillId;
        // * Ставим на первое место в список
        this._skills.unshift(attackSkill);
      }
    } catch (error) {
      e = error;
      AA.w(e);
      this._skills = [];
    }
  };
  _._isAttackSkill = function(index) {
    var e, ref;
    try {
      if (this.catIndex === 0 && this._attackSkillId > 0) {
        if (((ref = this._skills[index]) != null ? ref.id : void 0) === this._attackSkillId) {
          return true;
        }
      }
    } catch (error) {
      e = error;
      AA.w(e);
    }
    return false;
  };
})();

// ■ END Window_SkillSelectorList.coffee
//---------------------------------------------------------------------------


})();
//Plugin Alpha_ABSZ builded by PKD PluginBuilder 2.2.3 - 31.05.2025